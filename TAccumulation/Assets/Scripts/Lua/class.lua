---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by pc.
--- DateTime: 2020/10/30 16:36
---

---@param classname string
---@param super table
---@return table
function class(classname, super)
    local superType = type(super)
    local cls

    if superType ~= "function" and superType ~= "table" then
        superType = nil
        super = nil
    end

    if superType == "function" or (super and super.__ctype == 1) then
        -- inherited from native C++ Object
        cls = {}

        if superType == "table" then
            -- copy fields from super
            for k,v in pairs(super) do cls[k] = v end
            cls.__create = super.__create
            cls.super    = super
        else
            cls.__create = super
            cls.ctor = function() end
        end

        cls.__cname = classname
        cls.__ctype = 1

        function cls.new(...)
            local instance = cls.__create(...)
            -- copy fields from class to native object
            for k,v in pairs(cls) do instance[k] = v end
            instance.class = cls
            instance:ctor(...)
            return instance
        end

    else
        -- inherited from Lua Object
        if super then
            cls = {}
            setmetatable(cls, {__index = super})
            cls.super = super
        else
            cls = {ctor = function() end}
        end

        cls.__cname = classname
        cls.__ctype = 2 -- lua
        cls.__index = cls

        function cls.new(...)
            local instance = setmetatable({}, cls)
            --instance.class = cls
            instance:ctor(...)
            return instance
        end
    end

    return cls
end

local _partialId = 0
function partial(typeName)
    local component = {}

    -- add component typeName
    component.__isPartial = true
    component.typeName = typeName
    _partialId = _partialId + 1
    component.partialId = _partialId
    return component
end

local function _addPartialAttr(cls, component)
    for name, attr in pairs(component) do
        if name ~= "typeName" and name ~= "partialId" and name ~= "__isPartial" then
            if type(attr) ~= "function" then
                error(string.format("[ERROR] The partial attr %s is not a function ",  name))
            end

            ---获取当前类的原始方法
            local rawFunc = rawget(cls, name)
            if rawFunc == nil then
                cls[name] = attr
            else
                print(string.format("[WARNING] The attribute name %s is already in the Class %s!",
                        name, cls.__cname))
                cls[name] = function(...)
                    rawFunc(...)
                    attr(...)
                end
            end
        end
    end
end

----@warning:添加类似c#-partial的partial类，partial之间最好不要有大量多次”重载函数“（同名函数）
function addPartial(cls, component)
    assert(component.__isPartial, "must be a partial")
    assert(component.typeName ~= nil, "partial must have a name" )

    if cls.partialNames then
        assert(cls.partialNames[component.typeName] == nil, "class already has same partial " .. component.typeName)
    else
        cls.partialNames = { }
    end

    cls.partialNames[component.typeName] = component
    _addPartialAttr(cls, component)
end

----@xstruct（作为class内部结构定义，用于区分）
local emptyCtor = function() end
function xstruct(structname, super)
    local cls
    if super then
        cls = {}
        setmetatable(cls, {__index = super})
        cls.super = super
    else
        cls = {ctor = emptyCtor}
        setmetatable(cls, cls)
    end


    local _newInstance = function(...)
        local instance = setmetatable({}, cls)
        instance:ctor(...)
        return instance
    end

    ---创建接口
    cls.new = _newInstance
    cls.__cname = structname
    cls.__index = cls
    cls.__call = function(t, ...) return _newInstance(...) end
    return cls
end