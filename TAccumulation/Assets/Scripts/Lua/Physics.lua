---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Bayue.
--- DateTime: 2020/12/24 15:40
---

---@class Physics
Physics = {}

---@param circlePos FVector3
---@param radius Fix 圆半径
---@param shapeArgX Fix 矩形半边长1
---@param shapeArgY Fix 矩形半边长2
---@return boolean
function Physics.Test2DCircleVSRect(
        circlePos,
        radius,
        shapeArgX,
        shapeArgY)
    local h = FVector2.New(shapeArgX, shapeArgY)
    local v = FVector2.Max(FVector2.New(circlePos.x,circlePos.z),FVector2.New(-circlePos.x,-circlePos.z))
    v:Sub(h)
    local u = FVector2.Max(v,FVector2.zero)
    return u:SqrMagnitude()<radius * radius
end

---@param circlePos FVector3
---@param radius Fix 圆半径
---@param shapeArg1 Fix 圆半径
---@return boolean
function Physics.Test2DCircleVSCircle(
        circlePos,
        radius,
        shapeArg1)
    return radius * radius + shapeArg1 * shapeArg1 > (FVector2.New(circlePos.x,circlePos.z)):SqrMagnitude()
end

--扇形以Y轴为对称轴，方向向Y轴正方向，顶点在原点
---@param circlePos FVector3 圆对于扇形局部空间的pos
---@param radius Fix 圆半径
---@param shapeArg1 Fix 扇形边长
---@param shapeArg2 Fix 扇形圆心角半弧度
---@return boolean
function Physics.Test2DCircleVSSector(
        circlePos,
        radius,
        shapeArg1,
        shapeArg2)
    circlePos.x = MathFix.Abs(circlePos.x)
    local p = FVector2.New(circlePos.x,circlePos.z)
    local dSqr = p:SqrMagnitude()
    local theta = shapeArg2  * FDeg2Rad
    if dSqr > (radius + shapeArg1) * (radius + shapeArg1) then
        return false
    end

    if dSqr <= radius * radius then
        return true
    end

    if circlePos.z > MathFix.Sqrt(dSqr) * MathFix.Cos(theta) then
        return true
    end

    return Physics.Test2DCircleVSSegment(circlePos:NewRotateAngleY(-shapeArg2),radius,shapeArg1)
end


---@param circlePos FVector3 圆对于扇形局部空间的pos
---@param radius Fix 圆半径
---@param SegLength Fix 线段长度
---@return boolean
function Physics.Test2DCircleVSSegment(
        circlePos,
        radius,
        SegLength)
    if SegLength == 0 then
        return false
    end

    local rSqr = radius * radius
    if circlePos.x * circlePos.x + circlePos.z * circlePos.z <=  rSqr then
        return true
    end

    local d = FVector2.New(circlePos.x,circlePos.z - SegLength)
    if d.x * d.x + d.y * d.y <= rSqr then
       return true
    end

    if circlePos.x * circlePos.x > rSqr then
        return false
    end

    return circlePos.z * SegLength > FZero and (circlePos.z - SegLength) *(-SegLength) > FZero

end


---@param circlePos FVector3 圆对于扇形局部空间的pos
---@param radius Fix 圆半径
---@return boolean
function Physics.Test2DCircleVSRay(
        circlePos,
        radius)
    local center2ray = FVector2.New(-circlePos.x, -circlePos.z)
    local dotV = FVector2.Dot(center2ray, FVector2.up)
    local subLen = FVector2.Dot(center2ray, center2ray) - radius*radius
    if subLen > FZero and dotV > FZero then
        -- 射线源在圆外，方向相反，不会相交
        return false
    end
    local discr = dotV * dotV - subLen
    if discr < FZero then
        return false
    end

    return true
end


---@param radius Fix 半径
---@param moveSrcPoint FVector2 移动起点
---@param distance Fix 移动距离
---@return table 矩形相关参数
function Physics.GenCircleMoveRect(radius,moveSrcPoint,distance)
    local r = {}
    r.width = radius
    r.length = distance/FInt(2)
    r.srcPoint = FVector3.New(FZero,FZero,moveSrcPoint.y + r.length)
    return r
end


---@param width Fix 移动矩形半边长（移动方向法线方向的边）
---@param moveSrcPoint FVector3 移动起点
---@param distance Fix 移动距离
---@return table 矩形相关参数
function Physics.GenRectMoveRect(width,moveSrcPoint,distance)
    local r = {}
    r.width = width
    r.length = distance/FInt(2)
    r.srcPoint = FVector3.New(FZero,FZero,moveSrcPoint.y + r.length)

    return r
end

---@param theta Fix 扇形圆心角1/2弧度
---@param length Fix 扇形边长
---@param moveSrcPoint FVector3 移动起点
---@param distance Fix 移动距离
---@return table 矩形相关参数
function Physics.GenSectorMoveRect(theta,length,moveSrcPoint,distance)
    local r = {}
    r.width = length * MathFix.Sin(theta)
    r.length = distance/FInt(2)
    r.srcPoint = FVector3.New(FZero,FZero,moveSrcPoint.y + length * MathFix.Cos(theta) +  r.length)
    return r
end

function Physics.ToBoxConfig(rect)
    local r = {}
    r.ShapeType = ShapeType.Rect
    r.ShapeArg1 = rect.width
    r.ShapeArg2 = rect.length
    r.Offset = FVector3.New(rect.srcPoint.x,FZero,rect.srcPoint.y)
    r.MountType = MountType.Self
    return r
end


Physics.CollisionTestFunc = {}

Physics.CollisionTestFunc[ShapeType.Rect] =
function (selfPrevLocalPos,
          isContinuous,
          targetLocalPos,
          radius,
          shapeWidth,
          shapeLength)
    if Physics.Test2DCircleVSRect(targetLocalPos,radius,shapeWidth,shapeLength) then
        return true
    end

    if not isContinuous then
        return false
    end

    local tempRect = Physics.GenRectMoveRect(shapeWidth,
            selfPrevLocalPos,
            selfPrevLocalPos:Magnitude())

    return  Physics.Test2DCircleVSRect(targetLocalPos:ToLocalPos(tempRect.srcPoint,FZero),radius,tempRect.width,tempRect.length)
end


Physics.CollisionTestFunc[ShapeType.Sector] =
function (selfPrevLocalPos,
          isContinuous,
          targetLocalPos,
          radius,
          sectorRadius,
          sectorTheta)
    if Physics.Test2DCircleVSSector(targetLocalPos,radius,sectorRadius,sectorTheta) then
        return true
    end

    if not isContinuous then
        return false
    end

    local tempRect = Physics.GenSectorMoveRect(sectorTheta,
            sectorRadius,
            selfPrevLocalPos,
            selfPrevLocalPos:Magnitude())

    return  Physics.Test2DCircleVSRect(targetLocalPos:ToLocalPos(tempRect.srcPoint,FZero),radius,tempRect.width,tempRect.length)
end


Physics.CollisionTestFunc[ShapeType.Circle] =
function (selfPrevLocalPos,
          isContinuous,
          targetLocalPos,
          targetRadius,
          actorRadius,...)
    if Physics.Test2DCircleVSCircle(targetLocalPos,targetRadius,actorRadius) then
        return true
    end

    if not isContinuous then
        return false
    end

    local tempRect = Physics.GenCircleMoveRect(actorRadius,
            selfPrevLocalPos,
            selfPrevLocalPos:Magnitude())

    return  Physics.Test2DCircleVSRect(targetLocalPos:ToLocalPos(tempRect.srcPoint,FZero),targetRadius,tempRect.width,tempRect.length)
end



Physics.CollisionTestFunc[ShapeType.Segment] =
function (selfPrevLocalPos,
          isContinuous,
          targetLocalPos,
          targetRadius,
          SegLength,...)
    return Physics.Test2DCircleVSSegment(targetLocalPos,targetRadius,SegLength)
end


Physics.CollisionTestFunc[ShapeType.Ray] =
function (selfPrevLocalPos,
          isContinuous,
          targetLocalPos,
          targetRadius,...)
    return Physics.Test2DCircleVSRay(targetLocalPos,targetRadius)
end




--实时碰撞挤出相关函数 start

---@param selfTrans Transform
---@param selfCollider Collider 被挤出碰撞体
---@param baseTrans Transform
---@param baseCollider Transform
---@return FVector3 挤出后的圆心位置
function Physics.ColliderExtrusion(selfTrans,selfCollider,baseTrans,baseCollider)
    local selfPoints = Physics.GetCapsulePoints(selfTrans,selfCollider)
    local basePoints = Physics.GetCapsulePoints(baseTrans,baseCollider)

    return Physics.ColliderExtrusionFunc[selfCollider:GetShape()][baseCollider:GetShape()](
            selfPoints,
            selfCollider:GetRadius(),
            basePoints,
            baseCollider:GetRadius())
end


---@param capTrans Transform
---@param capCollider Collider
---@return table 胶囊线段两个端点坐标或圆心
function Physics.GetCapsulePoints(capTrans,capCollider)
    if capCollider:GetShape() ~= ShapeType.Capsule then
        return {capTrans:GetWorldPosition()}
    end

    local capPos = capTrans:GetWorldPosition()
    local capDir = capTrans:GetLocalForward().normalized
    if capCollider:GetConfShape() == 2 then -- 纵向胶囊
        return {
            FVector3.New(capPos.x + capDir.x * capCollider:GetLength(),
                    FZero,
                    capPos.z + capDir.z * capCollider:GetLength()),
            FVector3.New(capPos.x - capDir.x * capCollider:GetLength(),
                    FZero,
                    capPos.z - capDir.z * capCollider:GetLength())
        }
    end

    if capCollider:GetConfShape() == 3 then -- 横向胶囊
        return {
            FVector3.New(capPos.x + capDir.z * capCollider:GetLength(),
                    FZero,
                    capPos.z - capDir.x * capCollider:GetLength()),
            FVector3.New(capPos.x - capDir.z * capCollider:GetLength(),
                    FZero,
                    capPos.z + capDir.x * capCollider:GetLength())
        }
    end

    return nil
end

---@param A FVector3 线段AB端点
---@param B FVector3 线段AB端点
---@param C FVector3 线段CD端点
---@param D FVector3 线段CD端点
---@return FVector3 交点坐标
function Physics.GetLineSegmentCrossPoint(A,B,C,D)
    -- 三角形abc 面积的2倍
    local areaABC = (A.x - C.x) * (B.z - C.z) - (A.z - C.z) * (B.x - C.x)

    -- 三角形abd 面积的2倍
    local areaABD = (A.x - D.x) * (B.z - D.z) - (A.z - D.z) * (B.x - D.x)

    -- 面积符号相同则两点在线段同侧,不相交 (对点在线段上的情况,本例当作不相交处理);
    if areaABC * areaABD >= FZero then
        return nil
    end

    -- 三角形cda 面积的2倍
    local areaCDA = (C.x - A.x) * (D.z - A.z) - (C.z - A.z) * (D.x - A.x)
    --  三角形cdb 面积的2倍
    -- 注意: 这里有一个小优化.不需要再用公式计算面积,而是通过已知的三个面积加减得出.
    local areaCDB = areaCDA + areaABC - areaABD
    if areaCDA * areaCDB >= FZero then
        return nil
    end

    --计算交点坐标
    local t = areaCDA / ( areaABD- areaABC )
    return FVector3.New(A.x + t*(B.x - A.x) ,FZero, A.z + t*(B.z - A.z) )
end


---@param P FVector3
---@param A FVector3 线段AB端点
---@param B FVector3 线段AB端点
---@return FVector3 点到线段最短距离向量, 点P为向量终点
function Physics.PointToSegmentDistance(P,A,B)
    local ap = P - A
    local ab = B - A

    local apDotAb =  FVector3.Dot(ap,ab)
    local abSqr = ab:SqrMagnitude()
    if abSqr == 0 then
        return ap
    end

    local r = apDotAb / abSqr
    if r < FZero then
        return ap
    elseif r >= FOne then
        return P - B
    end

    local acDis = apDotAb / ab:Magnitude()
    ab:SetNormalize()

    return P - FVector3.New(A.x + ab.x * acDis,FZero,A.z + ab.z * acDis ) --垂足C到P向量
end


Physics.ColliderExtrusionFunc = {}
Physics.ColliderExtrusionFunc[ShapeType.Circle] = {}
Physics.ColliderExtrusionFunc[ShapeType.Capsule] = {}

---@param selfPoints table 被挤出圆圆心
---@param selfRadius Fix
---@param basePoints table 相交圆圆心
---@param baseRadius Fix
---@return FVector3 挤出后的圆心位置
Physics.ColliderExtrusionFunc[ShapeType.Circle][ShapeType.Circle] =
function (selfPoints,selfRadius,basePoints,baseRadius)
    if #selfPoints < 1 or #basePoints < 1 then
        return nil
    end

    local d = selfPoints[1] - basePoints[1]
    d.y = FZero
    local magnitude = d:Magnitude()

    local l = selfRadius + baseRadius - magnitude
    if l <= FZero then
        return selfPoints[1]
    end

    if magnitude == FZero then
        d = FVector3.forward
    else
        d:SetNormalize()
    end

    return FVector3.New(selfPoints[1].x + l * d.x,FZero,selfPoints[1].z + l * d.z)
end


---@param circlePoints table 被挤出圆圆心
---@param circleRadius Fix
---@param capPoints table 胶囊线段端点
---@param capRadius Fix 胶囊半径
---@return FVector3 挤出后的圆心位置
Physics.ColliderExtrusionFunc[ShapeType.Circle][ShapeType.Capsule] =
function (circlePoints,circleRadius,capPoints,capRadius)
    if #capPoints < 2 or #circlePoints < 1 then
        return nil
    end

    local extVec = Physics.PointToSegmentDistance(circlePoints[1],capPoints[1],capPoints[2])

    local l = circleRadius + capRadius - extVec:Magnitude()
    if l <= FZero then
        return circlePoints[1]
    end

    extVec:SetNormalize()
    return FVector3.New(circlePoints[1].x + l * extVec.x,
            FZero,
            circlePoints[1].z + l * extVec.z)
end


---@param selfPoints table 被挤胶囊端点
---@param selfRadius Fix
---@param basePoints table 圆心
---@param baseRadius Fix 半径
---@return FVector3 挤出后的位置
Physics.ColliderExtrusionFunc[ShapeType.Capsule][ShapeType.Circle] =
function (selfPoints,selfRadius,basePoints,baseRadius)
    if #selfPoints < 2 or #basePoints < 1 then
        return nil
    end

    local selfPos = selfPoints[1] + (selfPoints[2] - selfPoints[1]) / FTwo --todo zhou
    local extVec = Physics.PointToSegmentDistance(basePoints[1],selfPoints[1],selfPoints[2])

    local l = baseRadius + selfRadius - extVec:Magnitude()
    if l <= FZero then
        return selfPos
    end

    extVec:SetNormalize()
    return FVector3.New(selfPos.x - l * extVec.x,
            FZero,
            selfPos.z - l * extVec.z)
end


---@param selfPoints table 被挤胶囊端点
---@param selfRadius Fix 半径
---@param basePoints table 胶囊端点
---@param baseRadius Fix 半径
---@return FVector3 挤出后的位置
Physics.ColliderExtrusionFunc[ShapeType.Capsule][ShapeType.Capsule] =
function (selfPoints,selfRadius,basePoints,baseRadius)
    if #selfPoints < 2 or #basePoints < 2 then
        return nil
    end

    local selfPos = selfPoints[1] + (selfPoints[2] - selfPoints[1]) / FTwo
    -- 胶囊线段相交
    local crossPoint = Physics.GetLineSegmentCrossPoint(basePoints[1],basePoints[2],selfPoints[1],selfPoints[2])
    if crossPoint then
        local tempSeg = crossPoint - selfPoints[1]
        local tempSeg2 = crossPoint - selfPoints[2]

        if tempSeg:Magnitude() > tempSeg2:Magnitude() then
            tempSeg = tempSeg2
        end
        selfPos = FVector3.New(selfPos.x + tempSeg.x,
                FZero,
                selfPos.z + tempSeg.z)

        local tempSegNor = Physics.PointToSegmentDistance(selfPos,basePoints[1],basePoints[2]):SetNormalize()
        local l = baseRadius + selfRadius
        return FVector3.New(selfPos.x - l * tempSegNor.x,
                FZero,
                selfPos.z - l * tempSegNor.z)

    end

    local d = Physics.PointToSegmentDistance(selfPoints[1],basePoints[1],basePoints[2])
    local d2 = Physics.PointToSegmentDistance(selfPoints[2],basePoints[1],basePoints[2])
    -- 取距离较短的点
    if d:Magnitude()>d2:Magnitude() then
        d = d2
    end

    local l = baseRadius + selfRadius - d:Magnitude()
    if l <= FZero then
        return selfPos
    end

    return FVector3.New(selfPos.x + l * d.x,
            FZero,
           selfPos.z + l * d.z)
end

--实时碰撞挤出相关函数 end

