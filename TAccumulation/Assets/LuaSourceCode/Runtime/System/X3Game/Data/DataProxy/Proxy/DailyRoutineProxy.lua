---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sms.
--- DateTime: 2023/3/30 17:36

---@class DailyRoutineProxy
local DailyRoutineProxy = class("DailyRoutineProxy", BaseProxy)

---@type DailyRoutineUtil 工具类
local DailyRoutineUtil = require('Runtime.System.X3Game.Modules.DailyRoutine.DailyRoutineUtil')

---@type RoutineDataHandler 数据计算类
local RoutineDataHandler = require("Runtime.System.X3Game.Modules.DailyRoutine.RoutineDataHandler")


-- 单个作息状态数据 (区间段 带优先级)
---@class RoutineItemData
---@field state number 作息状态枚举 
---@field startTime number 开始时间 时间戳
---@field endTime number 结束时间 时间戳
---@field priority number 优先级

-- 所有作息数据 (客户端维护的全量数据)
---@class AllRoutineData
---@field GeneralDataMapByMonth table<number, RoutineItemData[]>                        普通作息列表                   key: monthIdx
---@field SpecialDataMapByMonth table<number, RoutineItemData[]>                        特殊作息列表                   key: monthIdx
---@field TriggerDataList RoutineItemData[]                                             主动触发的作息段
---@field FinallyDataList RoutineItemData[]                                             经上面三层计算最终得到的作息段列表

local function __getDayTimeSeconds(timeStr)
    local hour, minute, second = string.match(timeStr, "(%d+):(%d+):(%d+)")
    return tonumber(second) + tonumber(minute) * 60 + tonumber(hour) * 60 * 60
end

-- 根据作息Id获取一段作息数据
---@param self DailyRoutineProxy
---@param scheduleId number DailyRoutineScheduleId
---@param priority number 优先级
---@param startTime number 开始时间 (绝对时间戳) 因为从DailyRoutineSchedule表计算的都是时间的offset, 要加上startTime作为基础才是一个绝对的时间戳
---@param endTime number 结束时间 (绝对时间戳) 时间段截止时间点 超过这个时间点的数据就丢掉吧
---@param initTimeOffset number 1. 当计算普通作息时, initTimeOffset是当月第一天0点所在时间戳 - scheduleId对应静态配置第一天0点所在时间戳;
---                             2. 当计算特殊作息时，比如活动, initTimeOffset是dateStartTime - 活动开始日的0点时间戳;
local function __getScheduleDataListById(self, scheduleId, priority, startTime, endTime, initTimeOffset)
    local allCfg = LuaCfgMgr.GetListByCondition("DailyRoutineSchedule", {ScheduleID = scheduleId})
    if table.isnilorempty(allCfg) then Debug.LogError("!! __getScheduleDataListById  Error 配置找不到, ScheduleId : " .. table.dump({scheduleId})) return end
    -- 按时间排序
    table.sort(allCfg, function(a, b)
        if a.Week ~= b.Week then return a.Week < b.Week end
        if a.DayNum ~= b.DayNum then return a.DayNum < b.DayNum end
        
        local dayTimeSeconds_a = __getDayTimeSeconds(a.StateStartTime)
        local dayTimeSeconds_b = __getDayTimeSeconds(b.StateStartTime)
        if dayTimeSeconds_a ~= dayTimeSeconds_b then return dayTimeSeconds_a < dayTimeSeconds_b end
        
        return a.ID < b.ID
    end)
    
    local scheduleDataList = {}
    
    local curIdx = 1
    local startTimeInDay = 0
    local _curTimeOffset = initTimeOffset or 0

    -- 计算当前scheduleId所在配置的初始时间 (绝对时间)
    local cfgInitTime = initTimeOffset and (startTime - initTimeOffset) or startTime
    -- 结束时间
    local cfgEndTime = endTime
    
    for i = 1, #allCfg do
        -- 当前作息状态的时间配置
        local curCfg = allCfg[i]
        -- 当前作息状态的下一个时间配置
        local nextCfg = allCfg[i + 1]
        
        -- 当前作息状态开始时间, 基于cfgInitTime的offset
        local stateStartTimeOffset = BllMgr.GetDailyRoutineBLL():GetTimeOffsetByCfg(curCfg)
        -- 当前作息状态结束时间, 基于cfgInitTime的offset
        local nextStateStartTimeOffset = nextCfg and BllMgr.GetDailyRoutineBLL():GetTimeOffsetByCfg(nextCfg) or (endTime - startTime + initTimeOffset)
        
        -- 如果当前时间在当前作息状态的时间段内
        if stateStartTimeOffset <= _curTimeOffset and _curTimeOffset < nextStateStartTimeOffset then                -- 时间段符合 把作息加进去
            
            local routineStartTime = math.max(cfgInitTime + stateStartTimeOffset, startTime)              -- 开始时间跟着配置走
            local routineEndTime = math.min(cfgInitTime + nextStateStartTimeOffset - 1, endTime)          -- 这个状态的截止时间是下一个状态的开始时间 - 1s
            
            if routineEndTime > routineStartTime then
                table.insert(scheduleDataList, {
                    state = curCfg.RoutineState,                                                   -- 当前状态
                    startTime = routineStartTime,                                                  -- 开始时间
                    endTime = routineEndTime,                                                      -- 结束时间
                    priority = priority or 0,                                                      -- 优先级
                    debug_cfgId = curCfg.ID,                                                       -- Debug用 当前配置id
                })
                _curTimeOffset = nextStateStartTimeOffset         -- 添加后把这个时间放到下一个区间里
                -- 到了最终结束时间点就break
                if _curTimeOffset + cfgInitTime >= cfgEndTime then break end
            end
        end
    end
    
    --Debug.LogError("【结果】根据作息Id, 开始时间, 结束时间获取一段作息数据: " .. table.dump({scheduleId, scheduleDataList}))
    
    return scheduleDataList
end

-- 同步普通作息
---@param roleId number 男主Id
---@param generalScheduleMap table<number,number> @ key: 年月(202309) value：scheduleID
local function __syncGeneralScheduleMap(self, roleId, generalScheduleMap)
    ---@type AllRoutineData
    local roleRoutineData = self.allRoutineDataMap[roleId]
    roleRoutineData.GeneralDataMapByMonth = roleRoutineData.GeneralDataMapByMonth or {}
    
    if table.isnilorempty(generalScheduleMap) then return end
    for yearMonth, generalScheduleId in pairs(generalScheduleMap) do
        local monthIdx = yearMonth % 100
        -- 如果这个月份的数据没有解析过 则从配置里解析一次
        if table.isnilorempty(roleRoutineData.GeneralDataMapByMonth[monthIdx]) then
            -- 获取这个月份的开始和结束时间
            local initTimeInMonth, endTimeInMonth = DailyRoutineUtil.GetInitTimeInMonth(yearMonth)
            -- 获取开始时间对应的星期数
            local initWeekDayInMonth = DailyRoutineUtil.GetWeekDay(initTimeInMonth)

            -- 添加普通作息 (如果本月1号是周一 则找配置表时从第二周的数据开始读取解析)
            local initTimeOffset = (self.curMonthInitWeekDay == 1 and 7 or self.curMonthInitWeekDay - 1) * (60 * 60 * 24)
            local generalScheduleDataList = __getScheduleDataListById(self, generalScheduleId, DailyRoutineEnum.GeneralRoutinePriority,
                    initTimeInMonth, endTimeInMonth, initTimeOffset)
            
            --Debug.LogError("__syncGeneralScheduleMap: " .. table.dump({generalScheduleId, DailyRoutineEnum.GeneralRoutinePriority,
            --                           initTimeInMonth, endTimeInMonth, initTimeOffset}))
            --Debug.LogError("result : " .. table.dump(generalScheduleDataList))
            roleRoutineData.GeneralDataMapByMonth[monthIdx] = generalScheduleDataList
        end
    end
end
DailyRoutineProxy.SyncGeneralScheduleMap = __syncGeneralScheduleMap

-- 获取当前月份全部的特殊作息数据, 结果的时间区间段不合并 只是把数据全放到一个列表中
---@param self DailyRoutineProxy
---@param roleId number 男主Id
---@param monthIdx number 月份数
---@return RoutineItemData[] 日程数据列表
local function __getAllSpecialScheduleMapWithoutMerged(self, roleId, monthIdx)
    ---@type AllRoutineData
    local roleRoutineData = self.allRoutineDataMap[roleId]
    
    local result = {}
    if roleRoutineData and roleRoutineData.SpecialDataMapByMonth and not table.isnilorempty(roleRoutineData.SpecialDataMapByMonth[monthIdx]) then
        local dataMapInMonth = roleRoutineData.SpecialDataMapByMonth[monthIdx]
        for idx, routineItem in pairs(dataMapInMonth) do
            table.insert(result, routineItem)
        end
    end
    
    -- 这里还是要排个序的
    table.sort(result, function(a, b)
        if a.startTime ~= b.startTime then return a.startTime < b.startTime end
        return a.priority < b.priority
    end)
    
    return result
end
DailyRoutineProxy.GetAllSpecialScheduleMapWithoutMerged = __getAllSpecialScheduleMapWithoutMerged


-- 同步特殊作息数据
---@param self DailyRoutineProxy 
---@param specialDates table<number,pbcmessage.SpecialDateMap> @ 特殊日期日程 key:年月日时(2023092100 或 2023092105) value:当日特殊日程
local function __syncSpecialScheduleMap(self, roleId, specialDates)
    local roleRoutineData = self.allRoutineDataMap[roleId]
    -- 特殊作息每次数据更新都要重新解析一次 和普通作息不一样 相对动态 这里每次进来都要清一次
    roleRoutineData.SpecialDataMapByMonth = {}
    
    if table.isnilorempty(specialDates) then return end

    -- 通过这个_yearMonthDayHour获取两个时间戳 开始时间和结束时间 这个时间段的计算和给定key格式和服务器约定的
    local function __getDateTimeLimitByNum(_yearMonthDayHour)
        local _startTimeLimitByServerDate = DailyRoutineUtil:ConvertYearMonthDayHour2UTCTimeStamp(_yearMonthDayHour)
        local _endTimeLimitByServerDate
        if _yearMonthDayHour % 10 == 0 then
            -- 如果是0点开始 那结束时间就是4.59分
            _endTimeLimitByServerDate = _startTimeLimitByServerDate + 60 * 60 * 5 - 1
        else
            -- 如果是5点开始 那结束时间就是23.59分
            _endTimeLimitByServerDate = _startTimeLimitByServerDate + 60 * 60 * (24 - 5) - 1
        end
        return _startTimeLimitByServerDate, _endTimeLimitByServerDate
    end
    
    -- key: 年月日小时格式的number 
    for yearMonthDayHour, specialDateMap in pairs(specialDates) do
        if not table.isnilorempty(specialDateMap.Map) then
            for specialDateId, _ in pairs(specialDateMap.Map) do
                local specialDateCfg = LuaCfgMgr.Get("DailyRoutineSpecialDate", specialDateId)
                if table.isnilorempty(specialDateCfg) then Debug.LogError("DailyRoutineSpecialDateCfg not found, " .. tostring(specialDateId)) return end
                local priority = specialDateCfg.Priority
                local monthIdx = math.floor((yearMonthDayHour % 1000000) / 10000)
                local scheduleId = specialDateCfg.ScheduleID
                local startTime, endTime = BllMgr.GetDailyRoutineBLL():GetTimeRangeByTypeAndParams(specialDateCfg.SpecialDateType,
                        specialDateCfg.TypePara, specialDateCfg.SpecialDateStart, specialDateCfg.SpecialDateEnd)
                
                if startTime and endTime and startTime > 0 and endTime > 0 then
                    -- 根据日期获取当日对应时段的开始和结束时间
                    local startTimeLimitByServerDate, endTimeLimitByServerDate = __getDateTimeLimitByNum(yearMonthDayHour)
                    
                    -- 这个是日程初始时间 - 活动开始时间 用于后续计算当前处于第几天
                    local initTimeOffset = startTimeLimitByServerDate - DailyRoutineUtil.GetStartDayTimestamp(startTime)
                    
                    startTime = math.max(startTime, startTimeLimitByServerDate)
                    endTime = math.min(endTime, endTimeLimitByServerDate)
                    local specialScheduleDataList = __getScheduleDataListById(self, scheduleId, priority, startTime, endTime, initTimeOffset)
                    -- 数据塞进去
                    roleRoutineData.SpecialDataMapByMonth[monthIdx] = roleRoutineData.SpecialDataMapByMonth[monthIdx] or {}
                    for _, _data in ipairs(specialScheduleDataList) do
                        table.insert(roleRoutineData.SpecialDataMapByMonth[monthIdx], _data)
                    end
                end
            end
        end
    end
    
    --Debug.LogError("specialRoutineDataMap : " .. table.dump(roleRoutineData))
end
DailyRoutineProxy.SyncSpecialScheduleMap = __syncSpecialScheduleMap

-- 同步主动触发作息数据
---@param self DailyRoutineProxy
---@param roleId number
---@param stateList pbcmessage.DailyRoutineState[]
local function __syncTriggerScheduleMap(self, roleId, stateList)
    -- 筛一遍数据并存储
    if not table.isnilorempty(stateList) then
        local curTime = TimerMgr.GetCurTimeSeconds()
        self.allRoutineDataMap[roleId] = self.allRoutineDataMap[roleId] or {}
        self.allRoutineDataMap[roleId].TriggerDataList = {}
        for _, routineData in ipairs(stateList) do
            if routineData and routineData.EndTime and routineData.EndTime > curTime then
                table.insert(self.allRoutineDataMap[roleId].TriggerDataList, {
                    state = routineData.State, startTime = routineData.StartTime, endTime = routineData.EndTime, priority = DailyRoutineEnum.TriggerRoutinePriority})
            end
        end
    end
end

---@param self DailyRoutineProxy
---@param roleId number 男主Id
---@param monthIdx number 月份
local function __getFinallyScheduleList(self, roleId, monthIdx)
    --Debug.LogError("计算男主最终作息 ： " .. table.dump({roleId, monthIdx}))
    local allScheduleList = {}
    if table.isnilorempty(self.allRoutineDataMap[roleId]) then
        Debug.LogError("Error ---- " .. table.dump({roleId}))
        return {}
    end
    local roleRoutineData = self.allRoutineDataMap[roleId]

    -- 整理数据
    for _, routineItem in ipairs(roleRoutineData.GeneralDataMapByMonth[monthIdx] or {}) do
        table.insert(allScheduleList, routineItem)
    end
    for _, routineItem in pairs(roleRoutineData.SpecialDataMapByMonth and roleRoutineData.SpecialDataMapByMonth[monthIdx] or {}) do
        table.insert(allScheduleList, routineItem)
    end
    for _, routineItem in pairs(roleRoutineData.TriggerDataList or {}) do
        table.insert(allScheduleList, routineItem)
    end

    -- 进行计算 区间段按优先级合并
    local result = RoutineDataHandler:CalcAndMergeScheduleList(allScheduleList)

    return result
end
DailyRoutineProxy.GetFinallyScheduleList = __getFinallyScheduleList

-- 重新计算指定男主当月的最终时间表
local function __syncFinallyDataByRoleId(self, roleId)
    self.allRoutineDataMap[roleId].FinallyDataList = __getFinallyScheduleList(self, roleId, self.curMonthIdx)

    -- 更新(重新计算)对应男主的作息状态
    self:UpdateCurRoutineDataMapByRoleId(roleId)
    
    -- 派发事件 表示当前男主作息表已更新
    EventMgr.Dispatch(DailyRoutineEnum.EventMap.SyncFinallyRoutineData, roleId)
    
    -- 日志开了就打印一条当前的作息数据
    if DailyRoutineDebugMgr:IsLogOn() then
        local logContentList = DailyRoutineDebugMgr:DumpTargetTypeRoutineDataByRoleId(roleId, 4, true)
        for _, logContent in ipairs(logContentList) do
            DailyRoutineDebugMgr:Log(string.format(" <color=#00FF00> [作息更新] </color> " .. logContent))
        end
    end
end
DailyRoutineProxy.SyncFinallyDataByRoleId = __syncFinallyDataByRoleId

-- 重新计算所有男主当月的最终时间表
local function __syncAllFinallyData(self)
    local unlockRoleList = BllMgr.GetRoleBLL():GetUnlockedRole()
    for roleId, v in pairs(unlockRoleList) do
        __syncFinallyDataByRoleId(self, roleId)
    end
end
DailyRoutineProxy.SyncAllFinallyData = __syncAllFinallyData

-- 同步全量数据 基于proto.RoleDailyRoutineData
---@param self DailyRoutineProxy
---@param roleDailyRoutineData pbcmessage.RoleDailyRoutineData
---@param needSyncTriggerSchedule bool 需要从服务器数据拉取TriggerSchedule
local function __syncAllDataByRoleId(self, roleId, roleDailyRoutineData, needSyncTriggerSchedule)
    -- 如果男主未解锁则直接返回
    if not BllMgr.GetRoleBLL():IsUnlocked(roleId) then return end

    -- 加个机制 这里如果没传 说明是希望以原有的数据重新计算作息
    roleDailyRoutineData = roleDailyRoutineData or self.roleMap[roleId]
    
    self.roleMap = self.roleMap or {}
    self.roleMap[roleId] = roleDailyRoutineData
    
    --Debug.LogError("原始数据解析 ： " .. table.dump({roleId, roleDailyRoutineData}))
    self.allRoutineDataMap[roleId] = self.allRoutineDataMap[roleId] or {}
    ---@type AllRoutineData
    local allRoutineData = self.allRoutineDataMap[roleId]

    -- 这里应该做检查 如果ScheduleMap里的普通作息都没有内容 则应该直接跳过这个role的数据检查
    if not roleDailyRoutineData or table.isnilorempty(roleDailyRoutineData.ScheduleMap) then return end
    
    -- Debug Safe Call
    local status, error = pcall(function()
        -- 同步普通作息数据
        __syncGeneralScheduleMap(self, roleId, roleDailyRoutineData.ScheduleMap)

        -- 同步特殊作息数据
        __syncSpecialScheduleMap(self, roleId, roleDailyRoutineData.SpecialDates)

        -- 同步主动触发作息数据   (这个只有登陆时有必要同步一次 后面都由客户端维护)
        if needSyncTriggerSchedule then
            __syncTriggerScheduleMap(self, roleId, roleDailyRoutineData.StateList)
        end

        -- 按优先级进行区间合并 计算最终的作息数据  (这里只算当月的最终作息数据)
        __syncFinallyDataByRoleId(self, roleId)
    end)
    if not status then
        Debug.LogError("男主作息函数执行错误: " .. error)
    end
end
DailyRoutineProxy.SyncAllDataByRoleId = __syncAllDataByRoleId

-- 刷新时间相关的信息
---@param self DailyRoutineProxy
local function __refreshCurMonthInfo(self)
    -- 获取当前月份
    self.curMonthIdx = DailyRoutineUtil.GetCurMonthIdx()
    -- 计算当前月份初始时间戳和结束时间戳
    self.curMonthInitTimeStamp, self.curMonthEndTimeStamp = DailyRoutineUtil.GetInitTimeInMonth()
    -- 当前月份初始星期数
    self.curMonthInitWeekDay = DailyRoutineUtil.GetWeekDay(self.curMonthInitTimeStamp)
    
    --Debug.LogError("刷新月份标记 RefreshCurMonthInfo : " .. table.dump({self.curMonthIdx, self.curMonthInitTimeStamp, self.curMonthEndTimeStamp, self.curMonthInitWeekDay}))

    -- 跨月刷新 (这里只是刷一个本地的当前月份标记 实际业务数据会从服务器推过来的)
    local curTime = TimerMgr.GetCurTimeSeconds()
    if self.monthlyTickTimer then TimerMgr.Discard(self.monthlyTickTimer) self.monthlyTickTimer = nil end
    if self.curMonthEndTimeStamp - curTime < 2 * 24 * 60 * 60 then  -- 剩余三天内跨月的话加个计时器吧刷新当前时间
        self.monthlyTickTimer = TimerMgr.AddTimer(
                self.curMonthEndTimeStamp - curTime + 3,    -- 
                function()
                    -- 跨月时间刷新
                    __refreshCurMonthInfo(self)
                    
                    -- 重新计算所有男主时间表
                    __syncAllFinallyData(self)
                end
        , self, 1)
    end
end
DailyRoutineProxy.RefreshCurMonthInfo = __refreshCurMonthInfo

-- 获取指定男主的作息数据
---@param self DailyRoutineProxy
---@param roleId number 男主Id
---@return RoutineItemData[]
local function __getRoutineDataListByRoleId(self, roleId)
    if not roleId or roleId <= 0 then return {} end
    
    if self.allRoutineDataMap and self.allRoutineDataMap[roleId] and self.allRoutineDataMap[roleId].FinallyDataList then
        return self.allRoutineDataMap[roleId].FinallyDataList or {}
    end
    return {}
end
DailyRoutineProxy.GetRoutineDataListByRoleId = __getRoutineDataListByRoleId

-- 计算当前月份和当前月份对应的初始时间戳
---@param self DailyRoutineProxy
---@param dailyRoutineData  pbcmessage.DailyRoutineData @ 日常作息
local function __onLogin(self, dailyRoutineData)
    if DailyRoutineDebugMgr:IsLogOn() then
        DailyRoutineDebugMgr:Log("登陆获取全量数据 " .. table.dump(dailyRoutineData))
    end
    
    -- 获取当前月份
    __refreshCurMonthInfo(self)
    
    -- get all data 登陆时要同步全量数据
    local function __syncAll()
        if dailyRoutineData and not table.isnilorempty(dailyRoutineData.RoleMap) then
            for roleId, data in pairs(dailyRoutineData.RoleMap) do
                __syncAllDataByRoleId(self, roleId, data, true)
            end
        end
    end
    __syncAll()
    
    -- 数据更新时检查时间
    EventMgr.AddListener(DailyRoutineEnum.EventMap.SyncFinallyRoutineData, function(roleId) 
        __refreshCurMonthInfo(self)
    end, self)
    
    -- 生日数据更新时可能导致男主作息时间更新
    EventMgr.AddListener(PlayerBirthdayEventMap.TimeDataUpdate, function()
        -- 在这里重新计算所有男主的作息
        local roleList = BllMgr.GetRoleBLL():GetUnlockedRoleCfg()
        if not table.isnilorempty(roleList) then
            for _, cfg in pairs(roleList) do
                local roleId = cfg.ID
                __syncAllDataByRoleId(self, roleId, nil, false)
            end
        end
    end, self)
end
DailyRoutineProxy.OnLogin = __onLogin

-- 计算当前所处的作息段数据 (指定男主)
---@param self DailyRoutineProxy
---@param roleId number 男主Id
local function __calcCurRoutineDataByRoleId(self, roleId)
    if not roleId or roleId <= 0 then return end

    local curTime = TimerMgr.GetCurTimeSeconds()
    local routineDataList = SelfProxyFactory.GetDailyRoutineProxy():GetRoutineDataListByRoleId(roleId)
    if table.isnilorempty(routineDataList) then Debug.LogError("routineDataList nil -- " .. tostring(roleId)) return end

    for _, v in ipairs(routineDataList) do
        if curTime >= v.startTime and curTime <= v.endTime then return v end
    end
end
DailyRoutineProxy.CalcCurRoutineDataByRoleId = __calcCurRoutineDataByRoleId

-- 更新指定男主当前作息数据
---@param self DailyRoutineProxy
---@param roleId number 男主Id
local function __updateCurRoutineDataMapByRoleId(self, roleId)
    local preState = self.curRoutineDataMap[roleId] and self.curRoutineDataMap[roleId].state

    -- discard pre timer
    self.curStateTickTimerMap = self.curStateTickTimerMap or {}
    if self.curStateTickTimerMap[roleId] then TimerMgr.Discard(self.curStateTickTimerMap[roleId]) self.curStateTickTimerMap[roleId] = nil end
    
    local routineData = self:CalcCurRoutineDataByRoleId(roleId)
    if table.isnilorempty(routineData) then
        Debug.LogError("获取指定男主当前作息数据失败！ " .. table.dump({roleId}))
        Debug.LogError(table.dump({(self.allRoutineDataMap[roleId] or {}).FinallyDataList}))
        return
    end
    
    self.curRoutineDataMap[roleId] = routineData
    local newState = routineData.state
    local stateEndTime = routineData.endTime
    
    if preState ~= newState then
        -- 把状态同步给服务器
        BllMgr.GetDailyRoutineBLL():SyncCurState2Server(roleId, newState)
        
        -- 派发事件 这个男主的作息状态更新了
        EventMgr.Dispatch(DailyRoutineEnum.EventMap.RoleRoutineStateChanged, roleId, newState)
    end
    
    -- check timer
    self.curStateTickTimerMap[roleId] = TimerMgr.AddTimer(
            stateEndTime - TimerMgr.GetCurTimeSeconds() + 2,
            function()
                -- 获取当前月份
                local curMonthIdx = DailyRoutineUtil.GetCurMonthIdx()
                if curMonthIdx ~= self.curMonthIdx then
                    -- 如果经历跨月 就放掉 因为有跨月跨天专门处理的timer来做逻辑 基于服务器数据来的
                else
                    __updateCurRoutineDataMapByRoleId(self, roleId)
                end
            end,
            self, 1
    )
end
DailyRoutineProxy.UpdateCurRoutineDataMapByRoleId = __updateCurRoutineDataMapByRoleId

-- 更新所有男主当前作息数据
---@param self DailyRoutineProxy
local function __updateCurRoutineDataMap(self)
    local unlockRoleCfgList = BllMgr.GetRoleBLL():GetUnlockedRoleCfg()
    if not table.isnilorempty(unlockRoleCfgList) then
        for _, roleCfg in pairs(unlockRoleCfgList) do
            local roleId = roleCfg.ID
            -- 更新下数据
            __updateCurRoutineDataMapByRoleId(self, roleId)
        end
    end
end
DailyRoutineProxy.UpdateCurRoutineDataMap = __updateCurRoutineDataMap

-- 找到下一个指定状态的作息数据
---@param self DailyRoutineProxy
---@param roleId number 男主Id
---@param state number
local function __getNextTargetStateRoutineData(self, roleId, state)
    ---@type AllRoutineData
    local roleRoutineData = self.allRoutineDataMap[roleId]
    if roleRoutineData and roleRoutineData.FinallyDataList then
        local curTime = TimerMgr.GetCurTimeSeconds()
        for _, routineItemData in ipairs(roleRoutineData.FinallyDataList) do
            if routineItemData.startTime > curTime and routineItemData.state == state then
                return routineItemData
            end
        end
    end
end
DailyRoutineProxy.GetNextTargetStateRoutineData = __getNextTargetStateRoutineData

-- 获取指定男主的主动触发作息数据
---@param self DailyRoutineProxy
---@return RoutineItemData[]
local function __getTriggerRoutineByRoleId(self, roleId, clearOutDatedData)
    self.allRoutineDataMap[roleId] = self.allRoutineDataMap[roleId] or {}
    self.allRoutineDataMap[roleId].TriggerDataList = self.allRoutineDataMap[roleId].TriggerDataList or {}
    
    -- 清理所有过期的TriggerDataList
    if clearOutDatedData then
        local curTime = TimerMgr.GetCurTimeSeconds()
        for i = #self.allRoutineDataMap[roleId].TriggerDataList, 1, -1 do
            local data = self.allRoutineDataMap[roleId].TriggerDataList[i]
            if data.endTime < curTime then
                table.remove(self.allRoutineDataMap[roleId].TriggerDataList, i)
            end
        end
    end
    
    return self.allRoutineDataMap[roleId].TriggerDataList
end
DailyRoutineProxy.GetTriggerRoutineByRoleId = __getTriggerRoutineByRoleId

-- 添加一个主动触发的状态到Map里 (被叫醒)
---@param self DailyRoutineProxy
local function __addTriggerRoutine2Map(self, roleId, state, startTime, endTime, priority)
    priority = priority or DailyRoutineEnum.TriggerRoutinePriority
    
    self.allRoutineDataMap[roleId] = self.allRoutineDataMap[roleId] or {}
    self.allRoutineDataMap[roleId].TriggerDataList = self.allRoutineDataMap[roleId].TriggerDataList or {}
    
    -- 添加新的状态数据
    table.insert(self.allRoutineDataMap[roleId].TriggerDataList, {state = state, startTime = startTime, endTime = endTime, priority = priority})
    
    -- 重新计算作息表
    __syncFinallyDataByRoleId(self, roleId)
end
DailyRoutineProxy.AddTriggerRoutine2Map = __addTriggerRoutine2Map

function DailyRoutineProxy:OnInit()
    ---@type table<number, AllRoutineData> 所有男主的作息数据Map          key: roleId, value: AllRoutineData
    self.allRoutineDataMap = {}
    
    ---@type table<number, RoutineItemData> 当前男主所处的作息数据状态     key: roleId,  value: RoutineItemData
    self.curRoutineDataMap = {}
    ---@type table<number, number> 维护当前男主的作息状态的定时器Map       key: roleId     value: timerId
    self.curStateTickTimerMap = {}
    
    ---@type number 当前月份
    self.curMonthIdx = 0
    ---@type number 当前月份初始日对应的时间戳
    self.curMonthInitTimeStamp = 0
    ---@type number 当前月份结束时间戳
    self.curMonthEndTimeStamp = 0
    ---@type number 当前月份初始星期数
    self.curMonthInitWeekDay = 0
end

local function __checkClearTimer(self)
    TimerMgr.DiscardTimerByTarget(self)
    self.monthlyTickTimer = nil
    self.curStateTickTimerMap = nil
end

function DailyRoutineProxy:OnClear()
    __checkClearTimer(self)
    
    self.allRoutineDataMap = {}
    self.curRoutineDataMap = {}
    
    self.curMonthIdx = 0
    self.curMonthInitTimeStamp = 0
    self.curMonthEndTimeStamp = 0
    self.curMonthInitWeekDay = 0
end

return DailyRoutineProxy