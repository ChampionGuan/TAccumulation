---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by afan002.
--- DateTime: 2023/10/19 17:52

---DropMultiple数据
---@class DropMultipleProxy
local DropMultipleProxy = class("DropMultipleProxy", BaseProxy)

---@class DropMultipleSortInfo
---@field rewardMultiple int 奖励倍数
---@field timesRefreshType Define.DateRefreshType 刷新周期类型
---@field rewardTimes int 剩余奖励次数
---@field timesLimit int 奖励次数上限
---@field nextRefreshTime int 下次刷新时间
---@field activityId int 活动ID
---@field priority int 优先级 0 : 活动多倍 10 : 回流 越大优先级越高

---统一初始化，只会调用一次
---@param owner ProxyFactory
function DropMultipleProxy:OnInit()
    self.refreshTimerIDDic = {}

    EventMgr.AddListener("CommonDailyReset", self.OnCommonDailyReset, self)
end

---统一清理相关数据状态，只会调用一次
function DropMultipleProxy:OnClear()
    self.refreshTimerIDDic = nil
    X3DataMgr.UnsubscribeWithTarget(self)
    TimerMgr.DiscardTimerByTarget(self)
    EventMgr.RemoveListenerByTarget(self)
end

---多倍活动跨天
function DropMultipleProxy:OnCommonDailyReset()
    --Debug.LogErrorFormatWithTag("多倍掉落刷新", "OnActivityDropMultipleDayPass")

    self:OnTimeRefresh()
end

---特殊刷新周期多倍活动刷新
function DropMultipleProxy:OnSpecialTimeRefresh()
    --Debug.LogErrorFormatWithTag("多倍掉落刷新", "OnSpecialTimeRefresh")

    self:OnTimeRefresh()
end

---刷新多倍掉落时间
function DropMultipleProxy:OnTimeRefresh()
    self:OnRefreshActivityMultipleTime()

    EventMgr.Dispatch("OnDropMultipleTimeRefresh")
end

--region Debug

---统一清理相关数据状态，只会调用一次
function DropMultipleProxy:SetDebugMode(active)
    self.debugMode = active
end

--endregion

--region ActivityDropMultiple

function DropMultipleProxy:UpdateActivityDropMultiple(activityID, DropMultiple)
    if not DropMultiple then
        return
    end

    local details = DropMultiple.Details
    if not details then
        return
    end

    local cfgDic = LuaCfgMgr.GetListByCondition("ActivityDropMultiple", { ActivityID = activityID })
    for ActivityID, v in pairs(cfgDic) do
        if details and details[v.ID] then
            self:UpdateActivityDropMultipleData(false, activityID, v.ID, details[v.ID].RewardTimes, details[v.ID].LastUpdateTime)
        else
            self:UpdateActivityDropMultipleData(false, activityID, v.ID, 0, TimerMgr.GetCurTimeSeconds())
        end
    end
end

---更新多倍奖励信息
---@param activityId int 活动ID
---@param id int 内部ID
---@param rewardTimes int 已使用奖励次数
---@param lastUpdateTime int 上次刷新时间
function DropMultipleProxy:UpdateActivityDropMultipleData(isNetMsg, activityId, id, rewardTimes, lastUpdateTime)
    if not activityId or not id then
        return
    end

    ---@type X3Data.ActivityDropMultipleData
    local data = X3DataMgr.Get(X3DataConst.X3Data.ActivityDropMultipleData, activityId)
    if not data then
        data = X3DataMgr.AddByPrimary(X3DataConst.X3Data.ActivityDropMultipleData, nil, activityId)
    end

    ---@type table<int, X3Data.DropMultipleData>
    local dropMultipleDataMap = data:GetDropMultipleDataMap()
    ---@type X3Data.DropMultipleData
    local dropMultipleData
    if dropMultipleDataMap then
        dropMultipleData = dropMultipleDataMap[id]
    end

    if not dropMultipleData then
        dropMultipleData = X3DataMgr.Add(X3DataConst.X3Data.DropMultipleData)
        data:AddOrUpdateDropMultipleDataMapValue(id, dropMultipleData)
    end

    dropMultipleData:SetRewardTimes(rewardTimes)
    dropMultipleData:SetLastUpdateTime(lastUpdateTime)

    local cfg = LuaCfgMgr.Get("ActivityDropMultiple", activityId, id)
    if cfg then
        local nextUpdateTime = TimeRefreshUtil.GetNextRefreshTime(lastUpdateTime, cfg.TimesRefreshType, cfg.TimesRefreshDetail)
        dropMultipleData:SetNextUpdateTime(nextUpdateTime)

        if cfg.TimesRefreshType > Define.DateRefreshType.Year then
            local curTime = TimerMgr.GetCurTimeSeconds()
            if not self.refreshTimerIDDic[nextUpdateTime] then
                self.refreshTimerIDDic[nextUpdateTime] = TimerMgr.AddTimer(nextUpdateTime - curTime, self.OnSpecialTimeRefresh, self)
            end
        end
    else
        dropMultipleData:SetNextUpdateTime(0)

        Debug.LogErrorFormatWithTag(GameConst.LogTag.DropMultiple, "cfg == nil key : %s_%s", tostring(activityId), tostring(id))
    end

    if isNetMsg then
        EventMgr.Dispatch("UpdateDropMultiple", cfg.EffectSystem, cfg.EffectStageType, cfg.SubType, cfg.EffectStage)
    end
end

---刷新活动多倍掉落时间
function DropMultipleProxy:OnRefreshActivityMultipleTime()
    ---@type X3Data.ActivityDropMultipleData[]
    local activityDropMultipleDataList = PoolUtil.GetTable()
    local count = X3DataMgr.GetAll(X3DataConst.X3Data.ActivityDropMultipleData, activityDropMultipleDataList)
    if count > 0 then
        local curTime = TimerMgr.GetCurTimeSeconds()
        for _, data in pairs(activityDropMultipleDataList) do
            local activityId = data:GetPrimaryValue()
            local cmsCfg = BllMgr.GetActivityCenterBLL():GetActivityCMSConfig(activityId)
            local isOpen, isClose = BllMgr.GetActivityCenterBLL():GetOpenState(cmsCfg, true)
            if isOpen or self.debugMode then
                ---@type table<int, X3Data.DropMultipleData>
                local dropMultipleDataMap = data:GetDropMultipleDataMap()
                if dropMultipleDataMap then
                    for id, dropMultipleData in pairs(dropMultipleDataMap) do
                        local oldLastUpdateTime = dropMultipleData:GetLastUpdateTime()
                        local oldNextUpdateTime = dropMultipleData:GetNextUpdateTime()
                        if oldLastUpdateTime < oldNextUpdateTime and oldNextUpdateTime <= curTime then
                            dropMultipleData:SetLastUpdateTime(oldNextUpdateTime)
                            dropMultipleData:SetRewardTimes(0)

                            local cfg = LuaCfgMgr.Get("ActivityDropMultiple", activityId, id)
                            if cfg then
                                local nextUpdateTime = TimeRefreshUtil.GetNextRefreshTime(oldNextUpdateTime + 1, cfg.TimesRefreshType, cfg.TimesRefreshDetail)
                                dropMultipleData:SetNextUpdateTime(nextUpdateTime)
                            else
                                dropMultipleData:SetNextUpdateTime(0)
                            end
                        end
                    end
                end
            end
        end
    end

    PoolUtil.Release(activityDropMultipleDataList)
end

---@param rewardMultiple int 奖励倍数
---@param timesRefreshType Define.DateRefreshType 刷新周期类型
---@return string rewardMultiple_timesRefreshType
function DropMultipleProxy:GetSortKey(rewardMultiple, timesRefreshType)
    local key = string.format("%s_%s", rewardMultiple, timesRefreshType)
    return key
end

---@param activityID int 活动ID
---@param id int 多倍活动ID
---@return string activity_activityID_id
function DropMultipleProxy:GetActivityDropMultipleKey(activityID, id)
    local key = string.format("activity_%s_%s", activityID, id)
    return key
end

---获取Activity的DropMultiple相关信息
---@param results table<string, DropMultipleSortInfo> 返回结果
---@param effectSystem int 系统枚举
---@param effectStageType int 关卡类型枚举
---@param subType int 关卡子类
---@param effectStage int 关卡ID
---@param filterParams table<string, any> 筛选参数组
function DropMultipleProxy:GetActivityDropMultipleInfo(results, effectSystem, effectStageType, subType, effectStage, filterParams)
    ---@type table<int, X3Data.ActivityDropMultipleData>
    local activityDropMultipleDataList = PoolUtil.GetTable()
    local count = X3DataMgr.GetAll(X3DataConst.X3Data.ActivityDropMultipleData, activityDropMultipleDataList)
    if count > 0 then
        effectSystem = effectSystem and effectSystem or 0
        effectStageType = effectStageType and effectStageType or 0
        subType = subType and subType or 0
        effectStage = effectStage and effectStage or 0

        for _, data in pairs(activityDropMultipleDataList) do
            local activityId = data:GetPrimaryValue()
            local cmsCfg = BllMgr.GetActivityCenterBLL():GetActivityCMSConfig(activityId)
            local isOpen, isClose = BllMgr.GetActivityCenterBLL():GetOpenState(cmsCfg, true)

            local meetFilter = not filterParams
            if filterParams then
                isOpen = isOpen or filterParams.ignoreOpen

                local matchActivity = not filterParams.activityID or filterParams.activityID == activityId
                meetFilter = matchActivity
            end

            if isOpen and meetFilter then
                ---@type table<int, X3Data.DropMultipleData>
                local dropMultipleDataMap = data:GetDropMultipleDataMap()
                if dropMultipleDataMap then
                    for id, dropMultipleData in pairs(dropMultipleDataMap) do
                        local cfg = LuaCfgMgr.Get("ActivityDropMultiple", activityId, id)
                        local isMatch = cfg
                                and (effectSystem == X3DataConst.DropMultipleEffectSystemType.DropMultipleEffectSystemTypeNone or cfg.EffectSystem == effectSystem) --不要求系统类型或系统类型匹配
                                and (effectStageType == 0 or cfg.EffectStageType == effectStageType)    --不要求关卡类型或关卡类型匹配
                                and (subType == 0 or not cfg.SubType or #cfg.SubType == 0 or table.containsvalue(cfg.SubType, subType)) --不要求关卡子类型或关卡子类型匹配
                                and (effectStage == 0 or not cfg.EffectStage or #cfg.EffectStage == 0 or table.containsvalue(cfg.EffectStage, effectStage)) --不指定关卡ID或关卡ID匹配
                        if isMatch then
                            local info = {
                                rewardMultiple = cfg.RewardMultiple,
                                timesRefreshType = cfg.TimesRefreshType,
                                rewardTimes = dropMultipleData:GetRewardTimes(),
                                timesLimit = cfg.TimesLimit,
                                nextRefreshTime = dropMultipleData:GetNextUpdateTime(),
                                activityId = cfg.ActivityID,
                                priority = 0,
                            }

                            if info.nextRefreshTime then
                                local key = self:GetSortKey(info.rewardMultiple, info.timesRefreshType)
                                if results[key] then
                                    local needReplace = false
                                    if results[key].nextRefreshTime == info.nextRefreshTime then
                                        needReplace = results[key].activityId > info.activityId
                                    else
                                        needReplace = results[key].nextRefreshTime == 0 or results[key].nextRefreshTime > info.nextRefreshTime
                                    end

                                    if needReplace then
                                        results[key].nextRefreshTime = info.nextRefreshTime
                                        results[key].activityId = info.activityId
                                    end

                                    results[key].rewardTimes = results[key].rewardTimes + info.rewardTimes
                                    results[key].timesLimit = results[key].timesLimit + info.timesLimit
                                else
                                    results[key] = info
                                end
                            end
                        end

                    end
                end
            end
        end
    end
    PoolUtil.Release(activityDropMultipleDataList)
end

--endregion

--region 回流活动多倍奖励

---获取回流活动多倍奖励信息
---@param dropMultipleInfoMap table<string, DropMultipleSortInfo> key : rewardMultiple_timeRefreshType value : DropMultipleSortInfo
---@param effectSystem X3DataConst.DropMultipleEffectSystemType 系统类型
---@param effectStageType Define.EStageType 关卡类型
---@param subType Define.Enum_StageType 关卡子类型
---@param effectStage int 关卡ID
function DropMultipleProxy:GetReturnActivityDropMultipleInfo(dropMultipleInfoMap, effectSystem, effectStageType, subType, effectStage)
    if not BllMgr.GetReturnActivityBll():IsInReturnActivity() then
        return
    end

    ---@type DropMultipleSortInfo
    local returnMultipleInfo = PoolUtil.GetTable()

    returnMultipleInfo.rewardMultiple = 2
    returnMultipleInfo.timesRefreshType = Define.DateRefreshType.Day
    returnMultipleInfo.rewardTimes = BllMgr.GetReturnActivityBll():GetDoubleTime(effectStageType)
    returnMultipleInfo.timesLimit = BllMgr.GetReturnActivityBll():GetDoubleMaxTime(effectStageType)
    returnMultipleInfo.nextRefreshTime = TimeRefreshUtil.GetNextRefreshTime(TimerMgr.GetCurTimeSeconds(), Define.DateRefreshType.Day)
    returnMultipleInfo.activityId = 0
    returnMultipleInfo.priority = 10

    local sortKey = self:GetSortKey(returnMultipleInfo.rewardMultiple, returnMultipleInfo.timesRefreshType)
    local dropMultipleInfo = dropMultipleInfoMap[sortKey]
    if dropMultipleInfo then
        local needReplace = false
        if dropMultipleInfo.nextRefreshTime ~= returnMultipleInfo.nextRefreshTime then
            needReplace = dropMultipleInfo.nextRefreshTime == 0 or dropMultipleInfo.nextRefreshTime > returnMultipleInfo.nextRefreshTime
        end

        if needReplace then
            dropMultipleInfo.nextRefreshTime = returnMultipleInfo.nextRefreshTime
        end

        dropMultipleInfo.rewardTimes = dropMultipleInfo.rewardTimes + returnMultipleInfo.rewardTimes
        dropMultipleInfo.timesLimit = dropMultipleInfo.timesLimit + returnMultipleInfo.timesLimit
    else
        dropMultipleInfo = {}
        dropMultipleInfoMap[sortKey] = dropMultipleInfo

        for k, v in pairs(returnMultipleInfo) do
            dropMultipleInfo[k] = v
        end
    end


    PoolUtil.Release(returnMultipleInfo)
end

--endregion


---@param infoA DropMultipleSortInfo
---@param infoB DropMultipleSortInfo
---@return bool
function DropMultipleProxy:Sort(infoA, infoB)
    local noLeftTimesA = infoA.rewardTimes >= infoA.timesLimit
    local noLeftTimesB = infoB.rewardTimes >= infoB.timesLimit
    --次数是否为0
    if noLeftTimesA ~= noLeftTimesB then
        return not noLeftTimesA
    end

    --奖励倍数
    if infoA.rewardMultiple ~= infoB.rewardMultiple then
        return infoA.rewardMultiple > infoB.rewardMultiple
    end

    --刷新类型不同，
    if infoA.timesRefreshType ~= infoB.timesRefreshType then
        --刷新时间
        if infoA.nextRefreshTime ~= infoB.nextRefreshTime then
            return infoB.nextRefreshTime == 0 or infoA.nextRefreshTime < infoB.nextRefreshTime
        end

        --优先级
        if infoA.priority ~= infoB.priority then
            return infoA.priority > infoB.priority
        end

        --活动ID
        if infoA.activityId ~= infoB.activityId then
            return infoA.activityId < infoB.activityId
        end
    end

    return false
end

---@param effectSystem X3DataConst.DropMultipleEffectSystemType 系统类型
---@param effectStageType Define.EStageType 关卡类型
---@param subType Define.Enum_StageType 关卡子类型
---@param effectStage int 关卡ID
---@param filterType int 筛选类型
---@param filterParams table<string, any> 筛选参数组
---@return int, int, int, int, int leftTimes, timesLimit, rewardMultiple, timesRefreshType, nextRefreshTime
function DropMultipleProxy:GetDropMultipleInfo(effectSystem, effectStageType, subType, effectStage, filterType, filterParams)
    ---@type table<string, DropMultipleSortInfo>
    local dropMultipleInfoMap = PoolUtil.GetTable()
    ---@type DropMultipleSortInfo[]
    local dropMultipleInfoList = PoolUtil.GetTable()

    filterType = filterType or X3DataConst.DropMultipleFilterType.DropMultipleFilterTypeAll

    ---多倍奖励活动
    if filterType == X3DataConst.DropMultipleFilterType.DropMultipleFilterTypeAll or filterType == X3DataConst.DropMultipleFilterType.DropMultipleFilterTypeActivity then
        self:GetActivityDropMultipleInfo(dropMultipleInfoMap, effectSystem, effectStageType, subType, effectStage, filterParams)
    end

    ---回流活动
    if filterType == X3DataConst.DropMultipleFilterType.DropMultipleFilterTypeAll or filterType == X3DataConst.DropMultipleFilterType.DropMultipleFilterTypeReturnActivity then
        self:GetReturnActivityDropMultipleInfo(dropMultipleInfoMap, effectSystem, effectStageType, subType, effectStage, filterParams)
    end

    for key, v in pairs(dropMultipleInfoMap) do
        table.insert(dropMultipleInfoList, v)
    end
    table.sort(dropMultipleInfoList, function(a, b) return self:Sort(a, b) end)

    local leftTimes = 0
    local timesLimit = 0
    local rewardMultiple = 0
    local timesRefreshType = 0
    local nextRefreshTime = 0

    local dropMultipleInfo = dropMultipleInfoList[1]
    if dropMultipleInfo then
        leftTimes = dropMultipleInfo.timesLimit - dropMultipleInfo.rewardTimes
        timesLimit = dropMultipleInfo.timesLimit
        rewardMultiple = dropMultipleInfo.rewardMultiple
        timesRefreshType = dropMultipleInfo.timesRefreshType
        nextRefreshTime = dropMultipleInfo.nextRefreshTime
    end

    PoolUtil.Release(dropMultipleInfoMap)
    PoolUtil.Release(dropMultipleInfoList)

    return leftTimes, timesLimit, rewardMultiple, timesRefreshType, nextRefreshTime
end

return DropMultipleProxy

