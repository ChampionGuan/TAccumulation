---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by doudou.
--- DateTime: 2022/5/13 16:32
---@class FriendProxy:BaseProxy
local FriendProxy = class("FriendProxy", BaseProxy)

---@type MixTable
local MixTable = require("Runtime.System.X3Game.Modules.Friend.MixTable")
--region local function
---@排序函数
local FriendSort = function(player1, player2)
    local info1 = player1.AppliedFriend and player1.AppliedFriend or player1
    local info2 = player2.AppliedFriend and player2.AppliedFriend or player2

    ---a)     在线的显示在最前面 ，不在线的显示在后面
    local aIsOnline = info1.LastLoginTime > info1.LastOfflineTime or false
    local bIsOnline = info2.LastLoginTime > info2.LastOfflineTime or false

    ---0.1、在线靠前
    if aIsOnline ~= bIsOnline then
        return aIsOnline
    end

    ---1、同时离线的玩家，离线时间点越是靠近现在
    if (not aIsOnline) and (not bIsOnline) then
        if info1.LastOfflineTime ~= info2.LastOfflineTime then
            return info1.LastOfflineTime > info2.LastOfflineTime
        end
    end

    ---2、是否有待领取的礼物
    if info1.isGiftDrawed ~= info2.isGiftDrawed then
        if info1.isGiftDrawed == false then
            return true
        end
        if info2.isGiftDrawed == false then
            return false
        end
    end

    ---3、等级、uid
    if info1.Level ~= info2.Level then
        return info1.Level > info2.Level
    end
    return info1.Uid > info2.Uid
end

local RefreshFriendedItem = function(friendInfo, indexPos, _playerInfo)
    local metaTable = getmetatable(friendInfo)
    if metaTable then
        local rawData = metaTable.__index
        for keyName, _ in pairs(rawData) do
            metaTable[keyName] = _playerInfo[keyName]
        end
        return true
    end
end

local RefreshFriendingItem = function(friendInfo, indexPos, _playerInfo)
    for keyName, _ in pairs(friendInfo) do
        friendInfo[keyName] = _playerInfo[keyName]
    end
    return true
end

local RefreshNewFriendInfo = function(friendInfo,  fullInfo, curFriendNew)
    local metaTable = getmetatable(friendInfo)
    if metaTable then
        local _rawData = metaTable.__index
        for keyName, value in pairs(_rawData) do
            if curFriendNew then
                fullInfo[keyName] = value
            else
                _rawData[keyName] = fullInfo[keyName]
            end
        end
    else
        for keyName, value in pairs(friendInfo) do
            if curFriendNew then
                fullInfo[keyName] = value
            else
                friendInfo[keyName] = fullInfo[keyName]
            end
        end
    end
    return true
end
--endregion

function FriendProxy:OnInit()
    ---@type pbcmessage.FriendData
    self.friendData = {}

    ---@type MixTable
    self.friendTable = MixTable.new("Uid", FriendSort)

    ---@type MixTable
    self.friendingTable = MixTable.new("Uid", FriendSort)

    ---@type MixTable
    self.applyTable = MixTable.new("Uid", FriendSort)

    ---@type MixTable
    self.recommendTable = MixTable.new("Uid", FriendSort)

    self.staminaSendDict = {}
    self.staminaReceiveDict = {}
    self.friendDict = {}
    self.friendingDict = {}    ---申请列表，红点单独用（为配合服务器优化数据）
    self.myApply = {}

    self.searchList = {}

    ---@type FriendCacheData
    self.cacheData = require("Runtime.System.X3Game.Data.DataProxy.Data.FriendCacheData").new()
end

function FriendProxy:Reset()
    self.friendData = nil

    self.friendTable:ClearData()
    self.friendingTable:ClearData()
    self.applyTable:ClearData()
    ---推荐列表是单独请求的，不在全量刷新时清除
    --self.recommendTable:ClearData()
    self.staminaSendDict = {}
    self.staminaReceiveDict = {}
    self.friendDict = {}
    self.searchList = {}
    self.friendingDict = {}
end

--region data
function FriendProxy:UpdateFriendData(data)
    self.friendData = data
end

function FriendProxy:RefreshMaxCount()
    self.friendData.FriendMaxNum = math.max(self:GetFriendCount(), self:GetFriendMaxCount())
end

function FriendProxy:SetFriendMaxCount(maxCount)
    self.friendData.FriendMaxNum = maxCount
end
--endregion


--region Stamina
function FriendProxy:AddStaminaSendMap(sendList, time)
    table.clear(self.staminaSendDict)
    if TimerMgr.GetCurTimeSeconds() - time <= 24 * 60 * 60 then
        for k, v in pairs(sendList) do
            self.staminaSendDict[v] = { Time = time }
        end
    end
end

function FriendProxy:AddStaminaSend(uid)
    if self.staminaSendDict[uid] then
        print("==server data is error===我给好友赠礼的、关联好友数据重复：", uid)
    else
        local info = { Time = TimerMgr.GetCurTimeSeconds()}
        self.staminaSendDict[uid] = info
    end
end

function FriendProxy:RemoveStaminaSendByList(list)
    if list == nil then
        return
    end
    for i = 1, #list do
        self.staminaSendDict[list[i]] = nil
    end
end

function FriendProxy:AddStaminaReceiveMap(receivedList, time, unRecvMap)
    table.clear(self.staminaReceiveDict)
    ---理论上只有未领取的时间是有意义的
    if unRecvMap then
        for k, v in pairs(unRecvMap) do
            self.staminaReceiveDict[k] = { Time = v, Recvd = false }
        end
    end
    if TimerMgr.GetCurTimeSeconds() - time <= 24 * 60 * 60 then
        if receivedList then
            for k, v in pairs(receivedList) do
                self.staminaReceiveDict[v] = { Time = time, Recvd = true }
            end
        end
    end
end

function FriendProxy:AddStaminaReceive(uid)
    if self.staminaReceiveDict[uid] then
        print("==server data is error===我给好友赠礼的、关联好友数据重复：", uid)
    else
        local info = { Time = TimerMgr.GetCurTimeSeconds(), Recvd = false }
        self.staminaReceiveDict[uid] = info
    end
end

function FriendProxy:RemoveStaminaReceiveByList(list)
    if list == nil then
        return
    end
    for i = 1, #list do
        self.staminaReceiveDict[list[i]] = nil
    end
end

function FriendProxy:SetStaminaDrawn(uid)
    local info = self.staminaReceiveDict[uid]
    if info then
        info.Recvd = true
    end
end
--endregion

--region friended

function FriendProxy:AddFriendBaseMap(friendIdList)
    if friendIdList then
        for _, uid in ipairs(friendIdList) do
            self.friendDict[uid] = true
        end
    end
end

function FriendProxy:AddFriendedMap(friendMap)
    for _, playerInfo in pairs(friendMap) do
        self:AddFriended(playerInfo)
    end
end

function FriendProxy:AddFriended(friend)
    if self.friendTable:GetByKey(friend.Uid) then
        print("==server data is error===好友数据重复：", friend.Uid)
        return false
    else
        local friendInfo = self:_GetFriendItem(friend)
        self.friendTable:AddByKey(friendInfo)
        self.friendDict[friend.Uid] = true
        EventMgr.Dispatch("FRIEND_DEL_APPLY_RP", friend.Uid)
        return true
    end
end

function FriendProxy:RemoveFriendedByUid(uid)
    local info, _ = self.friendTable:RemoveKey(uid)
    self.friendDict[uid] = nil
    --self.staminaSendDict[uid] = nil
    --self.staminaReceiveDict[uid] = nil
    return info
end

function FriendProxy:_GetFriendItem(rawData)
    local friendItem = {}
    setmetatable(friendItem, { __index = rawData })
    self:RefreshFriendedItem(friendItem, true)
    return friendItem
end

function FriendProxy:RefreshFriendedItem(friendItem, noSort)
    friendItem.isGiftSended = self.staminaSendDict[friendItem.Uid] ~= nil
    local staminaInfo = self.staminaReceiveDict[friendItem.Uid]
    if staminaInfo then
        friendItem.isGiftDrawed = staminaInfo.Recvd or false
        --[[
        ---好友赠礼的时间戳，超过指定时间过期
        if friendItem.isGiftDrawed then
            friendItem.giftRecvedTimeStamp = friendItem.Time
        end
        --]]
    else
        friendItem.isGiftDrawed = nil
        --friendItem.giftRecvedTimeStamp = nil
    end

    if not noSort then
        self.friendTable:Sort()
    end
end

function FriendProxy:RefreshFriendedItemByUid(uid)
    local info = self:GetFriendedByUid(uid)
    if info then
        self:RefreshFriendedItem(info)
    end
end

function FriendProxy:RefreshFriendedPlayerInfo(playerInfoList)
    if playerInfoList == nil then
        return
    end
    local resort = false
    for _, _playerInfo in ipairs(playerInfoList) do
        resort = resort or self.friendTable():RefreshByKey( _playerInfo.Uid, RefreshFriendedItem, _playerInfo)
    end
    if resort then
        self.friendTable():Sort()
    end
end

function FriendProxy:RefreshFriendedAll()
    local friendMap = self.friendTable:GetDataDict()
    for _,item in pairs(friendMap) do
        self:RefreshFriendedItem(item, true)
    end

    self.friendTable:Sort()
end
--endregion

--region friending

function FriendProxy:AddFriendingBaseMap(friendingMap)
    for uid, time in pairs(friendingMap) do
        self.friendingDict[uid] = time
        EventMgr.Dispatch("FRIEND_ADD_APPLY_RP", uid)
    end
end

function FriendProxy:AddFriendingMap(friendingList)
    for _, playerInfo in pairs(friendingList) do
        self:AddFriending(playerInfo)
    end
end

function FriendProxy:AddFriending(friend)
    friend.Uid = friend.AppliedFriend.Uid
    if self.friendTable:GetByKey(friend.Uid) then
        print("==server data is error===申请人已经是好友了：", friend.Uid)
        return false
    end
    local _tempPlayerInfo = self.friendingTable:GetByKey(friend.Uid)
    if _tempPlayerInfo then
        print("==server data is error===申请加为好友的数据重复：", friend.Uid)
        return false
    else
        self.friendingDict[friend.Uid] = friend.AppliedTime
        self.friendingTable:AddByKey(friend, friend.Uid)
        EventMgr.Dispatch("FRIEND_ADD_APPLY_RP", friend.Uid)
        return true
    end
end

function FriendProxy:RemoveFriendingByUid(uid)
    local info, _ = self.friendingTable:RemoveKey(uid)
    self.friendingDict[uid] = nil
    return info
end

function FriendProxy:RemoveFriendingList(items)
    if items == nil then
        return
    end
    for i = 1, #items do
        self.friendingDict[items[i].Uid] = nil
        EventMgr.Dispatch("FRIEND_DEL_APPLY_RP", items[i].Uid)
        self.friendingTable:RemoveItem(items[i])
    end
end

function FriendProxy:RefreshFriendingPlayerInfo(playerInfoList)
    if playerInfoList == nil then
        return
    end
    local resort = false
    for _, _playerInfo in ipairs(playerInfoList) do
        resort = resort or self.friendingTable():RefreshByKey( _playerInfo.Uid, RefreshFriendingItem, _playerInfo)
    end
    if resort then
        self.friendTable():Sort()
    end
end
--endregion



--region myApply

---根据服务器发送信息更新申请列表
function FriendProxy:UpdateMyApplyList(baseList, applyList)
    self:AddMyApplyList(applyList, true)
    for i = 1, #baseList do
        if not table.containsvalue(applyList, baseList[i]) then
            self:RemoveMyApply(baseList[i])
        end
    end
end

function FriendProxy:AddMyApplyList(uidList, isUpdate)
    if isUpdate == nil then
        isUpdate = false
    end
    for _, uid in ipairs(uidList) do
        self.myApply[uid] = { AppliedTime = TimerMgr.GetCurTimeSeconds() }
        if not isUpdate then
            EventMgr.Dispatch("EVENT_REFRESH_FRIENDING_APPLY", uid)
        end
    end
end

function FriendProxy:RemoveMyApply(uid)
    local info = self.myApply[uid]
    self.myApply[uid] = nil
    return info
end

function FriendProxy:RemoveMyApplyList(items)
    if items == nil then
        return
    end
    for i = 1, #items do
        self.myApply[items[i]] = nil
    end
end
--endregion

--region recommend
function FriendProxy:AddRecommendList(friendRecommendDict, isExcludeFriended)
    self:RefreshRecommend()
    for _, friendInfo in pairs(friendRecommendDict) do
        if isExcludeFriended then
            ----0、排除已经是好友的数据
            ----1、在我本地内存中的申请，也会被清理掉
            if (not self.friendTable:Contains(friendInfo.Uid))
                    and self.myApply[friendInfo.Uid] == nil
                    and (not self.recommendTable:Contains(friendInfo.Uid)) then
                self.recommendTable:AddByKey(friendInfo)
            end
        else
            if not self.recommendTable:Contains(friendInfo.Uid) then
                self.recommendTable:AddByKey(friendInfo)
            end
        end
    end
end

function FriendProxy:ClearRecommendDB(clearNum)
    if clearNum then
        self:_RemoveRecommendFriendingRange(clearNum)
    else
        self.recommendTable:ClearData()
    end
end

function FriendProxy:RefreshRecommend()
    local recommends = self.recommendTable:GetDataList()
    for i = #recommends, 1, -1 do
        if (self.friendTable:Contains(recommends[i].Uid))
                or self.myApply[recommends[i].Uid] ~= nil then
            self.recommendTable:Remove(i)
        end
    end
end

function FriendProxy:_RemoveRecommendFriendingRange(maxRemoveNum)
    if maxRemoveNum > 0 then
        local recommendCount = self.recommendTable:GetCount()
        if recommendCount > maxRemoveNum then
            local recommendDataSourceList = {}
            for i = maxRemoveNum + 1, recommendCount do
                table.insert(recommendDataSourceList, self.recommendTable:Get(i))
            end
            self.recommendTable:SetDataListSource(recommendDataSourceList)
        else
            self.recommendTable:ClearData()
        end
    end
end
--endregion

--region rank
function FriendProxy:AddRankInfoMap(rankMap)
    for k, v in pairs(rankMap) do
        self:_AddFriendRankInfo(k, v)
    end
end

function FriendProxy:_AddFriendRankInfo(uid, rankInfo)
    local info = self.friendTable:GetByKey(uid)
    if info ~= nil then
        info.RankInfo = {}
        info.RankInfo = rankInfo
    end
end
--endregion

--region search
function FriendProxy:AddFriendSearchList(searchList)
    self.searchList = searchList or {}
    for i = 1, #self.searchList do
        local fullInfo = self.cacheData:GetOtherPlayer(self.searchList[i].Uid)
        if fullInfo then  RefreshNewFriendInfo(self.searchList[i], fullInfo, true) end
    end
end

function FriendProxy:ClearSearch()
    self.searchList = {}
end
--endregion

--region refresh Player Info
function FriendProxy:RefreshPlayerInfo(info)
    local uid = info.Uid
    local friendedInfo = self.friendTable:GetByKey(uid)
    if friendedInfo and friendedInfo.LastUpdateTime < info.LastUpdateTime then
        if RefreshNewFriendInfo(friendedInfo, info) then
            self.friendTable:Sort()
        end
        EventMgr.Dispatch("EVENT_REFRESH_FRIENDED_SCROLLVIEW")
        EventMgr.Dispatch("EVENT_REFRESH_FRIENDED_RANK")
    end

    ----以下集合，暂不需要处理排序
    local friendInfo = self.friendingTable:GetByKey(uid)
    if friendInfo and friendInfo.AppliedFriend.LastUpdateTime < info.LastUpdateTime then
        self.friendingTable:Sort()
        EventMgr.Dispatch("EVENT_REFRESH_FRIENDING_REFRESH", true)
    end

    local recommendInfo = self.recommendTable:GetByKey(uid)
    if recommendInfo and recommendInfo.LastUpdateTime < info.LastUpdateTime then
        RefreshNewFriendInfo(recommendInfo, info)
        EventMgr.Dispatch("EVENT_REFRESH_FRIENDING_RECOMMMEND", true)
    end
end
--endregion

--region systemSetting
function FriendProxy:SetFriendPermission(value)
    if self.friendData then
        self.friendData.FriendPermission = value
    end
end

function FriendProxy:SetIPLocationShow(value)
    if self.friendData then
        self.friendData.IPLocationShow = value
    end
end

function FriendProxy:SetPhotoShow(value)
    if self.friendData then
        self.friendData.PhotoShow = value
    end
end

function FriendProxy:SetCardShow(value)
    if self.friendData then
        self.friendData.CardShow = value
    end
end
--endregion

--region Get
---@return MixTable
function FriendProxy:GetFriendedTable()
    return self.friendTable
end

---@return MixTable
function FriendProxy:GetFriendingTable()
    return self.friendingTable
end

---@return MixTable
function FriendProxy:GetRecommendTable()
    return self.recommendTable
end

function FriendProxy:GetFriendMap()
    return self.friendDict
end

function FriendProxy:GetFriendingMap()
    return self.friendingDict
end

function FriendProxy:GetMyApplyMap()
    return self.myApply
end

function FriendProxy:GetStaminaSendMap()
    return self.staminaSendDict
end

function FriendProxy:GetStaminaReceiveMap()
    return self.staminaReceiveDict
end

function FriendProxy:GetSearchList()
    return self.searchList
end

function FriendProxy:GetSearchIndexByUid(uid)
    for i = 1, #self.searchList do
        if self.searchList[i].Uid == uid then
            return i
        end
    end
end

function FriendProxy:GetFriendCount()
    return self.friendTable:GetCount() or 0
end

function FriendProxy:GetFriendMaxCount()
    return self.friendData.FriendMaxNum or 0
end

function FriendProxy:GetFriendedByUid(uid)
    return self.friendTable:GetByKey(uid)
end

function FriendProxy:GetMyApplyByUid(uid)
    return self.myApply[uid]
end

function FriendProxy:GetFriendPermission()
    return (self.friendData or {}).FriendPermission
end

function FriendProxy:GetIPLocationShow()
    return (self.friendData or {}).IPLocationShow
end

function FriendProxy:GetPhotoShow()
    return (self.friendData or {}).PhotoShow
end

function FriendProxy:GetCardShow()
    return (self.friendData or {}).CardShow
end
--endregion

--region cacheData
function FriendProxy:GetOtherPlayerInfo(targetID)
    local fullInfo = self.cacheData:GetOtherPlayer(targetID)
    if fullInfo then
        self:RefreshPlayerInfo(fullInfo.Base)
    end

    return fullInfo
end

function FriendProxy:AddOtherPlayer(targetID, fullInfo)
    self.cacheData:AddOtherPlayer(targetID)
    self:RefreshPlayerInfo(fullInfo.Base)
end
--endregion
return FriendProxy