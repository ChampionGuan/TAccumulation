---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dengzi.
--- DateTime: 2023/2/3 17:26
---@class WorldIntelligenceProxy
local WorldIntelligenceProxy = class("WorldIntelligenceProxy", BaseProxy)

function WorldIntelligenceProxy:OnInit()

end

---更新情报总数据
---@param worldInfoData pbcmessage.IntelligenceData
function WorldIntelligenceProxy:UpdateIntelligenceData(worldInfoData)
    if nil == worldInfoData or nil == worldInfoData.IntelligenceMap or nil == worldInfoData.IntelligenceMap[1] then
        --数据异常不做处理
        return
    end
    self:ClearData()
    if nil == worldInfoData.IntelligenceMap[1] or nil == worldInfoData.IntelligenceMap[1].IntelligenceIdMap then
        --无数据，返回
        return
    end
    ---@type table<number,boolean> @ key: 情报id
    local validWorldInfos = worldInfoData.IntelligenceMap[1].IntelligenceIdMap
    for id, rewarded in pairs(validWorldInfos) do
        self:UpdateSingleIntelligence(id, false, rewarded)
    end
    self:InitRedPoint()
    self:CheckReward()
end

---单条情报解锁
---@param worldInfoId number 情报ID
---@param isNew boolean 是否新解锁的情报，和已读未读无关
---@param rewarded boolean 是否获得过奖励
function WorldIntelligenceProxy:UpdateSingleIntelligence(worldInfoId, isNew, rewarded)
    if nil == worldInfoId then
        --参数错误
        return
    end
    local cfgData = LuaCfgMgr.Get("WorldInfoList", worldInfoId)
    if nil == cfgData then
        --获取表格数据错误
        return
    end
    --添加新的情报
    local success = self:_AddSingleIntelligence(worldInfoId, cfgData, rewarded)
    if success and isNew then
        self:_ShowPopup(worldInfoId)
        --新解锁情报更新红点
        self:SetWorldInfoReadState(worldInfoId, false)
        local mainInfoId = cfgData.LeadID > 0 and cfgData.LeadID or worldInfoId
        self:UpdateMainWorldInfoRedPoint(mainInfoId)
        self:UpdateEntryRedPoint(cfgData.Tab)
    end
end

---添加一条情报数据
---@param worldInfoId number 情报ID
---@param worldItemCfgData cfg.WorldInfoList 表数据
---@return boolean 是否添加成功
function WorldIntelligenceProxy:_AddSingleIntelligence(worldInfoId, worldItemCfgData, rewarded)
    local worldInfoData = X3DataMgr.Get(X3DataConst.X3Data.WorldInfoData, worldInfoId)
    if not worldInfoData then
        worldInfoData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.WorldInfoData, nil, worldInfoId)
    end
    worldInfoData:SetRewarded(rewarded)
    if worldItemCfgData.LeadID > 0 then
        local mainInfoCfg = LuaCfgMgr.Get("WorldInfoList", worldItemCfgData.LeadID)
        if not mainInfoCfg then
            --避免配置错误
            return false
        end
        --附属词条处理
        local main2WorldInfoList = X3DataMgr.Get(X3DataConst.X3Data.Main2WorldInfoList, worldItemCfgData.LeadID)
        if not main2WorldInfoList then
            main2WorldInfoList = X3DataMgr.AddByPrimary(X3DataConst.X3Data.Main2WorldInfoList, nil, worldItemCfgData.LeadID)
        end
        self:_AddWorldInfoIdToList(main2WorldInfoList, worldInfoId)
        return true
    else
        --主词条处理
        local entryId = worldItemCfgData.Tab
        local entryCfg = LuaCfgMgr.Get("WorldInfoEntry", entryId)
        if not entryCfg then
            --避免配置错误
            return false
        end
        local entry2WorldInfoList = X3DataMgr.Get(X3DataConst.X3Data.Entry2WorldInfoList, entryId)
        if not entry2WorldInfoList then
            entry2WorldInfoList = X3DataMgr.AddByPrimary(X3DataConst.X3Data.Entry2WorldInfoList, nil, entryId)
        end
        self:_AddWorldInfoIdToList(entry2WorldInfoList, worldInfoId)
        return true
    end
end

---添加ID到X3Data.WorldInfoList中，会根据Sort排序
---@param itemListData X3Data.Main2WorldInfoList ID列表
---@param newId number 新情报ID
function WorldIntelligenceProxy:_AddWorldInfoIdToList(itemListData, newId)
    local insertIndex = 1
    local itemIds = itemListData:GetItemIds()
    if table.isnilorempty(itemIds) then
        itemListData:AddItemIdsValue(newId)
        return
    end
    if table.containsvalue(itemIds, newId) then
        --重复不添加
        return
    end
    for _, id in ipairs(itemListData:GetItemIds()) do
        local cfgData = LuaCfgMgr.Get("WorldInfoList", id)
        local newIdCfgData = LuaCfgMgr.Get("WorldInfoList", newId)
        if cfgData and cfgData.Sort > newIdCfgData.Sort then
            break
        end
        insertIndex = insertIndex + 1
    end
    itemListData:AddItemIdsValue(newId, insertIndex)
end

---弹窗
---@param worldInfoId number 情报ID
function WorldIntelligenceProxy:_ShowPopup(worldInfoId)
    --弹窗
    if SysUnLock.IsUnLock(X3_CFG_CONST.SYSTEM_UNLOCK_WORLDINFO) then
        local cfgData = LuaCfgMgr.Get("WorldInfoList", worldInfoId)
        if cfgData and cfgData.PopUp ~= 1 then
            ErrandMgr.Add(X3_CFG_CONST.POPUP_WORLDINFO_GET,{ ID = worldInfoId})
        end
    end
end

---判断情报分类是否解锁
---@param entryId number 情报分类ID
---@return boolean
function WorldIntelligenceProxy:CheckWorldEntryUnlocked(entryId)
    if not entryId then
        return false
    end
    local entry2WorldInfoList = X3DataMgr.Get(X3DataConst.X3Data.Entry2WorldInfoList, entryId)
    return entry2WorldInfoList ~= nil
end

---判断某个情报数据是否已解锁
---@param worldInfoId number 情报ID
---@return boolean
function WorldIntelligenceProxy:CheckWorldInfoUnlocked(worldInfoId)
    local worldInfoCfg = LuaCfgMgr.Get("WorldInfoList", worldInfoId)
    if nil == worldInfoCfg then
        return false
    end
    if worldInfoCfg.LeadID > 0 then
        --附属词条判断,需要主词条和附属词条都解锁才算解锁。
        local main2WorldInfoList = X3DataMgr.Get(X3DataConst.X3Data.Main2WorldInfoList, worldInfoCfg.LeadID)
        if not main2WorldInfoList then
            return false
        end
        local subLocked = self:_CheckListExistId(main2WorldInfoList, worldInfoId)
        if subLocked then
            --副词条已解锁，再判断主词条是否解锁
            return self:CheckWorldInfoUnlocked(worldInfoCfg.LeadID)
        else
            return false
        end
    else
        --主词条判断
        local entryId = worldInfoCfg.Tab
        local entry2WorldInfoList = X3DataMgr.Get(X3DataConst.X3Data.Entry2WorldInfoList, entryId)
        if not entry2WorldInfoList then
            return false
        end
        return self:_CheckListExistId(entry2WorldInfoList, worldInfoId)
    end
end

---判断X3Data.WorldInfoList中是否包含id
---@param itemListData X3Data.Main2WorldInfoList ID列表
---@param id number id
function WorldIntelligenceProxy:_CheckListExistId(itemListData, id)
    if nil == itemListData or nil == itemListData:GetItemIds() then
        return false
    end
    return table.containsvalue(itemListData:GetItemIds(), id)
end

---获取已解锁的世界情报分类数据列表
---@return table<int,cfg.WorldInfoEntry>
function WorldIntelligenceProxy:GetWorldEntryData()
    ---@type X3Data.Entry2WorldInfoList[]
    local entryDatas = {}
    local cnt = X3DataMgr.GetAll(X3DataConst.X3Data.Entry2WorldInfoList, entryDatas)
    if not cnt or cnt == 0 then
        return nil
    end
    ---@type table<int,cfg.WorldInfoEntry>
    local result = {}
    for _, data in pairs(entryDatas) do
        local cfgData = LuaCfgMgr.Get("WorldInfoEntry", data:GetPrimaryValue())
        if cfgData then
            result[data:GetPrimaryValue()] = cfgData
        end
    end
    return result
end

---根据分类ID获取主词条数据列表
---@param entryId number 情报分类ID
---@return cfg.WorldInfoList[]
function WorldIntelligenceProxy:GetMainWorldInfosByEntry(entryId)
    local entry2WorldInfoList = X3DataMgr.Get(X3DataConst.X3Data.Entry2WorldInfoList, entryId)
    if not entry2WorldInfoList then
        return nil
    end
    ---@type cfg.WorldInfoList[]
    local result = {}
    for _, id in ipairs(entry2WorldInfoList:GetItemIds()) do
        local cfgData = LuaCfgMgr.Get("WorldInfoList", id)
        if cfgData then
            table.insert(result, cfgData)
        end
    end
    return result
end

---根据主词条ID获取附属词条数据列表
---@param mainId number 主词条情报ID
---@return cfg.WorldInfoList[]
function WorldIntelligenceProxy:GetSubWorldInfosByMain(mainId)
    local main2WorldInfoList = X3DataMgr.Get(X3DataConst.X3Data.Main2WorldInfoList, mainId)
    if not main2WorldInfoList then
        return nil
    end
    ---@type cfg.WorldInfoList[]
    local result = {}
    for _, id in ipairs(main2WorldInfoList:GetItemIds()) do
        local cfgData = LuaCfgMgr.Get("WorldInfoList", id)
        if cfgData then
            table.insert(result, cfgData)
        end
    end
    return result
end

---初始化红点数据
function WorldIntelligenceProxy:InitRedPoint()
    ---@type cfg.WorldInfoEntry[]
    local allEntryDataList = LuaCfgMgr.GetAll("WorldInfoEntry")
    for _, entryData in ipairs(allEntryDataList) do
        local allMainInfoList = self:GetMainWorldInfosByEntry(entryData.ID)
        if allMainInfoList and #allEntryDataList > 0 then
            for _, mainInfoData in ipairs(allMainInfoList) do
                self:UpdateMainWorldInfoRedPoint(mainInfoData.ID)
            end
        end
        self:UpdateEntryRedPoint(entryData.ID)
    end
end

---更新主词条红点数据(更新显示，不保存)
---@param worldInfoId number 情报ID
function WorldIntelligenceProxy:UpdateMainWorldInfoRedPoint(worldInfoId)
    if not self:GetWorldInfoReadState(worldInfoId) then
        --主词条未读，直接标记未读红点即可
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_WORLDNEWS_DESC, 1, worldInfoId)
        return
    end
    --主词条已读，接着判断下面的副词条是否已读
    local allRead = true
    local allSubInfoList = self:GetSubWorldInfosByMain(worldInfoId)
    if allSubInfoList and #allSubInfoList > 0 then
        for _, subInfoData in ipairs(allSubInfoList) do
            if not self:GetWorldInfoReadState(subInfoData.ID) then
                allRead = false
                break
            end
        end
    end
    RedPointMgr.UpdateCount(X3_CFG_CONST.RED_WORLDNEWS_DESC, allRead and 0 or 1, worldInfoId)
end

---分类ID对应红点定义
local EntryId2RedDef = {
    [1] = X3_CFG_CONST.RED_WORLDNEWS_HUNTERWIKI,
    [2] = X3_CFG_CONST.RED_WORLDNEWS_HISTORY,
    [3] = X3_CFG_CONST.RED_WORLDNEWS_LIFETIPS,
    [4] = X3_CFG_CONST.RED_WORLDNEWS_ANECDOTE,
    [5] = X3_CFG_CONST.RED_WORLDNEWS_ROLEINFO,
}

---更新分类红点数据(更新显示，不保存)
---@param entryId number 情报分类ID
function WorldIntelligenceProxy:UpdateEntryRedPoint(entryId)
    local allRead = true
    local allMainInfoList = self:GetMainWorldInfosByEntry(entryId)
    if allMainInfoList and #allMainInfoList > 0 then
        for _, mainInfoData in ipairs(allMainInfoList) do
            local redCnt = RedPointMgr.GetCount(X3_CFG_CONST.RED_WORLDNEWS_DESC, mainInfoData.ID)
            if redCnt > 0 then
                allRead = false
                break
            end
        end
    end
    RedPointMgr.UpdateCount(X3_CFG_CONST.RED_WORLDNEWS_TYPE_TAB, allRead and 0 or 1, entryId)
    RedPointMgr.UpdateCount(EntryId2RedDef[entryId], allRead and 0 or 1)
end

---设置词条已读状态，保存，不更新显示
---@param worldInfoId number 情报ID
---@param readState bool 是否已读, true:已读， false:未读
function WorldIntelligenceProxy:SetWorldInfoReadState(worldInfoId, readState)
    local value = readState and 1 or 0
    RedPointMgr.Save(value, X3_CFG_CONST.RED_WORLDNEWS_DESC, worldInfoId)
end

---获取词条已读状态
---@param worldInfoId number 情报ID
---@return boolean 是否已读, true:已读， false:未读
function WorldIntelligenceProxy:GetWorldInfoReadState(worldInfoId)
    local value = RedPointMgr.GetValue(X3_CFG_CONST.RED_WORLDNEWS_DESC, worldInfoId)
    return value == 1
end

---领奖
---@param worldInfoIdList number[] 情报ID列表
function WorldIntelligenceProxy:ReqGetReward(worldInfoIdList)
    if table.isnilorempty(worldInfoIdList) then
        return
    end
    local wantRewardIdList = PoolUtil.GetTable()
    for _, v in ipairs(worldInfoIdList) do
        repeat
            local cfg = LuaCfgMgr.Get("WorldInfoList", v)
            if cfg == nil or table.isnilorempty(cfg.Reward) then
                break
            end
            if (not self:IsReward(v)) and self:GetWorldInfoReadState(v) then
                --已读未领奖
                table.insert(wantRewardIdList, v)
            end
        until true
    end
    if #wantRewardIdList > 0 then
        local request = PoolUtil.GetTable()
        request.IntelligenceType = 1
        request.IntelligenceList = wantRewardIdList
        GrpcMgr.SendRequest(RpcDefines.GetIntelligenceRewardsRequest, request, true)
        PoolUtil.ReleaseTable(request)
    end
    PoolUtil.ReleaseTable(wantRewardIdList)
end

---是否领过奖
function WorldIntelligenceProxy:IsReward(worldInfoId)
    local worldInfoData = X3DataMgr.Get(X3DataConst.X3Data.WorldInfoData, worldInfoId)
    return worldInfoData and worldInfoData:GetRewarded() or false
end

---更新领奖数据
---@param worldInfoIdList number[] 情报ID列表
---@param reward boolean 领奖情况
function WorldIntelligenceProxy:UpdateReward(worldInfoIdList, reward)
    if table.isnilorempty(worldInfoIdList) then
        return
    end
    for _, v in ipairs(worldInfoIdList) do
        local worldInfoData = X3DataMgr.Get(X3DataConst.X3Data.WorldInfoData, v)
        if worldInfoData then
            worldInfoData:SetRewarded(reward)
        end
    end
end

---登陆时根据词条是否已读，来检查是否已经正确获得奖励了，如果存在已读的词条未获得奖励，那就重新获得一下
function WorldIntelligenceProxy:CheckReward()
    ---@type X3Data.WorldInfoData[]
    local allData = {}
    local cnt = X3DataMgr.GetAll(X3DataConst.X3Data.WorldInfoData, allData)
    if not cnt or cnt == 0 then
        return
    end
    local wantRewardIdList = PoolUtil.GetTable()
    for _, v in ipairs(allData) do
        table.insert(wantRewardIdList, v:GetPrimaryValue())
    end
    if #wantRewardIdList > 0 then
        self:ReqGetReward(wantRewardIdList)
    end
    PoolUtil.ReleaseTable(wantRewardIdList)
end

---清除数据
function WorldIntelligenceProxy:ClearData()
    X3DataMgr.RemoveAll(X3DataConst.X3Data.WorldInfoData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.Entry2WorldInfoList)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.Main2WorldInfoList)
end

function WorldIntelligenceProxy:OnClear()
    self:ClearData()
end

return WorldIntelligenceProxy