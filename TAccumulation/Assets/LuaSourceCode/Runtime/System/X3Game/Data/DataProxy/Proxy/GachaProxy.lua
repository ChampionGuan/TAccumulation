---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by kan.
--- DateTime: 2022/6/1 15:38
---
---@class GachaProxy:BaseProxy
local GachaProxy = class("GachaProxy", BaseProxy)

function GachaProxy:OnInit()
    self.groupDic = {}
    self.gachaDic = {}
    self.countRewardDic = {}
    self.guarantees = {}
end

function GachaProxy:Init(data)
    if data then
        if data.GachaGroups then
            for _, v in pairs(data.GachaGroups) do
                self:SetGroupData(v)
            end
        end
        if data.Gachas then
            for _, v in pairs(data.Gachas) do
                self:SetGachaData(v)
            end
        end
        if data.CountRewardGroups then
            for _, v in pairs(data.CountRewardGroups) do
                self:SetCountRewardData(v)
            end
        end
        if data.Guarantees then
            self:SetGuarantessCount(data.Guarantees)
        end

        local groupAll = LuaCfgMgr.GetListByCondition("GachaGroup", {ShowInGacha = 1})
        for _, groupCfg in pairs(groupAll) do
            self:TryGenServerGroupData(groupCfg.ID)
            local gachaAll = LuaCfgMgr.GetListByCondition("GachaAll", {GachaGroup = groupCfg.ID})
            for _, gachaCfg in pairs(gachaAll) do
                self:TryGenServerGachaData(gachaCfg.ID)
            end
        end

        GachaTimerMgr:OnEnter()
    end
end

function GachaProxy:OnClear()
    GachaTimerMgr:OnExit()
    self.groupDic = {}
    self.gachaDic = {}
    self.countRewardDic = {}
    self.guarantees = {}
end

--region 抽数奖励
---设置抽数奖励数据
function GachaProxy:SetCountRewardData(countRewardData)
    self.countRewardDic[countRewardData.RewardGroup] = countRewardData
end

---更新奖励数据
---@param rewardGroup int
---@param id int GachaCountReward 表 ID
function GachaProxy:UpdateCountRewardData(rewardGroup, id)
    local rewardData = self.countRewardDic[rewardGroup]
    if rewardData and rewardData.Rewards then
        rewardData.Rewards[id] = true
    end
end

---获取抽数奖励数据
function GachaProxy:GetCountRewardData(rewardGroup)
    return self.countRewardDic[rewardGroup]
end

---重置抽数奖励计数
---@param rewardGroup int
function GachaProxy:ResetGachaCountRewardCount(rewardGroup)
    if self.countRewardDic[rewardGroup] then
        self.countRewardDic[rewardGroup].Count = 0
    end
end

---获取抽数奖励，抽卡计数
---@param rewardGroup int
function GachaProxy:GetGachaCountRewardCount(rewardGroup)
    local rewardData = self:GetCountRewardData(rewardGroup)
    if rewardData then
        return rewardData.Count
    else
        return 0
    end
end

---获取抽数奖励，是否领取
---@param rewardGroup int
---@param id int GachaCountReward 表 ID
function GachaProxy:GetGachaCountRewardIsRewarded(rewardGroup, id)
    local rewardData = self:GetCountRewardData(rewardGroup)
    if rewardData then
        return rewardData.Rewards[id]
    else
        return false
    end
end
--endregion

--region 卡池组与卡池开启关闭
---设置卡池组关闭标志
---@param isClose bool
function GachaProxy:SetGroupCloseFlag(groupId, isClose)
    if self.groupDic[groupId] then
        self.groupDic[groupId].CloseFlag = isClose
    end
end

---获取卡池组关闭标志
function GachaProxy:GetGroupCloseFlag(groupId)
    if self.groupDic[groupId] and self.groupDic[groupId].CloseFlag then
        return self.groupDic[groupId].CloseFlag
    else
        return false
    end
end

---设置卡池关闭标志
---@param isClose bool
function GachaProxy:SetGachaCloseFlag(gachaId, isClose)
    if self.gachaDic[gachaId] then
        self.gachaDic[gachaId].CloseFlag = isClose
    end
end

---获取卡池关闭标志
function GachaProxy:GetGachaCloseFlag(gachaId)
    return self.gachaDic[gachaId].CloseFlag
end
--endregion

function GachaProxy:SetGroupData(groupData)
    local gachas
    if not table.isnilorempty(self.groupDic[groupData.GId]) then
        gachas = self.groupDic[groupData.GId].Gachas
    end
    self.groupDic[groupData.GId] = groupData
    if not table.isnilorempty(gachas) then
        self.groupDic[groupData.GId].Gachas = gachas
    end

    local rareRecords = {} -- 抽卡记录中，根据稀有度统计

    if not table.isnilorempty(groupData.ItemRecords) then
        for k, v in pairs(groupData.ItemRecords) do
            local quality = LuaCfgMgr.Get("CardBaseInfo", k).Quality
            if not rareRecords[quality] then
                rareRecords[quality] = 0
            end
            rareRecords[quality] = rareRecords[quality] + v
        end
    end

    self.groupDic[groupData.GId].RareRecords = rareRecords
end

function GachaProxy:GetGroupData(groupID)
    return self.groupDic[groupID]
end

function GachaProxy:SetGachaData(gachaData)
    self.gachaDic[gachaData.Id] = gachaData
    local gachaInfo = LuaCfgMgr.Get("GachaAll", gachaData.Id)
    if gachaInfo then
        local groupId = gachaInfo.GachaGroup
        if not self.groupDic[groupId] then
            self:TryGenServerGroupData(groupId)
        end
        if not self.groupDic[groupId].Gachas then
            self.groupDic[groupId].Gachas = {}
        end
        self.groupDic[groupId].Gachas[gachaData.Id] = gachaData
    end
end

function GachaProxy:GetGachaData(gachaID)
    return self.gachaDic[gachaID]
end

---设置保底计数
function GachaProxy:SetGuarantessCount(guarantees)
    for k, v in pairs(guarantees) do
        self.guarantees[k] = v
    end
end

function GachaProxy:GetGuaranteesCount(guaranteesId)
    return self.guarantees[guaranteesId]
end

---设置定轨卡池
function GachaProxy:SetStayTrackId(groupId, gachaId)
    if self.groupDic[groupId] then
        self.groupDic[groupId].StayTrack = gachaId
    end
end

function GachaProxy:GetStayTrackId(groupId)
    if self.groupDic[groupId] then
        return self.groupDic[groupId].StayTrack
    end
end

---设置男主池
function GachaProxy:SetManType(groupId, manType)
    if self.groupDic[groupId] then
        self.groupDic[groupId].ManType = manType
    end
end

function GachaProxy:GetManType(groupId)
    if self.groupDic[groupId] then
        return self.groupDic[groupId].ManType
    end
end

---获取卡池剩余保底抽数
function GachaProxy:GetGachaNum(groupId,gachaID)
    local gachaCfg = LuaCfgMgr.Get("GachaAll", gachaID)
    local gachaRule = LuaCfgMgr.Get("GachaRule", gachaCfg.RuleShow)
    if gachaRule then
        local count = self:GetGuaranteesCount(gachaRule.CountID)
        if count then
            return gachaRule.Param1 + 1 - count
        else
            return gachaRule.Param1 + 1
        end
    else
        return -1
    end
end

---获取后端下发的卡池组开启时间
function GachaProxy:GetGachaGroupStartTime(groupId)
    if self.groupDic[groupId] and self.groupDic[groupId].StartTime then
        return self.groupDic[groupId].StartTime
    end
end

---设置后端下发的卡池组开启时间
function GachaProxy:SetGachaGroupStartTime(groupId, timestamp)
    if self.groupDic[groupId] and self.groupDic[groupId].StartTime == nil then
        self.groupDic[groupId].StartTime = timestamp
    end
end

---获取能手动开启的卡池组列表
function GachaProxy:GetManualOpenGachaGroups()
    local ret = {}
    for _, v in pairs(self.groupDic) do
        local gachaGroup = LuaCfgMgr.Get("GachaGroup", v.GId)
        if gachaGroup.ManualOpen == 1 and not self.groupDic[gachaGroup.ID].StartTime and not self.groupDic[gachaGroup.ID].CloseFlag then
            table.insert(ret, v)
        end
    end

    return ret
end

---更新卡池组本期的抽卡记录
function GachaProxy:UpdateGachaGroupRecord(groupId, gachaResult)
    if self.groupDic[groupId] then
        if table.isnilorempty(self.groupDic[groupId].ItemRecords) then
            self.groupDic[groupId].ItemRecords = {}
        end
        if table.isnilorempty(self.groupDic[groupId].RareRecords) then
            self.groupDic[groupId].RareRecords = {}
        end
        for _, v in pairs(gachaResult) do
            local cardID = v.Id
            local quality = LuaCfgMgr.Get("CardBaseInfo", cardID).Quality
            if not self.groupDic[groupId].ItemRecords[cardID] then
                self.groupDic[groupId].ItemRecords[cardID] = 0
            end
            if not self.groupDic[groupId].RareRecords[quality] then
                self.groupDic[groupId].RareRecords[quality] = 0
            end
            self.groupDic[groupId].ItemRecords[cardID] = self.groupDic[groupId].ItemRecords[cardID] + v.Num
            self.groupDic[groupId].RareRecords[quality] = self.groupDic[groupId].RareRecords[quality] + v.Num
        end
    end
end

function GachaProxy:GetGachaGroupRecord(groupId)
    if self.groupDic[groupId] and self.groupDic[groupId].ItemRecords then
        return self.groupDic[groupId].ItemRecords
    end
    return {}
end

function GachaProxy:AddGachaAccNum(gachaId, num)
    if self.gachaDic[gachaId] then
        self.gachaDic[gachaId].AccNum = self.gachaDic[gachaId].AccNum + num
    end
end

function GachaProxy:GetGachaAccNum(gachaId)
    if self.gachaDic[gachaId] then
        return self.gachaDic[gachaId].AccNum or 0
    end
end

function GachaProxy:GetGachaGroupAccNum(groupId)
    if self.groupDic[groupId] then
        local accNum = 0
        for _, v in pairs(self.groupDic[groupId].Gachas) do
            accNum = accNum + v.AccNum
        end
        return accNum
    end
    return 0
end

---构造服务端数据
---由于现在卡池组开放不依赖于服务端下发消息，所有当客户端认为有卡池开放时先构造一个模拟数据，
---当前卡池与服务器通信时，服务器会下发新的数据覆盖
function GachaProxy:TryGenServerGroupData(groupID)
    local groupData = self:GetGroupData(groupID)
    if groupData ~= nil then
        return
    end

    local groupInfo = LuaCfgMgr.Get("GachaGroup", groupID)
    if groupInfo == nil then
        return
    end

    local data = {}
    data.GId = groupID          -- int卡池组id
    data.ManType = 0            -- int选定的男主id（男主池有效）
    data.ActiveNum = 0          -- int当日活动卡池组浏览次数
    data.ItemRecords = nil      -- map<思念id,数量>
    data.StartTime = nil        -- int卡池组手动或自动开启时间
    data.Current = nil          -- 本期卡池记录，用于重新开启时重置等
    data.StayTrack = 0          -- 定轨卡池有效
    self:SetGroupData(data)
end

function GachaProxy:TryGenServerGachaData(gachaID)
    local gachaData = self:GetGachaData(gachaID)
    if gachaData ~= nil then
        return
    end

    local gachaInfo = LuaCfgMgr.Get("GachaAll", gachaID)
    if gachaInfo == nil then
        return
    end

    local data = {}
    data.Id = gachaID
    data.AccNum = 0
    data.CloseFlag = nil
    data.Current = nil

    self:SetGachaData(data)
end

return GachaProxy