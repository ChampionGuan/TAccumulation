---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xingzi003.
--- DateTime: 2022/9/1 20:43
---
---@class FaceEditProxy : BaseProxy @捏脸Proxy
local FaceEditProxy = class("FaceEditProxy", BaseProxy)
local FaceEditConst = require("Runtime.System.X3Game.GameConst.FaceEditConst")
local FaceEditUtil = require("Runtime.System.X3Game.Modules.FaceEdit.FaceEditUtil")
local FaceLocalDataUtil = require("Runtime.System.X3Game.Modules.FaceEdit.FaceLocalDataUtil")
local FaceEditData = require("Runtime.System.X3Game.Data.DataProxy.Data.FaceEditData")
local FaceLocalDataConst = require("Runtime.System.X3Game.GameConst.FaceLocalDataConst")
local EditData = FaceEditData.EditData
local OperData = FaceEditData.OperData

function FaceEditProxy:OnInit()
    ---@type table<number, number> 本地保存原始数据
    self._originalLocalData = nil

    ---@type table<number, number> 服务器下发原始捏脸数据
    self._originalKneadServerData = nil
    ---@type table<number, number> 服务器下发原始妆发数据
    self._originalMakeupServerData = nil

    ---@type EditData 服务器捏脸数据，用于捏脸编辑等
    self._serverKneadEditData = nil
    ---@type EditData 服务器妆发数据，仅在拍照模式中使用
    self._serverMakeupEditData = nil


    ---@type EditData 捏脸编辑数据，捏脸编辑模式下使用（工作区数据）
    self._editData = nil
    ---@type EditData 临时妆发数据
    self._tempData = nil

    ---@type table<number, number> 当前编辑的初始数据 （用于Undo找到初始数据）
    self._sourceData = nil

    ---@type number 当前历史数据步骤进度
    self._curHistoryIndex = 0
    ---@type table[] OperData[] 历史操作记录列表
    self._historyList = {}
    ---@type table<number, table> 历史操作数据
    self._historyDataDict = {}  -- key - { list = { {EditItem, ..}, curIdx = 0 }

    ---@type table<number, number> 选中的未解锁项
    self._lockedSelectDic = nil
    ---@type table<number, number> key对应的配置默认值
    self._defaultCfgValueDic = nil

    ---@type table[] 妆发模板列表
    self._makeupTemplates = nil

    ---@type table<number, table> 风格脸槽位信息
    self._faceStyleInfo = nil
    ---@type number 当前权重最大的风格脸CfgId
    self._faceStyleMaxWeightId = nil

    ---@type UIData
    self.uiData = nil
    ---@type table<number, FaceEditData.UINode>
    self.uiDataNodeDict = {}

    ---本次编辑，玩家选择的属性颜色，用于颜色继承
    self._propColorDict = {}
    ---本次编辑，玩家选择的发色高级属性颜色，用于颜色继承
    self._hairAdvancedColorDict = {}

    self._tryHairCfgId = nil
    self._tryOnCloth = nil
    self._tryOnDecoList = {}

    ---当前编辑的 EditItems 的快照
    self._curEditItemsSnapshot = nil
end

function FaceEditProxy:OnClear()
    self:ClearData()
end

---清理数据
function FaceEditProxy:ClearData()
    self:ClearDataForEdit()
    if self._serverMakeupEditData then
        self._serverMakeupEditData:ClearData()
        self._serverMakeupEditData = nil
    end
    if self._serverKneadEditData then
        self._serverKneadEditData:ClearData()
        self._serverKneadEditData = nil
    end
    self:ClearTempData()
    self._originalLocalData = nil
    self._originalKneadServerData = nil
    self._originalMakeupServerData = nil
    self._defaultCfgValueDic = nil
    self._makeupTemplates = nil
    self._faceStyleInfo = nil
    self._faceStyleMaxWeightId = nil
    self.uiData = nil
    self.uiDataNodeDict = nil
    self.hairEditColor = nil
    self._curEditItemsSnapshot = nil
end

---清理数据（捏脸编辑模式）
function FaceEditProxy:ClearDataForEdit()
    self:ClearHistoryData()
    self:ClearLockedInfo()
    self:ClearTryOnInfo()

    self:SetSourceData(nil)
    if self._editData then
        self._editData:ClearData()
        self._editData = nil
    end

    self._propColorDict = {}
    self._hairAdvancedColorDict = {}
    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "FaceEditProxy:ClearDataForEdit()")
end

---@param editDatas table<number, number> 服务器捏脸数据
---@param templates table<number, pbcmessage.KneadFaceTemplate> 服务器妆发模板数据
function FaceEditProxy:InitServerData(editDatas, templates)
    ---初始化捏脸数据
    self._originalKneadServerData = table.clone(editDatas.EditDataKneadface)
    self._serverKneadEditData = EditData.new(self._originalKneadServerData)

    ---初始化妆发数据
    self._originalMakeupServerData = table.clone(editDatas.EditDataKneadface)
    if next(editDatas.EditDataMakeup) then
        for k, v in pairs(editDatas.EditDataMakeup) do
            local mainType = FaceEditUtil.GetMainTypeByKey(k)
            if mainType == FaceEditConst.MainType.Hair or mainType == FaceEditConst.MainType.Makeup then
                self._originalMakeupServerData[k] = v
            end
        end
    end
    self._serverMakeupEditData = EditData.new(self._originalMakeupServerData)

    ---初始化临时妆发数据
    self._makeupTemplates = {}
    if templates and next(templates) then
        for id, template in pairs(templates) do
            local item = {}
            item.templateId = id
            item.templateName = template.TemplateName
            item.data = template.EditData
            table.insert(self._makeupTemplates, item)
        end
        table.sort(self._makeupTemplates, function(a, b)
            return a.templateId < b.templateId
        end)
    end
end

function FaceEditProxy:InitOtherData(editDatas)
    if editDatas then
        self._originalKneadServerData = table.clone(editDatas.EditDataKneadface)
        self._serverKneadEditData = EditData.new(self._originalKneadServerData)
    end
end

function FaceEditProxy:InitData()
    self:InitFaceStyleInfo()
end

function FaceEditProxy:LoadData()
    self:ClearHistoryData()
    local sourceData = self._originalKneadServerData
    self._editData = EditData.new(sourceData)
    self:SetSourceData(sourceData)
    self:LoadStyleFaceInfo()
    self:InitUIData()
end

function FaceEditProxy:LoadLocalData()
    self:ClearHistoryData()
    self:InitLocalData()
    local sourceData = self._originalKneadServerData
    if not table.isnilorempty(self._originalLocalData) then
        sourceData = self._originalLocalData
    end
    self._editData = EditData.new(sourceData)
    self:SetSourceData(sourceData)
    self:LoadStyleFaceInfo()
    self:InitUIData()
end

function FaceEditProxy:LoadMakeupData()
    self:ClearHistoryData()
    local sourceData = self._originalKneadServerData
    if not table.isnilorempty(self._originalMakeupServerData) then
        sourceData = self._originalMakeupServerData
    end
    self._editData = EditData.new(sourceData)
    self:SetSourceData(sourceData)
    self:LoadStyleFaceInfo()
    self:InitUIData()
end

function FaceEditProxy:LoadDataFromSource(sourceData)
    self:ClearHistoryData()
    if not sourceData or not next(sourceData) then
        sourceData = self._originalKneadServerData
    end

    sourceData = FaceEditUtil.FilterLockedEditItems(sourceData)

    self._editData = EditData.new(sourceData)
    self:SetSourceData(sourceData)

    self:LoadStyleFaceInfo()

    self:InitUIData()
end

---保存至服务器
function FaceEditProxy:SaveServerData(mode)
    self:DeleteLocalData()
    self:ClearHistoryData()
    self:ClearLockedInfo()

    if mode then
        if (mode == FaceEditConst.Mode.First or mode == FaceEditConst.Mode.ReKnead) then
            if self._serverKneadEditData then
                self._serverKneadEditData:ClearData()
            end
            table.clear(self._originalKneadServerData)

            self._originalKneadServerData = self._editData and self._editData:GetSaveData() or {}
            self._serverKneadEditData:LoadData(self._originalKneadServerData)

            --- 每次捏脸之后，将头发数据覆盖到新的捏脸数据上
            local clonedOriginalKneadServerData = table.clone(self._originalKneadServerData)
            if next(self._originalMakeupServerData) then
                for k, v in pairs(self._originalMakeupServerData) do
                    local mainType = FaceEditUtil.GetMainTypeByKey(k)
                    if mainType == FaceEditConst.MainType.Hair then
                        clonedOriginalKneadServerData[k] = v
                    end
                end
            end
            self._originalMakeupServerData = clonedOriginalKneadServerData
            if self._serverMakeupEditData then
                self._serverMakeupEditData:ClearData()
            end
            self._serverMakeupEditData:LoadData(self._originalMakeupServerData)
        elseif mode == FaceEditConst.Mode.NewMakeupAndHair then
            if self._serverMakeupEditData then
                self._serverMakeupEditData:ClearData()
            end
            table.clear(self._originalMakeupServerData)
            self._originalMakeupServerData = self._editData and self._editData:GetSaveData() or {}
            self._serverMakeupEditData:LoadData(self._originalMakeupServerData)
        end
    end

    if self._editData and mode ~= FaceEditConst.Mode.NewMakeupAndHair then -- 新版妆发不清除妆发数据
        self._editData:ClearData()
        self._editData = nil
    end

    self:SetSourceData(nil)
end

---@return boolean self._editData是否包含风格脸数据
function FaceEditProxy:ContainsFaceStyle()
    return self._editData and self._editData:ContainsFaceStyle() or false
end

---@return boolean @是否选择了特殊项
function FaceEditProxy:PickedSpecialItem(mode)
    if mode == FaceEditConst.Mode.TempMakeupAndHair then
        return false
    end
    return self._editData and self._editData:ContainsSpecialHair() or false
end

---@return bool @是否选择了未解锁的项
function FaceEditProxy:PickedLockedItem()
    return not table.isnilorempty(self._lockedSelectDic)
end

---@return number @查询分类型下选择了未解锁项的数量
function FaceEditProxy:GetLockedCount(mainType, subType)
    if not mainType then
        return 0
    end

    local count = 0
    self._lockedSelectDic = self._lockedSelectDic or {}
    for key, _ in pairs(self._lockedSelectDic) do
        local main, sub, _ = FaceEditUtil.GetTypes(key)
        if main == mainType and (not subType or sub == subType) then
            count = count + 1
        end
    end
    Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "GetLockedCount(%s, %s) = %s", mainType, subType, count)
    return count
end

---@param key number
---@param value number
---@param locked boolean @是否未解锁
function FaceEditProxy:SetLockedInfo(key, value, locked)
    self._lockedSelectDic = self._lockedSelectDic or {}

    local val = locked and value or nil
    if self._lockedSelectDic[key] ~= val then
        self._lockedSelectDic[key] = val

        Debug.LogWithTag(GameConst.LogTag.FaceEdit, "SetLockedInfo() ", table.dump(self._lockedSelectDic, "lockedInfo"))
        EventMgr.Dispatch(FaceEditConst.Event.ChangeUnlockItem)
    end
end

function FaceEditProxy:ClearLockedInfo()
    self._lockedSelectDic = nil
    EventMgr.Dispatch(FaceEditConst.Event.ChangeUnlockItem)
end

---是否编辑/删除需要塑容卡的项（FaceStyle Bone Voice Skin）
function FaceEditProxy:PickedNeedKneadItem()
    local save_data, delete_keys, _ = self:GetSaveDataServer()

    --local keySkin = FaceEditUtil.GetKey(FaceEditConst.MainType.Skin)
    --if save_data[keySkin] or table.indexof(delete_keys, keySkin) then
    --    return true
    --end
    --
    --local keyVoice = FaceEditUtil.GetKey(FaceEditConst.MainType.Voice)
    --if save_data[keyVoice] or table.indexof(delete_keys, keyVoice) then
    --    return true
    --end
    --
    --for propType = FaceEditConst.EditPropType.PosA_Index, FaceEditConst.EditPropType.PosC_Weight do
    --    local key = FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, propType)
    --    if save_data[key] or table.indexof(delete_keys, key) then
    --        return true
    --    end
    --end
    --
    --for key, _ in pairs(save_data) do
    --    local mainType = FaceEditUtil.GetMainTypeByKey(key)
    --    if mainType == FaceEditConst.MainType.Bone then
    --        return true
    --    end
    --end
    --
    --for _, key in ipairs(delete_keys) do
    --    local mainType = FaceEditUtil.GetMainTypeByKey(key)
    --    if mainType == FaceEditConst.MainType.Bone then
    --        return true
    --    end
    --end

    if not table.isnilorempty(save_data) or not table.isnilorempty(delete_keys) then
        return true
    end

    return false
end

---获取要保存的数据：过滤无效数据,过滤与服务器相同的数据
---@return table<number, number> @保存的数据
---@return table[] number[] @删除的key
---@return bool @is_cover是否全部覆盖数据
function FaceEditProxy:GetSaveDataServer(isMakeup)
    local save_data = self._editData and self._editData:GetSaveData() or {}
    local delete_keys = {}
    local originalServerData = isMakeup and self._originalMakeupServerData or self._originalKneadServerData
    local is_cover = table.isnilorempty(originalServerData)
    if not is_cover then
        for key, _ in pairs(originalServerData) do
            if not save_data[key] then
                table.insert(delete_keys, key)
            end
        end
        for key, value in pairs(save_data) do
            if originalServerData[key] and value == originalServerData[key] then
                save_data[key] = nil
            end
            if isMakeup then
                local mainType = FaceEditUtil.GetMainTypeByKey(key)
                if not (mainType == FaceEditConst.MainType.Hair or mainType == FaceEditConst.MainType.Makeup) then
                    save_data[key] = nil
                end
            end
        end
    end
    return save_data, delete_keys, is_cover
end

function FaceEditProxy:SyncPropStyleFaceBone(dict, force)
    if dict then
        local bones = {}
        local cfgName = FaceEditUtil.GetCfgName(FaceEditConst.MainType.Bone)
        --local editItems = {}
        for name, value in pairs(dict) do
            local cfg = LuaCfgMgr.GetDataByCondition(cfgName, { ParaName = name })
            if cfg and cfg.ID then
                local key = FaceEditUtil.GetKey(FaceEditConst.MainType.Bone, nil, cfg.ID)
                if not self._editData:ContainsKey(key) or force then
                    self:SetPropDataInner(key, value, not force)
                    bones[key] = value
                end
            end
        end
        --self:UpdateUIDataNodeByEditData(editItems)

        Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems Bone")
        EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems, nil, FaceEditConst.MainType.Bone)
        return bones
    end
end

function FaceEditProxy:ClearTryOnInfo()
    self._tryHairCfgId = nil
    self._tryOnCloth = nil
    self._tryOnDecoList = {}
end

function FaceEditProxy:SetTryOnHair(hairCfgId)
    self._tryHairCfgId = hairCfgId
end

function FaceEditProxy:SetTryOnCloth(resourceId)
    self._tryOnCloth = resourceId
end

function FaceEditProxy:UpdateTryOnDeco(partName, value)
    self._tryOnDecoList[partName] = value
end

function FaceEditProxy:HasTryOnPart()
    local defaultHair = 101
    local isDefaultHair = self._tryHairCfgId and self._tryHairCfgId ~= defaultHair

    local defaultCloth = 101
    local isDefaultCloth = self._tryOnCloth and self._tryOnCloth ~= defaultCloth

    local hasDeco = false
    for _, v in pairs(self._tryOnDecoList) do
        if v then
            hasDeco = true
            break
        end
    end
    return isDefaultHair or hasDeco or isDefaultCloth
end

---风格脸设置属性数据
function FaceEditProxy:SetPropDataInner(key, value, is_sub)
    if not key or not value then
        return
    end

    --if key == FaceEditUtil.GetKey(FaceEditConst.MainType.Hair) and self._tryHairCfgId then
    --    return
    --end

    local data = self:GetInnerChangeItems(key, value, is_sub)

    if self._editData then
        self._editData:UpdateData(data)
    end

    return data
end

---@param key number @编辑项key
---@param value number|Color @编辑项值
---@param propClass number FaceEditConst.UIPropClass
---@param silent boolean 静默 不抛刷新事件
function FaceEditProxy:SetPropData(key, value, silent, propClass, locked, isTempMakeup)
    if not key or not value then
        return
    end

    if propClass == FaceEditConst.UIPropClass.Color then
        self._propColorDict[key] = value
    end

    --if propClass == FaceEditConst.UIPropClass.Style then
    --    self:SetLockedInfo(key, value, locked)
    --end

    local editItems = self:GetChangeItems(key, value, propClass)

    if self._editData then
        self._editData:UpdateData(editItems)
    end

    local mainItem
    local subItems = {}
    for _, v in ipairs(editItems) do
        if v.key ~= key then
            table.insert(subItems, v)
        else
            mainItem = v
        end
    end
    self:AddToHistory(mainItem.key, mainItem.value, subItems)
    self:UpdateUIDataNodeByEditData(editItems)

    if not silent then
        Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems key = ", key)
        EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems, key)
    end

    local applyItems = self:GetApplyData(key, propClass, editItems, isTempMakeup)
    return applyItems
end

function FaceEditProxy:GetApplyData(key, propClass, editItems, isTempMakeup)
    -- applyData需过滤1: 特殊发型非临时妆发模式 不使用自定义属性
    if key == FaceEditUtil.GetKey(FaceEditConst.MainType.Hair) and propClass == FaceEditConst.UIPropClass.Style and not isTempMakeup and editItems then
        local specialKey = FaceEditUtil.GetKey(FaceEditConst.MainType.Hair, nil, FaceEditConst.EditPropType.IsSpecial)
        local isSpecial = false
        for _, item in ipairs(editItems) do
            if item.key == specialKey then
                isSpecial = item.value == 1
                break
            end
        end
        if isSpecial then
            local applyData = {}
            for _, item in ipairs(editItems) do
                local propType = FaceEditUtil.GetThirdType(item.key)
                if not table.indexof(FaceEditConst.HairCustomPropTypes, propType) then
                    table.insert(applyData, item)
                end
            end

            local lst = {}
            for _, v in ipairs(applyData) do
                table.insert(lst, v:ToString())
            end
            Debug.LogWithTag(GameConst.LogTag.FaceEdit, "GetApplyData(Special) = ", table.concat(lst, "\n\t"))
            return applyData
        end
    end

    local lst = {}
    for _, v in ipairs(editItems) do
        table.insert(lst, v:ToString())
    end
    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "GetApplyData = ", table.concat(lst, "\n\t"))
    return editItems
end

---@return table[] EditItem[]
function FaceEditProxy:GetChangeItems(key, value, propClass)
    local mainType, subType, propType = FaceEditUtil.GetTypes(key)

    if (mainType ~= FaceEditConst.MainType.Hair and mainType ~= FaceEditConst.MainType.Makeup) then
        return { FaceEditData.EditItem.new(key, value) }
    end

    local needKeepColor = self._propColorDict[key] and true or false
    if propClass == FaceEditConst.UIPropClass.Style and needKeepColor then
        -- 改样式 保留色系 修正value
        local oldValue = value
        value = self:GetStyleKeepColor(key, value)
        Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "SetPropStyle(%s, %s) %s", key, oldValue, oldValue ~= value and ("保留色系value -> " .. value) or "")
    end

    local main_item = FaceEditData.EditItem.new(key, value)
    local data = { main_item }

    if propClass == FaceEditConst.UIPropClass.Color then
        -- 改推荐色 存ColorID
        Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "SetPropColor(%s, %s)", key, value)

        local cfgName = FaceEditUtil.GetCfgName(mainType, subType)
        local cfg = LuaCfgMgr.Get(cfgName, value)
        local colorID = cfg.ColorID
        if colorID == nil or colorID < 1 then
            colorID = value % 10
        end
        local keyColorID = FaceEditUtil.GetKey(mainType, subType, FaceEditConst.EditPropType.PresetColorID)
        local item = FaceEditData.EditItem.new(keyColorID, colorID)
        table.insert(data, item)
    end

    -- 如果妆容的样式是风格脸的样式，浓淡数据使用风格脸的数据
    local styleId = self:GetFaceStyleMaxWeightStyleId()
    local cfg = LuaCfgMgr.Get("FaceStyle", styleId)
    local sub_dic = self:_GetSubs(key, value)
    local isStyleFaceSameProp = (FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyebrow) == key and cfg.DefaultEyebrow == value) or
                        (FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeLiner) == key and cfg.DefaultEyeLiner == value) or
                        (FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Lip) == key and cfg.DefaultLip == value) or
                        (FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Blush) == key and cfg.DefaultBlush == value) or
                        (FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Decorate) == key and cfg.DefaultDecorate == value) or
                        (FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyeshadow) == key and cfg.DefaultEyeShadow == value)

    if sub_dic and next(sub_dic) then
        for k, v in pairs(sub_dic) do
            if isStyleFaceSameProp then
                if k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyeshadow, FaceEditConst.EditPropType.SubDensity) then
                    v = cfg.EyeShadowDepth * FaceEditConst.ConfigDeflateFactor
                elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Lip, FaceEditConst.EditPropType.SubDensity) then
                    v = cfg.LipDepth * FaceEditConst.ConfigDeflateFactor
                elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyebrow, FaceEditConst.EditPropType.SubDensity) then
                    v = cfg.EyebrowDepth * FaceEditConst.ConfigDeflateFactor
                elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeLiner, FaceEditConst.EditPropType.SubDensity) then
                    v = cfg.EyeLinerDepth * FaceEditConst.ConfigDeflateFactor
                elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Blush, FaceEditConst.EditPropType.SubDensity) then
                    v = cfg.BlushDepth * FaceEditConst.ConfigDeflateFactor
                elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Decorate, FaceEditConst.EditPropType.SubDensity) then
                    v = cfg.DecorateDepth * FaceEditConst.ConfigDeflateFactor
                end
            end
            local item = FaceEditData.EditItem.new(k, v, true)
            table.insert(data, item)
        end
    end

    local holdCustomProp = not table.containsvalue(FaceEditConst.HairCustomPropTypes, propType)
    -- 样式无：清理自定义属性 PresetColorID Density Gloss
    if mainType == FaceEditConst.MainType.Makeup and propClass == FaceEditConst.UIPropClass.Style and value == 1 then
        for _, prop in ipairs(FaceEditConst.MakeupCustomPropTypes) do
            local _key = FaceEditUtil.GetKey(mainType, subType, prop)
            if self._editData:ContainsKey(_key) then
                local item = FaceEditData.EditItem.new(_key, nil)
                table.insert(data, item)
                holdCustomProp = false
            end
        end
    end

    if key == FaceEditUtil.GetKey(FaceEditConst.MainType.Hair) then
        if propClass == FaceEditConst.UIPropClass.Color then
            -- 发型改推荐色：玩家先修改了自定义颜色，之后又切换了推荐色，自定义不保留
            for _, prop in ipairs(FaceEditConst.HairCustomPropTypes) do
                local _key = FaceEditUtil.GetKey(FaceEditConst.MainType.Hair, nil, prop)
                if self._editData:ContainsKey(_key) then
                    local item = FaceEditData.EditItem.new(_key, nil)
                    table.insert(data, item)
                    holdCustomProp = false
                end
            end
        end
    end

    -- 继承保留的自定义属性
    if holdCustomProp then
        if sub_dic and next(sub_dic) then
            for k, v in pairs(sub_dic) do
                local cKey = FaceEditUtil.GetCustomKey(k)
                if cKey then
                    local cItem = self._editData:GetItem(cKey)
                    if cItem then
                        local item = FaceEditData.EditItem.new(cKey, cItem.value, cItem.is_sub)
                        table.insert(data, item)
                    end
                end
            end
        end
    end

    local keyEyeR = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR)
    local keyEyeL = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeL)
    local keyEyeRCover = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.EyeRCover)
    local keyEyeLCover = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.EyeLCover)
    local keySingleCover = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, nil, FaceEditConst.EditPropType.EyeSingleCover)
    if key == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.TogA) then -- 开关异色瞳
        if value and value == 1 then -- 开启异色瞳
            table.insert(data, FaceEditData.EditItem.new(keySingleCover, self._editData:GetValue(keyEyeR))) -- 记录单色瞳色
            table.insert(data, FaceEditData.EditItem.new(keyEyeR, self:GetCoverEyeValue(keyEyeRCover)))
            table.insert(data, FaceEditData.EditItem.new(keyEyeL, self:GetCoverEyeValue(keyEyeLCover)))
        else -- 关闭异色瞳
            table.insert(data, FaceEditData.EditItem.new(keyEyeRCover, self._editData:GetValue(keyEyeR))) -- 记录异色瞳色
            table.insert(data, FaceEditData.EditItem.new(keyEyeLCover, self._editData:GetValue(keyEyeL))) -- 记录异色瞳色
            table.insert(data, FaceEditData.EditItem.new(keyEyeR, self:GetCoverEyeValue(keySingleCover)))
            table.insert(data, FaceEditData.EditItem.new(keyEyeL, self:GetCoverEyeValue(keySingleCover)))
        end
    elseif key == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeL) then -- 设置瞳色
        local keyTogA = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.TogA)
        local isTogAOn = self._editData:GetValue(keyTogA)
        if not isTogAOn or isTogAOn == 0 then -- 异色瞳关闭
            table.insert(data, FaceEditData.EditItem.new(keyEyeR, value))
            table.insert(data, FaceEditData.EditItem.new(keySingleCover, value))
        else -- 异色瞳开启
            table.insert(data, FaceEditData.EditItem.new(keyEyeLCover, value))
        end
    elseif key == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR) then
        local keyTogA = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.TogA)
        local isTogAOn = self._editData:GetValue(keyTogA)
        if isTogAOn and isTogAOn == 1 then -- 异色瞳开启
            table.insert(data, FaceEditData.EditItem.new(keyEyeRCover, value))
        end
    end

    table.sort(data, function(a, b)
        return a.key < b.key
    end)

    return data
end

function FaceEditProxy:GetCoverEyeValue(key)
    local value = self._editData:GetValue(key)
    if value then
        return value
    end
    return 1
end

---风格脸中 key 关联的设置数据
---@return table[] EditItem[]
function FaceEditProxy:GetInnerChangeItems(key, value, is_sub)
    local main_item = FaceEditData.EditItem.new(key, value, is_sub)
    local data = { main_item }

    local sub_dic = self:_GetSubs(key, value)
    if sub_dic and next(sub_dic) then
        local styleId = self:GetFaceStyleMaxWeightStyleId()
        local cfg = LuaCfgMgr.Get("FaceStyle", styleId)
        for k, v in pairs(sub_dic) do
            if k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyeshadow, FaceEditConst.EditPropType.SubDensity) then
                v = cfg.EyeShadowDepth * FaceEditConst.ConfigDeflateFactor
            elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Lip, FaceEditConst.EditPropType.SubDensity) then
                v = cfg.LipDepth * FaceEditConst.ConfigDeflateFactor
            elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyebrow, FaceEditConst.EditPropType.SubDensity) then
                v = cfg.EyebrowDepth * FaceEditConst.ConfigDeflateFactor
            elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeLiner, FaceEditConst.EditPropType.SubDensity) then
                v = cfg.EyeLinerDepth * FaceEditConst.ConfigDeflateFactor
            elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Blush, FaceEditConst.EditPropType.SubDensity) then
                v = cfg.BlushDepth * FaceEditConst.ConfigDeflateFactor
            elseif k == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Decorate, FaceEditConst.EditPropType.SubDensity) then
                v = cfg.DecorateDepth * FaceEditConst.ConfigDeflateFactor
            end

            local item = FaceEditData.EditItem.new(k, v, true)
            table.insert(data, item)
        end
    end

    return data
end

---获取关联子属性列表
---@param key number @编辑项key
---@param value number|Color @编辑项值
---@return table<number, number|Color> 编辑项关联子属性列表
function FaceEditProxy:_GetSubs(key, value)
    local dict = {}
    if not key or not value then
        return dict
    end

    local mainType, subType, propType = FaceEditUtil.GetTypes(key)

    ---高级自定义颜色，六个自定义属性全记录
    ---如果 editData 中不存在某个属性的记录，从 editData 中读取当前显示的属性值
    if mainType == FaceEditConst.MainType.Hair and table.containsvalue(FaceEditConst.HairCustomPropTypes, propType) then
        for _, custom_type in ipairs(FaceEditConst.HairCustomPropTypes) do
            local key_sub = FaceEditUtil.GetKey(mainType, subType, custom_type)
            local cItem = self._editData:GetItem(key_sub)
            if not cItem and key_sub ~= key then
                local default_sub_key = FaceEditUtil.GetKey(mainType, subType, FaceEditConst.SubPropTypes2[custom_type])
                if default_sub_key then
                    local default_sub_edit_item = self._editData:GetItem(default_sub_key)
                    if default_sub_edit_item and default_sub_edit_item.value then
                        dict[key_sub] = default_sub_edit_item.value
                    end
                end
            end
        end
        return dict
    end

    if propType ~= FaceEditConst.EditPropType.StyleAndColor then
        return dict
    end

    local subCfgDic = FaceEditUtil.GetSubCfgDic(mainType, subType)
    if not subCfgDic or not next(subCfgDic) then
        return dict
    end

    local cfg_name = FaceEditUtil.GetCfgName(mainType, subType)
    if not cfg_name or type(cfg_name) ~= "string" then
        Debug.LogErrorFormatWithTag(GameConst.LogTag.FaceEdit,
                " FaceEditUtil.GetCfgName(%s, %s) 配置表名不对 cfg_name = %s", mainType, subType, cfg_name)
        return dict
    end

    local cfg = LuaCfgMgr.Get(cfg_name, value)
    if not cfg then
        return dict
    end

    for prop_type, field_name in pairs(subCfgDic) do
        local key_sub = FaceEditUtil.GetKey(mainType, subType, prop_type)
        local value_sub = cfg and cfg[field_name]
        if key_sub and value_sub then
            local value_type = FaceEditUtil.GetDataTypeByKey(key_sub)
            if value_type then
                if value_type == FaceEditConst.ValueDataTypes.Float then
                    value_sub = value_sub * FaceEditConst.ConfigDeflateFactor
                elseif value_type == FaceEditConst.ValueDataTypes.Float100 then
                    value_sub = value_sub * FaceEditConst.ConfigDeflateFactor100
                elseif value_type == FaceEditConst.ValueDataTypes.Color then
                    value_sub = Color.HexToRGBA(value_sub)
                end
            end

            dict[key_sub] = value_sub
        end
    end

    return dict
end

function FaceEditProxy:GetItemByKeys(keys)
    local editItems = {}
    if keys then
        for _, key in ipairs(keys) do
            local value = self:GetValueForEdit(key)
            local item = FaceEditData.EditItem.new(key, value, true)
            table.insert(editItems, item)
        end
    end
    return editItems
end

function FaceEditProxy:SetSourceData(data)
    self._sourceData = data
    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "SetSourceData() ", data and table.dump(data, "data") or "nil")
end

-----------------------------------------------------------

---获取捏脸应用数据（非捏脸编辑模式）
---@param dataType number 捏脸使用的数据类型
function FaceEditProxy:GetEditItems(dataType)
    local editItems = nil
    if dataType == FaceEditConst.DataType.Temp then
        editItems = self:GetTempData()
    end
    if table.isnilorempty(editItems) then
        local severData = dataType == FaceEditConst.DataType.Morph and self._serverKneadEditData or self._serverMakeupEditData
        editItems = severData and severData:GetListData()
    end
    return editItems
end

---获取捏脸应用数据（捏脸编辑模式）
---@param isTemp boolean 捏脸使用的数据类型
function FaceEditProxy:GetEditItemsForEdit(isTemp)
    local editItems = nil
    
    if isTemp then
        editItems = self:GetTempData()
    end

    if table.isnilorempty(editItems) then
        editItems = self._editData and self._editData:GetListData()
    end
    return editItems
end

function FaceEditProxy:TakeEditItemsSnapshot()
    self._curEditItemsSnapshot = self:GetEditItemsForEdit(false)
end

function FaceEditProxy:GetEditItemsSnapshot()
    return self._curEditItemsSnapshot
end

function FaceEditProxy:ApplyEditItemsSnapshot(isClear)
    if self._curEditItemsSnapshot then
        self._editData:ClearData()
        self._editData:UpdateData(self._curEditItemsSnapshot)
        self:UpdateFaceStyleInfo(self._curEditItemsSnapshot)
    end
    if isClear then
        self._curEditItemsSnapshot = nil
    end
end


-----------------------------------------------------------


---获取编辑值（捏脸编辑模式）
--- editData > _sourceData > 配置值
---@param key number @编辑项key
function FaceEditProxy:GetValueForEdit(key, excludeSubKey)
    local value = self:GetOnlyEditValue(key, excludeSubKey)
    if value then
        return value
    end

    if excludeSubKey then
        return self:GetDefaultCfgValue(key)
    else
        return self:GetEditSourceValue(key)
    end
end

---获取当前编辑区初始值（捏脸编辑模式，用于Undo找到初始数据）
---优先规则：_sourceData > 配置值
---@param key number @编辑项key
function FaceEditProxy:GetEditSourceValue(key)
    if not key then
        return
    end

    if self._sourceData then
        if self._sourceData[key] then
            return FaceEditUtil.GetServerDeflateValue(key, self._sourceData[key])
        end

        local subKey = FaceEditUtil.GetSubKey(key)
        if subKey and self._sourceData[subKey] then
            return FaceEditUtil.GetServerDeflateValue(key, self._sourceData[subKey])
        end
    end

    return self:GetDefaultCfgValue(key)
end

---获取默认值（非捏脸编辑模式）
---优先规则：临时妆发值 > 服务器值 > 配置值
---@param key number @编辑项key
---@param dataType number @当前使用的捏脸数据类型
function FaceEditProxy:GetDefaultValue(key, dataType)
    if not key then
        return
    end

    if dataType == FaceEditConst.DataType.Temp and self._tempData then
        local value = self._tempData:GetValueWithSubKey(key)
        if value then
            return value
        end
    end

    local severData = dataType == FaceEditConst.DataType.Morph and self._originalKneadServerData or self._originalMakeupServerData
    local value = severData and severData[key]
    if not value then
        local subKey = FaceEditUtil.GetSubKey(key)
        if subKey then
            value = severData and severData[subKey]
        end
    end

    if value then
        return FaceEditUtil.GetServerDeflateValue(key, value)
    end

    return self:GetDefaultCfgValue(key)
end

---获取配置默认值
---（妆发属性为默认初始脸配置）
---@param key number @编辑项key
---@return number @默认配置值
function FaceEditProxy:GetDefaultCfgValue(key)
    if not key then
        return
    end

    local mainType, subType, propType = FaceEditUtil.GetTypes(key)
    if mainType == FaceEditConst.MainType.Bone then
        return FaceEditConst.DefaultValueBone
    end

    if mainType == FaceEditConst.MainType.Version then
        return FaceEditConst.DefaultVersion
    end

    if mainType == FaceEditConst.MainType.Voice then
        return BllMgr.GetFaceBLL():GetDefaultPlayerVoice(subType)
    end

    key = FaceEditUtil.GetSubKey(key) or key

    if not self._defaultCfgValueDic then
        local cfg = LuaCfgMgr.Get(FaceEditUtil.GetCfgName(FaceEditConst.MainType.StyleFace), FaceEditConst.FaceStyleInitialCfgId)
        self._defaultCfgValueDic = {
            [FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosA_Index)] = FaceEditConst.FaceStylePosCfgIds[1],
            [FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosA_Weight)] = 0,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosB_Index)] = FaceEditConst.FaceStylePosCfgIds[2],
            [FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosB_Weight)] = 0,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosC_Index)] = FaceEditConst.FaceStylePosCfgIds[3],
            [FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosC_Weight)] = 0,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Skin)] = cfg and cfg.DefaultSkin,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Hair)] = cfg and cfg.DefaultHair,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Hair, nil, FaceEditConst.EditPropType.SubTogB)] = FaceEditConst.DefaultValueTogB,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyebrow, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultEyebrow,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Lip, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultLip,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Lip, FaceEditConst.EditPropType.Gloss)] = cfg and cfg.DefaultGloss,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeL, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultEyeLeft,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultEyeRight,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.SubTogA)] = FaceEditConst.DefaultValueTogA,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyeshadow, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultEyeshadow,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeLiner, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultEyeLiner,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyelash, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultEyelash,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Blush, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultBlush,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Decorate, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultDecorate,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyelid, FaceEditConst.EditPropType.StyleAndColor)] = cfg and cfg.DefaultEyelid,
            [FaceEditUtil.GetKey(FaceEditConst.MainType.Voice)] = FaceEditConst.DefaultValueVoice,
        }
    end

    if key and self._defaultCfgValueDic and self._defaultCfgValueDic[key] then
        return self._defaultCfgValueDic[key]
    end

    local styleId = self._defaultCfgValueDic[FaceEditUtil.GetKey(mainType, subType, FaceEditConst.EditPropType.StyleAndColor)]
    if styleId then
        local cfg = LuaCfgMgr.Get(FaceEditUtil.GetCfgName(mainType, subType), styleId)
        local fieldName = FaceEditUtil.GetSubCfgFieldName(mainType, subType, propType)
        local value = cfg and fieldName and cfg[fieldName]
        if value then
            local dataType = FaceEditUtil.GetDataTypeByKey(key)
            if dataType then
                if dataType == FaceEditConst.ValueDataTypes.Color then
                    value = Color.HexToRGBA(value)
                elseif dataType == FaceEditConst.ValueDataTypes.Float then
                    value = value * FaceEditConst.ConfigDeflateFactor
                elseif dataType == FaceEditConst.ValueDataTypes.Float100 then
                    value = value * FaceEditConst.ConfigDeflateFactor100
                end
            end
        end
        --self._defaultCfgValueDic[key] = value
        return value
    end
end

---@param key number @编辑项key
---@param excludeSubKey boolean 排除SubKey
function FaceEditProxy:GetOnlyEditValue(key, excludeSubKey)
    --异瞳处理：读取右眼时 判断异色瞳关且有覆盖数据则读取覆盖数据，否则读本身数据
    if key == FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR) then
        local cover = self:_GetExtraValueEyeR()
        if cover then
            return cover
        end
    end

    if self._editData then
        if excludeSubKey then
            return self._editData:GetValue(key)
        else
            return self._editData:GetValueWithSubKey(key)
        end
    end
end

function FaceEditProxy:GetCurrentValue(key, isMakeup)
    if isMakeup then
        return self._serverMakeupEditData:GetValue(key)
    else
        return self._serverKneadEditData:GetValue(key)
    end
end

---获取保留推荐色系对应的新值
---@param key number @样式编辑项key
---@param value number @编辑项值
---@return number @保留的推荐色系对应的新值
function FaceEditProxy:GetStyleKeepColor(key, value)
    -- 妆容/发型换样式时，如果玩家有自定义推荐色 则默认选择同色系
    local mainType, subType, propType = FaceEditUtil.GetTypes(key)
    if mainType and (mainType == FaceEditConst.MainType.Hair or mainType == FaceEditConst.MainType.Makeup) and propType == FaceEditConst.EditPropType.StyleAndColor then
        local keyColor = FaceEditUtil.GetKey(mainType, subType, FaceEditConst.EditPropType.PresetColorID)
        local colorId = self._editData:GetValue(keyColor)
        if colorId then
            local cfgName = FaceEditUtil.GetCfgName(mainType, subType)
            if cfgName then
                local styleID = LuaCfgMgr.Get(cfgName, value).StyleID
                local newCfg = LuaCfgMgr.GetListByCondition(cfgName, {StyleID = styleID})
                if newCfg then
                    for _, v in pairs(newCfg) do
                        if v.ColorID == colorId then
                            return v.ID
                        end
                    end
                end
            end
        end
    end
    return value
end

---@return number @右眼异瞳关闭时的覆盖数据
function FaceEditProxy:_GetExtraValueEyeR()
    local keyTog = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.TogA)
    local tog = self._editData and self._editData:GetValue(keyTog)
    if not tog or tog == 0 then
        local keyCover = FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR, FaceEditConst.EditPropType.EyeRCover)
        local cover = self._editData:GetValue(keyCover)
        if cover then
            return cover
        end
    end
end

-----------------------------------------------------------

--region 风格脸
function FaceEditProxy:InitFaceStyleInfo()
    self._faceStyleMaxWeightId = nil
    self._faceStyleInfo = {
        [1] = { ["cfgId"] = FaceEditConst.FaceStylePosCfgIds[1], ["weight"] = 1,
                ["keyIdx"] = FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosA_Index),
                ["keyWeight"] = FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosA_Weight) },
        [2] = { ["cfgId"] = FaceEditConst.FaceStylePosCfgIds[2], ["weight"] = 0,
                ["keyIdx"] = FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosB_Index),
                ["keyWeight"] = FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosB_Weight) },
        [3] = { ["cfgId"] = FaceEditConst.FaceStylePosCfgIds[3], ["weight"] = 0,
                ["keyIdx"] = FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosC_Index),
                ["keyWeight"] = FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosC_Weight) },
    }
end

function FaceEditProxy:GetFaceStyleInfo(posIdx)
    return posIdx and self._faceStyleInfo and self._faceStyleInfo[posIdx]
end

function FaceEditProxy:UpdateSourceData()
    self:ClearHistoryData()
    if self._editData and next(self._editData) then
        self:SetSourceData(self._editData and self._editData:GetMapData())
        self:UpdateUIDataNodeByEditData(self._editData:GetListData())
    end
end

function FaceEditProxy:UpdateVersion(dataType)
    local key = FaceEditUtil.GetKey(FaceEditConst.MainType.Version)
    local preVersion = self:GetDefaultValue(key, dataType)
    local editItems = self:GetChangeItems(key, preVersion + 1)

    if self._editData then
        self._editData:UpdateData(editItems)
    end
end

---重新加载风格脸数据
function FaceEditProxy:ReloadStyleFace()
    self._editData:ClearData()
    -- 回到圆盘中间初始脸
    self:InitFaceStyleInfo()
    local editItems = self:LoadStyleFaceInfo(true)
    return editItems
end

function FaceEditProxy:LoadStyleFaceInfo(force)
    local editItems = {}

    local contained = self:ContainsFaceStyle()
    for posIdx = 1, 3 do
        local info = self._faceStyleInfo and self._faceStyleInfo[posIdx]
        if contained then
            info.cfgId = self:GetValueForEdit(info.keyIdx)
            info.weight = self:GetValueForEdit(info.keyWeight)
        end
        if not contained or force then
            table.insertto(editItems, self:SetPropDataInner(info.keyIdx, info.cfgId))
            table.insertto(editItems, self:SetPropDataInner(info.keyWeight, info.weight))
        end
    end
    if not contained or force then
        table.insertto(editItems, self:UpdateFaceStyleMakeup(false, force))
    end

    return editItems
end

function FaceEditProxy:GetStyleFaceInfo()
    local editItems = {}

    local contained = self:ContainsFaceStyle()
    for posIdx = 1, 3 do
        local info = self._faceStyleInfo and self._faceStyleInfo[posIdx]
        if contained then
            info.cfgId = self:GetValueForEdit(info.keyIdx)
            info.weight = self:GetValueForEdit(info.keyWeight)
        end
        table.insertto(editItems, self:GetInnerChangeItems(info.keyIdx, info.cfgId))
        table.insertto(editItems, self:GetInnerChangeItems(info.keyWeight, info.weight))
    end

    local styleId = self:GetFaceStyleMaxWeightStyleId()
    local cfgName = FaceEditUtil.GetCfgName(FaceEditConst.MainType.StyleFace)
    local cfg = LuaCfgMgr.Get(cfgName, styleId)
    if cfg then
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Skin), cfg.DefaultSkin, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Hair), cfg.DefaultHair, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyebrow), cfg.DefaultEyebrow, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Lip), cfg.DefaultLip, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeL), cfg.DefaultEyeLeft, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR), cfg.DefaultEyeRight, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyeshadow), cfg.DefaultEyeShadow, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeLiner), cfg.DefaultEyeLiner, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyelash), cfg.DefaultEyelash, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Blush), cfg.DefaultBlush, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Decorate), cfg.DefaultDecorate, true))
        table.insertto(editItems, self:GetInnerChangeItems(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyelid), cfg.DefaultEyelid, true))
    end

    return editItems
end

function FaceEditProxy:UpdateFaceStyleInfo(editItems)
    if editItems then
        for _, item in pairs(editItems) do
            if item.key == FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosA_Index) then
                self._faceStyleInfo[1].cfgId = item.value
            elseif item.key == FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosA_Weight) then
                self._faceStyleInfo[1].weight = item.value
            elseif item.key == FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosB_Index) then
                self._faceStyleInfo[2].cfgId = item.value
            elseif item.key == FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosB_Weight) then
                self._faceStyleInfo[2].weight = item.value
            elseif item.key == FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosC_Index) then
                self._faceStyleInfo[3].cfgId = item.value
            elseif item.key == FaceEditUtil.GetKey(FaceEditConst.MainType.StyleFace, nil, FaceEditConst.EditPropType.PosC_Weight) then
                self._faceStyleInfo[3].weight = item.value
            end
        end
    end
end

function FaceEditProxy:GetFaceStyleReplaceableListNew()
    local result = {}
    local uiData = self:GetStyleFaceUIData()
    if uiData and uiData.children then
        for _, item in ipairs(uiData.children) do
            if item.cfgId then
                table.insert(result, item)
            end
        end
    end
    return result
end

function FaceEditProxy:GetFaceStyleReplaceableList(posIdx)
    -- 列表中选中当前圆盘上选中的风格脸，不显示其他两个使用中的风格脸
    local result = {}
    local uiData = self:GetStyleFaceUIData()
    if uiData and uiData.children then
        for _, item in ipairs(uiData.children) do
            --if item.cfgId and item.cfgId ~= FaceEditConst.FaceStyleInitialCfgId then
            if item.cfgId then
                if posIdx and self._faceStyleInfo[posIdx] and self._faceStyleInfo[posIdx].cfgId == item.cfgId then
                    table.insert(result, item)
                else
                    local isIn = false
                    for _, info in ipairs(self._faceStyleInfo) do
                        if item.cfgId == info.cfgId then
                            isIn = true
                            break
                        end
                    end
                    if not isIn then
                        table.insert(result, item)
                    end
                end
            end
        end
    end
    return result
end

function FaceEditProxy:GetFaceStylePolarPos()
    local weights = { self._faceStyleInfo[1].weight, self._faceStyleInfo[2].weight, self._faceStyleInfo[3].weight }
    local polar = self:WeightsToPolar(weights)
    Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "weights {%0.2f, %0.2f, %0.2f} -> [%0.2f,%0.2f]", weights[1], weights[2], weights[3], polar.x, polar.y)
    return polar
end

function FaceEditProxy:GetFaceStyleMaxWeightStyleId()
    local baseId = FaceEditConst.FaceStyleInitialCfgId
    local baseWeight = 1 - (self._faceStyleInfo[1].weight + self._faceStyleInfo[2].weight + self._faceStyleInfo[3].weight)

    local maxVal = baseWeight
    local maxIdx = 0
    for i = 1, 3 do
        if self._faceStyleInfo[i].weight > maxVal then
            maxVal = self._faceStyleInfo[i].weight
            maxIdx = i
        end
    end
    if maxIdx > 0 then
        return self._faceStyleInfo[maxIdx].cfgId
    end
    return baseId
end

function FaceEditProxy:SetFaceStylePolarPos(polar, isDragging)
    local weights = self:PolarToWeights(polar)
    --Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "polar [%0.2f,%0.2f] -> {%0.2f, %0.2f, %0.2f}", polar.x, polar.y, weights[1], weights[2], weights[3])
    local editItems = self:SetFaceStyleWeight(weights, not isDragging)

    if not isDragging then
        self:AddToHistory(FaceEditConst.HistoryGivenKeys.FaceStyle, 2, editItems)
    end

    return editItems
end

function FaceEditProxy:PolarToWeights(polar)
    local weights = { 0, 0, 0 }
    local posAng = { FaceEditConst.FaceStylePresetAngles.x, FaceEditConst.FaceStylePresetAngles.y, FaceEditConst.FaceStylePresetAngles.z }

    for i = 1, 2 do
        if polar.y >= posAng[i] and polar.y <= posAng[i + 1] then
            local ratio = (polar.y - posAng[i]) / (posAng[i + 1] - posAng[i])
            weights[i] = (1 - ratio) * polar.x
            weights[i + 1] = ratio * polar.x
        end
    end
    if polar.y > posAng[3] then
        local ratio = (polar.y - posAng[3]) / (1 + posAng[1] - posAng[3])
        weights[3] = (1 - ratio) * polar.x
        weights[1] = ratio * polar.x
    elseif polar.y < posAng[1] then
        local ratio = (posAng[1] - polar.y) / (1 + posAng[1] - posAng[3])
        weights[1] = (1 - ratio) * polar.x
        weights[3] = ratio * polar.x
    end

    return weights
end

function FaceEditProxy:WeightsToPolar(weights)
    local polar = Vector2.zero
    local posAng = { FaceEditConst.FaceStylePresetAngles.x, FaceEditConst.FaceStylePresetAngles.y, FaceEditConst.FaceStylePresetAngles.z }
    local tolerance = 0.001

    local sum = weights[1] + weights[2] + weights[3]
    polar.x = sum

    if sum <= 0.001 then
        polar.y = 0
        return polar
    end

    weights[1] = weights[1] / sum
    weights[2] = weights[2] / sum
    weights[3] = weights[3] / sum

    if weights[1] > tolerance then
        if (weights[2] > tolerance) then
            polar.y = (posAng[2] - posAng[1]) * weights[2] + posAng[1]
        elseif (weights[3] > tolerance) then
            local y = (1 + posAng[1] - posAng[3]) * weights[1] + posAng[3]
            polar.y = y >= 1 and y - 1 or y
        else
            polar.y = posAng[1]
        end
    elseif (weights[2] > tolerance) then
        if (weights[3] > tolerance) then
            polar.y = (posAng[3] - posAng[2]) * weights[3] + posAng[2]
        else
            polar.y = posAng[2]
        end
    elseif (weights[3] > tolerance) then
        polar.y = posAng[3]
    end

    return polar
end

function FaceEditProxy:SetFaceStyleIndex(posIdx, cfgId)
    local info = posIdx and self._faceStyleInfo[posIdx]
    if info and cfgId then
        if info.cfgId ~= cfgId then
            info.cfgId = cfgId
            local editItems = {}
            table.insertto(editItems, self:SetPropDataInner(info.keyIdx, info.cfgId))
            table.insertto(editItems, self:UpdateFaceStyleMakeup())

            self:AddToHistory(FaceEditConst.HistoryGivenKeys.FaceStyle, 1, editItems)

            return editItems
        end
    end
end

function FaceEditProxy:SetFaceStyleWeight(weights, force)
    local editItems = {}
    for posIdx = 1, 3 do
        local info = self._faceStyleInfo and self._faceStyleInfo[posIdx]
        local weight = weights and weights[posIdx]
        if info and weight then
            info.weight = weight
            table.insertto(editItems, self:SetPropDataInner(info.keyWeight, info.weight))
        end
    end
    table.insertto(editItems, self:UpdateFaceStyleMakeup(nil, force))
    return editItems
end

function FaceEditProxy:UpdateFaceStyleMakeup(excludeSkin, force)
    -- Bone: 不做频繁计算，进详细捏脸时调用 SyncPropStyleFaceBone 同步Bone数据,
    -- 由于需要本地化数据，因此只能在设置的时候同步
    -- Makeup: 根据最大的weight设置妆容
    local styleId = self:GetFaceStyleMaxWeightStyleId()
    if not force and self._faceStyleMaxWeightId == styleId then
        return
    end
    self._faceStyleMaxWeightId = styleId
    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "风格脸妆容 CfgID = ", styleId)
    local cfgName = FaceEditUtil.GetCfgName(FaceEditConst.MainType.StyleFace)
    local cfg = LuaCfgMgr.Get(cfgName, styleId)
    if cfg then
        local editItems = {}
        if not excludeSkin then
            table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Skin), cfg.DefaultSkin, true))
        end
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Hair), cfg.DefaultHair, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyebrow), cfg.DefaultEyebrow, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Lip), cfg.DefaultLip, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeL), cfg.DefaultEyeLeft, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeR), cfg.DefaultEyeRight, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyeshadow), cfg.DefaultEyeShadow, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.EyeLiner), cfg.DefaultEyeLiner, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyelash), cfg.DefaultEyelash, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Blush), cfg.DefaultBlush, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Decorate), cfg.DefaultDecorate, true))
        table.insertto(editItems, self:SetPropDataInner(FaceEditUtil.GetKey(FaceEditConst.MainType.Makeup, FaceEditConst.MakeupType.Eyelid), cfg.DefaultEyelid, true))
        return editItems
    end
end

--endregion

--region makeupTemplates 妆发模板

function FaceEditProxy:GetTemplatesCount()
    return self._makeupTemplates and #self._makeupTemplates or 0
end

--function FaceEditProxy:GetTemplateMaxId()
--    local template = self._makeupTemplates and self._makeupTemplates[#self._makeupTemplates]
--    return template and template.templateId or 0
--end

--function FaceEditProxy:GetTemplateByIndex(index)
--    return index and self._makeupTemplates and self._makeupTemplates[index]
--end

---@return number 在列表中的位置下标
---@return table 模板信息
function FaceEditProxy:GetTemplateByID(templateId)
    self._makeupTemplates = self._makeupTemplates or {}
    if templateId then
        for idx, template in ipairs(self._makeupTemplates) do
            if template.templateId == templateId then
                return templateId, template
            end
        end
    end
    return -1, nil
end

function FaceEditProxy:AddOrSetTemplate(templateId, name, data)
    if not templateId then
        return
    end

    local _, template = self:GetTemplateByID(templateId)
    if not template then
        template = {}
        template.templateId = templateId
        table.insert(self._makeupTemplates, template)
        table.sort(self._makeupTemplates, function(a, b)
            return a.templateId < b.templateId
        end)
    end
    template.templateName = name
    if data then
        template.data = data
    end
    EventMgr.Dispatch(FaceEditConst.Event.TemplateChangeFinish, templateId)
end

function FaceEditProxy:DeleteTemplate(templateId)
    local pos, _ = self:GetTemplateByID(templateId)
    if pos and pos > -1 then
        table.remove(self._makeupTemplates, pos)
    end
    EventMgr.Dispatch(FaceEditConst.Event.TemplateChangeFinish)
end

function FaceEditProxy:GetSaveDataTemplate()
    return self._editData and self._editData:GetSaveData() or {}
end

---@param templateData table<number, number>
---@return table[] EditItem[] 应用数据
function FaceEditProxy:LoadApplyTemplate(templateId)
    local _, template = self:GetTemplateByID(templateId)
    local templateData = template and template.data
    if templateData then
        self:LoadDataFromSource(templateData)
    end
end

--endregion

--region originalLocalData 本地数据

function FaceEditProxy:InitLocalData()
    if self._originalLocalData then
        return
    end
    local encodeLocalData = PlayerPrefs.GetString(FaceLocalDataUtil.GetPrefsKeyLocalData())
    if not string.isnilorempty(encodeLocalData)  then
        self._originalLocalData = self:DecodeLocalData(encodeLocalData)
    end
end

function FaceEditProxy:DeleteLocalData()
    self._originalLocalData = nil
    PlayerPrefs.DeleteKey(FaceLocalDataUtil.GetPrefsKeyLocalData())
end

--- 要保存的本地数据
function FaceEditProxy:SaveLocalData()
    local encodeStr = self:EncodeLocalData()
    Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "[%s] = %s", FaceLocalDataUtil.GetPrefsKeyLocalData(), encodeStr)
    PlayerPrefs.SetString(FaceLocalDataUtil.GetPrefsKeyLocalData(), encodeStr)
    PlayerPrefs.Save()
end

function FaceEditProxy:GetLocalData()
    return PlayerPrefs.GetString(FaceLocalDataUtil.GetPrefsKeyLocalData())
end

--- 删除预捏脸数据
function FaceEditProxy:DeletePreMorphData()
    local key = string.concat(FaceLocalDataUtil.GetPrefsKeyLocalData(), "_PreMorph")
    PlayerPrefs.DeleteKey(key)
end

--- 保存预捏脸数据
function FaceEditProxy:SavePreMorphData()
    local encodeStr = self:EncodeLocalData(true)
    Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "[%s] = %s", FaceLocalDataUtil.GetPrefsKeyLocalData(), encodeStr)
    local key = string.concat(FaceLocalDataUtil.GetPrefsKeyLocalData(), "_PreMorph")
    PlayerPrefs.SetString(key, encodeStr)
    PlayerPrefs.Save()
end

function FaceEditProxy:GetPreMorphData()
    local key = string.concat(FaceLocalDataUtil.GetPrefsKeyLocalData(), "_PreMorph")
    return PlayerPrefs.GetString(key)
end

function FaceEditProxy:EncodeLocalData(includeVoice)
    local save_data = self._editData and self._editData:GetSaveData() or {}
    local arr = {}
    local keys = FaceLocalDataUtil.GetAllKey(nil, includeVoice)
    for i = 1, #keys do
        local id = keys[i][1]
        table.insert(arr, save_data[id] and FaceLocalDataUtil.GetLocalValue(id, save_data[id]) or 0)
    end
    local bytes = ""
    bytes = string.concat(bytes, string.char(FaceLocalDataUtil.GetCurrentLocalVersion()))

    for i = 1, #arr do
        local length = keys[i][2]
        for j = length, 1, -1 do
            local num = (arr[i] >> (j - 1) * 8) & 0xff
            bytes = string.concat(bytes, string.char(num))
        end
    end

    return CS.X3Game.FaceEdit.DataConvertUtil.GetSavedString(bytes)
end

function FaceEditProxy:DecodeLocalData(str, includeVoice)
    local realData = CS.X3Game.FaceEdit.DataConvertUtil.GetRealBytes(str)
    local localData = {}
    if not string.isnilorempty(realData) then
        local dataVersion = string.byte(realData, 1)
        if dataVersion ~= FaceLocalDataUtil.GetCurrentLocalVersion() then
            Debug.LogWithTag(GameConst.LogTag.FaceEdit, "Old VersionId")
        end
        local keys = FaceLocalDataUtil.GetAllKey(dataVersion, includeVoice)
        if keys == nil then
            Debug.LogErrorWithTag(GameConst.LogTag.FaceEdit, "Invalid VersionId")
            return nil
        end
        local dataIdx = 1
        for i = 1, #keys do
            local id = keys[i][1]
            local length = keys[i][2]
            local num = 0
            for j = length, 1, -1 do
                dataIdx = dataIdx + 1
                if dataIdx > #realData then
                    Debug.LogErrorWithTag(GameConst.LogTag.FaceEdit, "Error Data Length")
                    return nil
                end
                num = num | (string.byte(realData, dataIdx) <<(j - 1) * 8)
            end
            local value, invalid = FaceLocalDataUtil.GetEditValue(id, num, dataVersion)
            if invalid then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.FaceEdit, "Cannot Find Cfg Id by Value %d for id %d", num, id)
                return nil
            else
                localData[id] = value
            end
        end
    else
        Debug.LogErrorWithTag(GameConst.LogTag.FaceEdit, "Cannot Get info from input string")
        return nil
    end

    local subDict = {}
    for key, value in pairs(localData) do
        local sub_dic = self:_GetSubs(key, FaceEditUtil.GetServerDeflateValue(key, value))
        if sub_dic and next(sub_dic) then
            for k, v in pairs(sub_dic) do
                subDict[k] = FaceEditUtil.GetServerInflateValue(k, v)
            end
        end
    end

    for k,v in pairs(subDict) do
        if localData[k] == nil then
            localData[k] = v
        end
    end
    return localData
end

--endregion

--region AIFace Data
function FaceEditProxy:LoadAIFaceMakeupData(makeup, density)
    local localData = {}
    local originalData = self._editData:GetSaveData()
    for i, value in pairs(makeup) do
        local keys = FaceLocalDataConst.AIFaceMakeupList[i]
        if keys then
            for _, key in pairs(keys) do
                local mainKey = FaceEditUtil.GetMainTypeByKey(key)
                local subKey = FaceEditUtil.GetSubTypeByKey(key)
                local propKey = FaceEditUtil.GetThirdType(key)
                local validRecord = false
                if (propKey ~= FaceEditConst.EditPropType.Gloss or value ~= 0) and
                        (subKey ~= FaceEditConst.MakeupType.Decorate or value ~= 0) then
                    value = value == -1 and 1 or value
                    if LuaCfgMgr.Get(FaceEditUtil.GetCfgName(mainKey, subKey), value) then
                        localData[key] = value * FaceEditConst.ServerInflateFactor
                        validRecord = true
                    end
                end

                if not validRecord then
                    localData[key] = originalData[key]
                end
            end
        end
    end

    for i,value in pairs(density) do
        local key = FaceLocalDataConst.AIFaceMakeupDensityList[i]
        if key then
            if value > 0 then
                localData[key] = value * FaceEditConst.AIFaceDeflateFactor * FaceEditConst.ServerInflateFactor
            end
        end
    end

    local subDict = {}
    for key, value in pairs(localData) do
        local sub_dic = self:_GetSubs(key, FaceEditUtil.GetServerDeflateValue(key, value))
        if sub_dic and next(sub_dic) then
            for k, v in pairs(sub_dic) do
                subDict[k] = FaceEditUtil.GetServerInflateValue(k, v)
            end
        end
    end

    for k,v in pairs(subDict) do
        if localData[k] == nil then
            localData[k] = v
        end
    end
    return localData
end
--endregion
--region tempData 临时妆发
--[[
    进入拍照 使用tempData/serverData 刷新捏脸
    离开拍照 清理tempData
    拍照进入临时妆发，(使用tempData/serverData)Load editData,
    临时妆发保存 tempData （全部数据）
]]

---@return table[] EditItem[]
function FaceEditProxy:GetTempData()
    if self._tempData then
        return self._tempData:GetListData()
    end
end

function FaceEditProxy:ClearTempData()
    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "clear self._tempData")
    if self._tempData then
        self._tempData:ClearData()
        self._tempData = nil
    end
end

---保存临时妆发数据
function FaceEditProxy:SaveTempData()
    self:ClearHistoryData()
    self._tempData = self._editData
    self._editData = nil
end

--endregion

--region historyData 操作的历史数据
function FaceEditProxy:ClearHistoryData()
    self._curHistoryIndex = 0
    self._historyList = {}
    self._historyDataDict = {}
end

function FaceEditProxy:AddToHistory(key, value, subs)
    self._historyList = self._historyList or {}
    self._historyDataDict = self._historyDataDict or {}

    -- 删除 curOperListIndex到最后的之间操作记录
    if self._curHistoryIndex < #self._historyList then
        for i = #self._historyList, self._curHistoryIndex + 1, -1 do
            table.remove(self._historyList, i)
        end
        for _key, info in pairs(self._historyDataDict) do
            if info.curIdx and info.curIdx < #info.list then
                for i = #info.list, info.curIdx + 1, -1 do
                    table.remove(info.list, i)
                end
            end

            if table.isnilorempty(info.list) then
                self._historyDataDict[_key] = nil
            end
        end
    end

    local item = OperData.new(key, value)
    if subs then
        item:SetSubs(subs)
    end

    table.insert(self._historyList, item)
    self._curHistoryIndex = #self._historyList

    self._historyDataDict[key] = self._historyDataDict[key] or {}
    local info = self._historyDataDict[key]
    info.list = info.list or {}
    table.insert(info.list, FaceEditData.EditItem.new(key, value, false))
    info.curIdx = #info.list

    if subs then
        for _, sItem in ipairs(subs) do
            local _key = sItem.key
            self._historyDataDict[_key] = self._historyDataDict[_key] or {}
            local sInfo = self._historyDataDict[_key]
            sInfo.list = sInfo.list or {}
            table.insert(sInfo.list, FaceEditData.EditItem.new(_key, sItem.value, sItem.is_sub))
            sInfo.curIdx = #sInfo.list
        end
    end
end

---@return number OperData.key
---@return table[] EditItem[]
function FaceEditProxy:GetHistoryData(isForward)
    local result = {}

    local index = isForward and self._curHistoryIndex + 1 or self._curHistoryIndex

    local item = index and self._historyList and self._historyList[index]

    local keys = item and item:GetKeys()
    if not keys then
        return -1, result
    end
    for _, key in ipairs(keys) do
        if not table.keyof(FaceEditConst.HistoryGivenKeys, key) then
            local info = self._historyDataDict[key]
            if info and info.curIdx then
                local idx = isForward and info.curIdx + 1 or info.curIdx - 1
                local e_item = idx and info.list and info.list[idx]
                if e_item then
                    table.insert(result, e_item)
                else
                    if FaceEditUtil.GetMainTypeByKey(key) == FaceEditConst.MainType.Hair then
                        local sub_key = FaceEditUtil.GetSubKey(key)
                        if sub_key and not isForward then
                            -- 如果是发型的自定义属性，找当前对应的sub属性值，并且清空自定义属性
                            local sub_info = self._historyDataDict[sub_key]
                            local sub_item = sub_info and sub_info.curIdx and sub_info.list and sub_info.list[sub_info.curIdx]
                            if sub_item then
                                table.insert(result, sub_item)
                            else
                                local sub_value = self:GetEditSourceValue(sub_key)
                                if sub_value == nil then
                                    --Debug.LogErrorWithTag(GameConst.LogTag.FaceEdit, "检查异常空值 key = ", key)
                                end
                                sub_item = FaceEditData.EditItem.new(sub_key, sub_value, true)
                                table.insert(result, sub_item)
                            end
                            e_item = FaceEditData.EditItem.new(key, nil, true)
                            table.insert(result, e_item)
                        else
                            local value = self:GetEditSourceValue(key)
                            if value == nil then
                                --Debug.LogErrorWithTag(GameConst.LogTag.FaceEdit, "检查异常空值 key = ", key)
                            end
                            e_item = FaceEditData.EditItem.new(key, value, true)
                            table.insert(result, e_item)
                        end
                    else
                        local added = false
                        local sub_key = FaceEditUtil.GetSubKey(key)
                        -- 如果是自定义属性，找当前对应的sub属性值
                        if sub_key and not isForward then
                            local sub_info = self._historyDataDict[sub_key]
                            local sub_item = sub_info and sub_info.curIdx and sub_info.list and sub_info.list[sub_info.curIdx]
                            if sub_item then
                                table.insert(result, sub_item)
                                added = true
                            end
                            --如果是妆容的自定义属性，找当前对应的sub属性值，并且清空自定义属性
                            if FaceEditUtil.GetMainTypeByKey(key) == FaceEditConst.MainType.Makeup then
                                e_item = FaceEditData.EditItem.new(key, nil, true)
                                table.insert(result, e_item)
                            end
                        end

                        if not added then
                            local value = self:GetEditSourceValue(key)
                            if value == nil then
                                --Debug.LogErrorWithTag(GameConst.LogTag.FaceEdit, "检查异常空值 key = ", key)
                            end
                            e_item = FaceEditData.EditItem.new(key, value, true)
                            table.insert(result, e_item)
                        end
                    end
                end
                info.curIdx = idx
                if info.curIdx < 0 or info.curIdx > #info.list then
                    Debug.LogErrorWithTag(GameConst.LogTag.FaceEdit, "operDataList curIdx 超出数组范围 key = ", key, info.curIdx)
                end
            end
        end
    end

    local operKey = item.key

    if UNITY_EDITOR then
        local lst = {}
        for _, v in ipairs(result) do
            table.insert(lst, v:ToString())
        end
        Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "operKey = %s, GetHistoryData = %s", operKey, table.concat(lst, "\n"))
    end

    return operKey, result
end

function FaceEditProxy:UndoData(isTempMakeup)
    if self._curHistoryIndex and self._curHistoryIndex > 0 then
        local operKey, editItems = self:GetHistoryData(false)
        self._curHistoryIndex = self._curHistoryIndex - 1
        if table.isnilorempty(editItems) then
            return
        end
        local notGivenOper = not table.keyof(FaceEditConst.HistoryGivenKeys, operKey)

        if self._editData then
            self._editData:UpdateData(editItems)
        end

        -- 风格脸更新数据
        if operKey == FaceEditConst.HistoryGivenKeys.FaceStyle then
            self:UpdateFaceStyleInfo(editItems)
        end

        self:UpdateUIDataNodeByEditData(editItems)

        local mainType = operKey == FaceEditConst.HistoryGivenKeys.FaceStyle and FaceEditConst.MainType.StyleFace
        Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems %s, %s", notGivenOper and operKey, mainType)
        EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems, notGivenOper and operKey, mainType)

        -- applyData需过滤
        if notGivenOper then
            local mainItem = editItems and editItems[1]
            if mainItem and mainItem.key then
                local isStyle = FaceEditUtil.GetThirdType(mainItem.key) == FaceEditConst.EditPropType.StyleAndColor
                local applyItems = self:GetApplyData(mainItem.key, isStyle and FaceEditConst.UIPropClass.Style, editItems, isTempMakeup)
                return applyItems
            end
        end
        return editItems
    end
end

function FaceEditProxy:CanUndo()
    if self._curHistoryIndex and self._curHistoryIndex > 0 then
        return true
    end
    return false
end

function FaceEditProxy:RedoData(isTempMakeup)
    if self._curHistoryIndex and self._curHistoryIndex < #self._historyList then
        local operKey, editItems = self:GetHistoryData(true)
        self._curHistoryIndex = self._curHistoryIndex + 1
        if table.isnilorempty(editItems) then
            return
        end
        local notGivenOper = not table.keyof(FaceEditConst.HistoryGivenKeys, operKey)

        if self._editData then
            self._editData:UpdateData(editItems)
        end
        -- 风格脸更新数据
        if operKey == FaceEditConst.HistoryGivenKeys.FaceStyle then
            self:UpdateFaceStyleInfo(editItems)
        end

        self:UpdateUIDataNodeByEditData(editItems)

        local mainType = operKey == FaceEditConst.HistoryGivenKeys.FaceStyle and FaceEditConst.MainType.StyleFace
        Debug.LogFormatWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems %s, %s", notGivenOper and operKey, mainType)
        EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems, notGivenOper and operKey, mainType)

        -- applyData需过滤
        if notGivenOper then
            local mainItem = editItems and editItems[1]
            if mainItem and mainItem.key then
                local isStyle = FaceEditUtil.GetThirdType(mainItem.key) == FaceEditConst.EditPropType.StyleAndColor
                local applyItems = self:GetApplyData(mainItem.key, isStyle and FaceEditConst.UIPropClass.Style, editItems, isTempMakeup)
                return applyItems
            end
        end
        return editItems
    end
end

function FaceEditProxy:CanRedo()
    if self._curHistoryIndex and self._curHistoryIndex < #self._historyList then
        return true
    end
    return false
end

--重置Detail：回到风格脸数据
function FaceEditProxy:ResetData1()
    -- 判断当前已重置
    local operData = self._historyList and self._curHistoryIndex and self._historyList[self._curHistoryIndex]
    if operData and operData.key == FaceEditConst.HistoryGivenKeys.Reset then
        return
    end

    local keys = self._editData:GetKeys()
    self._editData:ClearData()
    self:ClearLockedInfo()

    local editItems = self:LoadStyleFaceInfo(true)
    return editItems, keys
end

--重置Detail：回到风格脸数据，记录到历史栈
function FaceEditProxy:ResetData2(keys)
    local editItems = table.clone(self._editData:GetListData())

    -- 加上删除的部分 用配置默认值
    local delKeys = {}
    local newKeys = self._editData:GetKeys()
    if keys then
        for _, key in ipairs(keys) do
            if not table.indexof(newKeys, key) then
                table.insert(delKeys, key)
            end
        end
    end

    for _, key in ipairs(delKeys) do
        local item = FaceEditData.EditItem.new(key, self:GetDefaultCfgValue(key), true)
        table.insert(editItems, item)
    end

    self:AddToHistory(FaceEditConst.HistoryGivenKeys.Reset, 1, editItems)

    self:UpdateUIDataNodeByEditData(editItems)

    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems")
    EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems)

    return editItems
end

--重置Detail：回到风格脸数据，不记录到历史栈
function FaceEditProxy:ResetData3(keys)
    local editItems = table.clone(self._editData:GetListData())

    -- 加上删除的部分 用配置默认值
    local delKeys = {}
    local newKeys = self._editData:GetKeys()
    if keys then
        for _, key in ipairs(keys) do
            if not table.indexof(newKeys, key) then
                table.insert(delKeys, key)
            end
        end
    end

    for _, key in ipairs(delKeys) do
        local item = FaceEditData.EditItem.new(key, self:GetDefaultCfgValue(key), true)
        table.insert(editItems, item)
    end

    --self:AddToHistory(FaceEditConst.HistoryGivenKeys.Reset, 1, editItems)

    self:UpdateUIDataNodeByEditData(editItems)

    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems")
    EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems)

    return editItems
end

---重置捏声音数据，记录到历史栈中
function FaceEditProxy:ResetVoiceData()
    local keys = self._editData:GetKeys()
    local editItems = {}
    for _, v in pairs(keys) do
        local mainType = FaceEditUtil.GetMainTypeByKey(v)
        if mainType == FaceEditConst.MainType.Voice then
            local item = FaceEditData.EditItem.new(v, self:GetDefaultCfgValue(v), true)
            table.insert(editItems, item)
        end
    end
    if not table.isnilorempty(editItems) then
        self:AddToHistory(FaceEditConst.HistoryGivenKeys.Reset, 0, editItems)
        self._editData:UpdateData(editItems)
        self:UpdateUIDataNodeByEditData(editItems)
        Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems")
        EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems, editItems[1].key)
    end
    return editItems
end

---重置捏声音数据，不记录到历史栈中
function FaceEditProxy:ResetVoiceData2()
    local keys = self._editData:GetKeys()
    local editItems = {}
    for _, v in pairs(keys) do
        local mainType = FaceEditUtil.GetMainTypeByKey(v)
        if mainType == FaceEditConst.MainType.Voice then
            local item = FaceEditData.EditItem.new(v, self:GetDefaultCfgValue(v), true)
            table.insert(editItems, item)
        end
    end
    if not table.isnilorempty(editItems) then
        self._editData:UpdateData(editItems)
        self:UpdateUIDataNodeByEditData(editItems)
        Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems")
        EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems, editItems[1].key)
    end
    return editItems
end

---重置FaceStyle：回到圆盘中间初始脸
function FaceEditProxy:ResetDataBase()
    -- 判断当前已重置
    local polarPos = self:GetFaceStylePolarPos()
    if Vector2.Magnitude(polarPos) < 0.0001 then
        return
    end
    --local operData = self._historyList and self._curHistoryIndex and self._historyList[self._curHistoryIndex]
    --if operData and operData.key == FaceEditConst.HistoryGivenKeys.FaceStyle and operData.value == 0 then
    --    return
    --end

    self._editData:ClearData()
    self:ClearLockedInfo()
    self:InitFaceStyleInfo()

    local editItems = self:LoadStyleFaceInfo(true)

    self:AddToHistory(FaceEditConst.HistoryGivenKeys.FaceStyle, 0, editItems)

    self:UpdateUIDataNodeByEditData(editItems)

    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems")
    EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems)

    return editItems
end

---重置妆发：回到风格脸对应的妆容和头发
function FaceEditProxy:ResetDataMakeup()
    -- 判断当前已重置
    local operData = self._historyList and self._curHistoryIndex and self._historyList[self._curHistoryIndex]
    if operData and operData.key == FaceEditConst.HistoryGivenKeys.Reset then
        return
    end

    local keys = self._editData:GetKeys()

    self._editData:ClearMakeupAndHair()
    self:ClearLockedInfo()

    local editItems = self:UpdateFaceStyleMakeup(true, true)

    -- 加上删除的部分 用配置默认值
    local delKeys = {}
    local newKeys = self._editData:GetKeys()
    for _, key in ipairs(keys) do
        if not table.indexof(newKeys, key) then
            table.insert(delKeys, key)
        end
    end

    for _, key in ipairs(delKeys) do
        local item = FaceEditData.EditItem.new(key, self:GetDefaultCfgValue(key), true)
        table.insert(editItems, item)
    end

    self:AddToHistory(FaceEditConst.HistoryGivenKeys.Reset, 2, editItems)

    self:UpdateUIDataNodeByEditData(editItems)

    Debug.LogWithTag(GameConst.LogTag.FaceEdit, "抛事件_RefreshEditItems")
    EventMgr.Dispatch(FaceEditConst.Event.RefreshEditItems)

    return editItems
end

---是否有操作数据
function FaceEditProxy:HasFaceEditHistory()
    if table.nums(self._historyList) == 0 then
        return false
    else
        return true
    end
end

---获取当前历史步骤
function FaceEditProxy:GetCurrHistoryIndex()
    if self._curHistoryIndex and self._curHistoryIndex > 0 then
        return self._curHistoryIndex
    end
    return 0
end

--endregion

--region uiData 界面展示数据

--- 某个样式节点是否未获得
local _CheckNodeIsLocked = function(cfg)
    if cfg.ItemCondition ~= 0 then
        local itemAmount = BllMgr.GetItemBLL():GetItemNum(cfg.ItemCondition)
        return itemAmount == 0
    end
    return false
end

---样式选择节点，是否被选中
local _CheckNodeIsSelected = function(mainType, subType, nodeType, styleID, cfgID, isColorNode)
    local isHairOrMakeupStyle = mainType == FaceEditConst.MainType.Makeup or mainType == FaceEditConst.MainType.Hair
    if isHairOrMakeupStyle and not isColorNode then
        local key = FaceEditUtil.GetKey(mainType, subType, nodeType)
        local selectedCfgId = SelfProxyFactory.GetFaceEditProxy():GetValueForEdit(key)
        local tableName = FaceEditConst.TypeToCfgDic[mainType]
        if subType ~= nil then
            tableName = tableName[subType]
        end
        local selectCfg = LuaCfgMgr.GetDataByCondition(tableName, { ID = selectedCfgId })
        if selectCfg then
            local selectedStyleID = selectCfg.StyleID
            if not selectedStyleID then
                selectedStyleID = selectedCfgId
            end
            return selectedStyleID == styleID
        end

        Debug.LogErrorFormatWithTag(GameConst.LogTag.FaceEdit, "Invalid SelectId : %d", selectedCfgId)
        return false
    else
        local key = FaceEditUtil.GetKey(mainType, subType, nodeType)
        local selectedCfgId = SelfProxyFactory.GetFaceEditProxy():GetValueForEdit(key)
        return selectedCfgId == cfgID
    end
end

local _SortLeafNodeBySort = function(a, b)
    if a.sort and b.sort then
        return a.sort < b.sort
    elseif a.cfgId and b.cfgId then
        return a.cfgId < b.cfgId
    else
        return false
    end
end

local _SortLeafHairNode = function(a, b)
    local weightA = a.isLocked and 1 or 0
    local weightB = b.isLocked and 1 or 0
    if weightA ~= weightB then
        return weightA < weightB
    end
    weightA = a.sort
    weightB = b.sort
    return weightA < weightB
end

local _SortTabNodeBySort = function(a, b)
    return a.sort < b.sort
end

---将 uiNode 插入字典中
local _InsertUINodeToDict = function(uiNode, dict)
    local editKey = FaceEditUtil.GetKey(uiNode.mainType, uiNode.subType, uiNode.nodeType)
    local key = string.concat(editKey, "_", uiNode.cfgId)
    dict[key] = uiNode
end

local _TryGenCommonNode = function(mainType, rootNode, uiDataNodeDict)
    if rootNode and rootNode:GetChildrenNum() == 0 then
        local cfgName = FaceEditUtil.GetCfgName(mainType)
        local cfgList = LuaCfgMgr.GetAll(cfgName)
        local level1Item = FaceEditData.UINode.new(mainType, "")
        local level2Item = FaceEditData.UINode.new(mainType, "")
        for i = 1, #cfgList do
            local nodeInfo = cfgList[i]
            local node = FaceEditData.UIImageNode.new(mainType, nodeInfo.Des, {
                cfgId = nodeInfo.ID,
                image = nodeInfo.Icon,
                sort = nodeInfo.Sort,
                isSelect = _CheckNodeIsSelected(mainType, nil, FaceEditConst.EditPropType.StyleAndColor, nil, nodeInfo.ID),
                nodeType = FaceEditConst.EditPropType.StyleAndColor
            })
            level2Item:AddChild(node)
            _InsertUINodeToDict(node, uiDataNodeDict)
        end
        level2Item:SortChildren(_SortLeafNodeBySort) -- 对叶子节点根据 Sort 字段排序
        level1Item:AddChild(level2Item)
        rootNode:AddChild(level1Item)
    end
end

local _TryGenBoneNode = function(mainType, L1Type, L2Type, rootNode)
    -- 生成一级页签
    if rootNode:GetChildrenNum() == 0 then
        for i = 1, table.nums(FaceEditConst.BoneType) do
            local cfg = LuaCfgMgr.GetListByCondition("FaceBone", { ClassID = i })
            local boneNodeL1 = FaceEditData.UIIconNode.new(mainType, cfg[1].Class, cfg[1].SubClassIconUnSelect)
            boneNodeL1.cfgId = cfg[1].ID
            boneNodeL1.sort = cfg[1].ClassSort
            rootNode:AddChild(boneNodeL1)
        end
        rootNode:SortChildren(_SortTabNodeBySort)
    end

    -- 生成二级页签
    local boneNodeL1 = rootNode:GetChild(L1Type)
    local cfgList = LuaCfgMgr.GetListByCondition("FaceBone", { ClassID = L1Type })
    if boneNodeL1:GetChildrenNum() == 0 then
        for i = 1, #cfgList do
            local boneNodeL2 = FaceEditData.UIIconNode.new(mainType, cfgList[i].SubClass, cfgList[i].SubClassIconUnSelect)
            boneNodeL2.cfgId = cfgList[i].ID
            boneNodeL2.sort = cfgList[i].Sort
            boneNodeL1:AddChild(boneNodeL2)
        end
        boneNodeL1:SortChildren(_SortTabNodeBySort)
    end

    -- 生成属性节点
    local boneNodeL2 = boneNodeL1:GetChild(L2Type)
    local cfgDetailList = LuaCfgMgr.GetListByCondition("FaceBoneDetail", { BoneID = boneNodeL2.cfgId })
    if boneNodeL2:GetChildrenNum() == 0 then
        for j = 1, #cfgDetailList do
            local boneNodeL3 = FaceEditData.UISliderNode.new(mainType, cfgDetailList[j].Name, {
                limitMax = cfgDetailList[j].LimitMax,
                limitMin = cfgDetailList[j].LimitMin,
                cfgId = cfgDetailList[j].ID,
                sort = cfgDetailList[j].Sort,
            })
            boneNodeL2:AddChild(boneNodeL3)
        end
        boneNodeL2:SortChildren(_SortLeafNodeBySort)
    end
end

local _TryGenMakeupNode = function(mainType, L1Type, rootNode, uiDataNodeDict)
    -- 生成一级页签与二级页签
    if rootNode:GetChildrenNum() == 0 then
        local icon = ""
        local sort = 0
        -- 眉妆
        icon = LuaCfgMgr.Get("FaceDetailType", 2).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 2).Sort
        local makeupNode1 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[1].tabName, icon, sort)
        local makeupNode1_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel")
        makeupNode1:AddChild(makeupNode1_1)
        local makeupNode1_2 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7961, "recColor", "OCX_HairMakeupColorPanel01")
        makeupNode1:AddChild(makeupNode1_2)
        rootNode:AddChild(makeupNode1)

        -- 唇妆
        icon = LuaCfgMgr.Get("FaceDetailType", 8).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 8).Sort
        local makeupNode2 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[2].tabName, icon, sort)
        local makeupNode2_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel")
        makeupNode2:AddChild(makeupNode2_1)
        local makeupNode2_2 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7961, "recColor", "OCX_HairMakeupColorPanel01")
        makeupNode2:AddChild(makeupNode2_2)
        local makeupNode2_3 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7962, "custom", "OCX_HairMakeupSelectPanel")
        makeupNode2:AddChild(makeupNode2_3)
        rootNode:AddChild(makeupNode2)

        -- 美瞳
        icon = LuaCfgMgr.Get("FaceDetailType", 9).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 9).Sort
        local makeupNode3 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[3].tabName, icon, sort)
        local makeupNode3_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_PupilStylePanel")
        makeupNode3:AddChild(makeupNode3_1)
        rootNode:AddChild(makeupNode3)

        -- 眼影
        icon = LuaCfgMgr.Get("FaceDetailType", 6).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 6).Sort
        local makeupNode4 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[4].tabName, icon, sort)
        local makeupNode4_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel")
        makeupNode4:AddChild(makeupNode4_1)
        local makeupNode4_2 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7961, "recColor", "OCX_HairMakeupColorPanel01")
        makeupNode4:AddChild(makeupNode4_2)
        rootNode:AddChild(makeupNode4)

        -- 眼皮
        icon = LuaCfgMgr.Get("FaceDetailType", 4).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 4).Sort
        local makeupNode5 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[5].tabName, icon, sort)
        local makeupNode5_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel03")
        makeupNode5:AddChild(makeupNode5_1)
        rootNode:AddChild(makeupNode5)

        -- 眼线
        icon = LuaCfgMgr.Get("FaceDetailType", 5).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 5).Sort
        local makeupNode6 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[6].tabName, icon, sort)
        local makeupNode6_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel")
        makeupNode6:AddChild(makeupNode6_1)
        local makeupNode6_2 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7961, "recColor", "OCX_HairMakeupColorPanel01")
        makeupNode6:AddChild(makeupNode6_2)
        rootNode:AddChild(makeupNode6)

        -- 睫毛
        icon = LuaCfgMgr.Get("FaceDetailType", 3).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 3).Sort
        local makeupNode7 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[7].tabName, icon, sort)
        local makeupNode7_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel")
        makeupNode7:AddChild(makeupNode7_1)
        local makeupNode7_2 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7961, "recColor", "OCX_HairMakeupColorPanel")
        makeupNode7:AddChild(makeupNode7_2)
        rootNode:AddChild(makeupNode7)

        --腮红
        icon = LuaCfgMgr.Get("FaceDetailType", 1).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 1).Sort
        local makeupNode8 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[8].tabName, icon, sort)
        local makeupNode8_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel01")
        makeupNode8:AddChild(makeupNode8_1)
        local makeupNode8_2 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7961, "recColor", "OCX_HairMakeupColorPanel01")
        makeupNode8:AddChild(makeupNode8_2)
        rootNode:AddChild(makeupNode8)

        -- 脸饰
        icon = LuaCfgMgr.Get("FaceDetailType", 7).TypeIcon
        sort = LuaCfgMgr.Get("FaceDetailType", 7).Sort
        local makeupNode9 = FaceEditData.UIIconNode.new(mainType, FaceEditConst.MakeupL1TabName[9].tabName, icon, sort)
        local makeupNode9_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7960, "hairStyle", "OCX_HairMakeupStylePanel02")
        makeupNode9:AddChild(makeupNode9_1)
        rootNode:AddChild(makeupNode9)
    end

    rootNode:SortChildren(_SortTabNodeBySort)

    -- 生成样式节点
    local makeupNodeL2Style = rootNode:GetChild(L1Type):GetChild(1) -- 样式节点
    if makeupNodeL2Style:GetChildrenNum() == 0 then
        local cfgList = LuaCfgMgr.GetAll(FaceEditConst.MakeupL1TabName[L1Type].tableName)
        for k, v in pairs(cfgList) do
            if v.ShowType == 0 or (BllMgr.GetFaceEditBLL():GetMode() ~=FaceEditConst.Mode.First) then
                if L1Type ~= 3 and v.StyleID then
                    local styleNode = makeupNodeL2Style:GetChild(v.StyleID)
                    if not styleNode then
                        styleNode = FaceEditData.UIImageNode.new(mainType, v.Des1, {
                            image = v.StyleIcon,
                            cfgId = v.ID,
                            isSelect = _CheckNodeIsSelected(mainType, FaceEditConst.MakeupL1TabName[L1Type].MakeupSubType, FaceEditConst.EditPropType.StyleAndColor, v.StyleID),
                            styleID = v.StyleID,
                            sort = v.StyleID,
                            subType = FaceEditConst.MakeupL1TabName[L1Type].MakeupSubType,
                            nodeType = FaceEditConst.EditPropType.StyleAndColor,
                        })
                        makeupNodeL2Style:InsertNode(v.StyleID, styleNode)
                    end
                    -- 推荐色节点
                    if styleNode and v.StyleID == styleNode.styleID then
                        local colorNode = FaceEditData.UIImageNode.new(mainType, "", {
                            image = v.ColorIcon,
                            cfgId = v.ID,
                            subType = FaceEditConst.MakeupL1TabName[L1Type].MakeupSubType,
                            styleID = v.StyleID,
                            isSelect = _CheckNodeIsSelected(mainType, FaceEditConst.MakeupL1TabName[L1Type].MakeupSubType, FaceEditConst.EditPropType.StyleAndColor, v.StyleID, v.ID, true),
                            isSpecial = v.IsSpecial == 1,
                            isLocked = _CheckNodeIsLocked(v),
                            itemCondition = v.ItemCondition,
                            sort = v.Sort,
                            isColorNode = true,
                            nodeType = FaceEditConst.EditPropType.StyleAndColor,
                        })
                        if v.IsDefaultColor and v.IsDefaultColor == 1 then
                            styleNode.cfgId = v.ID
                            styleNode.isSpecial = v.IsSpecial == 1
                            styleNode.isLocked = _CheckNodeIsLocked(v)
                            styleNode.itemCondition = v.ItemCondition
                            styleNode.itemId = v.ItemCondition
                        end
                        _InsertUINodeToDict(colorNode, uiDataNodeDict)
                        styleNode:AddChild(colorNode)
                        styleNode:SortChildren(_SortLeafNodeBySort)
                    end
                else
                    -- 美瞳节点和脸装节点，没有推荐色
                    local styleNode = makeupNodeL2Style:GetChild(k)
                    if not styleNode then
                        styleNode = FaceEditData.UIImageNode.new(mainType, v.Des, {
                            image = v.StyleIcon,
                            cfgId = v.ID,
                            styleID = k,
                            sort = v.Sort,
                            isSelect = _CheckNodeIsSelected(mainType, FaceEditConst.MakeupL1TabName[L1Type].MakeupSubType, FaceEditConst.EditPropType.StyleAndColor, k, v.ID),
                            subType = FaceEditConst.MakeupL1TabName[L1Type].MakeupSubType,
                            nodeType = FaceEditConst.EditPropType.StyleAndColor,
                        })
                        -- 为其添加一个空的 colorNode，用以保证结构统一
                        local colorNode = FaceEditData.UIImageNode.new(mainType, "", {
                            image = "",
                            cfgId = v.ID,
                            subType = FaceEditConst.MakeupL1TabName[L1Type].MakeupSubType,
                            styleID = k,
                            isSelect = false,
                            isSpecial = false,
                            isLocked = false,
                            sort = 1,
                            isColorNode = true,
                            nodeType = FaceEditConst.EditPropType.StyleAndColor,
                        })
                        colorNode.parent = styleNode
                        _InsertUINodeToDict(colorNode, uiDataNodeDict)
                        makeupNodeL2Style:InsertNode(k, styleNode)
                    end
                end
            end
        end
        makeupNodeL2Style:ChildrenDicToArrary()
        makeupNodeL2Style:SortChildren(_SortLeafNodeBySort)
    end
end

local _TryGenHairNode = function(mainType, rootNode, uiDataNodeDict)
    -- 生成一级页签与二级页签
    if rootNode:GetChildrenNum() == 0 then
        local hairNode1 = FaceEditData.UINode.new(mainType, "")
        -- 发型
        local hairNode1_1 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7932, "hairStyle", "OCX_HairMakeupStylePanel01")
        hairNode1:AddChild(hairNode1_1)
        -- 颜色
        local hairNode1_2 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7941, "recColor", "OCX_HairMakeupColorPanel")
        hairNode1:AddChild(hairNode1_2)
        -- 颜色高级
        local hairNode1_3 = FaceEditData.UIHairMakeupTabNode.new(mainType, UITextConst.UI_TEXT_7962, "custom", "OCX_HairMakeupColorAdvancePanel")
        hairNode1:AddChild(hairNode1_3)
        rootNode:AddChild(hairNode1)
    end

    -- 生成样式节点
    local hairNodeL2Style = rootNode:GetChild(1):GetChild(1) -- 样式节点
    if hairNodeL2Style:GetChildrenNum() == 0 then
        local cfgList = LuaCfgMgr.GetAll("FaceHair")
        for _, v in pairs(cfgList) do
            local styleNode = hairNodeL2Style:GetChild(v.StyleID)
            if not styleNode and v.StyleID ~= nil then
                styleNode = FaceEditData.UIImageNode.new(mainType, v.Des1, {
                    image = v.StyleIcon,
                    cfgId = v.ID,
                    isSelect = _CheckNodeIsSelected(mainType, nil, FaceEditConst.EditPropType.StyleAndColor, v.StyleID),
                    styleID = v.StyleID,
                    isDefault = v.IsDefault,
                    sort = v.StyleID,
                    nodeType = FaceEditConst.EditPropType.StyleAndColor,
                })
                hairNodeL2Style:InsertNode(v.StyleID, styleNode)
            end

            -- 推荐色节点
            if v.StyleID == styleNode.styleID then
                local colorNode = FaceEditData.UIImageNode.new(mainType, "", {
                    image = v.ColorIcon,
                    cfgId = v.ID,
                    styleID = v.StyleID,
                    isSelect = _CheckNodeIsSelected(mainType, nil, FaceEditConst.EditPropType.StyleAndColor, v.StyleID, v.ID, true),
                    isSpecial = v.IsSpecial == 1,
                    isLocked = _CheckNodeIsLocked(v),
                    itemCondition = v.ItemCondition,
                    sort = v.Sort,
                    isColorNode = true,
                    nodeType = FaceEditConst.EditPropType.StyleAndColor,
                })
                if v.IsDefaultColor and v.IsDefaultColor == 1 then
                    styleNode.cfgId = v.ID
                    styleNode.isSpecial = v.IsSpecial == 1
                    styleNode.isLocked = _CheckNodeIsLocked(v)
                    styleNode.itemCondition = v.ItemCondition
                    styleNode.itemId = v.ItemCondition
                    styleNode.isDefault = v.IsDefault
                end
                _InsertUINodeToDict(colorNode, uiDataNodeDict)
                styleNode:AddChild(colorNode)
                styleNode:SortChildren(_SortLeafNodeBySort)
            end
        end
        hairNodeL2Style:ChildrenDicToArrary()
        hairNodeL2Style:SortChildren(_SortLeafHairNode)
    end
end

local _TryGenVoiceNode = function(mainType, rootNode)
    if rootNode:GetChildrenNum() == 0 then
        local level1Item = FaceEditData.UINode.new(mainType, "")
        local level2Item = FaceEditData.UINode.new(mainType, "")
        local node = FaceEditData.UISliderNode.new(mainType, "", {
            LimitMax = 1,
            LimitMin = -1,
            cfgId = -1
        })
        level2Item:AddChild(node)
        level1Item:AddChild(level2Item)
        rootNode:AddChild(level1Item)
    end
end

function FaceEditProxy:InitUIData()
    self.uiData = FaceEditData.UIData.new()
    self.uiDataNodeDict = {}
end

---根据页签类型获取所需 UI 数据，具体页签内的 UIData 数据懒加载，需要时才读表生成
function FaceEditProxy:GetOrGenUIDataByType(mainType, L1Type, L2Type)
    local tabNode = self.uiData:GetChild(mainType)
    if mainType == FaceEditConst.MainType.Bone then
        if L1Type <= 0 or L2Type <= 0 then
            Debug.LogError("SubType is invalid")
            return nil
        end
        _TryGenBoneNode(mainType, L1Type, L2Type, tabNode)
    elseif mainType == FaceEditConst.MainType.Makeup then
        if L1Type <= 0 or L2Type <= 0 then
            Debug.LogError("SubType is invalid")
            return nil
        end
        _TryGenMakeupNode(mainType, L1Type, tabNode, self.uiDataNodeDict)
    elseif mainType == FaceEditConst.MainType.Hair then
        if L1Type <= 0 or L2Type <= 0 then
            Debug.LogError("SubType is invalid")
            return nil
        end
        _TryGenHairNode(mainType, tabNode, self.uiDataNodeDict)
    elseif mainType == FaceEditConst.MainType.Voice then
        _TryGenVoiceNode(mainType, tabNode)
    else
        -- StyleFace && Skin
        _TryGenCommonNode(mainType, tabNode, self.uiDataNodeDict)
    end
    return tabNode
end

function FaceEditProxy:GetStyleFaceUIData()
    local data = self:GetOrGenUIDataByType(FaceEditConst.MainType.StyleFace)
    return data:GetChild(1):GetChild(1)
end

function FaceEditProxy:GetUIData()
    return self.uiData
end

function FaceEditProxy:GetL1MenuUIData(mainTypes)
    if mainTypes == nil or table.nums(mainTypes) == 0 then
        return self.uiData.children
    end
    local result = {}
    for _, v in ipairs(mainTypes) do
        if self.uiData:GetChild(v) then
            table.insert(result, self.uiData:GetChild(v))
        end
    end
    return result
end

---获取骨骼数据
function FaceEditProxy:GetFaceBoneValue(uiSliderNode)
    local key = FaceEditUtil.GetKey(uiSliderNode.mainType, nil, uiSliderNode.cfgId)
    local value = self:GetValueForEdit(key, true)
    return value
end

---通过 EditData，获取某个样式节点
function FaceEditProxy:GetUIDataNodeByEditData(editKey, editValue)
    if type(editValue) == "number" then
        local key = string.concat(editKey, "_", math.floor(editValue))
        return self.uiDataNodeDict[key]
    end
    return nil
end

function FaceEditProxy:HasCustomHairColor()
    for _, prop in ipairs(FaceEditConst.HairCustomPropTypes) do
        local _key = FaceEditUtil.GetKey(FaceEditConst.MainType.Hair, nil, prop)
        if self._editData:ContainsKey(_key) then
            return true
        end
    end
    return false
end

function FaceEditProxy:_IsCustomHairColorProp(propType)
    for _, prop in ipairs(FaceEditConst.HairCustomPropTypes) do
        if prop == propType then
            return true
        end
    end
    return false
end

---通过 EditData，更新 UIData
function FaceEditProxy:UpdateUIDataNodeByEditData(editItems)
    for _, v in pairs(editItems) do
        local editKey = v.key
        local editValue = v.value
        local uiNode = self:GetUIDataNodeByEditData(editKey, editValue)
        if uiNode then
            local isHairOrMakeup = uiNode.mainType == FaceEditConst.MainType.Makeup or uiNode.mainType == FaceEditConst.MainType.Hair
            if isHairOrMakeup then
                local styleNodes = uiNode.parent.parent.children
                for _, styleNode in pairs(styleNodes) do
                    if styleNode.isSelect then
                        for _, colorNode in pairs(styleNode.children) do
                            colorNode.isSelect = false
                        end
                        styleNode.isSelect = false
                    end
                end
                uiNode.isSelect = true

                uiNode.parent.isSelect = true
            else
                local parent = uiNode.parent
                for _, node in pairs(parent.children) do
                    node.isSelect = false
                end
                uiNode.isSelect = true
            end
        end
        --- 如果是自定义高级颜色属性，记录当前的自定义发色
        local mainType, subType, propType = FaceEditUtil.GetTypes(editKey)
        if mainType == FaceEditConst.MainType.Hair then -- and table.containsvalue(FaceEditConst.HairCustomPropTypes, propType) then
            local key = nil
            if table.containsvalue(FaceEditConst.SubPropTypes, propType) then
                key = editKey
                self._hairAdvancedColorDict[key] = editValue
            elseif table.containskey(FaceEditConst.SubPropTypes, propType) then
                key = FaceEditUtil.GetKey(FaceEditConst.MainType.Hair, subType, FaceEditConst.SubPropTypes[propType])
                self._hairAdvancedColorDict[key] = editValue
            end
        end
    end
end

function FaceEditProxy:GetHairAdvancedColor(key)
    if self._hairAdvancedColorDict and self._hairAdvancedColorDict[key] then
        return self._hairAdvancedColorDict[key]
    end
end

--endregion

return FaceEditProxy