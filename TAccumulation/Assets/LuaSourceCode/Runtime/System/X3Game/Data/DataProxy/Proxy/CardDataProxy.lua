---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dengzi.
--- DateTime: 2023/5/26 15:01
---@class CardDataProxy : BaseProxy 羁绊卡数据
local CardDataProxy = class("CardDataProxy", BaseProxy)

---@class CardDataProvider
---@field CardServerData X3Data.CardData
---@field CardCfgData cfg.CardBaseInfo

local function InitConfigData()
    local allCnt = 0
    local allCardCfgList = table.dictoarray(LuaCfgMgr.GetAll("CardBaseInfo"))
    table.sort(allCardCfgList, function(a, b)
        return a.Rank < b.Rank
    end)
    for _, v in pairs(allCardCfgList) do
        if v.Visible == 1 then
            allCnt = allCnt + 1
            if v.SuitID > 0 then
                local suitData = X3DataMgr.Get(X3DataConst.X3Data.CardSuitConfigData, v.SuitID)
                if not suitData then
                    suitData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardSuitConfigData, nil, v.SuitID)
                end
                local suitQuality = suitData:GetSuitQuality() and math.max(suitData:GetSuitQuality(), v.Quality) or v.Quality
                suitData:SetSuitQuality(suitQuality)
                suitData:AddCardListValue(v.ID)
            end
            if v.ManType > 0 then
                local manTypeData = X3DataMgr.Get(X3DataConst.X3Data.CardManTypeDataList, v.ManType)
                if not manTypeData then
                    manTypeData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardManTypeDataList, nil, v.ManType)
                end
                manTypeData:AddCfgCardListValue(v.ID)
            end
            if v.PosType > 0 then
                local posTypeData = X3DataMgr.Get(X3DataConst.X3Data.CardPosDataList, v.PosType)
                if not posTypeData then
                    posTypeData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardPosDataList, nil, v.PosType)
                end
                posTypeData:AddCfgCardListValue(v.ID)
            end
        end
    end
    local cardManagedData = X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1)
    cardManagedData:SetAllCardNum(allCnt)
end

---最大突破等级
---@param cardId int
---@return int
local function GetCardStarMaxNum(cardId)
    local maxRetNum = 0
    local cardBaseCfg = LuaCfgMgr.Get("CardBaseInfo", cardId)
    if cardBaseCfg ~= nil then
        local cardRareCfg = LuaCfgMgr.Get("CardRare", cardBaseCfg.Quality)
        if cardRareCfg ~= nil then
            maxRetNum = cardRareCfg.MaxStarNum
        end
    end
    return maxRetNum
end

---最大进阶等级
---@return int
local function GetCardMaxPhaseLv()
    local retNum = 0
    local cardMaxPhase = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.CARDMAXPHASE)
    if cardMaxPhase ~= nil then
        retNum = cardMaxPhase
    end
    return retNum
end

---卡最大等级
---@return int
local function GetCardMaxLevel(cardId, starLevel)
    ---@type cfg.CardBaseInfo
    local cardCfg = LuaCfgMgr.Get("CardBaseInfo", cardId)
    ---@type cfg.CardStar
    local cardStarCfg = LuaCfgMgr.Get("CardStar", cardCfg.StarID, starLevel)
    if cardStarCfg then
        return cardStarCfg.LevelLimit
    end
end

---@param cardId int  羁绊卡id
---@param cardLevel int  羁绊卡等级
---@return boolean
local function CardLevelIsMax(cardId, cardLevel)
    local cardMaxLevel = GetCardMaxLevel(cardId, GetCardStarMaxNum(cardId))
    return cardLevel >= cardMaxLevel
end

---@param phaseLevel int 品阶等级
---@return boolean
local function CardPhaseLevelIsMax(phaseLevel)
    return phaseLevel >= GetCardMaxPhaseLv()
end

---@param cardId int  羁绊卡id
---@param starLevel int  羁绊卡星级
---@return boolean
local function CardStarLevelIsMax(cardId, starLevel)
    return starLevel >= GetCardStarMaxNum(cardId, starLevel)
end

---@param awakenStatus X3DataConst.AwakenStatus   羁绊卡觉醒状态
---@return boolean
local function CardAwakenLevelIsMax(awakenStatus)
    return awakenStatus == X3DataConst.AwakenStatus.Awaken
end

---@param cardData X3Data.CardData
---@return X3Data.GemCore[]
local function GetEquippedGemCores(cardData)
    if not cardData or not cardData:GetGemCores() then
        return nil
    end
    local result = {}
    for _, gemCoreId in pairs(cardData:GetGemCores()) do
        local gemCoreData = SelfProxyFactory.GetGemCoreProxy():GetGemCoreDataByGemCoreId(gemCoreId, cardData:GetUId())
        if gemCoreData then
            table.insert(result, gemCoreData)
        end
    end
    return result
end

---@param cardData X3Data.CardData
local function GetCardPropertyCache(cardData)
    local uid = cardData:GetUId()
    if not uid or uid == SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        return X3DataMgr.Get(X3DataConst.X3Data.CardAttrData, cardData:GetPrimaryValue())
    else
        local condition = PoolUtil.GetTable()
        condition[X3DataConst.X3DataField.CardAttrData.CardId] = cardData:GetPrimaryValue()
        condition[X3DataConst.X3DataField.CardAttrData.UId] = cardData:GetUId()
        local cardAttrData = X3DataMgr.GetByCondition(X3DataConst.X3Data.CardAttrData, condition)
        PoolUtil.ReleaseTable(condition)
        return cardAttrData
    end
end

---@param cardData X3Data.CardData
---@return X3Data.CardAttrData
local function CreateCardPropertyCache(cardData)
    local uid = cardData:GetUId()
    ---@type X3Data.CardAttrData
    local cardAttrData = nil
    if not uid or uid == SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        cardAttrData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardAttrData, nil, cardData:GetPrimaryValue())
        cardAttrData:SetUId(uid)
    else
        local data = PoolUtil.GetTable()
        data.CardId = cardData:GetPrimaryValue()
        data.UId = cardData:GetUId()
        cardAttrData = X3DataMgr.Add(X3DataConst.X3Data.CardAttrData, data)
        PoolUtil.ReleaseTable(data)
    end
    local finalProperty, baseProperty, gemCoreProperty, talentProperty = DevelopPropertyUtil.GetCardFinalProperty(cardData:GetPrimaryValue(),
            cardData:GetLevel(),
            cardData:GetStarLevel(),
            cardData:GetPhaseLevel(),
            cardData:GetAwaken(),
            GetEquippedGemCores(cardData))
    for k, v in pairs(baseProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateBaseAttrValue(k, v)
    end
    for k, v in pairs(gemCoreProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateGemCoreAttrValue(k, v)
    end
    for k, v in pairs(talentProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateTalentAttrValue(k, v)
    end
    for k, v in pairs(finalProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateFinalAttrValue(k, v)
    end
    return cardAttrData
end

---@param cardData X3Data.CardData
local function RemoveCardPropertyCache(cardData)
    local uid = cardData:GetUId()
    if not uid or uid == SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        X3DataMgr.Remove(X3DataConst.X3Data.CardAttrData, cardData:GetPrimaryValue())
    else
        local data = PoolUtil.GetTable()
        data.CardId = cardData:GetPrimaryValue()
        data.UId = cardData:GetUId()
        X3DataMgr.RemoveByCondition(X3DataConst.X3Data.CardAttrData, data)
        PoolUtil.ReleaseTable(data)
    end
end

---更新基础属性，等级、星级、品阶、觉醒变化需要调用
local function UpdateCardPropertyCache(cardData)
    local cardAttrData = GetCardPropertyCache(cardData)
    if not cardAttrData then
        --缓存里没有，不需要更新，下次获取属性的时候会重新创建
        return
    end
    local finalProperty, baseProperty, gemCoreProperty, talentProperty = DevelopPropertyUtil.GetCardFinalProperty(cardData:GetPrimaryValue(),
            cardData:GetLevel(),
            cardData:GetStarLevel(),
            cardData:GetPhaseLevel(),
            cardData:GetAwaken(),
            GetEquippedGemCores(cardData))
    cardAttrData:ClearBaseAttrValue()
    for k, v in pairs(baseProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateBaseAttrValue(k, v)
    end
    cardAttrData:ClearGemCoreAttrValue()
    for k, v in pairs(gemCoreProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateGemCoreAttrValue(k, v)
    end
    cardAttrData:ClearTalentAttrValue()
    for k, v in pairs(talentProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateTalentAttrValue(k, v)
    end
    cardAttrData:ClearFinalAttrValue()
    for k, v in pairs(finalProperty:GetPropertyMap()) do
        cardAttrData:AddOrUpdateFinalAttrValue(k, v)
    end
end

---@return X3Data.CardData
local function GetCardDataByUId(cardId, uid)
    if not uid or uid == SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        --自己的卡会通过X3Data系统设置cardId为主键，可以通过Get接口传入主键（cardId）直接获取数据
        return X3DataMgr.Get(X3DataConst.X3Data.CardData, cardId)
    else
        local condition = PoolUtil.GetTable()
        condition[X3DataConst.X3DataField.CardData.Id] = cardId
        condition[X3DataConst.X3DataField.CardData.UId] = uid
        local cardData = X3DataMgr.GetByCondition(X3DataConst.X3Data.CardData, condition)
        PoolUtil.ReleaseTable(condition)
        return cardData
    end
end

---@return boolean
local function RemoveCardDataByUId(cardId, uid)
    if not uid or uid == SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        return X3DataMgr.Remove(X3DataConst.X3Data.CardData, cardId)
    else
        local condition = PoolUtil.GetTable()
        condition[X3DataConst.X3DataField.CardData.Id] = cardId
        condition[X3DataConst.X3DataField.CardData.UId] = uid
        local success = X3DataMgr.RemoveByCondition(X3DataConst.X3Data.CardData, condition)
        PoolUtil.ReleaseTable(condition)
        return success
    end
end

---创建卡片任务数据
local function CreateCardQuestData(cardId)
    local cfg = LuaCfgMgr.Get("CardBaseInfo", cardId)
    if not cfg then
        return nil
    end
    local cardQuestData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardQuestData, nil, cardId)
    local condition = PoolUtil.GetTable()
    --单卡任务
    if cfg.CardRewardGroup and #cfg.CardRewardGroup > 0 then
        for i = 1, #cfg.CardRewardGroup do
            condition.RewardGroup = cfg.CardRewardGroup[i]
            local cfgRewardList = LuaCfgMgr.GetListByCondition("CardReward", condition)
            for _, v in pairs(cfgRewardList) do
                cardQuestData:AddOrUpdateCardQuestsValue(v.CardRewardID, GameConst.CardQuestStatus.UnFinish)
            end
        end
    end
    --套装任务
    if cfg.SuitID > 0 and cfg.SuitRewardGroup and #cfg.SuitRewardGroup > 0 then
        local suitQuestData = X3DataMgr.Get(X3DataConst.X3Data.CardSuitQuestData, cfg.SuitID)
        if not suitQuestData then
            suitQuestData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardSuitQuestData, nil, cfg.SuitID)
            for j = 1, #cfg.SuitRewardGroup do
                condition.RewardGroup = cfg.SuitRewardGroup[j]
                local cfgRewardList = LuaCfgMgr.GetListByCondition("CardReward", condition)
                for _, v in pairs(cfgRewardList) do
                    suitQuestData:AddOrUpdateSuitQuestsValue(v.CardRewardID, GameConst.CardQuestStatus.UnFinish)
                end
            end
        end
    end
    PoolUtil.ReleaseTable(condition)
end

---删除Card相关任务数据
local function RemoveCardQuestData(cardId)
    local cfg = LuaCfgMgr.Get("CardBaseInfo", cardId)
    if not cfg then
        return nil
    end
    X3DataMgr.Remove(X3DataConst.X3Data.CardQuestData, cardId)
end

---获取卡任务数据
local function GetCardQuestData(cardId)
    local cardQuestData = X3DataMgr.Get(X3DataConst.X3Data.CardQuestData, cardId)
    return cardQuestData
end

---@param questData table<int,int>
local function UpdateCardQuestData(cardId, questData)
    if not questData then
        return
    end
    local cardQuestData = GetCardQuestData(cardId)
    if cardQuestData then
        for k, v in pairs(questData) do
            cardQuestData:UpdateCardQuestsValue(k, v)
        end
    end
end

local function GetCardSuitQuestData(suitId)
    local cardSuitQuestData = X3DataMgr.Get(X3DataConst.X3Data.CardSuitQuestData, suitId)
    return cardSuitQuestData
end

---@param questData table<int,int>
local function UpdateCardSuitQuestData(suitId, questData)
    if not questData then
        return
    end
    local cardSuitQuestData = GetCardSuitQuestData(suitId)
    if cardSuitQuestData then
        for k, v in pairs(questData) do
            cardSuitQuestData:UpdateSuitQuestsValue(k, v)
        end
    end
end

---@param serverData pbcmessage.Card
---@return X3Data.CardData
local function CreateOrUpdateCardData(serverData)
    local cardCfgData = LuaCfgMgr.Get("CardBaseInfo", serverData.Id)
    if nil == cardCfgData then
        Debug.LogErrorFormat("服务器下发了客户端不存在的Card：%s", tostring(serverData.Id))
        return nil
    end
    local cardId = serverData.Id
    local curUserId = SelfProxyFactory.GetPlayerInfoProxy():GetUid()
    local card = GetCardDataByUId(cardId, curUserId)
    if not card then
        ---添加卡
        card = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardData, serverData, serverData.Id)
        card:SetUId(curUserId)
        --同时创建并更新任务数据
        CreateCardQuestData(cardId)
        UpdateCardQuestData(cardId, serverData.CardRewards)
        --根据卡的装备位置分类
        local cardPosDataList = X3DataMgr.Get(X3DataConst.X3Data.CardPosDataList, cardCfgData.PosType)
        if not cardPosDataList then
            cardPosDataList = X3DataMgr.Add(X3DataConst.X3Data.CardPosDataList)
            cardPosDataList:SetPrimaryValue(cardCfgData.PosType)
        end
        cardPosDataList:AddCardListValue(cardId)
        --根据卡的所属男主分类
        local cardManTypeDataList = X3DataMgr.Get(X3DataConst.X3Data.CardManTypeDataList, cardCfgData.ManType)
        if not cardManTypeDataList then
            cardManTypeDataList = X3DataMgr.Add(X3DataConst.X3Data.CardManTypeDataList)
            cardManTypeDataList:SetPrimaryValue(cardCfgData.ManType)
        end
        cardManTypeDataList:AddCardListValue(cardId)
        --记录一下是否满级
        local levelIsMax = CardLevelIsMax(cardId, serverData.Level)
        if levelIsMax then
            X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):AddOrUpdateLevelMaxCardMapValue(cardId, true)
        end
        --记录一下是否满品质
        local phaseLevelIsMax = CardPhaseLevelIsMax(serverData.PhaseLevel)
        if phaseLevelIsMax then
            X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):AddOrUpdatePhaseLevelMaxCardMapValue(cardId, true)
        end
        --记录一下是否满星
        local starLevelIsMax = CardStarLevelIsMax(cardId, serverData.StarLevel)
        if starLevelIsMax then
            X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):AddOrUpdateStarLevelMaxCardMapValue(cardId, true)
        end
        --记录一下是否觉醒
        local awakenLevelIsMax = CardAwakenLevelIsMax(serverData.Awaken)
        if awakenLevelIsMax then
            X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):AddOrUpdateAwakeLevelMaxCardMapValue(cardId, true)
        end
    else
        card:DecodeByIncrement(serverData)
        UpdateCardQuestData(cardId, serverData.CardRewards)
    end
    return card
end

---@param cardDataList pbcmessage.Card[]
local function DeleteCardData(cardDataList)
    local curUserId = SelfProxyFactory.GetPlayerInfoProxy():GetUid()
    for i = 1, #cardDataList do
        local cardServerData = cardDataList[i]
        local cardData = GetCardDataByUId(cardServerData.Id, curUserId)
        if cardData then
            RemoveCardPropertyCache(cardData)
            RemoveCardQuestData(cardServerData.Id)
            RemoveCardDataByUId(cardServerData.Id, curUserId)
        end
        X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):RemoveLevelMaxCardMapValue(cardServerData.Id)
        X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):RemoveStarLevelMaxCardMapValue(cardServerData.Id)
        X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):RemovePhaseLevelMaxCardMapValue(cardServerData.Id)
        X3DataMgr.Get(X3DataConst.X3Data.CardManagedData, 1):RemoveAwakeLevelMaxCardMapValue(cardServerData.Id)
        local cardCfgData = LuaCfgMgr.Get("CardBaseInfo", cardServerData.Id)
        if cardCfgData then
            local cardPosDataList = X3DataMgr.Get(X3DataConst.X3Data.CardPosDataList, cardCfgData.PosType)
            if cardPosDataList then
                local cardList = cardPosDataList:GetCardList()
                if cardList then
                    table.removebyvalue(cardList, cardServerData.Id)
                end
            end
            local cardManTypeDataList = X3DataMgr.Get(X3DataConst.X3Data.CardManTypeDataList, cardCfgData.ManType)
            if cardManTypeDataList then
                local cardList = cardManTypeDataList:GetCardList()
                if cardList then
                    table.removebyvalue(cardList, cardServerData.Id)
                end
            end
        end
    end
end

---@param serverData pbcmessage.Card
local function CreateOrUpdateOtherCardData(serverData, uid)
    local cardCfgData = LuaCfgMgr.Get("CardBaseInfo", serverData.Id)
    if nil == cardCfgData then
        Debug.LogErrorFormat("服务器下发了客户端不存在的Card：%s", tostring(serverData.Id))
        return nil
    end
    local curUserId = SelfProxyFactory.GetPlayerInfoProxy():GetUid()
    local otherUserId = uid
    if curUserId == otherUserId then
        Debug.LogError("用户自己的卡不能调用这个接口，请检查！")
        return
    end
    local card = GetCardDataByUId(serverData.Id, otherUserId)
    if not card then
        card = X3DataMgr.Add(X3DataConst.X3Data.CardData, serverData)
        card:SetUId(otherUserId)
    else
        card:DecodeByIncrement(serverData)
    end
end

---初始化
---@param owner ProxyFactory
function CardDataProxy:OnInit(owner)
    self.super.OnInit(self, owner)
    self:Subscribe()
    self.cardManagedData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.CardManagedData, nil, 1)
    InitConfigData()
end

function CardDataProxy:OnClear()
    self:UnSubscribe()
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardAttrData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardInitAttrData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardPosDataList)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardManTypeDataList)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardManagedData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardSuitConfigData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardQuestData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CardSuitQuestData)
    X3DataMgr.RemoveAll(X3DataConst.X3Data.OtherSuitPhaseData)
end

function CardDataProxy:Subscribe()
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardData, self.OnCardExpChanged, self, X3DataConst.X3DataField.CardData.Exp)
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardData, self.OnCardLevelChanged, self, X3DataConst.X3DataField.CardData.Level)
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardData, self.OnCardPhaseChanged, self, X3DataConst.X3DataField.CardData.PhaseLevel)
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardData, self.OnCardStarChanged, self, X3DataConst.X3DataField.CardData.StarLevel)
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardData, self.OnCardAwakenChanged, self, X3DataConst.X3DataField.CardData.Awaken)
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardData, self.OnCardGemCoreChanged, self, X3DataConst.X3DataField.CardData.GemCores)
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardQuestData, self.OnCardQuestDataChanged, self, X3DataConst.X3DataField.CardQuestData.CardQuests)
    X3DataMgr.Subscribe(X3DataConst.X3Data.CardSuitQuestData, self.OnCardSuitQuestDataChanged, self, X3DataConst.X3DataField.CardSuitQuestData.SuitQuests)
    EventMgr.AddListener(GemCoreConst.Event.GEM_CORE_LEVEL_CHANGE, self.OnGemCoreLevelChanged, self)
end

function CardDataProxy:UnSubscribe()
    X3DataMgr.UnsubscribeWithTarget(self)
    EventMgr.RemoveListenerByTarget(self)
end

---Card等级变更
---@param data X3Data.CardData
---@param changeFlag X3DataConst.X3DataChangeFlag
function CardDataProxy:OnCardExpChanged(data, changeFlag)
    if nil == data then
        Debug.LogError("X3Data OnCardLevelChanged Callback Error")
        return
    end
    if data:GetUId() ~= SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        --控制只有自己的卡才会走下面的流程
        return
    end

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardExpChanged, data:GetPrimaryValue())
end

---Card等级变更
---@param data X3Data.CardData
---@param changeFlag X3DataConst.X3DataChangeFlag
function CardDataProxy:OnCardLevelChanged(data, changeFlag)
    if nil == data then
        Debug.LogError("X3Data OnCardLevelChanged Callback Error")
        return
    end
    if data:GetUId() ~= SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        --控制只有自己的卡才会走下面的流程
        return
    end
    local cardId = data:GetPrimaryValue()
    local levelIsMax = self:CardLevelIsMax(cardId, data:GetLevel())
    if levelIsMax then
        self.cardManagedData:AddOrUpdateLevelMaxCardMapValue(cardId, true)
    end
    UpdateCardPropertyCache(data)

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardLevelChanged, cardId)
end

---Card品阶变更
---@param data X3Data.CardData
---@param changeFlag X3DataConst.X3DataChangeFlag
function CardDataProxy:OnCardPhaseChanged(data, changeFlag)
    if nil == data then
        Debug.LogError("X3Data OnCardPhaseChanged Callback Error")
        return
    end
    if data:GetUId() ~= SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        --控制只有自己的卡才会走下面的流程
        return
    end
    local cardId = data:GetPrimaryValue()
    local phaseLevelIsMax = self:CardPhaseLevelIsMax(data:GetPhaseLevel())
    if phaseLevelIsMax then
        self.cardManagedData:AddOrUpdatePhaseLevelMaxCardMapValue(cardId, true)
    end
    UpdateCardPropertyCache(data)

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardPhaseLevelChanged, cardId)
end

---Card星级变更
---@param data X3Data.CardData
---@param changeFlag X3DataConst.X3DataChangeFlag
function CardDataProxy:OnCardStarChanged(data, changeFlag)
    if nil == data then
        Debug.LogError("X3Data OnCardStarChanged Callback Error")
        return
    end
    if data:GetUId() ~= SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        --控制只有自己的卡才会走下面的流程
        return
    end
    local cardId = data:GetPrimaryValue()
    local starLevelIsMax = self:CardStarLevelIsMax(cardId, data:GetStarLevel())
    if starLevelIsMax then
        self.cardManagedData:AddOrUpdateStarLevelMaxCardMapValue(cardId, true)
    end
    UpdateCardPropertyCache(data)

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardStarLevelChanged, cardId)
end

---Card觉醒变更
---@param data X3Data.CardData
---@param changeFlag X3DataConst.X3DataChangeFlag
function CardDataProxy:OnCardAwakenChanged(data, changeFlag)
    if nil == data then
        Debug.LogError("X3Data OnCardAwakenChanged Callback Error")
        return
    end
    if data:GetUId() ~= SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        --控制只有自己的卡才会走下面的流程
        return
    end
    local cardId = data:GetPrimaryValue()
    local awakenLevelIsMax = self:CardAwakenLevelIsMax(data:GetAwaken())
    if awakenLevelIsMax then
        self.cardManagedData:AddOrUpdateAwakeLevelMaxCardMapValue(cardId, true)
    end
    UpdateCardPropertyCache(data)

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardAwakenLevelChanged, cardId)
end

---Card装备的芯核变更
---@param data X3Data.CardData
---@param changeFlag X3DataConst.X3DataChangeFlag
function CardDataProxy:OnCardGemCoreChanged(data, changeFlag)
    if nil == data then
        Debug.LogError("X3Data OnCardGemCoreChanged Callback Error")
        return
    end
    if data:GetUId() ~= SelfProxyFactory.GetPlayerInfoProxy():GetUid() then
        --控制只有自己的卡才会走下面的流程
        return
    end
    local cardId = data:GetPrimaryValue()
    UpdateCardPropertyCache(data)

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardGemCoreChanged, cardId)
end

---芯核等级变更
---@param gemCoreId int
function CardDataProxy:OnGemCoreLevelChanged(gemCoreId)
    if nil == gemCoreId or gemCoreId <= 0 then
        Debug.LogError("GEM_CORE_LEVEL_CHANGE Event Msg Error")
        return
    end
    local cardList = self:GetCardList()
    if table.isnilorempty(cardList) then
        return
    end
    for _, cardData in pairs(cardList) do
        local cardId = cardData:GetPrimaryValue()
        local cardGemCores = cardData:GetGemCores()
        if cardGemCores then
            for _, coreId in pairs(cardGemCores) do
                if coreId == gemCoreId then
                    UpdateCardPropertyCache(cardData)
                    EventMgr.Dispatch(GameConst.CardEvent.CardGemCoreChanged, cardId)
                end
            end
        end
    end
end

---card单卡任务变化
---@param data X3Data.CardQuestData
function CardDataProxy:OnCardQuestDataChanged(data, changeFlag)
    local cardId = data:GetPrimaryValue()

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardQuestDataChanged, cardId)
end

---card套装任务变化
---@param data X3Data.CardSuitQuestData
function CardDataProxy:OnCardSuitQuestDataChanged(data, changeFlag)
    local suitId = data:GetPrimaryValue()

    --消息需要放在最后发
    EventMgr.Dispatch(GameConst.CardEvent.CardSuitQuestDataChanged, suitId)
end

---添加卡
---@param cardDataList table<number,pbcmessage.Card>
function CardDataProxy:AddOrUpdateCardData(cardDataList)
    for k, v in pairs(cardDataList) do
        CreateOrUpdateCardData(v)
    end
end

---添加卡
---@param cardDataList table<number,pbcmessage.Card>
function CardDataProxy:AddOrUpdateOtherCardData(cardDataList, uid)
    for k, v in pairs(cardDataList) do
        CreateOrUpdateOtherCardData(v, uid)
    end
end

---初始化他人的套装品阶
function CardDataProxy:InitOtherSuitPhase(suitPhaseMap, uid)
    self:ClearOtherSuitPhase(uid)
    if suitPhaseMap then
        for suitId, phaseLevel in pairs(suitPhaseMap) do
            local data = X3DataMgr.AddByPrimary(X3DataConst.X3Data.OtherSuitPhaseData, nil, suitId)
            data:SetUid(uid)
            data:SetSuitPhase(phaseLevel)
        end
    end
end

---移除他人的卡
function CardDataProxy:ClearOtherCardData(uid)
    local otherUserId = uid
    if not otherUserId then
        return
    end
    local curUserId = SelfProxyFactory.GetPlayerInfoProxy():GetUid()
    if curUserId == otherUserId then
        Debug.LogError("用户自己的卡不能调用这个接口，请检查！")
        return
    end
    local condition = PoolUtil.GetTable()
    condition[X3DataConst.X3DataField.CardData.UId] = otherUserId
    X3DataMgr.RemoveByCondition(X3DataConst.X3Data.CardData, condition)
    PoolUtil.ReleaseTable(condition)
    local attrCondition = PoolUtil.GetTable()
    attrCondition[X3DataConst.X3DataField.CardAttrData.UId] = otherUserId
    X3DataMgr.RemoveByCondition(X3DataConst.X3Data.CardAttrData, attrCondition)
    PoolUtil.ReleaseTable(attrCondition)
end

---初始化他人的套装品阶
function CardDataProxy:ClearOtherSuitPhase(uid)
    local otherUserId = uid
    if not otherUserId then
        return
    end
    local curUserId = SelfProxyFactory.GetPlayerInfoProxy():GetUid()
    if curUserId == otherUserId then
        Debug.LogError("用户自己的卡不能调用这个接口，请检查！")
        return
    end
    local condition = PoolUtil.GetTable()
    condition[X3DataConst.X3DataField.OtherSuitPhaseData.Uid] = otherUserId
    X3DataMgr.RemoveByCondition(X3DataConst.X3Data.OtherSuitPhaseData, condition)
    PoolUtil.ReleaseTable(condition)
end

--region  服务器数据推送相关
---@param msg pbcmessage.CardData
function CardDataProxy:OnEnterGameReply(msg)
    if msg == nil or msg.CardMap == nil then
        return
    end
    self:AddOrUpdateCardData(msg.CardMap)
    if msg.SuitRewards then
        for suitId, suitRewardsData in pairs(msg.SuitRewards) do
            UpdateCardSuitQuestData(suitId, suitRewardsData.Rewards)
        end
    end
end

---@param msg pbcmessage.CardUpdateReply
function CardDataProxy:CardUpdateReply(msg)
    if msg.OpType == 1 or msg.OpType == 3 then
        self:AddOrUpdateCardData(msg.CardList)
        if msg.OpType == 1 then
            EventMgr.Dispatch(GameConst.CardEvent.CardAdd, msg.CardList)
        end
    elseif msg.OpType == 2 then
        DeleteCardData(msg.CardList)
        EventMgr.Dispatch(GameConst.CardEvent.CardRemove, msg.CardList)
    end
end

---羁绊卡突破升星
function CardDataProxy:OnCardStarUpReply(cardId)
    local cardData = self:GetData(cardId)
    if not cardData then
        return
    end
    cardData:SetStarLevel(cardData:GetStarLevel() + 1)
end

---羁绊卡进阶
function CardDataProxy:OnCardProgressReply(cardId)
    local cardData = self:GetData(cardId)
    if not cardData then
        return
    end
    cardData:SetPhaseLevel(cardData:GetPhaseLevel() + 1)
end

---羁绊卡升级
---@param reply pbcmessage.CardAddExpReply
function CardDataProxy:OnCardAddExpReply(cardId, reply)
    local cardData = self:GetData(cardId)
    if not cardData then
        return
    end
    cardData:SetExp(reply.Exp)
    cardData:SetLevel(reply.Level)
end

---羁绊卡觉醒
function CardDataProxy:OnCardAwakenReply(cardId)
    local cardData = self:GetData(cardId)
    if not cardData then
        return
    end
    cardData:SetAwaken(X3DataConst.AwakenStatus.Awaken)
end

---羁绊卡任务状态更新
---@param reply pbcmessage.CardRewardStateUpdateReply
function CardDataProxy:OnCardRewardStateUpdate(reply)
    if table.isnilorempty(reply.RewardStatus) then
        return
    end
    local cardQuestStatusMap = PoolUtil.GetTable()
    local cardSuitQuestStatusMap = PoolUtil.GetTable()
    for rewardId, status in pairs(reply.RewardStatus) do
        local cardReward = LuaCfgMgr.Get("CardReward", rewardId)
        if not cardReward then
            return
        end
        if GameConst.CardQuestDefine[cardReward.Type] == GameConst.CardQuestType.CardSelf then
            --单卡任务
            cardQuestStatusMap[rewardId] = status
        elseif GameConst.CardQuestDefine[cardReward.Type] == GameConst.CardQuestType.CardSuit then
            --套卡任务
            cardSuitQuestStatusMap[rewardId] = status
        end
    end
    UpdateCardQuestData(reply.CardId, cardQuestStatusMap)
    local cardCfg = LuaCfgMgr.Get("CardBaseInfo", reply.CardId)
    if cardCfg then
        UpdateCardSuitQuestData(cardCfg.SuitID, cardSuitQuestStatusMap)
    end
    PoolUtil.ReleaseTable(cardQuestStatusMap)
    PoolUtil.ReleaseTable(cardSuitQuestStatusMap)
end

---最大突破等级
---@param cardId int
---@return int
function CardDataProxy:GetCardStarMaxNum(cardId)
    return GetCardStarMaxNum(cardId)
end

---最大进阶等级
---@return int
function CardDataProxy:GetCardMaxPhaseLv()
    return GetCardMaxPhaseLv()
end

---@param cardId int  羁绊卡id
---@param cardLevel int  羁绊卡等级
---@return boolean
function CardDataProxy:CardLevelIsMax(cardId, cardLevel)
    return CardLevelIsMax(cardId, cardLevel)
end

---@param phaseLevel int 品阶等级
---@return boolean
function CardDataProxy:CardPhaseLevelIsMax(phaseLevel)
    return CardPhaseLevelIsMax(phaseLevel)
end

---@param cardId int  羁绊卡id
---@param starLevel int  羁绊卡星级
---@return boolean
function CardDataProxy:CardStarLevelIsMax(cardId, starLevel)
    return CardStarLevelIsMax(cardId, starLevel)
end

---@param awakenStatus X3DataConst.AwakenStatus   羁绊卡觉醒状态
---@return boolean
function CardDataProxy:CardAwakenLevelIsMax(awakenStatus)
    return CardAwakenLevelIsMax(awakenStatus)
end

---装备芯核Reply
---@param reply pbcmessage.CardPutOnGemCoreReply
---@return table<int> removeCoreIdList
function CardDataProxy:OnCardPutOnGemCoreReply(reply)
    local removeCoreIdList = {}
    local cardData = self:GetData(reply.CardID)
    if cardData then
        for i = 1, #reply.CoreID do
            local gemCoreCfg = SelfProxyFactory.GetGemCoreProxy():GetGemCoreCfgById(reply.CoreID[i])
            if gemCoreCfg then
                local removeCoreId = self:GetGemCoreId(reply.CardID, gemCoreCfg.SiteID)
                if removeCoreId then
                    table.insert(removeCoreIdList, removeCoreId)
                    cardData:RemoveGemCoresValue(table.indexof(cardData:GetGemCores(), removeCoreId))
                end
                cardData:AddGemCoresValue(reply.CoreID[i])
                if reply.OldCardID[i] > 0 then
                    local oldCardData = self:GetData(reply.OldCardID[i])
                    if oldCardData then
                        local oldRemoveCoreId = self:GetGemCoreId(reply.OldCardID[i], gemCoreCfg.SiteID)
                        if oldRemoveCoreId then
                            table.insert(removeCoreIdList, oldRemoveCoreId)
                            oldCardData:RemoveGemCoresValue(table.indexof(oldCardData:GetGemCores(), oldRemoveCoreId))
                        end
                    end
                end
            end
        end
    end
    return removeCoreIdList
end

---卸下芯核
---@param reply pbcmessage.CardTakeOffGemCoreReply
function CardDataProxy:OnCardTakeOffGemCoreReply(reply)
    local cardData = self:GetData(reply.CardID)
    if cardData then
        local gemCores = cardData:GetGemCores()
        for _, gemCoreId in pairs(reply.CoreID) do
            local index = table.indexof(gemCores, gemCoreId)
            if index then
                cardData:RemoveGemCoresValue(index)
            end
        end
    end
end

--endregion

--region 属性相关

---获取Card初始属性,可用于卡片预览模式，如抽卡、图鉴界面
---@return table<int,int> key:PropertyType  value:PropertyValue
function CardDataProxy:GetCardInitProperties(cardId)
    local cardPropertyCache = X3DataMgr.Get(X3DataConst.X3Data.CardInitAttrData, cardId)
    if cardPropertyCache then
        return cardPropertyCache:GetInitAttr()
    else
        cardPropertyCache = X3DataMgr.Add(X3DataConst.X3Data.CardInitAttrData)
        cardPropertyCache:SetPrimaryValue(cardId)
        --初始属性，初始等级、星级、觉醒、品阶、无芯核
        local initPropertyMap = DevelopPropertyUtil.GetCardFinalProperty(cardId,
                Define.DevelopDefaultValue.CardLevel,
                Define.DevelopDefaultValue.CardStarLevel,
                Define.DevelopDefaultValue.CardPhaseLevel,
                Define.DevelopDefaultValue.CardAwakeLevel,
                nil)                               :GetPropertyMap()
        for k, v in pairs(initPropertyMap) do
            cardPropertyCache:AddOrUpdateInitAttrValue(k, v)
        end
        return cardPropertyCache:GetInitAttr()
    end
end

---获取Card基础属性,只能获取已有卡的属性
---@return table<int,int> key:PropertyType  value:PropertyValue, 可能为空
function CardDataProxy:GetCardBaseProperties(cardId, uid)
    local cardData = self:GetData(cardId, uid)
    if not cardData then
        return nil
    end
    local cardPropertyCache = GetCardPropertyCache(cardData)
    if cardPropertyCache then
        return cardPropertyCache:GetBaseAttr()
    else
        cardPropertyCache = CreateCardPropertyCache(cardData)
        return cardPropertyCache:GetBaseAttr()
    end
end

---获取Card芯核加成属性,只能获取已有卡的属性
---@return table<int,int> key:PropertyType  value:PropertyValue, 可能为空
function CardDataProxy:GetCardGemCoreProperties(cardId, uid)
    local cardData = self:GetData(cardId, uid)
    if not cardData then
        return nil
    end
    local cardPropertyCache = GetCardPropertyCache(cardData)
    if cardPropertyCache then
        return cardPropertyCache:GetGemCoreAttr()
    else
        cardPropertyCache = CreateCardPropertyCache(cardData)
        return cardPropertyCache:GetGemCoreAttr()
    end
end

---获取Card天赋加成属性,只能获取已有卡的属性
---@return table<int,int> key:PropertyType  value:PropertyValue, 可能为空
function CardDataProxy:GetCardTalentProperties(cardId, uid)
    local cardData = self:GetData(cardId, uid)
    if not cardData then
        return nil
    end
    local cardPropertyCache = GetCardPropertyCache(cardData)
    if cardPropertyCache then
        return cardPropertyCache:GetTalentAttr()
    else
        cardPropertyCache = CreateCardPropertyCache(cardData)
        return cardPropertyCache:GetTalentAttr()
    end
end

---获取Card当前属性,只能获取已有卡的属性
---@return table<int,int> key:PropertyType  value:PropertyValue, 可能为空
function CardDataProxy:GetCardCurProperties(cardId, uid)
    local cardData = self:GetData(cardId, uid)
    if not cardData then
        return nil
    end
    local cardPropertyCache = GetCardPropertyCache(cardData)
    if cardPropertyCache then
        return cardPropertyCache:GetFinalAttr()
    else
        cardPropertyCache = CreateCardPropertyCache(cardData)
        return cardPropertyCache:GetFinalAttr()
    end
end

---指定参数获取Card属性,只能获取已有卡的属性
---@return table<int,int>,table<int,int>,table<int,int>,table<int,int>  最终属性，基础属性，芯核加成属性，天赋加成属性。key:PropertyType  value:PropertyValue, 可能为空
function CardDataProxy:GetCardProperties(cardId, uid, level, starLevel, phaseLevel, awakeLevel)
    local cardData = self:GetData(cardId, uid)
    if not cardData then
        return nil
    end
    if not level then
        level = cardData:GetLevel()
    end
    if not starLevel then
        starLevel = cardData:GetStarLevel()
    end
    if not phaseLevel then
        phaseLevel = cardData:GetPhaseLevel()
    end
    if not awakeLevel then
        awakeLevel = cardData:GetAwaken()
    end
    local finalProperty, baseProperty, gemCoreProperty, talentProperty = DevelopPropertyUtil.GetCardFinalProperty(cardId, level, starLevel, phaseLevel, awakeLevel, GetEquippedGemCores(cardData))
    return finalProperty:GetPropertyMap(), baseProperty:GetPropertyMap(), gemCoreProperty:GetPropertyMap(), talentProperty:GetPropertyMap()
end

--endregion

--region 获取数据

---获取卡
---@return X3Data.CardData
---@param uid number 用户ID
function CardDataProxy:GetData(cardId, uid)
    return GetCardDataByUId(cardId, uid)
end

---获取卡上装备的芯核
---@return X3Data.GemCore[]
---@param uid number 用户ID
function CardDataProxy:GetCardGemCores(cardId, uid)
    local cardData = self:GetData(cardId, uid)
    return GetEquippedGemCores(cardData)
end

---获取卡列表
---@return X3Data.CardData[],number
---@param uid number 用户ID
function CardDataProxy:GetCardList(uid)
    if not uid then
        uid = SelfProxyFactory.GetPlayerInfoProxy():GetUid()
    end
    local result = {}
    local cnt = X3DataMgr.GetAll(X3DataConst.X3Data.CardData, result, function(x3Data)
        ---@type X3Data.CardData
        local cardData = x3Data
        if cardData:GetUId() == uid then
            return true
        end
    end)
    return result, cnt
end

---根据位置类型获取卡列表，此接口只支持获取用户自己的卡
---@return X3Data.CardData[]
function CardDataProxy:GetCardListByPos(posType)
    local cardPosDataList = X3DataMgr.Get(X3DataConst.X3Data.CardPosDataList, posType)
    if cardPosDataList then
        local cardIdList = cardPosDataList:GetCardList()
        if not cardIdList then
            return nil
        end
        local cardDataList = {}
        for _, id in pairs(cardIdList) do
            local cardData = self:GetData(id)
            if cardData then
                table.insert(cardDataList, cardData)
            end
        end
        return cardDataList
    end
    return nil
end

---根据男主类型获取卡列表，此接口只支持获取用户自己的卡
---@return X3Data.CardData[]
function CardDataProxy:GetCardListByRoleId(roleId)
    if roleId == -1 then
        return self:GetCardList()
    end
    local cardManTypeDataList = X3DataMgr.Get(X3DataConst.X3Data.CardManTypeDataList, roleId)
    if cardManTypeDataList then
        local cardIdList = cardManTypeDataList:GetCardList()
        if not cardIdList then
            return nil
        end
        local cardDataList = {}
        for _, id in pairs(cardIdList) do
            local cardData = self:GetData(id)
            if cardData then
                table.insert(cardDataList, cardData)
            end
        end
        return cardDataList
    end
    return nil
end

---根据男主类型获取配置中的卡ID列表
---@return number[]
function CardDataProxy:GetCardCfgListByRoleId(roleId)
    local cardManTypeDataList = X3DataMgr.Get(X3DataConst.X3Data.CardManTypeDataList, roleId)
    if cardManTypeDataList then
        return cardManTypeDataList:GetCfgCardList()
    end
    return nil
end

---获取配置中所有开放的卡
---@return int
function CardDataProxy:GetCardCfgAllNum()
    return self.cardManagedData:GetAllCardNum()
end

---获取卡最大等级
---@return int
function CardDataProxy:GetCardMaxLevel(cardId, starLevel)
    return GetCardMaxLevel(cardId, starLevel)
end

---获取自己已满级的卡数量
---@return int
function CardDataProxy:GetLevelMaxCardNum()
    local cnt = 0
    local map = self.cardManagedData:GetLevelMaxCardMap()
    if map then
        for _, isMax in pairs(map) do
            if isMax then
                cnt = cnt + 1
            end
        end
    end
    return cnt
end

---获取自己已满星的卡数量
---@return int
function CardDataProxy:GetStarLevelMaxCardNum()
    local cnt = 0
    local map = self.cardManagedData:GetStarLevelMaxCardMap()
    if map then
        for _, isMax in pairs(map) do
            if isMax then
                cnt = cnt + 1
            end
        end
    end
    return cnt
end

---获取自己已满品阶的卡数量
---@return int
function CardDataProxy:GetPhaseLevelMaxCardNum()
    local cnt = 0
    local map = self.cardManagedData:GetPhaseLevelMaxCardMap()
    if map then
        for _, isMax in pairs(map) do
            if isMax then
                cnt = cnt + 1
            end
        end
    end
    return cnt
end

---获取自己已觉醒的卡数量
---@return int
function CardDataProxy:GetAwakenCardNum()
    local cnt = 0
    local map = self.cardManagedData:GetAwakeLevelMaxCardMap()
    if map then
        for _, isMax in pairs(map) do
            if isMax then
                cnt = cnt + 1
            end
        end
    end
    return cnt
end

---@return int
function CardDataProxy:GetGemCoreId(cardId, siteId, uid)
    local cardData = SelfProxyFactory.GetCardDataProxy():GetData(cardId, uid)
    if not cardData then
        return nil
    end
    local cardGemCores = cardData:GetGemCores()
    if not cardGemCores then
        return nil
    end
    for _, gemCoreId in pairs(cardGemCores) do
        local gemCoreCfg = SelfProxyFactory.GetGemCoreProxy():GetGemCoreCfgById(gemCoreId, cardData:GetUId())
        if gemCoreCfg and gemCoreCfg.SiteID == siteId then
            return gemCoreId
        end
    end
    return nil
end

---@return X3Data.GemCore
function CardDataProxy:GetGemCore(cardId, uid, siteId)
    local gemCoreId = self:GetGemCoreId(cardId, siteId, uid)
    if gemCoreId == nil then
        return nil
    end
    return SelfProxyFactory.GetGemCoreProxy():GetGemCoreDataByGemCoreId(gemCoreId, uid)
end

---获取Card套装配置的所有卡（不一定获得了）
---@return number[]
function CardDataProxy:GetSuitCards(suitId)
    local suitData = X3DataMgr.Get(X3DataConst.X3Data.CardSuitConfigData, suitId)
    if suitData then
        return suitData:GetCardList()
    end
    return nil
end

---获取套装稀有度
---@return number
function CardDataProxy:GetSuitQuality(suitId)
    local suitData = X3DataMgr.Get(X3DataConst.X3Data.CardSuitConfigData, suitId)
    if suitData then
        return suitData:GetSuitQuality()
    end
    return 0
end

---根据SuitId获取套装叠花数
---@return number -1:未成套, 0~n:叠花数
function CardDataProxy:GetSuitPhaseLevel(suitId)
    local suitCards = self:GetSuitCards(suitId)
    if not suitCards or #suitCards == 0 then
        Debug.LogErrorFormat("获取不到套装的卡列表，suitId:%s", tostring(suitId))
        return -1
    end
    local suitCfg = LuaCfgMgr.Get("CardSuit", suitId, 0)
    if not suitCfg then
        return -1
    end
    local minPhaseLevel = 9999
    local obtainedCardCnt = 0
    for _, id in ipairs(suitCards) do
        local suitCardData = self:GetData(id)
        if suitCardData then
            obtainedCardCnt = obtainedCardCnt + 1
            minPhaseLevel = math.min(minPhaseLevel, suitCardData:GetPhaseLevel())
        end
    end
    if obtainedCardCnt >= suitCfg.Num then
        return minPhaseLevel
    end
    return -1
end

---获取他人的套装品阶
---@return number -1:未成套, 0~n:叠花数
function CardDataProxy:GetOtherSuitPhaseLevel(suitId)
    if not suitId then
        return -1
    end
    local data = X3DataMgr.Get(X3DataConst.X3Data.OtherSuitPhaseData, suitId)
    if not data then
        return -1
    end
    return data:GetSuitPhase()
end

---根据Card获取套装叠花数
---@return number -1:未成套或者根本不是套装的部件, 0~n:叠花数
function CardDataProxy:GetSuitPhaseLevelByCard(cardId)
    local cardCfg = LuaCfgMgr.Get("CardBaseInfo", cardId)
    if not cardCfg or cardCfg.SuitID <= 0 then
        return -1
    end
    return self:GetSuitPhaseLevel(cardCfg.SuitID)
end

---获取卡任务状态列表
---@return table<int,GameConst.CardQuestStatus> key:rewardId, value:任务状态
function CardDataProxy:GetCardQuestList(cardId)
    local cardData = self:GetData(cardId)
    if not cardData then
        return nil
    end
    local cardQuestData = GetCardQuestData(cardId)
    if not cardQuestData then
        return nil
    end
    return cardQuestData:GetCardQuests()
end

---获取卡套装任务状态列表
---@return table<int,GameConst.CardQuestStatus> key:rewardId, value:任务状态
function CardDataProxy:GetCardSuitQuestList(suitId)
    local cardSuitQuestData = GetCardSuitQuestData(suitId)
    if not cardSuitQuestData then
        return nil
    end
    return cardSuitQuestData:GetSuitQuests()
end

--endregion

return CardDataProxy