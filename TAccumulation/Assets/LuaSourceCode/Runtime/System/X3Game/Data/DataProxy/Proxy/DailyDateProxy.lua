---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 峻峻.
--- DateTime: 2021/11/12 15:10
---
---日常约会数据
---@class DailyDateProxy : BaseProxy
local DailyDateProxy = class("DailyDateProxy", BaseProxy)
local OpenTimeData = require("Runtime.System.X3Game.Modules.OpenTime.OpenTimeData")
local CS_DateTimeOffset = CS.System.DateTimeOffset
local CS_TimeSpan = CS.System.TimeSpan


---@class DailyDateModel
---@field id int 玩法Id
---@field openTimeData OpenTimeData 开启时间数据
---@field difficultyMap table<int, boolean>
---@field startTime CS.System.DateTimeOffset 玩法开启时间
---@field start_timestamp int 玩法开启时间戳
---@field endTime CS.System.DateTimeOffset 玩法结束时间
---@field end_timestamp int 玩法结束时间戳

---初始化
---@param owner ProxyFactory
function DailyDateProxy:OnInit(owner)
    self.super.OnInit(self, owner)
    ---@type table<int, DailyDateModel> 日常约会数据
    self.dailyDateModelDict = {}
    ---@type boolean 可否放弃新手关
    self.isCanGiveUp = false
    ---@type S3Int 快乐巧克力获取上限
    self.dailyDateChocolateLimit = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DAILYDATECHOCOLATELIMIT)

    if UNITY_EDITOR then
        self:SetIsCanGiveUp(PlayerPrefs.GetInt("X3-DailyDate-isCanGiveUp") == 1)
    end
end

---解析登录协议
---@return boolean
function DailyDateProxy:InitDailyDateData()
    local hasNewDailyDate = false
    local hasNewDifficulty = false
    hasNewDailyDate = self:InitDailyDateList()
    hasNewDifficulty = self:InitDifficultyMap()
    return hasNewDailyDate or hasNewDifficulty
end

---获取日常数据Model列表
---@return table<int, DailyDateModel>
function DailyDateProxy:GetDailyDateModelDict()
    return self.dailyDateModelDict
end

---添加日常约会开启时间等数据
---@return boolean
function DailyDateProxy:InitDailyDateList()
    ---@type cfg.DailyDateEntry[]
    local allCfg = LuaCfgMgr.GetAll("DailyDateEntry")
    local hasNew = false
    for _, dailyDateEntry in pairs(allCfg) do
        if self:IsDateOpen(dailyDateEntry.ID) then
            if self.dailyDateModelDict[dailyDateEntry.ID] == nil then
                hasNew = true
            end
            local model = self:GetDailyDateModel(dailyDateEntry.ID)
            local startTime, endTime = model.openTimeData:GetNearestOpenTime(TimerMgr.GetCurTimeSeconds())
            if startTime > 0 then
                model.startTime = CS_DateTimeOffset.FromUnixTimeSeconds(startTime)
                model.startTime = model.startTime:ToOffset(CS_TimeSpan(TimerMgr.GetTimeZone(), 0, 0))
                model.start_timestamp = startTime
            end
            if endTime > 0 then
                model.endTime = CS_DateTimeOffset.FromUnixTimeSeconds(endTime)
                model.endTime = model.endTime:ToOffset(CS_TimeSpan(TimerMgr.GetTimeZone(), 0, 0))
                model.end_timestamp = endTime
            end
        end
    end
    return hasNew
end

---获得日常约会数据
---@param id int 日常约会id
---@return DailyDateModel
function DailyDateProxy:GetDailyDateModel(id)
    if self.dailyDateModelDict[id] == nil then
        local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", id)
        ---@type DailyDateModel
        local model = {}
        model.id = id
        model.openTimeData = OpenTimeData.new()
        model.openTimeData:Parse(dailyDateEntry.OpenTimeType, dailyDateEntry.OpenTimeDetail)
        model.difficultyMap = {}
        model.start_timestamp = 0
        model.end_timestamp = 0
        self.dailyDateModelDict[id] = model
    end
    return self.dailyDateModelDict[id]
end
---endregion

---把后端的GroupID转换成difficultyID减少判断时的查表
---@return boolean
function DailyDateProxy:InitDifficultyMap()
    local hasNew = false
    for id, model in pairs(self.dailyDateModelDict) do
        local datas = self:GetDifficulties(id, 1)
        for _, value in pairs(datas) do
            if ConditionCheckUtil.CheckConditionByCommonConditionGroupId(value.OpenCondition) then
                if model.difficultyMap[value.ID] == nil then
                    hasNew = true
                end
                model.difficultyMap[value.ID] = false
            end
        end
    end
    return hasNew
end

---是否有新的日常约会
---@param entryId int 玩法Id
---@return boolean
function DailyDateProxy:HasNewDailyDateByEntryID(entryId)
    local model = self:GetDailyDateModel(entryId)
    local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", entryId)
    if model.difficultyMap ~= nil then
        for i, v in pairs(model.difficultyMap) do
            if v == false then
                local gamePlay = LuaCfgMgr.Get("GamePlay", dailyDateEntry.GameType)
                local difficulty = LuaCfgMgr.Get(gamePlay.ConnectDifficulty, i)
                if self:IsDateInOpenTime(entryId) and ConditionCheckUtil.CheckConditionByCommonConditionGroupId(difficulty.ShowCondition) then
                    return true
                end
            end
        end
    end
    return false
end

---约会是否开启
---@param id int 日常约会Id
---@return boolean
function DailyDateProxy:IsDateOpen(id)
    local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", id)
    return SysUnLock.IsUnLock(dailyDateEntry.SystemID) and ConditionCheckUtil.CheckConditionByCommonConditionGroupId(dailyDateEntry.OpenCondition)
end

---约会是否在开启时间内
---@param id int 约会Id
---@return boolean
function DailyDateProxy:IsDateInOpenTime(id)
    local model = self:GetDailyDateModel(id)
    return model.openTimeData:IsInOpenTime(TimerMgr.GetCurTimeSeconds())
end

---获取约会剩余次数
---@param id int 约会Id
---@param manType int 男主Id
---@return int
function DailyDateProxy:GetLeftTimes(id, manType)
    if BllMgr.GetRoleBLL():IsUnlocked(manType) == false then
        return 0
    end
    local customRecord = SelfProxyFactory.GetCustomRecordProxy():GetCustomRecord(DataSaveCustomType.DataSaveCustomTypeDailyDateEnterCount, id, manType)
    local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", id)
    if SysUnLock.IsUnLock(dailyDateEntry.SystemID) and self:IsDateInOpenTime(dailyDateEntry.ID) then
        return customRecord and customRecord.value or dailyDateEntry.Times
    else
        return 0
    end
end

---获取某个男主的所有玩法的剩余次数
---@param manType int 男主Id
---@return int
function DailyDateProxy:GetLeftTimesAll(manType)
    manType = manType ~= nil and manType or 1
    local datas = LuaCfgMgr.GetAll("DailyDateEntry")
    local count = 0
    for _, v in pairs(datas) do
        count = count + self:GetLeftTimes(v.ID, manType)
    end
    return count
end

---获得总的最大次数
---@return int
function DailyDateProxy:GetMaxTimesAll()
    local datas = LuaCfgMgr.GetAll("DailyDateEntry")
    local count = 0
    for _, v in pairs(datas) do
        if self:IsDateInOpenTime(v.ID) and SysUnLock.IsUnLock(v.SystemID) then
            count = count + v.Times
        end
    end
    return count
end

---获得剩余可购买次数
---@param id int 日常约会id
---@param manType int 男主Id
---@return int
function DailyDateProxy:GetLeftCanBuyTimes(id, manType)
    return self:GetMaxCanBuyTimes(id) - self:GetBuyCount(id, manType)
end

---获取约会已购买次数
---@param id int 日常约会id
---@param manType int 男主Id
---@return int
function DailyDateProxy:GetBuyCount(id, manType)
    return self:GetSingleBuyCount(id, manType)
end

---获取最大可购买次数
---@param id int 约会id
---@return int
function DailyDateProxy:GetMaxCanBuyTimes(id)
    local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", id)
    return dailyDateEntry.TimesBuyLimit
end

---获得购买价格
---@param id int 约会id
---@param index int 第几次购买
---@return int
function DailyDateProxy:GetPrice(id, index)
    local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", id)
    local price = dailyDateEntry.TimesPartyBuyPrice
    return price[index + 1] or price[#price]
end

---获取Difficulty配置
---@param dailyDateEntryId int 玩法Id
---@param id int difficultyId
function DailyDateProxy:GetDifficulty(dailyDateEntryId, id)
    local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", dailyDateEntryId)
    local gamePlay = LuaCfgMgr.Get("GamePlay", dailyDateEntry.GameType)
    return LuaCfgMgr.Get(gamePlay.ConnectDifficulty, id)
end

---获取Difficulty配置
---@param dailyDateEntryId int 玩法Id
---@param roleId int 男主Id
function DailyDateProxy:GetDifficulties(dailyDateEntryId, roleId)
    local dailyDateEntry = LuaCfgMgr.Get("DailyDateEntry", dailyDateEntryId)
    local filtedList = {}
    local subItems = {}
    if dailyDateEntry then
        local gamePlay = LuaCfgMgr.Get("GamePlay", dailyDateEntry.GameType)
        subItems = LuaCfgMgr.GetAll(gamePlay.ConnectDifficulty)
        if subItems ~= nil then
            for _, value in pairs(subItems) do
                local realKey = value.Group
                local checkRole = true
                if roleId ~= nil and value.ManType ~= roleId then
                    checkRole = false
                end
                if table.containsvalue(dailyDateEntry.ConnectStage, realKey) and checkRole and
                        ConditionCheckUtil.CheckConditionByCommonConditionGroupId(tonumber(value.ShowCondition)) then
                    filtedList[#filtedList + 1] = value
                end
            end
        end
    end
    return filtedList
end

---是否有新的日常约会
---@return boolean
function DailyDateProxy:HasNewDailyDate()
    local datas = LuaCfgMgr.GetAll("DailyDateEntry")
    for key, value in pairs(datas) do
        if value.EntryType == 1 then
            if self:HasNewDailyDateByEntryID(value.ID) then
                return true
            end
        end
    end
    return false
end

---判断是否为同一种玩法
---@param dailyDateEntryId int 玩法Id
---@param id1 int difficultyId
---@param id2 int difficultyId
---@return boolean
function DailyDateProxy:IsSameGame(dailyDateEntryId, id1, id2)
    local result = false
    local data1 = self:GetDifficulty(dailyDateEntryId, id1)
    local data2 = self:GetDifficulty(dailyDateEntryId, id2)
    local cfg = LuaCfgMgr.Get("DailyDateEntry", dailyDateEntryId)
    if cfg.GameType == Define.GamePlayType.GamePlayTypeUfoCatcher then
        if data1.PlayerNumType == data2.PlayerNumType and data1.CatchType == data2.CatchType then
            result = true
        end
    elseif cfg.GameType == Define.GamePlayType.GamePlayTypeMiao then
        if data1.MiaoCardType == data2.MiaoCardType then
            result = true
        end
    elseif cfg.GameType == Define.GamePlayType.GamePlayTypeBlockTower then
        if data1.BlockTowerType == data2.BlockTowerType then
            result = true
        end
    end
    return result
end

---判断列表中是否有同一种玩法的
---@param dailyDateEntryId int 玩法Id
---@param id1 int difficultyId
---@param checkList int[]
---@return boolean
function DailyDateProxy:HasSameGame(dailyDateEntryId, checkId, checkList)
    local result = false
    if checkList then
        for k,_ in pairs(checkList) do
            result = self:IsSameGame(dailyDateEntryId, checkId, k)
            if result then
                return true
            end
        end
    end
    return result
end

---是否达到了每周快乐巧克力获取上限
---@return boolean
function DailyDateProxy:HappyChocolateLimited()
    return self:HappyChocolateRewardedCount() >= self:HappyChocolateRewardLimit()
end

---快乐巧克力获取数量
---@return int
function DailyDateProxy:HappyChocolateRewardedCount()
    return self.owner:GetUserRecordProxy():GetUserRecordValue(DataSaveRecordType.DataSaveRecordTypeChocolateLimit)
end

---每周快乐巧克力获取上限
---@return int
function DailyDateProxy:HappyChocolateRewardLimit()
    return self.dailyDateChocolateLimit.Num
end

--region 数据Get/Set
---获得单人约会购买次数
---@param manType int 男主Id
---@return int
function DailyDateProxy:GetSingleBuyCount(id, manType)
    local customRecord = SelfProxyFactory.GetCustomRecordProxy():GetCustomRecord(DataSaveCustomType.DataSaveCustomTypeDailyDateBuyCount, id, manType)
    return customRecord and customRecord.value or 0
end

---可否放弃新手关
---@return boolean
function DailyDateProxy:IsCanGiveUp()
    return self.isCanGiveUp
end

---设置新手关可否放弃
---@param isCanGiveUp boolean
function DailyDateProxy:SetIsCanGiveUp(isCanGiveUp)
    if UNITY_EDITOR then
        self.isCanGiveUp = isCanGiveUp
        PlayerPrefs.SetInt("X3-DailyDate-isCanGiveUp", self.isCanGiveUp and 1 or 0)
    end
end
--endregion

---清理逻辑
function DailyDateProxy:OnClear()
    table.clear(self.dailyDateModelDict)
    self.isCanGiveUp = false
    self.dailyDateChocolateLimit = nil
    self.super.OnClear(self)
end

return DailyDateProxy