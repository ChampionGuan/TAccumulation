---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xiaofang.
--- DateTime: 2023/8/17 20:37
---@class LegendProxy:BaseProxy
local LegendProxy = class("LegendProxy", BaseProxy)
---@type ScoreStoryConst
local ScoreStoryConst = require("Runtime.System.X3Game.UI.UIView.ScoreStoryChapterWnd.Data.ScoreStoryConst")

function LegendProxy:OnInit()
    EventMgr.AddListener("RoleUnlockEvent", self.AddRoleEvent, self)
    EventMgr.AddListener("UpdateRoleLoveDataEvent", self.UpdateRoleLoveDataEvent, self)
    X3DataMgr.Subscribe(X3DataConst.X3Data.Item, self.OnCostItemChange, self)
    EventMgr.AddListener(GameConst.CardEvent.CardAdd, self.AddCardEvent, self)
    self.checkItemChange = PoolUtil.GetTable()
    self.checkCardMap = PoolUtil.GetTable()
    self.tLogMap = {}
    self:InitData()
end

function LegendProxy:InitData()
    local roleMap = BllMgr.GetRoleBLL():GetUnlockedRoleCfg()
    for i, role in pairs(roleMap) do
        self:InitRoleData(role.ID)
    end
end

---@param item X3Data.Item
function LegendProxy:OnCostItemChange(item)
    if item and self.checkItemChange[item:GetPrimaryValue()] then
        local roleMap = BllMgr.GetRoleBLL():GetUnlockedRoleCfg()
        for _, role in pairs(roleMap) do
            self:RefreshRoleData(role.ID)
        end
        EventMgr.Dispatch(ScoreStoryConst.Event.ON_CHANGE_KNOW_VALUE_EVENT)
    end
end

---@param cardList pbcmessage.Card[]
function LegendProxy:AddCardEvent(cardList)
    for i, v in pairs(cardList) do
        local scoreId = self.checkCardMap[v.Id]
        if scoreId then
            local legendCfg = LuaCfgMgr.Get("LegendStoryInfo", scoreId)
            if legendCfg then
                local roleLegend = self:GetRoleLegendData(legendCfg.RoleID)
                local legendItem = X3DataMgr.Get(X3DataConst.X3Data.LegendItem, scoreId)
                self:UpdateLegendItemData(roleLegend, legendItem, legendCfg)
                self:RefreshRedState(roleLegend:GetPrimaryValue())
                self.checkCardMap[v.Id] = nil
            end
        end
    end
    self:CheckTLog()
end

---新解锁男主
---@param roleId int
function LegendProxy:AddRoleEvent(roleId)
    self:InitRoleData(roleId)
end

---男主牵绊度更新
function LegendProxy:UpdateRoleLoveDataEvent(roleId)
    self:RefreshRoleData(roleId)
end

---初始化男主数据
---@param roleId int
function LegendProxy:InitRoleData(roleId)
    local roleLegend = self:GetRoleLegendData(roleId)
    local storyList = LuaCfgMgr.GetListByCondition("LegendStoryInfo", { RoleID = roleId })
    for i, v in pairs(storyList) do
        local legendItem = X3DataMgr.AddByPrimary(X3DataConst.X3Data.LegendItem, nil, v.SCoreID)
        self:UpdateLegendItemData(roleLegend, legendItem, v)
    end
    if next(self.tLogMap) then
        self:CheckTLog()
    end
    self:RefreshRedState(roleId)
end

---刷新男主传说数据
---@param roleId int
function LegendProxy:RefreshRoleData(roleId)
    local roleLegend = self:GetRoleLegendData(roleId)
    local legendData = roleLegend:GetLegend()
    if legendData then
        for i, v in pairs(legendData) do
            local legendItem = X3DataMgr.Get(X3DataConst.X3Data.LegendItem, v:GetPrimaryValue())
            self:UpdateLegendItemData(roleLegend, legendItem)
        end
        self:CheckTLog()
    end
    self:RefreshRedState(roleId)
end

---刷新红点
---@param roleId int
function LegendProxy:RefreshRedState(roleId)
    if not self:IsUnlock() then
        return
    end
    local roleData = self:GetRoleLegendData(roleId)
    ---@type X3Data.LegendItem[]
    local legendData = roleData:GetLegend()
    if legendData then
        local secNew = 0
        local chapterNew = 0
        local rewardNew = 0
        for _, legendItem in pairs(legendData) do
            local count = 0
            if legendItem:GetStateType() == X3DataConst.StoryStateType.StoryStateTypeFinish then
                count = count + 1
                rewardNew = rewardNew + 1
            end
            if legendItem:GetIsNew() then
                count = count + 1
                chapterNew = chapterNew + 1
            end
            ---@type X3Data.LegendSection[]
            local secData = legendItem:GetSectionData()
            if secData then
                for _, secItem in pairs(secData) do
                    if secItem:GetIsNew() then
                        count = count + 1
                        secNew = secNew + 1
                    end
                end
            end
            RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_START, count, legendItem:GetPrimaryValue())
        end
        --匹配选择男主界面红点
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW_ALL, secNew, roleId)
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_NEW_ALL, chapterNew, roleId)
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_REWARD_ALL, rewardNew, roleId)
        --匹配特约tab 特殊索引
        local key = BllMgr.GetSpecialDateBLL():GetManDateTypeId(roleId, Define.SpecialDateType.Legend)
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW_ALL, secNew, key)
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_NEW_ALL, chapterNew, key)
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_REWARD_ALL, rewardNew, key)
    end
end

---获得指定男主的传说数据
---@param roleId int
---@return X3Data.LegendList
function LegendProxy:GetRoleLegendData(roleId)
    if not roleId or roleId == 0 then
        return
    end
    local roleLegend = X3DataMgr.Get(X3DataConst.X3Data.LegendList, roleId)
    if not roleLegend then
        roleLegend = X3DataMgr.AddByPrimary(X3DataConst.X3Data.LegendList, nil, roleId)
    end
    return roleLegend
end

---@param legendData pbcmessage.StoryTypeData
function LegendProxy:UpdateServerData(legendData)
    if not legendData then
        return
    end
    self.server_story_map = legendData.StoryMap
    for i, v in pairs(legendData.StoryMap) do
        local cfg = LuaCfgMgr.Get("LegendStoryInfo", v.StoryID)
        if cfg then
            self:UpdateServerLegendItem(cfg.RoleID, v)
        end
    end
    for role_id, v in pairs(legendData.LastStoryIDs) do
        local roleLegend = self:GetRoleLegendData(role_id)
        roleLegend:SetLastStoryID(v)
    end
end

---是否需要上报TLog
---@param legendId int  SCoreID
function LegendProxy:IsUpTLog(legendId)
    if not self.server_story_map then
        return false
    end
    return self.server_story_map[legendId] ~= nil
end

---是否解锁传说
---@param legendId int SCoreID
---@return bool
function LegendProxy:IsHaveLegend(legendId)
    local itemData = X3DataMgr.Get(X3DataConst.X3Data.LegendItem, legendId)
    if not itemData then
        return false
    end
    if itemData:GetState() == X3DataConst.StoryStatus.Normal then
        return true
    end
    return false
end

---更新服务器数据
---@param roleId int
---@param data pbcmessage.StoryItem
function LegendProxy:UpdateServerLegendItem(roleId, data)
    local roleLegend = self:GetRoleLegendData(roleId)
    local itemData = X3DataMgr.Get(X3DataConst.X3Data.LegendItem, data.StoryID)
    if itemData then
        itemData:SetState(X3DataConst.StoryStatus.Normal)
        itemData:SetLastReadSection(data.LastReadSection)
        itemData:SetStateType(data.State)
        roleLegend:UpdateLegendValue(data.StoryID, itemData)
    end
end

---更新单个传说数据
---@param roleLegend X3Data.LegendList
---@param legendItem X3Data.LegendItem
function LegendProxy:UpdateLegendItemData(roleLegend, legendItem, legendCfg)
    if not roleLegend or not legendItem then
        return
    end
    if not legendCfg then
        legendCfg = LuaCfgMgr.Get("LegendStoryInfo", legendItem:GetPrimaryValue())
    end
    local isUnlock = self:CheckHasScore(legendItem:GetPrimaryValue())
    if legendCfg.LoveLevelCondition > 0 then
        isUnlock = isUnlock and BllMgr.GetRoleBLL():GetRoleLoveLevel(roleLegend:GetPrimaryValue()) >= legendCfg.LoveLevelCondition
    end
    for i, v in pairs(legendCfg.ConnectItemID) do
        self.checkItemChange[v.Num] = true
    end
    legendItem:SetState(isUnlock and X3DataConst.StoryStatus.Normal or X3DataConst.StoryStatus.Lock)
    local redVal = RedPointMgr.GetValue(X3_CFG_CONST.RED_SCORESTORY_NEW, legendItem:GetPrimaryValue())
    if isUnlock and redVal == Define.LegendRedState.None and self:IsUnlock() then
        RedPointMgr.Save(Define.LegendRedState.New, X3_CFG_CONST.RED_SCORESTORY_NEW, legendItem:GetPrimaryValue())
        redVal = RedPointMgr.GetValue(X3_CFG_CONST.RED_SCORESTORY_NEW, legendItem:GetPrimaryValue())
        if not self:IsUpTLog(legendItem:GetPrimaryValue()) then
            table.insert(self.tLogMap, BllMgr.GetScoreStoryBLL():CreateStoryRemind(X3DataConst.StoryType.Legend, legendItem:GetPrimaryValue(), 0))
        end
    end
    RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_NEW, redVal == Define.LegendRedState.New and 1 or 0, legendItem:GetPrimaryValue())
    legendItem:SetIsNew(redVal == Define.LegendRedState.New)
    local secList = legendItem:GetSectionData()
    if not secList then
        local sectionList = LuaCfgMgr.GetListByCondition("LegendStorySection", { SCoreID = legendItem:GetPrimaryValue() })
        table.sort(sectionList, function(a, b)
            return a.SectionID < b.SectionID
        end)
        for _, sec in ipairs(sectionList) do
            local secData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.LegendSection, nil, sec.SectionID)
            self:UpdateSectionData(roleLegend, legendItem, secData, sec)
        end
    else
        for _, secData in pairs(secList) do
            self:UpdateSectionData(roleLegend, legendItem, secData)
        end
    end
    RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_REWARD, legendItem:GetStateType() == X3DataConst.StoryStateType.StoryStateTypeFinish and 1 or 0, legendItem:GetPrimaryValue())
    roleLegend:AddOrUpdateLegendValue(legendItem:GetPrimaryValue(), legendItem)
end

---是否拥有score对应的思念卡
---@param scoreId int
function LegendProxy:CheckHasScore(scoreId)
    local scoreCfg = LuaCfgMgr.Get("SCoreBaseInfo", scoreId)
    local cards = scoreCfg and scoreCfg.Card
    local cardList = {}
    local isHave = false
    if cards then
        for i, v in pairs(cards) do
            local card = LuaCfgMgr.Get("CardBaseInfo", v)
            table.insert(cardList, card)
        end
        for i, v in pairs(cardList) do
            local isExit = BllMgr.GetCardBLL():IsHaveCard(v.ID)
            if isExit then
                isHave = true
                break
            else
                self.checkCardMap[v.ID] = scoreId
            end
        end
    end
    return isHave, cardList
end

---更新单个小节数据
---@param roleLegend X3Data.LegendList
---@param legendItem X3Data.LegendItem
---@param secData X3Data.LegendSection
---@param secCfg table
function LegendProxy:UpdateSectionData(roleLegend, legendItem, secData, secCfg)
    if not secCfg then
        secCfg = LuaCfgMgr.Get("LegendStorySection", secData:GetPrimaryValue())
    end
    local legendCfg = LuaCfgMgr.Get("LegendStoryInfo", legendItem:GetPrimaryValue())
    local num = BllMgr.GetItemBLL():GetItemNum(legendCfg.ConnectItemID[1].Num, legendCfg.ConnectItemID[1].ID)
    local isUnlock = num >= secCfg.Cost and legendItem:GetState() == X3DataConst.StoryStatus.Normal
    secData:SetState(isUnlock and X3DataConst.StoryStatus.Normal or X3DataConst.StoryStatus.Lock)
    if secCfg.Num > 1 then
        local lastData = X3DataMgr.Get(X3DataConst.X3Data.LegendSection, secData:GetPrimaryValue() - 1)
        if lastData then
            local redVal = RedPointMgr.GetValue(X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW, secData:GetPrimaryValue() - 1)
            secData:SetReadState(redVal == Define.LegendRedState.ReadFinish and X3DataConst.StoryReadState.HaveRead or X3DataConst.StoryReadState.NoRead)
        end
    else
        secData:SetReadState(X3DataConst.StoryReadState.HaveRead)
    end
    if secData:GetState() == X3DataConst.StoryStatus.Normal and secData:GetReadState() == X3DataConst.StoryReadState.HaveRead and self:IsUnlock() then
        local redVal = RedPointMgr.GetValue(X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW, secCfg.SectionID)
        if redVal == Define.LegendRedState.None then
            RedPointMgr.Save(Define.LegendRedState.New, X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW, secCfg.SectionID)
            redVal = RedPointMgr.GetValue(X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW, secCfg.SectionID)
            table.insert(self.tLogMap, BllMgr.GetScoreStoryBLL():CreateStoryRemind(X3DataConst.StoryType.Legend, legendItem:GetPrimaryValue(), secData:GetPrimaryValue()))
        end
        secData:SetIsNew(redVal == 1)
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW, redVal == Define.LegendRedState.New and 1 or 0, secCfg.SectionID)
    end
    legendItem:AddOrUpdateSectionDataValue(secCfg.SectionID, secData)
    roleLegend:AddOrUpdateLegendValue(legendItem:GetPrimaryValue(), legendItem)
end

---获取章节阅读完成进度
---@param legendItem X3Data.LegendItem
function LegendProxy:GetLegendHaveReadProgress(legendItem)
    if not legendItem then
        return 0
    end
    ---@type X3Data.LegendSection[]
    local secList = legendItem:GetSectionData()
    local unlockCount = 0
    local maxNum = 0
    if secList then
        for i, v in pairs(secList) do
            if v:GetState() == X3DataConst.StoryStatus.Normal and v:GetReadState() == X3DataConst.StoryReadState.HaveRead then
                local redVal = RedPointMgr.GetValue(X3_CFG_CONST.RED_SCORESTORY_CHAPTER_NEW, v:GetPrimaryValue())
                if redVal == Define.LegendRedState.ReadFinish then
                    unlockCount = unlockCount + 1
                end
            end
            maxNum = maxNum + 1
        end
    end
    return maxNum > 0 and math.ceil(unlockCount / maxNum * 100) or 0
end

---@param roleId int
function LegendProxy:GetOtherRoleRedState(roleId)
    local roleMap = BllMgr.GetRoleBLL():GetUnlockedRole()
    local count = 0
    for i, v in pairs(roleMap) do
        if v.Id ~= roleId then
            local roleData = self:GetRoleLegendData(v.Id)
            ---@type X3Data.LegendItem[]
            local legendData = roleData:GetLegend()
            if legendData then
                for _, legendItem in pairs(legendData) do
                    if legendItem:GetState() == X3DataConst.StoryStatus.Normal then
                        if legendItem:GetStateType() == X3DataConst.StoryStateType.StoryStateTypeFinish then
                            count = count + 1
                            break
                        end
                        if legendItem:GetIsNew() then
                            count = count + 1
                            break
                        end
                        ---@type X3Data.LegendSection[]
                        local secData = legendItem:GetSectionData()
                        if secData then
                            for _, secItem in pairs(secData) do
                                if secItem:GetIsNew() then
                                    count = count + 1
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    RedPointMgr.UpdateCount(X3_CFG_CONST.RED_SCORESTORY_SWITCHMAN, count)
end

function LegendProxy:IsUnlock()
    return SysUnLock.IsUnLock(X3_CFG_CONST.SYSTEM_UNLOCK_SPECIALDATE_STORYINFO)
end

function LegendProxy:SetParams(roleId)
    self.saveParams = roleId
end

---从传说AVG返回恢复UI
function LegendProxy:IsRecoverWnd()
    if self.saveParams then
        --和主线保持一致，在loading结束后再切换bgm
        ---@type ScoreStoryChapterWnd
        local ctrl = UIMgr.GetViewByTag(UIConf.ScoreStoryChapterWnd)
        if ctrl then
            ctrl:PlayBGM()
        end
        self.saveParams = nil
    end
end

function LegendProxy:CheckTLog()
    if next(self.tLogMap) then
        BllMgr.GetScoreStoryBLL():Send_TLogRemindTriggerRequest(self.tLogMap, function()
            table.clear(self.tLogMap)
        end)
    end
end

function LegendProxy:OnClear()
    X3DataMgr.UnsubscribeWithTarget(self)
    PoolUtil.ReleaseTable(self.checkItemChange)
    PoolUtil.ReleaseTable(self.checkCardMap)
end

return LegendProxy

