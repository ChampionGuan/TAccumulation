--- 
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sms.
--- DateTime: 2023/12/6 12:46
--- 挂机活动功能相关

---@class ActivityHangUpBLL
local ActivityHangUpBLL = class("ActivityHangUpBLL", BaseBll)

---@type ActivityHangUpConst
local ActivityHangUpConst = require("Runtime.System.X3Game.GameConst.ActivityHangUpConst")

------------------------------------------------------------------------------------------------------------------------
local logOn = false
local errLogOn = true

---@param self ActivityHangUpBLL
local function __log(self, _logContent)
    if logOn then
        Debug.LogError(string.format("【挂机活动】 Log: %s", _logContent))
    end
end
ActivityHangUpBLL.Log = __log

---@param self ActivityHangUpBLL
local function __logError(self, _logContent)
    if errLogOn then
        Debug.LogError(string.format("【挂机活动】 ErrorLog: %s", _logContent))
    end
end
ActivityHangUpBLL.LogError = __logError
------------------------------------------------------------------------------------------------------------------------

function ActivityHangUpBLL:OnInit()
    ---@type number 计时器 用于刷新挂机状态
    self.tickTimer = nil
    
    -- 数据更新时计时器逻辑刷新一下
    EventMgr.AddListener(
            ActivityHangUpConst.EventMap.DataUpdate,
            function(ignoreFlag)
                self:CheckRefreshTickTimer()
                
                self:UpdateAllRedPoint()
            end, self
    )
    
    -- 每日更新时刷新红点
    EventMgr.AddListener(Const.Event.TIME_TICK_HOUR, function(self, hour)
        if hour == 0 then
            self:UpdateAllRedPoint()
        end
    end, self)
end

function ActivityHangUpBLL:OnLogin()
    -- 刷新所有红点
    self:UpdateAllRedPoint()
end
    
function ActivityHangUpBLL:OnClear()
    if self.tickTimer then
        TimerMgr.Discard(self.tickTimer)
        self.tickTimer = nil
    end
    
    EventMgr.RemoveListenerByTarget(self)
end

-- GM命令接管
function ActivityHangUpBLL:HandleGMCommand(inputList)
    Debug.LogError("【挂机活动】GM命令执行: " .. table.dump(inputList))
    
    if inputList[3] == "logon" then
        logOn = true
    elseif inputList[3] == "logoff" then
        logOn = false
    elseif inputList[3] == "debugredpoint" then
        self:DebugRedPointValue()
    end
end

function ActivityHangUpBLL:DebugRedPointValue()
    local allHangUpCfg = LuaCfgMgr.GetAll("ActivityHangUpItem")
    if table.isnilorempty(allHangUpCfg) then return end
    local result = {}
    for id, v in pairs(allHangUpCfg) do
        table.insert(result, string.format("id : %d, count: %d, value: %d", id, RedPointMgr.GetCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, id), RedPointMgr.GetValue(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, id)))
    end
    
    Debug.LogError("DebugRedPointValue: " .. table.dump(result))
    
    local typeResult = {}
    for id = 1, 4 do
        table.insert(typeResult, string.format("tabId : %d, count: %d, value: %d", id, RedPointMgr.GetCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_TAB, id), RedPointMgr.GetValue(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_TAB, id)))
    end
    Debug.LogError("DebugRedPointTabValue: " .. table.dump(typeResult))
end

-- 刷新指定id的挂机红点
-- tips: GetValue和Save成对用 代表当前状态 0: 从未激活过红点 1: 激活过解锁红点 2: 激活过领奖红点 , GetCount和UpdateCount成对用 代表当前红点的显示情况
function ActivityHangUpBLL:UpdateRedPoint(hangUpId)
    if not hangUpId then return end
    local hangUpCfg = LuaCfgMgr.Get("ActivityHangUpItem", hangUpId)
    if table.isnilorempty(hangUpCfg) then return end
    
    local isHangUpUnlock = self:CheckIfHangUpUnlock(hangUpId)
    local state = self:GetHangUpState(hangUpId)
    local isReward = state and state == ActivityHangUpConst.HangUpState.Completed
    local isCompleted = state and state == ActivityHangUpConst.HangUpState.Rewarded
    
    local recordValue = RedPointMgr.GetValue(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, hangUpId)
    local isRedPointShow = RedPointMgr.GetCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, hangUpId) == 1

    if recordValue == 0 and isHangUpUnlock then     -- 刚刚解锁的挂机
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, 1, hangUpId)
        RedPointMgr.Save(1, X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, hangUpId)
    elseif recordValue <= 1 and isReward then
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, 1, hangUpId)
        RedPointMgr.Save(2, X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, hangUpId)
    elseif isCompleted then
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, 0, hangUpId)
    end
end

-- 刷新类型的红点
function ActivityHangUpBLL:UpdateTypeRedPoint(typeId)
    local hangUpIdCfgList = LuaCfgMgr.GetListByCondition("ActivityHangUpItem", {TypeGroupID = typeId})
    if table.isnilorempty(hangUpIdCfgList) then return end
    local showRedPoint = false
    for _, hangUpCfg in ipairs(hangUpIdCfgList) do
        local hangUpId = hangUpCfg.HangUPID
        local isRedPointShow = RedPointMgr.GetCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, hangUpId) == 1
        if isRedPointShow then showRedPoint = true break end
    end
    RedPointMgr.UpdateCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_TAB, showRedPoint and 1 or 0, typeId)
end

-- 刷新所有类型
function ActivityHangUpBLL:UpdateAllTypeRedPoint()
    local typeDic = {}
    local allHangUpCfg = LuaCfgMgr.GetAll("ActivityHangUpItem")
    if table.isnilorempty(allHangUpCfg) then return end
    for _, v in pairs(allHangUpCfg) do
        typeDic[v.TypeGroupID] = true
    end
    for typeId, flag in pairs(typeDic) do
        self:UpdateTypeRedPoint(typeId)
    end
end

-- 消除红点
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:CheckRemoveRedPoint(hangUpId)
    if not hangUpId then return end
    
    if (RedPointMgr.GetCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, hangUpId) == 1) and (RedPointMgr.GetValue(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, hangUpId) <= 1) then
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_ACTIVITY_RB_HANGUP_ITEM, 0, hangUpId)
    end
    
    local hangUpCfg = LuaCfgMgr.Get("ActivityHangUpItem", hangUpId)
    local typeId = hangUpCfg.TypeGroupID
    self:UpdateTypeRedPoint(typeId)
end

-- 消除指定类型的红点
---@param typeId number 类型Id
function ActivityHangUpBLL:RemoveRedPointByType(typeId)
    if not typeId then return end
    
    local allCfg = LuaCfgMgr.GetListByCondition("ActivityHangUpItem", {TypeGroupID = typeId})
    for idx, v in pairs(allCfg) do
        self:CheckRemoveRedPoint(v.HangUPID)
    end
end

-- 刷新这个活动下的所有挂机红点
function ActivityHangUpBLL:UpdateRedPointByActivityId(activityId)
    local allCfgList = LuaCfgMgr.GetListByCondition("ActivityHangUpItem", {ActivityID = activityId})
    local idList = {} for _, v in pairs(allCfgList) do table.insert(idList, v) end
    
    for _, v in pairs(idList) do
        self:UpdateRedPoint(v)
    end
end

-- 刷新所有挂机红点
function ActivityHangUpBLL:UpdateAllRedPoint()
    local allCfg = LuaCfgMgr.GetAll("ActivityHangUpItem")
    if table.isnilorempty(allCfg) then return end
    local idList = {}
    for id, v in pairs(allCfg) do
        local activityId = v.ActivityID
        table.insert(idList, id)
    end

    for _, v in pairs(idList) do
        self:UpdateRedPoint(v)
    end

    self:UpdateAllTypeRedPoint()
end


-- 刷新定时器 更新挂机数据状态 (处理从OnProgress -> Completed这个过程)
function ActivityHangUpBLL:CheckRefreshTickTimer()
    if self.tickTimer then
        TimerMgr.Discard(self.tickTimer)
        self.tickTimer = nil
    end
    
    local minEndTime
    local curTime = TimerMgr.GetCurTimeSeconds()
    local isDataUpdate = false
    
    local allDataMap = SelfProxyFactory.GetActivityHangUpProxy():GetAllData()
    if table.isnilorempty(allDataMap) then return end
    for hangUpId, hangUpData in pairs(allDataMap) do
        local endTime = BllMgr.GetActivityHangUpBLL():GetHangUpEndTime(hangUpId, hangUpData.StartTime)
        if hangUpData.Status == ActivityHangUpConst.HangUpState.Progress then
            -- 如果当前时间 >= endTime 则更改其状态
            if endTime and endTime > 0 and curTime >= endTime then
                allDataMap[hangUpId].Status = ActivityHangUpConst.HangUpState.Completed
                isDataUpdate = true
            elseif endTime and endTime > 0 and curTime < endTime then
                -- 如果时间还没到, 记录一个
                minEndTime = minEndTime or endTime
                minEndTime = math.min(minEndTime, endTime)
            end
        end
    end
    
    -- 如果有记录最小结束时间 则开一个Timer去做检查
    if minEndTime then
        self.tickTimer = TimerMgr.AddTimer(
                minEndTime - curTime,
                function()
                    self:CheckRefreshTickTimer()
                end, self, 1
        )
    end

    -- 如果有数据被修改 则抛出更新事件
    if isDataUpdate then
        EventMgr.Dispatch(ActivityHangUpConst.EventMap.DataUpdate)
    end
end

---@class ClientActivityHangUpData 客户端用的挂机活动数据
---@field hangUpId number HangUpId
---@field status number 当前状态
---@field startTime number 开始时间戳
---@field endTime number 结束时间戳

-- 计算正常挂机结束时间
---@param hangUpId number 挂机Id
---@param startTime number 挂机开始时间
---@return number 挂机结束时间
function ActivityHangUpBLL:GetHangUpEndTime(hangUpId, startTime)
    local cfg = LuaCfgMgr.Get("ActivityHangUpItem", hangUpId)
    if table.isnilorempty(cfg) then self:LogError("activity hangup cfg not found, id : " .. tostring(hangUpId)) return end
    return startTime + cfg.HangUpTime
end

-- 根据活动Id返回其挂机数据列表
---@param activityId number 活动Id
---@return table<number, ClientActivityHangUpData> 返回客户端整理后的数据
function ActivityHangUpBLL:GetHangUpDataListByActivityId(activityId)
    local result = {}
    local allDataMap = SelfProxyFactory.GetActivityHangUpProxy():GetAllData()
    if table.isnilorempty(allDataMap) then return result end
    for _id, _data in pairs(allDataMap) do
        local cfg = LuaCfgMgr.Get("ActivityHangUpItem", _id)
        if table.isnilorempty(cfg) then self:LogError("activity hangup cfg not found, id : " .. tostring(_id)) else
            if cfg.ActivityID and cfg.ActivityID == activityId then
                table.insert(result, {
                    hangUpId = _id,
                    startTime = _data.StartTime,
                    status = _data.Status,
                    endTime = _data.Status == ActivityHangUpConst.HangUpState.Progress and self:GetHangUpEndTime(_id, _data.StartTime) or 0,
            })
            end
        end
    end
    return result
end

-- 根据挂机Id和配置表中的绝对时间配置 获取其解锁时间戳
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:GetUnlockTimeStampByHangUpId(hangUpId)
    local cfg = LuaCfgMgr.Get("ActivityHangUpItem", hangUpId)
    if table.isnilorempty(cfg) then self:LogError("activity hangup cfg not found, id : " .. tostring(hangUpId)) return end
    local startTime = cfg.UnlockTime
    if not string.isnilorempty(startTime) then
        local datePart, timePart = startTime:match("(.+)=(.+)")
        local year, month, day = datePart:match("(%d%d%d%d)(%d%d)(%d%d)")
        local hour, min, sec = timePart:match("(%d%d):(%d%d):(%d%d)")

        local curDate = TimerMgr.GetCurDate()
        curDate.year = tonumber(year)
        curDate.month = tonumber(month)
        curDate.day = tonumber(day)
        curDate.hour = tonumber(hour)
        curDate.min = tonumber(min)
        curDate.sec = tonumber(sec)
        
        return TimerMgr.GetUnixTimestamp(curDate)
    end

    return 0
end

-- 检查挂机是否解锁
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:CheckIfHangUpUnlock(hangUpId)
    local cfg = LuaCfgMgr.Get("ActivityHangUpItem", hangUpId)
    if table.isnilorempty(cfg) then self:LogError("activity hangup cfg not found, id : " .. tostring(hangUpId)) return end
    
    -- 检查condition是否满足
    if cfg.Condition and cfg.Condition > 0 then
        if not ConditionCheckUtil.CheckConditionByCommonConditionGroupId(cfg.Condition) then
            local desc = ConditionCheckUtil.GetConditionDescByGroupId(cfg.Condition)
            return false, desc
        end
    end
    
    -- 检查绝对时间是否满足
    local curTime = TimerMgr.GetCurTimeSeconds()
    local unlockTime = self:GetUnlockTimeStampByHangUpId(hangUpId)
    local datePart, timePart = cfg.UnlockTime:match("(.+)=(.+)")
    local year, month, day = datePart:match("(%d%d%d%d)(%d%d)(%d%d)")
    local hour, min, sec = timePart:match("(%d%d):(%d%d):(%d%d)")
    
    if unlockTime and unlockTime > 0 and unlockTime > curTime then return false, UITextHelper.GetUIText(UITextConst.UI_TEXT_33627, year, month, day, hour, min) end
    
    return true
end

-- 获取当前进行中的挂机
---@param activityId number 活动Id
---@return ClientActivityHangUpData
function ActivityHangUpBLL:GetCurrentHangupData(activityId)
    local hangUpDataList = self:GetHangUpDataListByActivityId(activityId)
    if table.isnilorempty(hangUpDataList) then return end
    for _, hangUpData in pairs(hangUpDataList) do
        if hangUpData.status == ActivityHangUpConst.HangUpState.Completed or hangUpData.status == ActivityHangUpConst.HangUpState.Progress then return hangUpData end
    end
end

-- 获取挂机状态
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:GetHangUpState(hangUpId)
    local hangUpData = SelfProxyFactory.GetActivityHangUpProxy():GetDataById(hangUpId)
    if table.isnilorempty(hangUpData) then return ActivityHangUpConst.HangUpState.Normal end
    return hangUpData.Status
end

-- 检查挂机分组是否解锁
---@param activityId number 活动Id
---@param groupTypeId number 分组Id
function ActivityHangUpBLL:CheckIfTypeUnlock(activityId, groupTypeId)
    local allCfgList = LuaCfgMgr.GetListByCondition("ActivityHangUpItem", {ActivityID = activityId, TypeGroupID = groupTypeId})
    local list = {}
    for _, v in pairs(allCfgList) do
        local isUnlock, lockDes = self:CheckIfHangUpUnlock(v.HangUPID)
        if not isUnlock then return false, lockDes end
    end
    return true
end

-- 检查挂机分组是否有挂机在进行中
---@param activityId number 活动Id
---@param groupTypeId number 分组Id
function ActivityHangUpBLL:CheckIfTypeHangUpProgressState(activityId, groupTypeId)
    local allCfgList = LuaCfgMgr.GetListByCondition("ActivityHangUpItem", {ActivityID = activityId, TypeGroupID = groupTypeId})
    local list = {}
    for _, v in pairs(allCfgList) do
        local id = v.HangUPID
        local data = SelfProxyFactory.GetActivityHangUpProxy():GetDataById(id)
        if data and data.Status and (data.Status == ActivityHangUpConst.HangUpState.Progress or data.Status == ActivityHangUpConst.HangUpState.Completed) then return true end
    end
    return false
end

-- 获取挂机奖励DIYId
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:GetDIYIdByHangUpId(hangUpId)
    local cfg = LuaCfgMgr.Get("ActivityHangUpItem", hangUpId)
    local diyId = cfg.Reward and cfg.Reward[1] and cfg.Reward[1].ID
    local diyCfg = diyId and LuaCfgMgr.Get("ActivityDIYModelInfo", diyId)
    if table.isnilorempty(diyCfg) then Debug.LogError("diyCfg not found, id: " .. tostring(diyId)) return end
    return diyId
end

-- 获取挂机时间字符串
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:GetHangUpCostTimeStr(hangUpId)
    local cfg = LuaCfgMgr.Get("ActivityHangUpItem", hangUpId)
    local costTimeSeconds = cfg.HangUpTime
    local min = math.floor(costTimeSeconds / 60)
    local sec = costTimeSeconds - min * 60
    return string.format("%02d:%02d", min, sec)
end

-- 发送挂机请求
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:SendHangUpRequest(hangUpId)
    if not hangUpId then return end

    GrpcMgr.SendRequest(RpcDefines.ActivityHangUpRequest, {HangUpID = hangUpId}, true)
end

-- 发送加速请求
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:SendSpeedUpRequest(hangUpId)
    if not hangUpId then return end

    GrpcMgr.SendRequest(RpcDefines.ActivityHangUpSpeedUpRequest, {HangUpID = hangUpId}, true)
end

-- 发送领奖请求
---@param hangUpId number 挂机Id
function ActivityHangUpBLL:SendGetRewardRequest(hangUpId)
    if not hangUpId then return end

    GrpcMgr.SendRequest(RpcDefines.ActivityHangUpGetRewardRequest, {HangUpID = hangUpId}, true)
end

return ActivityHangUpBLL