------ Generated by EmmyLua(https://github.com/EmmyLua)--- Created by xiangyu.--- DateTime: 2023/5/26 17:01------@class FormationBLL:BaseBlllocal FormationBLL = class("FormationBLL", BaseBll)--region private 接口---获取槽位数量限制---@return table<int,int> 槽位类型：数量function FormationBLL:GetCardSlotLimitNum()    if self.CardSlotLimitNum ~= nil then        return self.CardSlotLimitNum    end    self.CardSlotLimitNum = {}    local allConfig = LuaCfgMgr.GetAll("TeamCardSet")    for i, v in pairs(allConfig) do        if self.CardSlotLimitNum[v.PosType] == nil then            self.CardSlotLimitNum[v.PosType] = 0        end        self.CardSlotLimitNum[v.PosType] = self.CardSlotLimitNum[v.PosType] + 1    end    return self.CardSlotLimitNumend---思念是否设置成功---@param table<int,int> key:slot value:cardID---@param int[] 不能使用的思念卡列表（主要用于多关卡编队的判断）---@return boolean 是否设置成功---@return boolean 是否全部设置解锁卡槽function FormationBLL:IsCardSetSuccess(cardIDs, noUseCards)    if cardIDs == nil then        return false, false    end    local isSetSuccess = false    local unlockSlotMap = self:TryGetUnLockCardSlot()    local posMapNoCard = PoolUtil.GetTable() --未上阵的思念卡    for i, v in pairs(unlockSlotMap) do        if v == true then            if cardIDs[i] ~= nil then                isSetSuccess = true            else                local teamCardSetCfg = LuaCfgMgr.Get("TeamCardSet", i)                if posMapNoCard[teamCardSetCfg.PosType[1]] == nil then                    posMapNoCard[teamCardSetCfg.PosType[1]] = 0                end                posMapNoCard[teamCardSetCfg.PosType[1]] = posMapNoCard[teamCardSetCfg.PosType[1]] + 1            end        end    end    local manType = self:GetCardDressMantype(cardIDs)    local roleID = manType == 0 and -1 or manType    local cards = SelfProxyFactory.GetCardDataProxy():GetCardListByRoleId(roleID)    local hasCards = PoolUtil.GetTable()    if cards ~= nil then        for i, v in pairs(cards) do            local id = v:GetPrimaryValue()            local canUse = true            if noUseCards and table.containsvalue(noUseCards, id) then                canUse = false            end            if canUse then                local isInSlot = false                for j, k in pairs(cardIDs) do                    if id == k then                        isInSlot = true                        break                    end                end                if not isInSlot then                    local baseInfo = LuaCfgMgr.Get("CardBaseInfo", id)                    local posType = baseInfo.PosType                    if hasCards[posType] == nil then                        hasCards[posType] = 0                    end                    hasCards[posType] = hasCards[posType] + 1                end            end        end    end    local setCountFull = true    for i, v in pairs(posMapNoCard) do        if hasCards[i] ~= nil and hasCards[i] > 0 then            setCountFull = false            break        end    end    PoolUtil.ReleaseTable(posMapNoCard)    PoolUtil.ReleaseTable(hasCards)    return isSetSuccess, setCountFullend---得到已经上阵的思念卡牌男主---@return int mantype 男主类型function FormationBLL:GetCardDressMantype(cards)    if cards == nil then        return 0    end    local manType = 0    for i, v in pairs(cards) do        local cfg = LuaCfgMgr.Get("CardBaseInfo", v)        if cfg ~= nil then            manType = cfg.ManType            break        end    end    return manTypeend---根据上阵的思念卡牌获取激活的套装---@param cardIDs table<int,int> key:槽位 value：上阵的思念卡牌ID---@return int 返回scoreID ,可能为0---@return int 返回SuitID，可能为0function FormationBLL:GetSuitScoreIDByCards(cardIDs)    if cardIDs == nil then        return 0, 0    end    local suitNumMap = {}    for i, v in pairs(cardIDs) do        local cardBaseInfoCfg = LuaCfgMgr.Get("CardBaseInfo", v)        if cardBaseInfoCfg ~= nil and cardBaseInfoCfg.SuitID ~= 0 then            local cardSuitCfg = LuaCfgMgr.Get("CardSuit", cardBaseInfoCfg.SuitID, 0)--同一个SuitID下的scoreID不会改变            if cardSuitCfg ~= nil then                if suitNumMap[cardBaseInfoCfg.SuitID] == nil then                    suitNumMap[cardBaseInfoCfg.SuitID] = {}                    suitNumMap[cardBaseInfoCfg.SuitID].Num = 0                    suitNumMap[cardBaseInfoCfg.SuitID].ScoreID = cardSuitCfg.ScoreID                    suitNumMap[cardBaseInfoCfg.SuitID].CardID = v                end                suitNumMap[cardSuitCfg.SuitID].Num = suitNumMap[cardSuitCfg.SuitID].Num + 1            end        end    end    local scoreID = 0    local suitID = 0    for i, v in pairs(suitNumMap) do        local cardSuitCfg = LuaCfgMgr.Get("CardSuit", i, 0)--同一个SuitID下的套装数不会改变        if v.Num >= cardSuitCfg.Num then            scoreID = cardSuitCfg.ScoreID            suitID = i            break        end    end    return scoreID, suitIDend--endregion--region 服务器通讯---请求获取阵型数据function FormationBLL:GetFormationDataRequest()    GrpcMgr.SendRequest(RpcDefines.GetFormationDataRequest, {})end---请求设置玩法编队---@param data pbcmessage.Formationfunction FormationBLL:RequestSetFormation(data)    local state = self:IsSetFormationSuccess(data)    if state == TeamConst.FormationSetState.SUCCESS or state == TeamConst.FormationSetState.SUCCESS_CARDNOFULL then        local reqMsg = {}        reqMsg.Formation = data        GrpcMgr.SendRequest(RpcDefines.SetFormationRequest, reqMsg, true)        self:ClearSelectPreFabIndex(data)    endend---请求设置预设编队---@param data pbcmessage.PreFabFormationfunction FormationBLL:RequestSetPreFabFormation(data)    -- 格式检查    local function __checkNameEmpty() return not (data and not string.isnilorempty(data.Name)) end    if __checkNameEmpty() then Debug.LogError("Set Prefab Formation Error : " .. table.dump({data})) return end    if data.SCoreID == nil or data.SCoreID == 0 then        --此时只是设置队伍名称        local requestData = {}        requestData.PreFabID = data.PreFabID        requestData.Name = data.Name        requestData.IsNameOnly = true        GrpcMgr.SendRequest(RpcDefines.SavePreFabFormationRequest, requestData, true)        return    end    local state = self:IsSetFormationSuccess(data)    if state == TeamConst.FormationSetState.SUCCESS or state == TeamConst.FormationSetState.SUCCESS_CARDNOFULL then        data.IsNameOnly = false        GrpcMgr.SendRequest(RpcDefines.SavePreFabFormationRequest, data, true)    endend---判断是否设置阵型成功---@param data pbcmessage.PreFabFormation or pbcmessage.Formation---@return Booleanfunction FormationBLL:IsSetFormationSuccess(data)    if data == nil then        return TeamConst.FormationSetState.CARDSETERROR    end    local cardSetSuccess, cardSetFull = self:IsCardSetSuccess(data.CardIDs)    if not cardSetSuccess then        --思念卡牌未设置正确        return TeamConst.FormationSetState.CARDSETERROR    end    for i, v in pairs(data.CardIDs) do        if data.CardIDs[i] == 0 then            data.CardIDs[i] = nil        end    end    if not data.SCoreID or data.SCoreID == 0 then        --战斗形态未设置正确        return TeamConst.FormationSetState.SCORESETERROR    end    if not data.WeaponId or data.WeaponId == 0 then        --女主武器未设置正确        return TeamConst.FormationSetState.WEAPONSETERROR    end    if not data.PlSuitId or data.PlSuitId == 0 then        --女主战斗装未设置正确        return TeamConst.FormationSetState.PLSUITSETERROR    end    if not cardSetFull then        --思念卡槽数量未满        return TeamConst.FormationSetState.SUCCESS_CARDNOFULL    end    return TeamConst.FormationSetState.SUCCESSend---请求进入战斗---@field stageId int 关卡id---@field teamType int 编队类型---@field hunterContestKey int 大螺旋的编队keyfunction FormationBLL:ReqDoStage(stageId, teamType, hunterContestKey)    local formationData = nil    if not self:IsTeamAllLimit(stageId) then        local teamId = self:GetTeamIdByStageId(teamType, stageId, hunterContestKey)        formationData = SelfProxyFactory.GetFormationProxy():GetFormationByGuid(teamId)        if formationData == nil then            Debug.LogError("formationData is null")            return        end    end    BllMgr.GetChapterAndStageBLL():SendDoStageT(stageId, formationData)end--endregion---获取阵型数据信息---@field key int---@field formationType int 编队类型---@field needInit boolean 是否需要初始化---@param stageId int 关卡id---@param hunterContestKey int 大螺旋的编队key---@return pbcmessage.Formation or pbcmessage.PreFabFormationfunction FormationBLL:GetFormationInfo(formationType, key, needInit, stageId, hunterContestKey)    local data = nil    local teamId = self:GetTeamIdByStageId(key, stageId, hunterContestKey)    if formationType == TeamConst.FormationType.Formation then        local isAllLimit = self:IsTeamAllLimit(stageId)        if isAllLimit then            data = {}            local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)            if cfg and cfg.TeamAllLimit then                local cards, scoreId, weaponId = self:GetAllLimitTeamData(stageId)                data.CardIDs = cards                data.SCoreID = scoreId                data.WeaponId = weaponId                --数据为空的时候使用默认战斗装                data.PlSuitId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTSKIN)            end        else            ---@type pbcmessage.Formation            data = SelfProxyFactory.GetFormationProxy():GetFormationByGuid(teamId)        end    end    if formationType == TeamConst.FormationType.PreFabFormation then        ---@type  pbcmessage.PreFabFormation        data = SelfProxyFactory.GetFormationProxy():GetPreFabFormationByID(key)    end    if needInit then        if data == nil then            data = {}            if formationType == TeamConst.FormationType.Formation then                data.Guid = teamId            else                if formationType == TeamConst.FormationType.PreFabFormation then                    data.PreFabID = key                    data.Name = UITextHelper.GetUIText(UITextConst.UI_TEXT_8339, key)                end            end        end        if data.CardIDs == nil then            data.CardIDs = {}        end        if data.WeaponId == nil or data.WeaponId == 0 then            --数据为空的时候使用默认武器            data.WeaponId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTWEAPON)        end        if data.PlSuitId == nil or data.PlSuitId == 0 then            --数据为空的时候使用默认战斗装            data.PlSuitId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTSKIN)        end        return data    end    return dataend---得到全关卡限定的上阵数据---@param stageId int 关卡id---@return table<int, int> key:槽位 value:cardID---@return int scoreId ---@return int weaponIdfunction FormationBLL:GetAllLimitTeamData(stageId)    local cards = {}    local scoreId = 0    local weaponId = 0    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil or cfg.TeamAllLimit == nil then        return nil, 0, 0    end    local cardSetID = cfg.TeamAllLimit.Type    local cardSetCfg = LuaCfgMgr.Get("CardSet", cardSetID)    if cardSetCfg ~= nil and cardSetCfg.CardID ~= nil then        for i, v in pairs(cardSetCfg.CardID) do            if v ~= 0 then                cards[i] = v            end        end    end    local scoreSetcfg = LuaCfgMgr.Get("ScoreSet", cfg.TeamAllLimit.ID)    if scoreSetcfg ~= nil then        scoreId = scoreSetcfg.ScoreID    end    local weaponSetCfg = LuaCfgMgr.Get("WeaponSet", cfg.TeamAllLimit.Num)    if weaponSetCfg ~= nil then        weaponId = weaponSetCfg.WeaponID    end    return cards, scoreId, weaponIdend---得到全限定关卡的cardSet配置---@param stageId int---@param cardID int---@return cfg.CardSetfunction FormationBLL:GetAllLimitCardSet(stageId)    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil or cfg.TeamAllLimit == nil then        return nil    end    local cardSetID = cfg.TeamAllLimit.Type    local cardSetCfg = LuaCfgMgr.Get("CardSet", cardSetID)    return cardSetCfgend---得到全限定关卡的ScoreSet配置---@param stageId int---@return cfg.ScoreSetfunction FormationBLL:GetAllLimitScoreSet(stageId)    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil or cfg.TeamAllLimit == nil then        return nil    end    local scoreSetcfg = LuaCfgMgr.Get("ScoreSet", cfg.TeamAllLimit.ID)    return scoreSetcfgend---自动设置战斗形态---@param cardIDs table<int,int> key:槽位 value：cardID---@param selectId int 上次选择的scoreId---@return int scoreIdfunction FormationBLL:GetScoreByAuto(cardIDs, selectId, selectCardIDs)    local hasEqual = true    if cardIDs and selectCardIDs then        for i = 1, TeamConst.CardSlotNum do            if cardIDs[i] ~= selectCardIDs[i] then                hasEqual = false                break            end        end    elseif cardIDs == nil and selectCardIDs == nil then        hasEqual = true    else        hasEqual = false    end    if hasEqual then        return selectId and selectId or 0    end    local manType = self:GetCardDressMantype(cardIDs)    if manType == 0 then        return 0    end    local beforeSuitScoreId = self:GetSuitScoreIDByCards(selectCardIDs)    local scoreId = self:GetSuitScoreIDByCards(cardIDs)    if scoreId ~= beforeSuitScoreId and scoreId ~= 0 then        if SelfProxyFactory.GetScoreProxy():GetScoreData(scoreId) then            return scoreId        end    end    if selectId and selectId > 0 then        local cfg = LuaCfgMgr.Get("SCoreBaseInfo", selectId)        if cfg.ManType == manType then            if SelfProxyFactory.GetScoreProxy():GetScoreData(selectId) then                return selectId            end        end    end    local list = SelfProxyFactory.GetScoreProxy():GetScoreDataList(manType)    table.sort(list, function(a, b)        local acfg = LuaCfgMgr.Get("SCoreBaseInfo", a:GetPrimaryValue())        local bcfg = LuaCfgMgr.Get("SCoreBaseInfo", b:GetPrimaryValue())        if acfg.Rare ~= bcfg.Rare then            return acfg.Rare > bcfg.Rare        end        return acfg.Rank > bcfg.Rank    end)    if #list > 0 then        return list[1]:GetPrimaryValue()    end    return 0end---获取槽位解锁列表和数量---@return table<int,boolean> key:槽位 value:是否解锁---@return int num 解锁的槽位数量function FormationBLL:TryGetUnLockCardSlot()    local unlockSlotMap = {}    local num = 0    local playerLevel = SelfProxyFactory.GetPlayerInfoProxy():GetLevel()    local allConfig = LuaCfgMgr.GetAll("TeamCardSet")    for i, v in pairs(allConfig) do        local unlock = playerLevel >= v.UnlockLevel        unlockSlotMap[i] = unlock        if unlock then            num = num + 1        end    end    return unlockSlotMap, numend---思念卡槽是否解锁---@param slot int 思念卡槽index---@return boolean 是否解锁---@return int 需要满足的解锁等级function FormationBLL:IsCardSlotUnLock(slot)    local playerLevel = SelfProxyFactory.GetPlayerInfoProxy():GetLevel()    local cfg = LuaCfgMgr.Get("TeamCardSet", slot)    return playerLevel >= cfg.UnlockLevel, cfg.UnlockLevelend---获取关卡的tag信息---@param stageId int 关卡id---@param cardIDs table<int,int>  key：槽位 value:思念id---@return table<int,table<int, boolean>> key :index : value: table = {TagID, TriggerNum, Trigger} 是否激活 可能返回nil，如果为nil则没有tag显示---@return boolean 是否全部激活function FormationBLL:TryGetLevelTag(stageId, cardIDs)    local commonStageEntryCfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if commonStageEntryCfg == nil or commonStageEntryCfg.Tag == nil then        return nil, false    end    local cardSlotTagTable = {}    if cardIDs ~= nil then        for i, cardId in pairs(cardIDs) do            if cardId > 0 then                local cardBaseInfoCfg = LuaCfgMgr.Get("CardBaseInfo", cardId)                local tagID = cardBaseInfoCfg.FormationTag                if cardSlotTagTable[tagID] == nil then                    cardSlotTagTable[tagID] = 0                end                cardSlotTagTable[tagID] = cardSlotTagTable[tagID] + 1            end        end    end    local isAllTrigger = true    local triggerTagTable = {}    for i, v in pairs(commonStageEntryCfg.Tag) do        local itemTagInfo = {}        itemTagInfo.TagID = v                                       -- TagID        itemTagInfo.TriggerNum = cardSlotTagTable[v] or 0           -- 触发次数 用于计算属性        if cardSlotTagTable[v] == nil then            itemTagInfo.Trigger = false            isAllTrigger = false        else            if cardSlotTagTable[v] > 0 then                cardSlotTagTable[v] = cardSlotTagTable[v] - 1                itemTagInfo.Trigger = true            else                itemTagInfo.Trigger = false                isAllTrigger = false            end        end        table.insert(triggerTagTable, #triggerTagTable + 1, itemTagInfo)    end    return triggerTagTable, isAllTriggerend-- 检查当前思念卡Tag是否匹配关卡Tag需求---@param stageId number 关卡Id---@param cardId number 思念Idfunction FormationBLL:CheckIfCardMatchStageTag(stageId, cardId)    if not cardId or cardId <= 0 then        return false    end    local stageCfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if not stageCfg or table.isnilorempty(stageCfg.Tag) then        return false    end    local cardBaseInfoCfg = LuaCfgMgr.Get("CardBaseInfo", cardId)    if not cardBaseInfoCfg then        return false    end    local tagId = cardBaseInfoCfg.FormationTag    return table.containsvalue(stageCfg.Tag, tagId)end---得到编队阵型的数量function FormationBLL:GetTeamPresetNum()    return LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.TEAMPRESETNUM)end---@class GetPropertiesTeamTypeParams 获取属性时基于特殊编队类型的特殊参数定义---@field rankLevel number 大螺旋用参数---得到属性信息（不包含牵绊度）---@param cardMap table<int,int> key:cardSlot value:cardID---@param scoreID int---@param teamType number 编队类型 (可选参数)---@param extraParams GetPropertiesTeamTypeParams 获取属性时基于特殊编队类型的特殊参数 (可选参数)---@return table<int,int> key:PropertyType  value:PropertyValue, 可能为空function FormationBLL:GetAllPropertiesByCard(cardMap, scoreID, teamType, extraParams)    teamType = teamType or TeamConst.TeamType.MainLineBattle    local map = DevelopPropertyUtil.CreateProperty()    for k, v in pairs(cardMap) do        if v ~= 0 then            local cardProperties            if teamType == TeamConst.TeamType.HunterContest then                cardProperties = BllMgr.GetHunterContestBLL():GetCardProperties(v, extraParams.rankLevel)            else                cardProperties = SelfProxyFactory.GetCardDataProxy():GetCardCurProperties(v)            end            if cardProperties ~= nil then                local developProperty = DevelopPropertyUtil.CreatePropertyByMap(cardProperties)                map:AddPropertys(developProperty)            end        end    end    if scoreID ~= nil then        local sCoreBaseInfoCfg = LuaCfgMgr.Get("SCoreBaseInfo", scoreID)        if sCoreBaseInfoCfg ~= nil then            map:AddProperty(X3_CFG_CONST.PROPERTY_CRITHURTADD, sCoreBaseInfoCfg.CritHurtAdd)        end    end    return mapend---得到牵绊度属性信息（只包含牵绊度）---@param cardMap table<int,int> key:cardSlot value:cardID---@return table<int,int> key:PropertyType  value:PropertyValue, 可能为空function FormationBLL:GetAllPropertysInLove(cardMap)    local manType = self:GetCardDressMantype(cardMap)    if manType == 0 then        return nil    end    local map = DevelopPropertyUtil.CreateProperty()    local lovePointLevel = BllMgr.GetRoleBLL():GetRoleLoveLevel(manType)    local loveCfg = LuaCfgMgr.Get("LovePointLevel", lovePointLevel)    if loveCfg then        map:AddProperty(X3_CFG_CONST.PROPERTY_MAXHP, loveCfg.PropMaxHP)        map:AddProperty(X3_CFG_CONST.PROPERTY_PHYATTACK, loveCfg.PropPhyAtk)        map:AddProperty(X3_CFG_CONST.PROPERTY_PHYDEFENCE, loveCfg.PropPhyDef)    end    return mapend---获取服务器编队数据---@param index int---@return pbcmessage.PreFabFormation 可能为nilfunction FormationBLL:GetPreFabFormationByID(index)    return SelfProxyFactory.GetFormationProxy():GetPreFabFormationByID(index)endlocal function GetWeight(scoreId, selectId, limit, suitScore, roleId)    local cfg = LuaCfgMgr.Get("SCoreBaseInfo", scoreId)    if scoreId == selectId then        return 5 -- 上次选择    end    if suitScore == scoreId then        return 4 --套装id    end    if cfg ~= nil and cfg.ManType ~= roleId then        return 2    end    if not limit then        --编队限制        return 1    end    return 3end---获取当前关卡的score列表---@param stageId int---@param lastSelectId int---@return table<X3Data.SCore> 上次选择>已拥有>禁用，同类型内按品质>ID排序。---@return int roleIdfunction FormationBLL:GetScoreDataList(stageId, cards, lastSelectId)    local roleId = self:GetCardDressMantype(cards)    local scoreList = SelfProxyFactory.GetScoreProxy():GetScoreDataList()    local suitScore = self:GetSuitScoreIDByCards(cards)    table.sort(scoreList, function(a, b)        local aID = a:GetPrimaryValue()        local bID = b:GetPrimaryValue()        local state, aLimit = self:GetScoreUseState(stageId, aID, roleId)        local state, bLimit = self:GetScoreUseState(stageId, bID, roleId)        local aWeight = GetWeight(aID, lastSelectId, aLimit, suitScore, roleId)        local bWeight = GetWeight(bID, lastSelectId, bLimit, suitScore, roleId)        if aWeight == bWeight then            local acfg = LuaCfgMgr.Get("SCoreBaseInfo", aID)            local bcfg = LuaCfgMgr.Get("SCoreBaseInfo", bID)            if acfg.Rare ~= bcfg.Rare then                return acfg.Rare > bcfg.Rare            else                return acfg.Rank > bcfg.Rank            end        else            return aWeight > bWeight        end    end)    return scoreList, roleIdend---得到当前score的使用状态---@param stageId int 关卡id---@param scoreId int scoreid---@return int TeamConst.ScoreUseState ---score使用状态类型function FormationBLL:GetScoreUseState(stageId, scoreId, roleId)    local unlock = SelfProxyFactory.GetScoreProxy():ScoreIsUnlock(scoreId)    if not unlock then        return TeamConst.ScoreUseState.NOHAS, false    end    local cfg = LuaCfgMgr.Get("SCoreBaseInfo", scoreId)    if cfg.ManType ~= roleId then        return TeamConst.ScoreUseState.NOUSE_ROLELIMIT, false    end    local commonStageEntryCfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if commonStageEntryCfg and commonStageEntryCfg.TeamLimit then        local teamLimitCfg = LuaCfgMgr.Get("TeamLimit", commonStageEntryCfg.TeamLimit)        if teamLimitCfg then            if teamLimitCfg.LimitType == X3_CFG_CONST.TIMELIMIT_ROLE then                if not table.containsvalue(teamLimitCfg.Params, cfg.ManType) then                    return TeamConst.ScoreUseState.NOUSE_ROLELIMIT, false                end            end            if teamLimitCfg.LimitType == X3_CFG_CONST.TIMELIMIT_NOROLE then                if table.containsvalue(teamLimitCfg.Params, cfg.ManType) then                    return TeamConst.ScoreUseState.NOUSE_ROLELIMIT, false                end            end        end    end    return TeamConst.ScoreUseState.CANUSE, trueend---通过weaponid获取cfg_MyWeaponType配置---@param weaponId int---@return cfg_MyWeaponTypefunction FormationBLL:GetMyWeaponTypeCfgByWeaponId(weaponId)    local cfgWeaponID = 0    if weaponId == nil or weaponId == 0 then        cfgWeaponID = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTWEAPON)    else        cfgWeaponID = weaponId    end    local cfg_MyWeapon = LuaCfgMgr.Get("MyWeapon", cfgWeaponID)    local cfg_MyWeaponType = LuaCfgMgr.Get("MyWeaponType", cfg_MyWeapon.WeaponType)    return cfg_MyWeaponTypeend---获取女主当前所使用套装id---@param formationType int 编队类型 TeamConst.FormationType.Formation：玩法编队 TeamConst.FormationType.PreFabFormation：预设编队---@param id int 编队id---@return int suitIdfunction FormationBLL:GetMyCurrentFashionSuitID(formationType, id)    if id == nil or id == 0 then        return LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTSKIN)    end    local suitId = 0    if formationType == TeamConst.FormationType.Formation then        local data = SelfProxyFactory.GetFormationProxy():GetFormationByGuid(id)        suitId = data == nil and 0 or data.PlSuitId    else        if formationType == TeamConst.FormationType.PreFabFormation then            local data = SelfProxyFactory.GetFormationProxy():GetPreFabFormationByID(id)            suitId = data == nil and 0 or data.PlSuitId        end    end    if suitId == nil or suitId == 0 then        --没有穿戴，就走默认初始配置        suitId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTSKIN)    end    return suitIdend--获得武器数据function FormationBLL:GetWeaponData(weaponType, selectId)    local weaponData = BllMgr.GetWeaponBLL():GetWeapons(weaponType)    table.sort(weaponData, function(a, b)        local isUnlock1 = BllMgr.GetWeaponBLL():GetServerWeapon(a.MyWeaponID) and 1 or 0        local isUnlock2 = BllMgr.GetWeaponBLL():GetServerWeapon(b.MyWeaponID) and 1 or 0        if selectId ~= nil then            if a.MyWeaponID == selectId then                return true            end            if b.MyWeaponID == selectId then                return false            end        end        if isUnlock1 ~= isUnlock2 then            return isUnlock1 > isUnlock2        end        local redCount1 = BllMgr.GetWeaponBLL():GetWeaponRedDotCount(a.MyWeaponID)        local redCount2 = BllMgr.GetWeaponBLL():GetWeaponRedDotCount(b.MyWeaponID)        if redCount1 ~= redCount2 then            return redCount1 > redCount2        end        local exclusive1 = BllMgr.GetWeaponBLL():IsExclusiveWeapon(a.MyWeaponID) and 1 or 0        local exclusive2 = BllMgr.GetWeaponBLL():IsExclusiveWeapon(b.MyWeaponID) and 1 or 0        if exclusive1 ~= exclusive2 then            return exclusive1 > exclusive2        end        if a.WeaponType ~= b.WeaponType then            return a.WeaponType > b.WeaponType        end        if a.Rank ~= b.Rank then            return a.Rank > b.Rank        end        return a.MyWeaponID > b.MyWeaponID    end)    return weaponDataend---是否专属武器---@param weaponId int---@return boolfunction FormationBLL:IsExclusiveWeapon(weaponId)    if not self.exclusiveWeaponData then        self.exclusiveWeaponData = {}        ---@type cfg.SCoreBaseInfo[]        local AllScoreBaseInfo_cfg = LuaCfgMgr.GetAll("SCoreBaseInfo")        for k, v in pairs(AllScoreBaseInfo_cfg) do            if v.WeaponID ~= 0 then                self.exclusiveWeaponData[v.WeaponID] = v.ID            end        end    end    return table.containskey(self.exclusiveWeaponData, weaponId), self.exclusiveWeaponData[weaponId]end--获得女主皮肤数据function FormationBLL:GetMyFashionData()    if not self.fashionData then        self.fashionData = LuaCfgMgr.GetListByCondition("FormationSuit", { ScoreID = 0 })    end    local showFashionData = {}    for i, v in pairs(self.fashionData) do        if BllMgr.GetItemBLL():GetItemNum(v.SuitID) == 0 then            if v.ShopGoodsID == nil then                table.insert(showFashionData, { cfg = v, state = GameConst.TeamSwitchFashionState.Lock })            else                local isCan, showTip, limitType = self:IsCanBuy(v)                if isCan then                    table.insert(showFashionData, { cfg = v, state = GameConst.TeamSwitchFashionState.CanBuy })                else                    if not limitType then                        --商城未显示时搭档列表也不显示                        table.insert(showFashionData, { cfg = v, state = GameConst.TeamSwitchFashionState.NoBuy, showTip = showTip })                    end                end            end        else            local value = RedPointMgr.GetValue(X3_CFG_CONST.RED_FORMATIONSUIT_NEW, v.SuitID)            table.insert(showFashionData, { cfg = v, state = value == 1 and GameConst.TeamSwitchFashionState.NewGet or GameConst.TeamSwitchFashionState.Normal })        end    end    table.sort(showFashionData, function(a, b)        if a.state ~= b.state then            return a.state > b.state        end        return a.cfg.Rank > b.cfg.Rank    end)    return showFashionDataendlocal function GetFashionSuitWeight(selectId, suitId, scoreId)    if suitId == selectId then        return 4    end    local isTag = BllMgr.GetScoreBLL():Is_Couple_SuitId_ScoreId(suitId, scoreId)    if isTag then        --是否是专属        return 3    end    local isForbidden = BllMgr.GetScoreBLL():Is_Forbidden_SuitId_ScoreId(suitId, scoreId)    if isForbidden then        return 1    end    return 2end---获取战斗装对应的商品Cfg---@param formationSuitID int---@return cfg.ShopGroup 可能为nilfunction FormationBLL:GetShopCfgByFormationSuit(formationSuitID)    local shopGroupData = nil    local suitCfg = LuaCfgMgr.Get("FormationSuit", formationSuitID)    if suitCfg and suitCfg.ShopGoodsID ~= nil then        for i, v in ipairs(suitCfg.ShopGoodsID) do            local shopGroupDataCfg = LuaCfgMgr.Get("ShopGroup", v)            if shopGroupDataCfg ~= nil and BllMgr.GetShopMallBLL():CheckShopIsOpen(shopGroupDataCfg.ShopID) and BllMgr.GetShopMallBLL():CheckShopGoodsIsShow(shopGroupDataCfg, true) then                shopGroupData = shopGroupDataCfg                break            end        end    end    return shopGroupDataend---获取编队的fashion数据function FormationBLL:GetFormationFashionData(selectId, scoreId)    if not self.formationFashionData then        self.formationFashionData = LuaCfgMgr.GetListByCondition("FormationSuit", { ScoreID = 0 })    end    local showFashionData = {}    for i, v in pairs(self.formationFashionData) do        if BllMgr.GetItemBLL():GetItemNum(v.SuitID) ~= 0 then            table.insert(showFashionData, { cfg = v })        end    end    table.sort(showFashionData, function(a, b)        local aWeight = GetFashionSuitWeight(selectId, a.cfg.SuitID, scoreId)        local bWeight = GetFashionSuitWeight(selectId, b.cfg.SuitID, scoreId)        if aWeight == bWeight then            return a.cfg.Rank > b.cfg.Rank        else            return aWeight > bWeight        end    end)    return showFashionDataendlocal function GetFashionDataWeight(cfg, selectId)    if cfg.SuitID == selectId then        return 3    end    if cfg.CoupleSCoreID ~= 0 then        return 2 -- 是否是专属    end    return 1end---获取拥有的fashion列表function FormationBLL:GetFormationFashionDataByOwner(selectId)    if not self.formationFashionData then        self.formationFashionData = LuaCfgMgr.GetListByCondition("FormationSuit", { ScoreID = 0 })    end    local showFashionData = {}    for i, v in pairs(self.formationFashionData) do        if BllMgr.GetItemBLL():GetItemNum(v.SuitID) ~= 0 then            table.insert(showFashionData, { cfg = v })        end    end    table.sort(showFashionData, function(a, b)        local aWeight = GetFashionDataWeight(a.cfg, selectId)        local bWeight = GetFashionDataWeight(b.cfg, selectId)        if aWeight == bWeight then            return a.cfg.Rank > b.cfg.Rank        else            return aWeight > bWeight        end    end)    return showFashionDataend---设置预设编队信息到玩法编队并返回数据---@param key int 玩法编队id---@param index int 阵前编队id---@param stageId int 关卡id---@return pbcmessage.Formationfunction FormationBLL:GetSetFormationData(key, index, stageId)    local preFormationData = self:GetFormationInfo(TeamConst.FormationType.PreFabFormation, index, true)    local data = {}    data.Guid = self:GetTeamIdByStageId(key, stageId)    data.WeaponId = preFormationData.WeaponId    data.PlSuitId = preFormationData.PlSuitId    data.SCoreID = preFormationData.SCoreID    data.CardIDs = preFormationData.CardIDs    return dataendfunction FormationBLL:IsCanBuy(suitData)    local checkGoods = function(shopGroupData)        if not shopGroupData then            return false, nil        end        if not BllMgr.GetShopMallBLL():CheckShopIsOpen(shopGroupData.ShopID) then            return false, nil, true        end        local isCanShow, limitType = BllMgr.GetShopMallBLL():CheckShopGoodsIsShow(shopGroupData, false)        if not isCanShow then            return false, nil, limitType        end        if not BllMgr.GetShopMallBLL():ShopGoodsIsHave(shopGroupData.ID) then            return false, UITextConst.UI_TEXT_9494        end        if BllMgr.GetShopMallBLL():IsSoldOut(shopGroupData) then            return false, UITextConst.UI_TEXT_9362        end        return ConditionCheckUtil.CheckConditionByIntList(shopGroupData.PurchaseCondition), shopGroupData.PurchaseTips    end    local canBuy, tips, limitType    local suitCfg = LuaCfgMgr.Get("FormationSuit", suitData.SuitID)    if suitCfg and suitCfg.ShopGoodsID ~= nil then        for i, v in ipairs(suitCfg.ShopGoodsID) do            local shopGroupDataCfg = LuaCfgMgr.Get("ShopGroup", v)            if shopGroupDataCfg ~= nil then                canBuy, tips, limitType = checkGoods(shopGroupDataCfg)                if canBuy then                    break                end            end        end    end    return canBuy, tips, limitTypeend---得到推荐等级---@param stageId int 关卡id---@param cards table<int,int> key:槽位 value：cardID---@return int level 关卡等级---@return boolean 是否满足推荐等级function FormationBLL:GetRecommendLevel(stageId, cards)    local commonStageEntryCfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    local stageLevel = commonStageEntryCfg.RecoLevel    if cards == nil then        return stageLevel, true    end    local isReach = true    for i, v in pairs(cards) do        local cardData = SelfProxyFactory.GetCardDataProxy():GetData(v)        if cardData then            local cardLevel = cardData:GetLevel()            if cardLevel < stageLevel then                isReach = false                break            end        end    end    return stageLevel, isReachend---是否解锁武器大类---@param weaponType int 武器类型---@return Boolean 是否解锁武器大类function FormationBLL:IsLockWeaponType(weaponType)    local weaponCfg = LuaCfgMgr.Get("MyWeaponType", weaponType)    return ConditionCheckUtil.CheckConditionByCommonConditionGroupId(weaponCfg.Condition)end---得到关卡限制的思念卡牌---@param stageId int 关卡id---@param cardId int 思念卡id---@return Boolean 是否可以使用 true:可以使用function FormationBLL:IsCardLimitUse(stageId, cardId)    if stageId == nil then        return true    end    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil then        return true    end    local cardCfg = LuaCfgMgr.Get("CardBaseInfo", cardId)    if cfg.TeamLimit ~= 0 then        local teamLimitCfg = LuaCfgMgr.Get("TeamLimit", cfg.TeamLimit)        if teamLimitCfg then            if teamLimitCfg.LimitType == X3_CFG_CONST.TIMELIMIT_ROLE then                if not table.containsvalue(teamLimitCfg.Params, cardCfg.ManType) then                    return false                end            end            if teamLimitCfg.LimitType == X3_CFG_CONST.TIMELIMIT_NOROLE then                if table.containsvalue(teamLimitCfg.Params, cardCfg.ManType) then                    return false                end            end        end    end    if cfg.TeamAllLimit then        local cardSetID = cfg.TeamAllLimit.Type        local cardSetCfg = LuaCfgMgr.Get("CardSet", cardSetID)        if cardSetCfg == nil or cardSetCfg.CardID == nil then            return true        end        return table.containsvalue(cardSetCfg.CardID, cardId)    end    return trueend---得到当前关卡可以使用的角色类型数据---@param stageId int 关卡id---@return table<int,cfg.RoleInfo> 可能为nilfunction FormationBLL:GetCurrentStageUseRoleType(stageId)    local roleMap = {}    local roleList = BllMgr.GetRoleBLL():GetRoleCfgList()    for i, v in pairs(roleList) do        if v.IsOpen == 1 then            roleMap[v.ID] = v        end    end    if stageId == nil then        return roleMap    end    ---@type cfg.CommonStageEntry    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil then        return roleMap    end    if cfg.TeamLimit ~= 0 then        ---@type cfg.TeamLimit        local teamLimitCfg = LuaCfgMgr.Get("TeamLimit", cfg.TeamLimit)        if teamLimitCfg then            if teamLimitCfg.LimitType == X3_CFG_CONST.TIMELIMIT_ROLE then                for i, v in pairs(roleMap) do                    if not table.containsvalue(teamLimitCfg.Params, i) then                        roleMap[i] = nil                    end                end            elseif teamLimitCfg.LimitType == X3_CFG_CONST.TIMELIMIT_NOROLE then                for i, v in ipairs(teamLimitCfg.Params) do                    if roleMap[v] then                        roleMap[v] = nil                    end                end            end        end    end    return roleMapend---得到关卡限制的score(全限定)---@param stageId int 关卡id---@param scoreId int scoreId---@return Boolean 是否可以使用 true:可以使用function FormationBLL:IsScoreLimitUse(stageId, scoreId)    if stageId == nil then        return true    end    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil or cfg.TeamAllLimit == nil then        return true    end    local scoreSetcfg = LuaCfgMgr.Get("ScoreSet", cfg.TeamAllLimit.ID)    if scoreSetcfg == nil or scoreSetcfg.ScoreID == nil then        return true    end    return scoreSetcfg.ScoreID == scoreIdend---得到关卡限制的Weapon(全限定)---@param stageId int 关卡id---@param weaponID int scoreId---@return Boolean 是否可以使用 true:可以使用function FormationBLL:IsWeaponLimitUse(stageId, weaponID)    if stageId == nil then        return true    end    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil or cfg.TeamAllLimit == nil then        return true    end    local weaponSetCfg = LuaCfgMgr.Get("WeaponSet", cfg.TeamAllLimit.Num)    if weaponSetCfg == nil then        return true    end    return weaponSetCfg.WeaponID == weaponIDend---当前编队是否可以使用---@param stageId int 关卡id---@param teamId int 阵容id---@return Boolean true：可以使用function FormationBLL:IsCanUsePreFabFormation(stageId, teamId)    local formationData = SelfProxyFactory.GetFormationProxy():GetPreFabFormationByID(teamId)    if formationData == nil then        --阵型为空，可以直接使用        return true    end    for i, v in pairs(formationData.CardIDs) do        if not self:IsCardLimitUse(stageId, v) then            return false        end    end    if not self:IsScoreLimitUse(stageId, formationData.SCoreID) then        return false    end    if not self:IsWeaponLimitUse(stageId, formationData.WeaponId) then        return false    end    return trueend---是否是全限定关卡---@param stageId int 关卡id---@return Boolean 是否是全限定关卡function FormationBLL:IsTeamAllLimit(stageId)    if stageId == nil then        return false    end    local cfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg == nil then        return false    end    return not table.isnilorempty(cfg.TeamAllLimit)end---根据关卡获得teamid(拿之前的逻辑)---@param stageId int 关卡id---@param teamType int 编队类型---@param hunterContestKey int  大螺旋的编队key---@return int teamIdfunction FormationBLL:GetTeamIdByStageId(teamType, stageId, hunterContestKey)    local teamId = teamType    if teamType == TeamConst.TeamType.SoulTrial then        local soulTrialId = BllMgr.GetSoulTrialBLL():GetSoulTrialIdByStageId(stageId)        --深空试炼类型特殊处理 stageId == SoulTrial表格ID        local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)        if cfg_SoulTrial.RoleID <= 0 then            teamId = 17        else            teamId = 11 + cfg_SoulTrial.RoleID        end    elseif teamType == TeamConst.TeamType.TowerBattle then        teamId = X3_CFG_CONST.TEAM_TOWER    elseif teamType == TeamConst.TeamType.CombatSupplies then        teamId = X3_CFG_CONST.TEAM_TRIAL_1    elseif teamType == TeamConst.TeamType.FettersUpgrade then        teamId = X3_CFG_CONST.TEAM_TRIAL_2    elseif teamType == TeamConst.TeamType.FettersBreakout then        teamId = X3_CFG_CONST.TEAM_TRIAL_3    elseif teamType == TeamConst.TeamType.PledgeSpecialTraining then        teamId = X3_CFG_CONST.TEAM_TRIAL_4    elseif teamType == TeamConst.TeamType.GemCore then        teamId = self:GetGemCoreTeamId(stageId)    elseif teamType == TeamConst.TeamType.Doll then        teamId = X3_CFG_CONST.TEAM_TRIAL_5    elseif teamType == TeamConst.TeamType.HunterContest then        --猎人锦标赛        teamId = hunterContestKey    end    return teamIdend---得到芯核副本的队伍id---@param stageId int 关卡id---@return int 得到芯核副本的队伍idfunction FormationBLL:GetGemCoreTeamId(stageId)    ---@type cfg.CommonStageEntry    local cfg_all_GemCoreInstance = LuaCfgMgr.GetAll("GemCoreInstance")    for _, cfg_GemCoreInstance in pairs(cfg_all_GemCoreInstance) do        for _, id in pairs(cfg_GemCoreInstance.LevelList) do            if id == stageId then                return cfg_GemCoreInstance.TeamType            end        end    end    return nilendfunction FormationBLL:GetPlCoupleScoreId(plSuitId)    ---@type cfg.FormationSuit    local cfg_FormationSuit = LuaCfgMgr.Get("FormationSuit", plSuitId)    ---当前男主对应的女主情侣套装    local coupleScoreId = cfg_FormationSuit and cfg_FormationSuit.CoupleSCoreID or 0    return coupleScoreIdend---得到匹配的战斗装---@param scoreId int---@param curPlSuitId int 当前的战斗装---@return int 返回匹配的战斗装idfunction FormationBLL:GetPlCoupleSuitID(scoreId, curPlSuitId)    if scoreId == 0 then        return LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTSKIN)    end    local plSuitId = curPlSuitId    local cfg_FormationSuit = LuaCfgMgr.Get("FormationSuit", curPlSuitId)    if cfg_FormationSuit then        if cfg_FormationSuit.CoupleSCoreID ~= 0 and cfg_FormationSuit.CoupleSCoreID ~= scoreId then            plSuitId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTSKIN)        elseif cfg_FormationSuit.CoupleSCoreID == scoreId then            return plSuitId        end    end    local scoreCurSuit = BllMgr.GetFashionBLL():GetCurEquipSuitId(scoreId)    ---@type cfg.FormationSuit    local cfg_scoreFormationSuit = LuaCfgMgr.Get("FormationSuit", scoreCurSuit)    if cfg_scoreFormationSuit then        if cfg_scoreFormationSuit.CoupleSuitID ~= 0 then            if BllMgr.GetFashionBLL():IsSuitIdUnlock(cfg_scoreFormationSuit.CoupleSuitID) then                plSuitId = cfg_scoreFormationSuit.CoupleSuitID                return plSuitId            end        end    end    ---@type cfg.FormationSuit[]    local suitDatas_cfg = LuaCfgMgr.GetListByCondition("FormationSuit", { CoupleSCoreID = scoreId })    for k, v in pairs(suitDatas_cfg) do        if BllMgr.GetFashionBLL():IsSuitIdUnlock(v.SuitID) then            plSuitId = v.SuitID            return plSuitId        end    end    return plSuitIdend---得到自动匹配武器和皮肤情况---@return Boolean 是否自动匹配function FormationBLL:GetAutoMatchWeaponPlSuitToggle()    local autoMatch = false    local hasKey = BllMgr.GetPlayerServerPrefsBLL():HasKey(GameConst.CustomDataIndex.FORMATION_AUTOMATCHWEAPONANDPLSUIT)    if not hasKey then        self:SetAutoMatchWeaponPlSuitToggle(true)        autoMatch = true    else        local num = BllMgr.GetPlayerServerPrefsBLL():GetInt(GameConst.CustomDataIndex.FORMATION_AUTOMATCHWEAPONANDPLSUIT)        autoMatch = num == 1 and true or false    end    return autoMatchend---设置自动匹配情况---@param num int 0:不自动匹配 1：自动匹配function FormationBLL:SetAutoMatchWeaponPlSuitToggle(toggle)    local num = toggle == true and 1 or 0    BllMgr.GetPlayerServerPrefsBLL():SetInt(GameConst.CustomDataIndex.FORMATION_AUTOMATCHWEAPONANDPLSUIT, num)end---得到选择的预设编队Index---@param formationData pbcmessage.Formation---@return int 得到选择的预设编队Index -1表示没有选择function FormationBLL:GetSelectPreFabIndex(formationData)    local chooseIndex = PlayerPrefs.GetInt(string.format("%s_%s", TeamConst.FormationChoosePreFabKey,            tostring(formationData.Guid)))    local preFabFormation = SelfProxyFactory.GetFormationProxy():GetPreFabFormationByID(chooseIndex)    if preFabFormation == nil then        return -1    end    if not self:CheckFormationEqual(preFabFormation, formationData) then        self:ClearSelectPreFabIndex(formationData)        return -1    end    return chooseIndexend---对比两个编队信息是否相等---@param preFabFormation pbcmessage.Formation---@param formationData pbcmessage.Formation---@return booleanfunction FormationBLL:CheckFormationEqual(preFabFormation, formationData)    if self:CheckCardsEqual(preFabFormation.CardIDs, formationData.CardIDs) == false then        return false    end    if preFabFormation.SCoreID ~= formationData.SCoreID then        return false    end    if preFabFormation.PlSuitId ~= formationData.PlSuitId then        return false    end    if preFabFormation.WeaponId ~= formationData.WeaponId then        return false    end    return trueend---检查思念卡是否相同---@param preFabCards table<number,number> @ key:槽位 value：思念ID---@param currentCards table<number,number> @ key:槽位 value：思念IDfunction FormationBLL:CheckCardsEqual(preFabCards, currentCards)    if preFabCards and currentCards then        local preFabCount = 0        for i, v in pairs(preFabCards) do            if currentCards[i] == nil or currentCards[i] ~= v then                return false            end            preFabCount = preFabCount + 1        end        local formationCount = 0        for i, v in pairs(currentCards) do            if preFabCards[i] == nil or preFabCards[i] ~= v then                return false            end            formationCount = formationCount + 1        end        if preFabCount ~= formationCount then            return false        end    end    if currentCards == nil then        if preFabCards ~= nil then            return false        end    end    if preFabCards == nil then        if currentCards ~= nil then            return false        end    end    return trueend---设置玩法编队选择的预设编队index---@param formationData pbcmessage.Formation---@param index int 选择的indexfunction FormationBLL:SetSelectPreFabIndex(formationData, index)    PlayerPrefs.SetInt(string.format("%s_%s", TeamConst.FormationChoosePreFabKey,            tostring(formationData.Guid)), index)end---清除玩法编队选择的预设编队index---@param formationData pbcmessage.Formationfunction FormationBLL:ClearSelectPreFabIndex(formationData)    PlayerPrefs.SetInt(string.format("%s_%s", TeamConst.FormationChoosePreFabKey,            tostring(formationData.Guid)), 0)end--region 多关卡编队---设置多关卡编队信息，并返回多关卡编队数据---@param stageId int 第几个编队---@param formationData pbcmessage.Formationfunction FormationBLL:SetMultipleStageFormationData(stageId, formationData)    if self.multipleStageMap == nil then        self.multipleStageMap = {}    end    self.multipleStageMap[stageId] = formationDataend---得到思念卡所在的编队队伍序号---@param cardID int 上阵的思念卡牌ID---@return int 所在的编队序号，没有，返回0function FormationBLL:GetCardFormationIndex(cardID)    if self.multipleStageMap == nil then        return 0    end    local stageId = 0    local cardIndex = 0    for i, v in pairs(self.multipleStageMap) do        if v.CardIDs ~= nil then            for slot, k in pairs(v.CardIDs) do                if k == cardID then                    stageId = i                    cardIndex = slot                    break                end            end            if stageId > 0 then                break            end        end    end    if stageId > 0 then        return BllMgr.GetSoulTrialBLL():GetStageIndex(stageId), cardIndex    end    return 0, 0end---获取多关卡编队信息---@param stageId int 关卡id---@param needInit boolean 是否需要初始化---@return pbcmessage.Formation 可能为nilfunction FormationBLL:GetMultipleStageFormationByStageId(stageId, needInit)    if self.multipleStageMap ~= nil and self.multipleStageMap[stageId] then        return self.multipleStageMap[stageId]    end    local formationData = nil    local serverData = SelfProxyFactory.GetFormationProxy():GetFormationByGuid(stageId) --self.multipleStageMap[stageId]    if serverData then        formationData = table.clone(serverData)        formationData.Guid = 0        if self.multipleStageMap == nil then            self.multipleStageMap = {}        end        self.multipleStageMap[stageId] = formationData    end    if not needInit then        return formationData    end    if self.multipleStageMap == nil then        if needInit then            self.multipleStageMap = {}        else            return nil        end    end    if formationData == nil then        formationData = {}        formationData.Guid = 0        formationData.CardIDs = {}        formationData.SCoreID = 0        formationData.WeaponId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTWEAPON)        formationData.PlSuitId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLAYERDEFAULTSKIN)    end    self.multipleStageMap[stageId] = formationData    return formationDataend---得到多关卡除去当前关卡的的所有上阵思念卡---@param stageID int 当前关卡---@return int[] 使用过的思念卡IDfunction FormationBLL:GetNoStageIdMultipleStageUseCards(stageID)    if self.multipleStageMap == nil then        return nil    end    local cards = {}    for i, v in pairs(self.multipleStageMap) do        if v then            if i ~= stageID and v.CardIDs then                for j, k in pairs(v.CardIDs) do                    table.insert(cards, k)                end            end        end    end    return cardsend---获取多关卡编队信息---@param soulTrialId int---@param stageIndex int 第几个关卡---@param needInit boolean 是否需要初始化---@return pbcmessage.Formation 可能为nilfunction FormationBLL:GetMultipleStageFormation(soulTrialId, stageIndex, needInit)    local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)    local stageId = cfg_SoulTrial.MissionID[stageIndex]    return self:GetMultipleStageFormationByStageId(stageId, needInit)end---立即向服务器同步当前的多关卡编队数据---@param soulTrialId number 深空试炼Idfunction FormationBLL:CheckRequestCurrentMultiFormationData(soulTrialId)    local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)    local allStageNum = #cfg_SoulTrial.MissionID    local mapNum = 0    for i, v in pairs(self.multipleStageMap) do        local itemCurrentState = self:IsSetFormationSuccess(v)        if itemCurrentState ~= TeamConst.FormationSetState.SUCCESS and itemCurrentState ~= TeamConst.FormationSetState.SUCCESS_CARDNOFULL then            --Debug.Log("当前关卡设置失败" .. table.dump({i, itemCurrentState, v}))            return        end        mapNum = mapNum + 1    end    if mapNum ~= allStageNum then        --Debug.Log("多关卡还有没有设置的关卡")        return    end    self:RequestStagesToServer()end---请求设置多关卡编队 需要保证关卡编队数据是正常非空---@param data pbcmessage.Formationfunction FormationBLL:SetMultipleStageFormationRequest(data, soulTrialId, index)    local stageIndex = index == nil and 1 or index    local currentState = self:IsSetFormationSuccess(data)    if currentState ~= TeamConst.FormationSetState.SUCCESS and currentState ~= TeamConst.FormationSetState.SUCCESS_CARDNOFULL then        Debug.LogFormat("当前关卡%d设置失败", stageIndex)        return    end    local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)    local stageId = cfg_SoulTrial.MissionID[stageIndex]    local allStageNum = #cfg_SoulTrial.MissionID    if self.multipleStageMap == nil then        self.multipleStageMap = {}    end    self.multipleStageMap[stageId] = table.clone(data)    local mapNum = 0    local isSetError = false    for i, v in pairs(self.multipleStageMap) do        if i ~= stageId then            local itemCurrentState = self:IsSetFormationSuccess(v)            if itemCurrentState ~= TeamConst.FormationSetState.SUCCESS and itemCurrentState ~= TeamConst.FormationSetState.SUCCESS_CARDNOFULL then                Debug.LogFormat("当前关卡%d设置失败", i)                isSetError = true                break            end        end        mapNum = mapNum + 1    end    if isSetError then        return    end    if mapNum ~= allStageNum then        Debug.LogFormat("多关卡还有没有设置的关卡")        return    end        self:RequestStagesToServer()end---请求设置多关卡编队function FormationBLL:RequestStagesToServer()    for j, k in pairs(self.multipleStageMap) do        if k then            k.Guid = 0 -- 多关卡stage请求要求Guid == 0        end    end    local requestData = {}    requestData.StageFormations = self.multipleStageMap    GrpcMgr.SendRequest(RpcDefines.SetStageFormationRequest, requestData, true)end--- 检查多关卡编队的思念上阵情况---@param showTips bool 是否弹出提示---@return bool, table<number, number> 返回一个bool result (是否通过), table result (没上满思念槽位的队伍序号列表)function FormationBLL:CheckMultiFormationCardList(showTips)    local dataMap = self.multipleStageMap    if table.isnilorempty(dataMap) then        if showTips then            UICommonUtil.ShowMessage(UITextHelper.GetUIText(UITextConst.UI_TEXT_21384))        end        return false    end    -- 已经解锁的槽位    local unlockSlotMap = BllMgr.GetFormationBLL():TryGetUnLockCardSlot()    -- 没有上满思念的队伍idx list    local notFullTeamIdxList = {}    for stageId, formationData in pairs(dataMap) do        local cardMap = formationData.CardIDs        local cardMapEmpty = true        local cardMapFull = true        for i = 1, TeamConst.CardSlotNum do            if unlockSlotMap[i] and cardMap[i] and cardMap[i] > 0 then                cardMapEmpty = false            end            if unlockSlotMap[i] and (not cardMap[i] or cardMap[i] == 0) then                cardMapFull = false            end        end        -- 该队伍没有上阵思念        if cardMapEmpty then            if showTips then                UICommonUtil.ShowMessage(UITextHelper.GetUIText(UITextConst.UI_TEXT_21384))            end            return false        end        -- 该队伍没有上满思念        if not cardMapFull then            table.insert(notFullTeamIdxList, self:GetStageIdxInMulti(stageId))        end    end    if not table.isnilorempty(notFullTeamIdxList) then        table.sort(notFullTeamIdxList, function(a, b)            return a < b        end)    end    return true, notFullTeamIdxListend---多关卡编队是否设置成功function FormationBLL:IsMultiplySetSuccess(soulTrialId)    if self.multipleStageMap == nil then        return false    end    local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)    local stageIds = cfg_SoulTrial.MissionID    local isSetSuccess = true    for i, v in ipairs(stageIds) do        if self.multipleStageMap[v] == nil then            isSetSuccess = false            break        end        local currentState = self:IsSetFormationSuccess(self.multipleStageMap[v])        if currentState ~= TeamConst.FormationSetState.SUCCESS and currentState ~= TeamConst.FormationSetState.SUCCESS_CARDNOFULL then            isSetSuccess = false            break        end    end    return isSetSuccessend---请求进入多关卡战斗function FormationBLL:ReqDoMutiplyStage(soulTrialId, stageId)    if not stageId then        if not self:IsMultiplySetSuccess(soulTrialId) then            return        end        local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)        if cfg_SoulTrial == nil or cfg_SoulTrial.MissionID == nil then            return        end        stageId = cfg_SoulTrial.MissionID[1]    end    BllMgr.GetChapterAndStageBLL():SendDoStageT(stageId, self.multipleStageMap[stageId])end---得到当前思念卡的使用状态---@param stageId int 原始的关卡id---@param teamType int 编队类型---@param cardId int 上阵的思念卡牌ID---@return boolean 是否使用---@return int 第几个编队使用---@return int 已经使用的编队关卡idfunction FormationBLL:GetCardUseState(stageId, teamType, cardId)    if not self:IsMultiplyStage(teamType, stageId) then        return false, 0    end    if self.multipleStageMap == nil then        return false, 0    end    local isUse = false    local useStageId = 0    for i, v in pairs(self.multipleStageMap) do        if v.CardIDs and table.containsvalue(v.CardIDs, cardId) then            isUse = true            useStageId = i            break        end    end    local index = 0    if useStageId ~= 0 then        local soulTrialId = BllMgr.GetSoulTrialBLL():GetSoulTrialIdByStageId(stageId)        local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)        index = table.indexof(cfg_SoulTrial.MissionID, useStageId)    end    return isUse, index, useStageIdend---设置多关卡编队思念卡替换---@param stageId int 原始的关卡id---@param teamType int 编队类型---@param cardId int 上阵的思念卡牌ID---@param slot int 槽位function FormationBLL:SetMultipleStageCardReplace(stageId, teamType, cardId, slot)    local isUse, index = self:GetCardUseState(stageId, teamType, cardId)    if not isUse then        return    end    if self.multipleStageMap == nil then        return    end    local soulTrialId = BllMgr.GetSoulTrialBLL():GetSoulTrialIdByStageId(stageId)    local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", soulTrialId)    local replaceStageId = cfg_SoulTrial.MissionID[index]    if self.multipleStageMap[replaceStageId] and self.multipleStageMap[replaceStageId].CardIDs then        local otherSlot = 0        for i, v in pairs(self.multipleStageMap[replaceStageId].CardIDs) do            if v == cardId then                otherSlot = i                break            end        end        if otherSlot > 0 then            self.multipleStageMap[replaceStageId].CardIDs[otherSlot] = nil            if table.nums(self.multipleStageMap[replaceStageId].CardIDs) == 0 then                self.multipleStageMap[replaceStageId] = nil            end        end    end    if self.multipleStageMap[stageId] == nil then        self.multipleStageMap[stageId] = {}    end    if self.multipleStageMap[stageId].CardIDs == nil then        self.multipleStageMap[stageId].CardIDs = {}    end    self.multipleStageMap[stageId].CardIDs[slot] = cardIdend---设置多关卡编队的思念卡数据为预设编队---@param stageId int 关卡id---@param teamType int 编队类型---@param useMap table 已经使用的编队信息function FormationBLL:SetMultipleStageCardReplaceByPreTeam(stageId, teamType, selectPreTeamIndex, useMap)    if self.multipleStageMap == nil then        self.multipleStageMap = {}    end    for i, v in pairs(useMap) do        local cardSlot = 0        for j, k in pairs(self.multipleStageMap[v.StageID].CardIDs) do            if k == v.CardID then                cardSlot = j                break            end        end        if cardSlot > 0 then            self.multipleStageMap[v.StageID].CardIDs[cardSlot] = nil        end    end    for i, v in pairs(self.multipleStageMap) do        if not self:IsCardSetSuccess(v.CardIDs) then            self.multipleStageMap[i] = nil        end    end    local data = self:GetSetFormationData(teamType, selectPreTeamIndex, stageId)    self.multipleStageMap[stageId] = dataend---得到当前多关卡选择的预设编队index---@param stageId int---@param formationData pbcmessage.Formation---@return int 可能为-1,-1表示没有选择任何一个编队indexfunction FormationBLL:GetMultiplePreformationIndex(stageId, formationData)    if self.multipleStageMap == nil or self.multipleStageMap[stageId] == nil then        return -1    end    if self.selectPreTeamIndexMap == nil then        self.selectPreTeamIndexMap = {}    end    if self.selectPreTeamIndexMap[stageId] == nil then        return -1    end    local index = self.selectPreTeamIndexMap[stageId]    local preFabFormation = SelfProxyFactory.GetFormationProxy():GetPreFabFormationByID(index)    if preFabFormation == nil then        return -1    end    if not self:CheckFormationEqual(preFabFormation, formationData) then        self.selectPreTeamIndexMap[stageId] = nil        return -1    end    return indexend---设置多关卡编队选中的预设编队index---@param stageId int---@param index intfunction FormationBLL:SetMultiplePreformationIndex(stageId, index)    if self.selectPreTeamIndexMap == nil then        self.selectPreTeamIndexMap = {}    end    local removeIndex = 0    for i, v in pairs(self.selectPreTeamIndexMap) do        if v == index then            removeIndex = i            break        end    end    if removeIndex > 0 then        self.selectPreTeamIndexMap[removeIndex] = nil    end    self.selectPreTeamIndexMap[stageId] = indexend---是否是多关卡---@param teamType int 编队类型---@param stageId int 关卡id---@return boolean 是否是多关卡, number 关卡数量function FormationBLL:IsMultiplyStage(teamType, stageId)    if teamType == nil or stageId == nil then        return false, 1    end    -- 深空试炼类型    if teamType == TeamConst.TeamType.SoulTrial then        -- 获取深空试炼Id        local soulTrialId = BllMgr.GetSoulTrialBLL():GetSoulTrialIdByStageId(stageId)        -- 返回是否多关卡        return BllMgr.GetSoulTrialBLL():CheckIfLayerMultiLevel(soulTrialId)    end    return false, 1end---检查多关卡编队的关卡对应序号---@param stageId int 关卡idfunction FormationBLL:GetStageIdxInMulti(stageId)    local stageCfg = LuaCfgMgr.Get("CommonStageEntry", stageId)    if not stageCfg then        Debug.LogError("Stage Cfg not found, stageId : " .. tostring(stageId))        return    end    if stageCfg.Type == Define.EStageType.SoulTrial then        local stageIdx, allStageCount = BllMgr.GetSoulTrialBLL():GetStageIndex(stageId)        return stageIdx    endend--endregion---得到当前的关卡id---@param stageId int 原始的关卡id---@param teamType int 队伍类型---@param index int 可以不传，仅仅用于多关卡的情况---@return int 关卡idfunction FormationBLL:GetCurrentStageId(stageId, teamType, index)    if teamType ~= TeamConst.TeamType.SoulTrial then        return stageId    end    local num = index == nil and 1 or index    if num > 0 then        local cfg_SoulTrial = LuaCfgMgr.Get("SoulTrial", stageId)        if cfg_SoulTrial and #cfg_SoulTrial.MissionID > num - 1 then            return cfg_SoulTrial.MissionID[num]        end    end    return stageIdend---清理深空试炼多关卡数据function FormationBLL:ClearSoulTrialData()    if self.multipleStageMap then        self.multipleStageMap = nil    endend---获取多关卡编队信息---@return table<int, pbcmessage.Formation> key:关卡id， value：编队信息function FormationBLL:GetAllMultipleStageFormation()    return self.multipleStageMapend---得到进入战斗的消耗---@param stageID int 关卡id---@return int num 消耗道具数量---@return int itemId 消耗的道具id---@return int itemType 道具类型function FormationBLL:GetEnterBattleCostItem(stageID)    if stageID == nil then        return 0, 0, 0    end    ---@type cfg.CommonStageEntry    local cfg_CommonStageEntry = LuaCfgMgr.Get("CommonStageEntry", stageID)    if cfg_CommonStageEntry and cfg_CommonStageEntry.EnterCost then        --策划目前只会针对一种消耗物品进行展示        if #cfg_CommonStageEntry.EnterCost > 0 then            local enterCost = cfg_CommonStageEntry.EnterCost[1]            local costNum = enterCost.Num            return costNum, enterCost.Type, enterCost.ID        end    end    return 0, 0, 0end-- 战斗返回的技能类型的系统展示排序权重 权重越低越先展示---@class GameConst.BattleSkillTypeSortWeightlocal BattleSkillTypeSortWeight = {    -- Score技能类型    [SkillType.Passive] = 1,    [SkillType.MaleActive] = 2,    [SkillType.Coop] = 3,    [SkillType.Ultra] = 4,    -- 武器技能类型    [SkillType.Attack] = 5,    [SkillType.Dodge] = 6,    [SkillType.Passive] = 7,    [SkillType.Active] = 8,}-- 根据思念Id获取对应技能信息列表 用于展示function FormationBLL:GetSkillInfoListByScoreId(scoreId)    local skillInfoList = BattleUtil.GetSkillInfoByScoreID(scoreId)    if table.isnilorempty(skillInfoList) then        return {}    end    -- 去掉空值    local list = {}    for _, v in pairs(skillInfoList) do        if v.id > 0 then            table.insert(list, v)        end    end    -- 优先级排序后返回    table.sort(skillInfoList, function(a, b)        if a.skillType ~= b.skillType then            local weight_a = BattleSkillTypeSortWeight[a.skillType]            local weight_b = BattleSkillTypeSortWeight[b.skillType]            return weight_a < weight_b        end        return a.id < b.id    end)    return skillInfoListend-- 根据武器Id获取对应技能信息列表 用于展示    -- 这里战斗侧提供的接口是用武器皮肤来传的, 但是系统并没有引入武器皮肤的概念, 目前用默认的, 后续如果有武器皮肤这个说法, 再改function FormationBLL:GetSkillInfoListByWeaponId(weaponId)    local weaponCfg = LuaCfgMgr.Get("MyWeapon", weaponId)    if not weaponCfg or not weaponCfg.DefaultSkinID then        return {}    end    local skillInfoList = BattleUtil.GetSkillInfoByWeaponID(weaponCfg.DefaultSkinID)    if table.isnilorempty(skillInfoList) then        return {}    end    -- 去掉空值    local list = {}    for _, v in pairs(skillInfoList) do        if v.id > 0 then            table.insert(list, v)        end    end    -- 优先级排序后返回    table.sort(skillInfoList, function(a, b)        if a.skillType ~= b.skillType then            local weight_a = BattleSkillTypeSortWeight[a.skillType]            local weight_b = BattleSkillTypeSortWeight[b.skillType]            return weight_a < weight_b        end        return a.id < b.id    end)    return skillInfoListend--region 一键上阵思念---比较是否匹配关卡tag---@param cardSlotData table<int,int> key:slot value：cardId---@param stageId int 关卡id---@return intlocal function getTagTrigger(cardSlotData, stageId)    local _, allTrigger = BllMgr.GetFormationBLL():TryGetLevelTag(stageId, cardSlotData)    if allTrigger then        return 1    end    return 0end---得到思念套装的品质---@param cardSlotData table<int,int> key:slot value：cardId---@param suitID int 套装id---@return intlocal function getCardSuitQuility(cardSlotData, suitID)    if suitID == 0 then        return 0    end    local suitQuility = 0    for i, v in pairs(cardSlotData) do        if (i  == 1 or i == 2) and v > 0 then            ---@type cfg.CardBaseInfo            local cardBaseInfoCfg = LuaCfgMgr.Get("CardBaseInfo", v)            suitQuility = cardBaseInfoCfg.Quality            break        end    end    return suitQuilityend---思念卡组品质总和---@param cardSlotData table<int,int> key:slot value：cardId---@return intlocal function getCardStarCount(cardSlotData)    local num = 0    for i, v in pairs(cardSlotData) do        local cardBaseInfoCfg = LuaCfgMgr.Get("CardBaseInfo", v)        local suitQuility = cardBaseInfoCfg.Quality        num = num + suitQuility    end    return numend--得到思念卡组等级总和---@param cardSlotData table<int,int> key:slot value：cardId---@return intlocal function getCardLevelCount(cardSlotData)    local num = 0    for i, v in pairs(cardSlotData) do        local cardData = SelfProxyFactory.GetCardDataProxy():GetData(v)        num = num + cardData:GetLevel()    end    return numend---得到tag数量---@param cardSlotData table<int,int> key:slot value：cardId---@param isHasTag boolean---@param cfg_CommonStageEntry cfg.CommonStageEntry---@return intlocal function getCardTagCount(cardSlotData, isHasTag, cfg_CommonStageEntry)    if isHasTag then        local num = 0        for i, v in pairs(cardSlotData) do            local cardBaseInfoCfg = LuaCfgMgr.Get("CardBaseInfo", v)            local tagID = cardBaseInfoCfg.FormationTag            if table.containsvalue(cfg_CommonStageEntry.Tag, tagID) then                num = num + 1            end        end        return num    end    return 0end---得到指定男主可以使用的思念卡列表---@param self FormationBLL---@param stageId int 关卡id---@param usedCards int[] 使用过的思念卡id---@param roleId int 角色id---@return int[] 思念id列表local function getAutoCanUseCardsByRole(self, stageId, usedCards, roleId)    local cards = SelfProxyFactory.GetCardDataProxy():GetCardListByRoleId(roleId)    if not cards then       return nil    end        local hasCards = false    local result = {}    for j, k in pairs(cards) do        local id = k:GetPrimaryValue()        local used = usedCards and table.containsvalue(usedCards, id) or false        if not used then            ---@type cfg.CardBaseInfo            local baseInfo = LuaCfgMgr.Get("CardBaseInfo", id)            if self:IsCardLimitUse(stageId, id) then                if result[baseInfo.PosType] == nil then                    result[baseInfo.PosType] = {}                end                table.insert(result[baseInfo.PosType], { cfg = baseInfo, data = k })                hasCards = true            end        end    end    if not hasCards then        result = nil    end    return resultend---得到所有可以使用的思念卡---@param self FormationBLL---@param stageId int---@param usedCards int[] 使用过的思念卡id---@return boolean 是否有可使用的思念卡local function getAutoCanUseCards(self, cardMap, stageId, usedCards)    local roleMap = self:GetCurrentStageUseRoleType(stageId)    local hasCards = false    for i, v in pairs(roleMap) do        if cardMap[v.ID] == nil then            cardMap[v.ID] = {}        end        local cards = getAutoCanUseCardsByRole(self, stageId, usedCards, v.ID)        if cards then            cardMap[v.ID] = cards            hasCards = true        end    end    return hasCardsend---一键上阵思念---@param stageId int---@param usedCards int[] 使用过的思念卡id---@param noCheckTag boolean 是否不检查tag---@param allTriggerNext boolean tag匹配后是否需要继续匹配---@return table<int,int> key:上阵slot, value：思念卡IDfunction FormationBLL:GetAutoAddCards(stageId, usedCards, noCheckTag, allTriggerNext)    ---@type X3Data.CardData[]    --先得到所有可用的思念卡，可能有关卡限制    local cardMap = PoolUtil.GetTable()    local hasCards = getAutoCanUseCards(self, cardMap, stageId, usedCards)    if not hasCards then        return nil    end    --匹配不同男主的思念列表：根据思念一件上阵规则排序    ---@type cfg.CommonStageEntry    local cfg_CommonStageEntry = LuaCfgMgr.Get("CommonStageEntry", stageId)    local isHasTag = cfg_CommonStageEntry.Tag ~= nil    ---思念星级>思念套装>思念等级    local oneSortSequence = { GameConst.CardSortType.Quality, GameConst.CardSortType.SuitCompose, GameConst.CardSortType.SuitAllLevel, GameConst.CardSortType.SuitId, GameConst.CardSortType.Level, GameConst.CardSortType.ID, GameConst.CardSortType.CardId }    --没有匹配到套装    local oneSortNoSuitSequence =  { GameConst.CardSortType.Quality, GameConst.CardSortType.Level, GameConst.CardSortType.ID, GameConst.CardSortType.CardId }    ---思念星级>思念等级    local twoSortSequence = { GameConst.CardSortType.Quality, GameConst.CardSortType.Level, GameConst.CardSortType.Tag, GameConst.CardSortType.ID, GameConst.CardSortType.CardId }    --编队预上阵阵容    local preCardAddSlot = PoolUtil.GetTable()        for i, v in pairs(cardMap) do        local cardSlotItem = self:GetRoleAutoAddCards(cfg_CommonStageEntry, v, oneSortSequence, twoSortSequence, oneSortNoSuitSequence, noCheckTag, allTriggerNext)        table.insert(preCardAddSlot, { roleId = i, cardSlot = cardSlotItem })    end        local cardSlotMap = PoolUtil.GetTable()    --筛选出所有没有全部匹配tag的编队并剔除    for i, v in ipairs(preCardAddSlot) do        if not isHasTag then            table.insert(cardSlotMap, table.clone(v))        else            local _, allTrigger = self:TryGetLevelTag(stageId, v.cardSlot)            if allTrigger then                --全部触发了                table.insert(cardSlotMap, table.clone(v))            end        end    end    PoolUtil.ReleaseTable(preCardAddSlot)        if #cardSlotMap == 0 then        --重新排序        ---思念星级>思念套装>思念等级>tag        local oneSortSequenceHasTag = { GameConst.CardSortType.Quality, GameConst.CardSortType.SuitCompose, GameConst.CardSortType.SuitAllLevel, GameConst.CardSortType.SuitWithTag, GameConst.CardSortType.Level, GameConst.CardSortType.Tag, GameConst.CardSortType.ID, GameConst.CardSortType.CardId }        local oneSortNoSuitSequenceHasTag =  { GameConst.CardSortType.Quality, GameConst.CardSortType.Level, GameConst.CardSortType.Tag, GameConst.CardSortType.ID, GameConst.CardSortType.CardId }        for j, k in pairs(cardMap) do            local cardSlotItem = self:GetRoleAutoAddCards(cfg_CommonStageEntry, k, oneSortSequenceHasTag, twoSortSequence, oneSortNoSuitSequenceHasTag, true, allTriggerNext)            table.insert(cardSlotMap, { roleId = j, cardSlot = cardSlotItem })        end    end        ---得到男主id，看板娘的话优先级最高    local function getCardSlotManType(roleId, mainRoleId)        local manType = roleId        if roleId == mainRoleId then            manType = 100        end        return manType    end        local mainRoleId = BllMgr.GetMainHomeBLL():GetData():GetRoleId()    table.sort(cardSlotMap, function(a, b)        if isHasTag then            local aTriggerTag = getTagTrigger(a.cardSlot, cfg_CommonStageEntry.ID)            local bTriggerTag = getTagTrigger(b.cardSlot, cfg_CommonStageEntry.ID)            if aTriggerTag ~= bTriggerTag then                return aTriggerTag > bTriggerTag            end        end        local _, aSuitId = self:GetSuitScoreIDByCards(a.cardSlot)        local _, bSuitId = self:GetSuitScoreIDByCards(b.cardSlot)        if aSuitId ~= bSuitId then            local aQuility = getCardSuitQuility(a.cardSlot, aSuitId)            local bQuility = getCardSuitQuility(b.cardSlot, bSuitId)            if aQuility ~= bQuility then                return aQuility > bQuility            end        end        local aStarCount = getCardStarCount(a.cardSlot)        local bStarCount = getCardStarCount(b.cardSlot)        if aStarCount ~= bStarCount then            return aStarCount > bStarCount        end        local aLevelCount = getCardLevelCount(a.cardSlot)        local bLevelCount = getCardLevelCount(b.cardSlot)        if aLevelCount ~= bLevelCount then            return aLevelCount > bLevelCount        end        if isHasTag then            local aTagNum = getCardTagCount(a.cardSlot, true, cfg_CommonStageEntry)            local bTagNum = getCardTagCount(b.cardSlot, true, cfg_CommonStageEntry)            if aTagNum ~= bTagNum then                return aTagNum > bTagNum            end        end        local aManType = getCardSlotManType(a.roleId, mainRoleId)        local bManType = getCardSlotManType(b.roleId, mainRoleId)        return aManType > bManType    end)    local result = #cardSlotMap > 0 and table.clone(cardSlotMap[1].cardSlot) or nil    PoolUtil.ReleaseTable(cardMap)    PoolUtil.ReleaseTable(cardSlotMap)    return resultend-----得到某个角色的思念卡上阵列表---@param cfg_CommonStageEntry cfg.CommonStageEntry---@param cards int[] 筛选出来的cardID列表function FormationBLL:GetRoleAutoAddCards(cfg_CommonStageEntry, cards, oneSortSequence, twoSortSequence, oneNoSuitSortSequence, noCheckTag, allTriggerNext)    local cardSlot = {}    local unlockSlotMap = self:TryGetUnLockCardSlot()    local isHasTag = cfg_CommonStageEntry.Tag ~= nil    if not isHasTag then        cardSlot = self:GetAutoAddCardsByNoTag(unlockSlotMap, cards, oneSortSequence, twoSortSequence, oneNoSuitSortSequence)        return cardSlot    end    local tagList = PoolUtil.GetTable()    local hasTagList = PoolUtil.GetTable()    for i, v in ipairs(cfg_CommonStageEntry.Tag) do        if hasTagList[v] == nil then            hasTagList[v] = 1            table.insert(tagList, {tagId = v, index = i})        end    end    PoolUtil.ReleaseTable(hasTagList)    if noCheckTag then        cardSlot = self:GetAutoAddCardsByTag(table.clone(tagList[1]), tagList, unlockSlotMap, cards, oneSortSequence, twoSortSequence, cfg_CommonStageEntry, true, noCheckTag, allTriggerNext)        return cardSlot    end    local allCardSlotList = PoolUtil.GetTable()    if #tagList == 1 then        table.insert(allCardSlotList, self:GetAutoAddCardsByTag(table.clone(tagList), tagList, unlockSlotMap, cards, oneSortSequence, twoSortSequence, cfg_CommonStageEntry, false , false, allTriggerNext))    else        table.insert(allCardSlotList, self:GetAutoAddCardsByTag(table.clone({tagList[1]}), tagList, unlockSlotMap, cards, oneSortSequence, twoSortSequence, cfg_CommonStageEntry, false , false, allTriggerNext))        table.insert(allCardSlotList, self:GetAutoAddCardsByTag(table.clone({tagList[2]}), tagList, unlockSlotMap, cards, oneSortSequence, twoSortSequence, cfg_CommonStageEntry, false , false, allTriggerNext))        table.insert(allCardSlotList, self:GetAutoAddCardsByTag(table.clone(tagList), tagList, unlockSlotMap, cards, oneSortSequence, twoSortSequence, cfg_CommonStageEntry, false , false, allTriggerNext))    end    local unlockNum = 0    for i = 3, 6 do        if unlockSlotMap[i] then            unlockNum = unlockNum + 1        end    end    if #cfg_CommonStageEntry.Tag <= unlockNum then        table.insert(allCardSlotList, self:GetAutoAddCardsByTag(table.clone(tagList), tagList, unlockSlotMap, cards, oneSortSequence, twoSortSequence, cfg_CommonStageEntry, true, false, allTriggerNext))    end    ---得到首张卡id    local function getFirstCardId(cardSlotItem)        if cardSlotItem[1] then            return cardSlotItem[1]        end        if cardSlotItem[3] then            return cardSlotItem[3]        end        return 0    end    table.sort(allCardSlotList, function(a, b)        local aTriggerTag = getTagTrigger(a, cfg_CommonStageEntry.ID)        local bTriggerTag = getTagTrigger(b, cfg_CommonStageEntry.ID)        if aTriggerTag ~= bTriggerTag then            return aTriggerTag > bTriggerTag        end        local _, aSuitId = self:GetSuitScoreIDByCards(a)        local _, bSuitId = self:GetSuitScoreIDByCards(b)        if aSuitId ~= bSuitId then            local aQuility = getCardSuitQuility(a, aSuitId)            local bQuility = getCardSuitQuility(b, bSuitId)            if aQuility ~= bQuility then                return aQuility > bQuility            end        end        local aStarCount = getCardStarCount(a)        local bStarCount = getCardStarCount(b)        if aStarCount ~= bStarCount then            return aStarCount > bStarCount        end        local aLevelCount = getCardLevelCount(a)        local bLevelCount = getCardLevelCount(b)        if aLevelCount ~= bLevelCount then            return aLevelCount > bLevelCount        end        local aTagNum = getCardTagCount(a, true, cfg_CommonStageEntry)        local bTagNum = getCardTagCount(b,true, cfg_CommonStageEntry)        if aTagNum ~= bTagNum then            return aTagNum > bTagNum        end        local aFirstCardID = getFirstCardId(a)        local bFirstCardID = getFirstCardId(b)        return aFirstCardID > bFirstCardID    end)    local result = table.clone(allCardSlotList[1])    PoolUtil.ReleaseTable(allCardSlotList)    PoolUtil.ReleaseTable(tagList)    return resultend---得到组成思念套装的思念卡idlocal function getSuitCardId(cardData, hasCardList)    local suitCardId = cardData.cfg.SuitCardID    if SelfProxyFactory.GetCardDataProxy():GetData(suitCardId) then        local has = false        for i, v in ipairs(hasCardList) do            if v.cfg.ID == suitCardId then                has = true                break            end        end        if has then            return suitCardId        end    end    return 0endlocal function getCardId(cardData, tagValue)    if cardData.cfg.FormationTag == tagValue then        return cardData.cfg.ID    end    return 0end---得到自动上阵的一二槽位的思念卡id---@param self FormationBLL---@param hasTagList---@param cfg_CommonStageEntry cfg.CommonStageEntry---@param cardSlot table<int,int> key:slot value:cardID---@param unlockSlotMap table<int, boolean> key:slot value:是否解锁---@param tagIndex int tag所在的index---@param slot int 要上阵的思念卡槽位---@param oneCardList int[] 筛选出来的cardID列表---@param oneSortSequence int[] 排序规则---@param tagID int 关卡tag---@param checkSuit boolean 是否检查套装---@return boolean 是否得到设置的思念卡---@return boolean 是否已经获取套装思念卡local function getAutoOneSlotCardIDByTag(self, hasTagList, cfg_CommonStageEntry, cardSlot, unlockSlotMap, tagIndex, slot, oneCardList, oneSortSequence, tagID, checkSuit)    local hasGetCard = false    local isSuitGet = false    self:SortCardList(oneCardList, oneSortSequence, tagID)    if getCardId(oneCardList[1], tagID) > 0 then        hasTagList[tagIndex] = tagID        hasGetCard = true        if checkSuit then            if slot == 1 and unlockSlotMap[2] then                local cardSuitID = getSuitCardId(oneCardList[1], oneCardList)                if cardSuitID > 0  then                    cardSlot[2] = cardSuitID                    isSuitGet = true                    for j, k in ipairs(cfg_CommonStageEntry.Tag) do                        if hasTagList[j] == nil and k == tagID then                            hasTagList[j] = tagID                            break                        end                    end                end            end        end    end    return hasGetCard, isSuitGetend---得到自动上阵的三到六槽位的思念卡id---@param self FormationBLL---@param twoCardsList int[] 筛选出来的cardID列表---@param cardSlot table<int,int> key:slot value:cardID---@param cfg_CommonStageEntry cfg.CommonStageEntry---@param twoSortSequence int[] 排序规则---@param allTagList---@param unlockSlotMap table<int, boolean> key:slot value:是否解锁---@param twoNoCheckTag Boolean 不检查tag---@param hasTagList---@param allTriggerIsNext Boolean 匹配tag后是否继续往下匹配local function getAutoTwoSlotCardIDByTag(self, twoCardsList, cardSlot, cfg_CommonStageEntry, twoSortSequence, allTagList, unlockSlotMap, twoNoCheckTag, hasTagList, allTriggerIsNext)    local _, isAllTrigger = self:TryGetLevelTag(cfg_CommonStageEntry.ID, cardSlot)    local twoCards = table.clone(twoCardsList)    if isAllTrigger then        if not allTriggerIsNext then            return        end        self:SortCardList(twoCards, twoSortSequence, nil, allTagList)        for i = 3, 6 do            local twoCardLength = twoCards and #twoCards or 0            if unlockSlotMap[i] and twoCardLength > 0 then                cardSlot[i] =twoCards[1].cfg.ID                table.remove(twoCards, 1)            end        end    else        local twoCardsLength        for i = 3, 6 do            twoCardsLength = twoCards and #twoCards or 0            if unlockSlotMap[i] and twoCardsLength > 0 then                local hasGetCard = false                if not twoNoCheckTag then                    for j, k in ipairs(cfg_CommonStageEntry.Tag) do                        if hasTagList[j] == nil then                            self:SortCardList(twoCards, twoSortSequence, k)                            local cardId = getCardId(twoCards[1], k)                            if cardId ~= 0 then                                table.remove(twoCards, 1)                                cardSlot[i] = cardId                                hasGetCard = true                                hasTagList[j] = k                                break                            end                        end                    end                end                local _, isTrigger = self:TryGetLevelTag(cfg_CommonStageEntry.ID, cardSlot)                if not hasGetCard then                    if not allTriggerIsNext and isTrigger then                        break                     end                    if isTrigger or twoNoCheckTag then                        self:SortCardList(twoCards, twoSortSequence, nil, allTagList)                    else                        self:SortCardList(twoCards, twoSortSequence)                    end                    cardSlot[i] = twoCards[1].cfg.ID                    table.remove(twoCards, 1)                else                    if isTrigger and (not allTriggerIsNext) then                        break                    end                end            end        end    endend---通过tag得到第一个槽位类型的思念卡上阵情况function FormationBLL:GetAutoAddCardsOneSlotByTwoTag(cfg_CommonStageEntry, tagList, hasTagList, unlockSlotMap, allCards, oneSortSequence, cardSlot, oneNoCheckTag, allTriggerIsNext)    local oneCardsLength = allCards[1] and #allCards[1] or 0    if oneCardsLength <= 0 then        return    end        local cards = table.clone(allCards[1])    local isSuitGet = false    for i = 1, 2 do        if not isSuitGet then            oneCardsLength = cards and #cards or 0            if unlockSlotMap[i] and oneCardsLength > 0 then                local isGetTagCard = false                if not oneNoCheckTag then                    for j, v in ipairs(tagList) do                        if hasTagList[v.index] == nil and not isSuitGet then                            isGetTagCard, isSuitGet = getAutoOneSlotCardIDByTag(self, hasTagList, cfg_CommonStageEntry, cardSlot, unlockSlotMap, v.index, i, cards, oneSortSequence, v.tagId, false)                            if isGetTagCard then                                break                            end                        end                    end                end                if not isGetTagCard then                    if not allTriggerIsNext then                        break                    else                        self:SortCardList(cards, oneSortSequence)                    end                end                cardSlot[i] = cards[1].cfg.ID                table.remove(cards, 1)                                if not allTriggerIsNext then                    local _, isTrigger = self:TryGetLevelTag(cfg_CommonStageEntry.ID, cardSlot)                    if isTrigger then                        break                    end                end            end        end    endend---关卡有tag获取对应的上阵数据function FormationBLL:GetAutoAddCardsByTag(tagList, allTagList, unlockSlotMap, allCards, oneSortSequence, twoSortSequence, cfg_CommonStageEntry, oneNoCheckTag, twoNoCheckTag, allTriggerIsNext)    local hasTagList = PoolUtil.GetTable()    local cardSlot = {}    local posType = 1    local oneCardList = table.clone(allCards[posType])    if #tagList == 1 or oneNoCheckTag then        local  isSuitGet = false        for i = 1, 2 do            if not isSuitGet then                local oneCardsLength = oneCardList and #oneCardList or 0                if unlockSlotMap[i] and oneCardsLength > 0 then                    local hasGetCard = false                    if not oneNoCheckTag then                        for n, v in ipairs(tagList) do                            hasGetCard, isSuitGet = getAutoOneSlotCardIDByTag(self, hasTagList, cfg_CommonStageEntry, cardSlot, unlockSlotMap, v.index, i, oneCardList, oneSortSequence, v.tagId, true)                            if hasGetCard then break end                        end                    end                    if not hasGetCard then                        if not allTriggerIsNext then                            break                        else                            if table.nums(allTagList) > 0 then                                self:SortCardList(oneCardList, oneSortSequence, nil, allTagList)                            else                                self:SortCardList(oneCardList, oneSortSequence)                            end                        end                    end                                        cardSlot[i] = oneCardList[1].cfg.ID                    table.remove(oneCardList, 1)                    if not allTriggerIsNext then                        local _, isTrigger = self:TryGetLevelTag(cfg_CommonStageEntry.ID, cardSlot)                        if isTrigger then                            break                        end                    end                end            end        end    else        self:GetAutoAddCardsOneSlotByTwoTag(cfg_CommonStageEntry, tagList, hasTagList, unlockSlotMap, allCards, oneSortSequence, cardSlot, oneNoCheckTag, allTriggerIsNext)    end    local twoCardsLength = allCards[2] and #allCards[2] or 0    if twoCardsLength > 0 then        getAutoTwoSlotCardIDByTag(self, allCards[2], cardSlot, cfg_CommonStageEntry, twoSortSequence, allTagList, unlockSlotMap, twoNoCheckTag, hasTagList, allTriggerIsNext)    end    PoolUtil.ReleaseTable(hasTagList)    tagList = nil    return cardSlotend---得到自动上阵的思念卡(不包含关卡tag)function FormationBLL:GetAutoAddCardsByNoTag(unlockSlotMap, allCards, oneSortSequence, twoSortSequence, oneNoSuitSortSequence)    local cardSlot = {}    local posType = 1    local oneCardList = table.clone(allCards[posType])    local isSuit = false    for i = 1, 2 do        if unlockSlotMap[i] and not isSuit then            local oneCardsLength = oneCardList and #oneCardList or 0            if oneCardsLength > 0 then                if i == 1 then                    self:SortCardList(oneCardList, oneSortSequence)                    cardSlot[i] = oneCardList[1].cfg.ID                    if unlockSlotMap[2] then                        local suitCardId = getSuitCardId(oneCardList[1], oneCardList)                        if suitCardId > 0 then                            --已经有匹配的套装                            cardSlot[2] = suitCardId                            isSuit = true                        end                    end                elseif i == 2 then                    self:SortCardList(oneCardList, oneNoSuitSortSequence)                    cardSlot[i] = oneCardList[1].cfg.ID                end                if not isSuit then                    table.remove(oneCardList, 1)                end            end        end    end    posType = 2    local twoCardList = table.clone(allCards[posType])    for i = 3, 6 do        if unlockSlotMap[i] then            local twoCardsLength = twoCardList and #twoCardList or 0            if twoCardsLength > 0 then                ---关卡无Tag时                self:SortCardList(twoCardList, twoSortSequence)                cardSlot[i] = twoCardList[1].cfg.ID                table.remove(twoCardList, 1)            end        end    end    return cardSlotend---检查是否在tagList列表里面local function checkInTagList(a, tagList)    local num = 0    for i, v in ipairs(tagList) do        if v.tagId == a.cfg.FormationTag  then            num = 1            break        end    end    return numend---最后上阵的时候：思念套卡的排序规则：是套卡->  套卡等级之和> taglocal function getSuitWithTagWeight(a, tagList)    ---@type cfg.CardBaseInfo    local cfg_CardBaseInfo = LuaCfgMgr.Get("CardBaseInfo", a.data:GetPrimaryValue())    if cfg_CardBaseInfo.SuitID > 0 then        local suitCardData = SelfProxyFactory.GetCardDataProxy():GetData(cfg_CardBaseInfo.SuitCardID)        if suitCardData ~= nil then            if tagList then                if checkInTagList(a, tagList) > 0 then                    return 2                end            end            return 1        end    end    return 0end---对cardlist进行排序function FormationBLL:SortCardList(cardList, sequence, tagId, tagList)    if cardList == nil or #cardList <= 0 then        return    end    local function checkTag(a, b)        local isMatch1 = a.cfg.FormationTag == tagId and 1 or 0        local isMatch2 = b.cfg.FormationTag == tagId and 1 or 0        if isMatch1 ~= isMatch2 then            return isMatch1 > isMatch2        end        return nil    end    table.sort(cardList, function(a, b)        if tagId then            local sortTag = checkTag(a , b)            if sortTag ~= nil then                return sortTag            end        end        for _, v in ipairs(sequence) do            if v == GameConst.CardSortType.Tag then                if tagList then                    local aWeight = checkInTagList(a, tagList)                    local bWeight = checkInTagList(b, tagList)                    if aWeight ~= bWeight then                        return aWeight > bWeight                    end                end            elseif v == GameConst.CardSortType.SuitWithTag then                local aWeight = getSuitWithTagWeight(a, tagList)                local bWeight = getSuitWithTagWeight(b, tagList)                if aWeight ~= bWeight then                    return aWeight > bWeight                elseif aWeight == 1 then                    return BllMgr.GetCardBLL():CardSortFunc(GameConst.CardSortType.SuitId, a.data, b.data)                end            elseif v == GameConst.CardSortType.SuitId then                local aWeight = getSuitWithTagWeight(a)                local bWeight = getSuitWithTagWeight(b)                if aWeight ~= bWeight then                    return aWeight > bWeight                elseif aWeight == 1 then                    return BllMgr.GetCardBLL():CardSortFunc(GameConst.CardSortType.SuitId, a.data, b.data)                end            else                local sortResult = BllMgr.GetCardBLL():CardSortFunc(v, a.data, b.data)                if sortResult ~= nil then                    return sortResult                end            end        end    end)end---得到关卡tag的数量---@param stageId int 关卡id---@return numberlocal function getStageTagNum(stageId)    local cfg_CommonStageEntry = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg_CommonStageEntry and cfg_CommonStageEntry.Tag then        return #cfg_CommonStageEntry.Tag    end    return 0end---得到关卡stage的tag种类数量---@param stageId int 关卡id---@return number local function getStageTagTypeNum(stageId)    local cfg_CommonStageEntry = LuaCfgMgr.Get("CommonStageEntry", stageId)    if cfg_CommonStageEntry and cfg_CommonStageEntry.Tag then        local hasTag = PoolUtil.GetTable()        local typeNum = 0        for i, v in ipairs(cfg_CommonStageEntry.Tag) do            if hasTag[v] == nil then                hasTag[v] = 1                typeNum = typeNum + 1            end        end        PoolUtil.ReleaseTable(hasTag)        return typeNum    end    return 0end---检查没有自动上阵的卡并上阵---@param self FormationBLL---@param cardSlot table<number, number> key:槽位 ， value：思念卡id---@param stageId int 关卡id---@param unlockSlotMap table<number, boolean> key:槽位， value：是否解锁---@param usedCards int[] 已经使用的思念卡列表---@param oneNoSuitSortSequence int[] 一号二号槽位排序规则---@param twoSortSequence int[] 三号至六号槽位排序规则local function checkAutoNoAdd(self, cardSlot, stageId, unlockSlotMap, usedCards, oneNoSuitSortSequence, twoSortSequence)    local roleID = self:GetCardDressMantype(cardSlot)    if roleID == 0 then        return    end    local cards = getAutoCanUseCardsByRole(self, stageId, usedCards, roleID)    if not cards or #cards == 0 then        return    end    --匹配不同男主的思念列表：根据思念一件上阵规则排序    ---@type cfg.CommonStageEntry    local cfg_CommonStageEntry = LuaCfgMgr.Get("CommonStageEntry", stageId)    local isHasTag = cfg_CommonStageEntry.Tag ~= nil    local tagList = PoolUtil.GetTable()    if isHasTag then        local hasTagList = PoolUtil.GetTable()        for i, v in ipairs(cfg_CommonStageEntry.Tag) do            if hasTagList[v] == nil then                hasTagList[v] = 1                table.insert(tagList, {tagId = v, index = i})            end        end        PoolUtil.ReleaseTable(hasTagList)    end        for i = 1, TeamConst.CardSlotNum do        if unlockSlotMap[i] and cardSlot[i] == nil then            if i <= 2 then                if cards[1] and #cards[1] > 0 then                    self:SortCardList(cards[1], oneNoSuitSortSequence, nil, isHasTag and tagList or nil)                    local cardId = cards[1][1].cfg.ID                    cardSlot[i] = cardId                    table.remove(cards[1], 1)                    table.insert(usedCards, cardId)                end            else                --3到6号位置                if cards[2] and #cards[2] > 0 then                    self:SortCardList(cards[2], twoSortSequence, nil, isHasTag and tagList or nil)                    local cardId = cards[2][1].cfg.ID                    cardSlot[i] = cardId                    table.remove(cards[2], 1)                    table.insert(usedCards, cardId)                end            end        end    end    PoolUtil.ReleaseTable(tagList)end---得到多关卡一键上阵的思念卡---@param stageMap table[] {Index：外层传入的顺序Index, stageID:关卡id} 关卡Id---@return table<number, table<number, number>> key:外层传入的顺序Index, value:上阵的思念卡列表, 可能为空function FormationBLL:GetMulipleStageAutoAddCards(stageMap)    if stageMap == nil then        return nil    end    local tempStageList = PoolUtil.GetTable()    tempStageList = table.clone(stageMap)    local function getStageMonsterLevel(stageId)        local cfg_CommonStageEntry = LuaCfgMgr.Get("CommonStageEntry", stageId)        if cfg_CommonStageEntry then            if #cfg_CommonStageEntry.MonsterForShow > 0 then                ---获取配置                local monsterForShow = cfg_CommonStageEntry.MonsterForShow[1]                local monsterPropCfg = BattleUtil.GetMonsterProperty(monsterForShow.Num)                if monsterPropCfg then                    return monsterPropCfg.Level                end            end        end        return 0    end    ---将当前所有需要上阵思念的关卡进行排序    ---1.关卡怪物最高等级，等级越高，越优先排序    ---2.按照关卡tag数量进行排序，关卡tag数量多的排序在前    ---3.tag数量相同的关卡，按tag种类少的在前    ---4.若前两项都相同，则按玩法关卡顺序排列    table.sort(tempStageList, function(a, b)         local aMonsterLevel = getStageMonsterLevel(a.stageID)        local bMonsterLevel = getStageMonsterLevel(b.stageID)        if aMonsterLevel ~= bMonsterLevel then            return aMonsterLevel > bMonsterLevel        end        local aTagNum = getStageTagNum(a.stageID)        local bTagNum = getStageTagNum(b.stageID)        if aTagNum ~= bTagNum then            return aTagNum > bTagNum        end        local aTagTypeNum = getStageTagTypeNum(a.stageID)        local bTagTypeNum = getStageTagTypeNum(b.stageID)        if aTagTypeNum ~= bTagTypeNum then            return aTagTypeNum > bTagTypeNum        end        return a.Index < b.Index    end)        local tempAllCards = PoolUtil.GetTable()    local preAddCardsStage = PoolUtil.GetTable()    for i, v in ipairs(tempStageList) do        local cards = self:GetAutoAddCards(v.stageID, tempAllCards, false, false)        if cards and table.nums(cards) > 0 then            --若所有男主没有队伍完全匹配关卡tag，且本关卡没有预上阵过，则清空本关卡所有的思念选择，将本关卡标记已经预上阵过            local _, allTrigger = self:TryGetLevelTag(v.stageID, cards)            if allTrigger then                for j, k in pairs(cards) do                    table.insert(tempAllCards, k)                end                preAddCardsStage[v.Index] = cards            end        end    end    local formationDataList = {}    local hasFullAdd = true --是否都已上阵    for i, v in ipairs(tempStageList) do        if preAddCardsStage[v.Index] == nil then            --没有上阵的阵容            local cards = self:GetAutoAddCards(v.stageID, tempAllCards, true, false)            if cards and table.nums(cards) > 0 then                for j, k in pairs(cards) do                    table.insert(tempAllCards, k)                end                formationDataList[v.Index] = cards            else                hasFullAdd = false                break            end        else            formationDataList[v.Index] = table.clone(preAddCardsStage[v.Index])        end    end    PoolUtil.ReleaseTable(preAddCardsStage)        if not hasFullAdd then        formationDataList = nil        PoolUtil.ReleaseTable(tempAllCards)        PoolUtil.ReleaseTable(tempStageList)        return nil    end    local oneSortNoSuitSequence =  { GameConst.CardSortType.Quality, GameConst.CardSortType.SuitCompose, GameConst.CardSortType.SuitAllLevel, GameConst.CardSortType.SuitWithTag, GameConst.CardSortType.Level, GameConst.CardSortType.Tag, GameConst.CardSortType.ID, GameConst.CardSortType.CardId }    ---思念星级>思念等级    local twoSortSequence = { GameConst.CardSortType.Quality, GameConst.CardSortType.Level, GameConst.CardSortType.Tag, GameConst.CardSortType.ID, GameConst.CardSortType.CardId }    local unlockSlotMap = self:TryGetUnLockCardSlot()    for i, v in ipairs(tempStageList) do        if formationDataList[v.Index] then            local stageID = v.stageID            checkAutoNoAdd(self, formationDataList[v.Index], stageID, unlockSlotMap, tempAllCards, oneSortNoSuitSequence, twoSortSequence)        end    end    PoolUtil.ReleaseTable(tempAllCards)    PoolUtil.ReleaseTable(tempStageList)    return formationDataListend--endregion---获取芯核数据---@param formationUID int 玩法编队id---@param cardID int 思念卡idfunction FormationBLL:GetGemCores(formationUID, cardID)    if formationUID >= 27 and formationUID <= 35 then        --猎人锦标赛        local rankLevel        if formationUID <= 29 then            rankLevel = 1 --初级猎人锦标赛        elseif formationUID <= 32 then            rankLevel = 2 --中级猎人锦标赛        else            rankLevel = 3 --高级猎人锦标赛        end        return BllMgr.GetHunterContestBLL():GetGemCores(cardID, rankLevel)    else        return SelfProxyFactory.GetCardDataProxy():GetCardGemCores(cardID)    endend---跳转到编队预设界面function FormationBLL:JumpPreFabFormation()    UIMgr.Open(UIConf.TeamWnd, TeamConst.FormationType.PreFabFormation)endreturn FormationBLL