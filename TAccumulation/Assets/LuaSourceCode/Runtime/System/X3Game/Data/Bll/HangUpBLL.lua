---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yizhimao002.
--- DateTime: 2022/11/14 10:49
---

---@class HangUpBLL
local HangUpBLL = class("HangUpBLL", BaseBll)
---@type HangUpConst
local HangUpConstData = require("Runtime.System.X3Game.GameConst.HangUpConst")
---@type function 
local dataCallBack
---@type pbcmessage.GetHangUpDataReply
local netData
---@type table<number, number> <ExploreState, ExploreType>
local curState

local DataRequestCoolingTime = 3

function HangUpBLL:OnInit()
    self.hangingUpTimer = nil
    self.lastDataRequestTime = -1000
end

--- UIView的MoveOut开关:在UIViewContext_Message2Box打开时设置
---@type boolean
local UIVIewMoveOutAC = false

---@param value boolean
function HangUpBLL:SetSpeedMoveOutAC(value)
    UIVIewMoveOutAC = value
end

---@return boolean
function HangUpBLL:GetSpeedMoveOutAC()
    return UIVIewMoveOutAC
end

--- @param replyData pbcmessage.GetHangUpDataReply
function HangUpBLL:SetNetData(replyData)
    netData = {}
    netData.ExploreWaves = {}
    netData.HangUps = {}

    if replyData ~= nil then
        netData = replyData
    end

    if self.hangingUpTimer then
        TimerMgr.Discard(self.hangingUpTimer)
        self.hangingUpTimer = nil
    end

    if netData.HangUps and table.nums(netData.HangUps) > 0 then
        local curExploreStamp = 0
        local nowExploreTime = TimerMgr.GetCurTimeSeconds()
        for _, v in pairs(netData.HangUps) do
            curExploreStamp = v.Timestamp
            if curExploreStamp > nowExploreTime then -- 挂机中
                self.hangingUpTimer = TimerMgr.AddTimer(curExploreStamp - nowExploreTime, self.HangUpFinish, self, 1)
                break
            end
        end
    end

    self:RefreshRedFunc()
end

--- @return pbcmessage.GetHangUpDataReply
function HangUpBLL:GetNetData()
    return netData
end

function HangUpBLL:SetStateData(state, type)
    curState = { ExploreState = state, ExploreType = type }
end

function HangUpBLL:GetStateData()
    return curState
end

--- @return function
function HangUpBLL:GetDataCallBack()
    return dataCallBack
end

--- @return function
function HangUpBLL:SetNullDataCallBack()
    dataCallBack = nil
end

--- 红点刷新
function HangUpBLL:RefreshRedFunc()
    local haveHangUp = false
    local curExploreStamp = 0
    for i, v in pairs(netData.HangUps) do
        if (v.ExploreID == HangUpConstData.NormalExploreId or v.ExploreID == HangUpConstData.SpecialExploreId) then
            curExploreStamp = v.Timestamp
            haveHangUp = true
        end
    end
    local nowExploreTime = TimerMgr.GetCurTimeSeconds()
    local thisExploreState = HangUpConstData.ExploreState.HangUpTo
    if(haveHangUp) then
        if (nowExploreTime >= curExploreStamp) then
            thisExploreState = HangUpConstData.ExploreState.HangUped
        else
            thisExploreState = HangUpConstData.ExploreState.HangUping
        end
    end
    RedPointMgr.UpdateCount(X3_CFG_CONST.RED_EXPLORE_REWARD, thisExploreState == 2 and 1 or 0)
    if thisExploreState == HangUpConstData.ExploreState.HangUpTo then
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_EXPLORE_COST, self:_CheckHangUpItemState())
    else
        RedPointMgr.UpdateCount(X3_CFG_CONST.RED_EXPLORE_COST, 0)
    end
end

---获取挂机结束可领奖的时间
function HangUpBLL:GetCheckRewardTime()
    if(netData ~= nil) then
        --获取挂机结束时间
        local reawardTime
        if(netData.HangUps ~= nil) then
            for i, v in pairs(netData.HangUps) do
                reawardTime = v.Timestamp
            end
            --local timeStamp = TimerMgr.GetDateByServerTimestamp(reawardTime)
            local timeStamp = TimerMgr.GetDateByUnixTimestamp(reawardTime)
            Debug.LogWarning("TimeStamp : " .. tostring(reawardTime))
            Debug.LogWarning(string.format("TimeStr : %02d-%02d-%02d %02d:%02d:%02d", 
                    timeStamp.year, timeStamp.month, timeStamp.day, timeStamp.hour, timeStamp.min, timeStamp.sec))
            return reawardTime
        end
    end
    return nil
end

function HangUpBLL:HangUpFinish()
    EventMgr.Dispatch("HangUp_SpeedUpReply") -- 与加速完成等价
    self:RefreshRedFunc()
    if self.hangingUpTimer then
        TimerMgr.Discard(self.hangingUpTimer)
        self.hangingUpTimer = nil
    end
end

--- 请求开始挂机
function HangUpBLL:BeginRequest(thisExploreID)
    local tab = { ExploreID = thisExploreID }
    self.ExploreID = thisExploreID
    GrpcMgr.SendRequest(RpcDefines.BeginRequest, tab, true)
end

function HangUpBLL:BeginReply(reply)
    local cfg = LuaCfgMgr.Get("HangUpReward", self.ExploreID)
    local totalTime = cfg.Time - 1
    if self.ExploreID then
        netData.HangUps[self.ExploreID] = {}
        netData.HangUps[self.ExploreID].ExploreID = self.ExploreID
        netData.HangUps[self.ExploreID].Timestamp = TimerMgr.GetCurTimeSeconds() + totalTime
        self.ExploreID = nil
    end

    if self.hangingUpTimer then
        TimerMgr.Discard(self.hangingUpTimer)
        self.hangingUpTimer = nil
    end
    self.hangingUpTimer = TimerMgr.AddTimer(totalTime, self.HangUpFinish, self, 1)

    self:RefreshRedFunc()
    EventMgr.Dispatch("HangUp_BeginRequestReply", reply)
end

--- 挂机完成获得奖励
function HangUpBLL:GetRewardRequest(thisExploreID)
    local tab = { ExploreID = thisExploreID }
    GrpcMgr.SendRequest(RpcDefines.GetRewardRequest, tab, true)
end

function HangUpBLL:GetRewardReply(reply)
    netData.HangUps = {}
    self:RefreshRedFunc()
    EventMgr.Dispatch("HangUp_GetRewardReply", reply)
end

--- 请求取消挂机
function HangUpBLL:CancelRequest(thisExploreID)
    local tab = { ExploreID = thisExploreID }
    GrpcMgr.SendRequest(RpcDefines.CancelRequest, tab, true)
end

function HangUpBLL:CancelReply(reply)
    netData.HangUps = {}
    if self.hangingUpTimer then
        TimerMgr.Discard(self.hangingUpTimer)
        self.hangingUpTimer = nil
    end
    self:RefreshRedFunc()
    EventMgr.Dispatch("HangUp_CancelReply", reply)
end

--- 请求加速挂机
function HangUpBLL:SpeedUpRequest(thisExploreID)
    local tab = { ExploreID = thisExploreID }
    self.ExploreID = thisExploreID
    GrpcMgr.SendRequest(RpcDefines.SpeedUpRequest, tab, true)
end

function HangUpBLL:SpeedUpReply(reply)
    if self.ExploreID then
        netData.HangUps[self.ExploreID] = {}
        netData.HangUps[self.ExploreID].ExploreID = self.ExploreID
        netData.HangUps[self.ExploreID].Timestamp = TimerMgr.GetCurTimeSeconds()
        self.ExploreID = nil
    end
    if self.hangingUpTimer then
        TimerMgr.Discard(self.hangingUpTimer)
        self.hangingUpTimer = nil
    end
    self:RefreshRedFunc()
    EventMgr.Dispatch("HangUp_SpeedUpReply", reply)
end

--- 上传曲线设置参数
--- @param exploreID number
--- @param p1 number
--- @param p2 number
function HangUpBLL:SetExploreWaveRequest(exploreID, p1, p2)
    self.tab = {
        ExploreID = exploreID,
        ExploreWave = { P1 = p1, P2 = p2 }, 
    }
    GrpcMgr.SendRequest(RpcDefines.SetExploreWaveRequest, self.tab, true)
end

function HangUpBLL:SetExploreWaveReply()
    if self.tab then
        netData.ExploreWaves[self.tab.ExploreID] = self.tab.ExploreWave
        self.tab = nil
    end
end

---判断拥有道具的状态(不能判断首次获得)
---@param itemID number
---@return boolean true:表示拥有该道具，false:表示未拥有该道具
function HangUpBLL:CheckHasItemState(itemID)
    local itemData = BllMgr.GetItemBLL():GetItem(itemID)
    if(itemData == nil) then return false end
    if(itemData.Num == 0) then return false end
    return true
end

---检查挂机领奖所用道具的状态
function HangUpBLL:_CheckHangUpItemState()
    local itemData = BllMgr.GetItemBLL():GetItem(HangUpConstData.HangUpNormal.ID)
    if itemData and itemData.Num > 0 then
        return 1
    end
    itemData = BllMgr.GetItemBLL():GetItem(HangUpConstData.HangUpSpecial.ID)
    if itemData and itemData.Num > 0 then
        return 1
    end
    return 0
end

---将服务器发送的奖励分为两个展示的表
---@param rewardTab table<S3Int>
---@return table,table,boolean
function HangUpBLL:GetRewardShowList(rewardTab)
    local fullCardTab = {}
    local zeroTransTab = {}
    local extraReward = {}
    local transReward = {}
    local hasCard = false
    for k, v in pairs(rewardTab) do
        if (v.Type == X3_CFG_CONST.ITEM_TYPE_CARD or v.Type == X3_CFG_CONST.ITEM_TYPE_SCORE) then
            table.insert(fullCardTab, v)
        elseif v.Type == 0 then
            table.insert(zeroTransTab, v)
            table.insert(transReward, v)
        else
            table.insert(extraReward, v)
        end
    end
    if (table.nums(fullCardTab) == 0 and table.nums(zeroTransTab) > 0) then
        hasCard = true
        for k, v in pairs(zeroTransTab) do
            local itemCfg = LuaCfgMgr.Get("Item", v.Id)
            local tmpItemData = { Id = v.Id, Type = itemCfg.Type, Num = v.Num }
            table.insert(fullCardTab, tmpItemData)
        end
    end
    return fullCardTab, extraReward, transReward, hasCard
end

---跳转挂机领奖界面
---@param page number 0、1普通；2特殊；不传会根据持有的磁石自动选择
---@param isRequestData bool 是否请求后端数据
function HangUpBLL:JumpToExploreWnd(page)
    if not SysUnLock.IsUnLock(41040) then
        return false
    end
    UIMgr.Open(UIConf.ExploreWnd, page)
    return true
end

function HangUpBLL:OnClear()
    if self.hangingUpTimer then
        TimerMgr.Discard(self.hangingUpTimer)
        self.hangingUpTimer = nil
    end
end

return HangUpBLL