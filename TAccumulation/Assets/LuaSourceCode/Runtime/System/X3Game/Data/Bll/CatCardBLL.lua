---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by pc.
--- DateTime: 2020/8/25 16:40
---@type CatCardConst
local CatCardConst = require("Runtime.System.X3Game.Modules.CatCard.Data.CatCardConst")
---@class CatCardBLL
local CatCardBLL = class("CatCardBLL", BaseBll)
---@type CatCardConditionCheckCtrl
local CatCardConditionCheckCtrl = require("Runtime.System.X3Game.Modules.CatCard.Controller.CatCardConditionCheckCtrl")

function CatCardBLL:IsCanRefreshAllModels()
    return self.isCanRefreshAllModels
end

function CatCardBLL:SetIsCanRefreshAllModels(isCanRefreshAllModels)
    self.isCanRefreshAllModels = isCanRefreshAllModels
end

---@return boolean
function CatCardBLL:IsPrepare()
    return self.isPrepare
end

---@param isPrepare boolean
function CatCardBLL:SetPrepare(isPrepare)
    self.isPrepare = isPrepare
end

function CatCardBLL:IsBreak()
    return self.isBreak
end

function CatCardBLL:IsRunningDirty()
    return self.is_running_dirty
end

function CatCardBLL:SetIsBreak(isBreak)
    if isBreak ~= self.isBreak then
        self.isBreak = isBreak
    end
end

function CatCardBLL:SetBreakProcedure(breakType, breakCall, breakTarget, ...)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_BREAK, breakType, breakCall, breakTarget, ...)
end

function CatCardBLL:SendMsgToGuide(...)
    EventMgr.Dispatch(Const.Event.CLIENT_TO_GUIDE, ...)
end

function CatCardBLL:IsInGuide()
    return SelfProxyFactory.GetGamePlayProxy():IsGuide(Define.GamePlayType.GamePlayTypeMiao, self.sub_id)
end

function CatCardBLL:GetDialogueData()
    return LuaCfgMgr.Get("DialogueInfo", self:GetDrama())
end

function CatCardBLL:GetRootModel()
    return self.stateData:GetMiaoCardDiff().Model
end

function CatCardBLL:GetScene()
    return self.stateData:GetMiaoCardDiff().Scene
end

function CatCardBLL:GetDrama()
    return self.stateData:GetMiaoCardDiff().Drama
end

function CatCardBLL:SetRtCamera(rt_camera)
    self.rt_camera = rt_camera
end

function CatCardBLL:GetRtCamera(rt_camera)
    return self.rt_camera
end

---@param mode CatCardConst.CardMode
function CatCardBLL:SetCardMode(mode)
    self.card_mode = mode
end

---@return CatCardConst.CardMode
function CatCardBLL:GetCardMode()
    return self.card_mode
end

function CatCardBLL:IsNeedRoll()
    local rollResult = self.stateData:GetRollResult()
    return rollResult == nil or (rollResult ~= CatCardConst.RoundRes.WIN and rollResult ~= CatCardConst.RoundRes.LOSS)   --已经不是第一轮了， 不需要Roll
end

---是否是某个玩家状态
function CatCardBLL:IsState(player_type)
    local state = self.stateData:GetState()
    if player_type == CatCardConst.PlayerType.PLAYER then
        return state >= CatCardConst.State.P1_PRE and state <= CatCardConst.State.P1_ACT
    else
        return state >= CatCardConst.State.P2_PRE and state <= CatCardConst.State.P2_ACT
    end
end

---获取卖萌反悔等待时间
function CatCardBLL:GetExchangeCardRegretWaitTime()
    local dt = 0
    local sp_action = self.stateData:GetMiaoCardDiff().SPAction
    if sp_action then
        local id = sp_action[1]
        local sp_conf = LuaCfgMgr.Get("MiaoCardSPAction", id)
        if sp_conf then
            dt = sp_conf.FucPara3 and sp_conf.FucPara3[1] or dt
            dt = dt / 1000
        end
    end
    return dt
end

---创建本地模拟数据
---@param datas table player_type,count
function CatCardBLL:MakeLocalCards(datas)
    local function make_data(player_type, num_count, func_count)
        local data = {}
        data.PlayerType = player_type
        data.NumCardCount = num_count
        data.FuncCardCount = func_count
        data.NumCardList = {}
        data.FuncCardList = {}
        return data
    end
    local cards = {}
    for k, v in pairs(datas) do
        local data = make_data(v.player_type, v.num_count, v.func_count)
        table.insert(cards, data)
    end
    self:SetCardInfo(cards)
end

function CatCardBLL:GetLocalState()
    return self.local_state
end

---@return CatCardStateData
function CatCardBLL:GetStateData()
    return self.stateData
end

function CatCardBLL:GetBuffData(playerType)
    return self.stateData:GetBuffData(playerType)
end

---指定类型玩家是否有指定buff
---@param buffId CatCardConst.BuffType
---@param playerType CatCardConst.PlayerType
function CatCardBLL:HasBuff(buffId, playerType)
    local buffData = self:GetBuffData(playerType)
    if next(buffData) then
        for i, v in pairs(buffData) do
            if v.ID == buffId then
                return true
            end
        end
    end
    return false
end

---设置本地辅助状态，
function CatCardBLL:SetLocalState(st, is_force, ...)
    if is_force or st ~= self.local_state then
        self.local_state = st
        if self:IsDebugMode() then
            self:Log("---local state---", self:GetLocalStateName(st))
        end
        EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_LOCAL_STATE_CHANGE, st, ...)
    end
end

---缓存分数
function CatCardBLL:SaveScore(score, player_type)
    self.save_score_map[player_type] = score
end

---本地状态检测
---@param state_flag string  CatCardConst.LocalState.IN_SWITCHING --状态标识符
function CatCardBLL:IsInLocalState(state_flag)
    if not state_flag then
        Debug.LogError("[CatCardBLL:IsInLocalState]--failed state_flag is nil")
        return false
    end
    local local_state = self:GetLocalState()
    local start_state = CatCardConst.LocalState[state_flag]
    local end_state_key = self.local_state_check_map[state_flag]
    if not end_state_key then
        end_state_key = string.concat(state_flag, CatCardConst.LOCAL_STATE_FLAG)
        self.local_state_check_map[state_flag] = end_state_key
    end
    local end_state = CatCardConst.LocalState[end_state_key]
    if local_state >= start_state and local_state < end_state then
        return true
    end
    return false
end

---local state 是否处于idle状态
function CatCardBLL:IsLocalStateIdle()
    return self:GetLocalState() == CatCardConst.LocalState.NONE
end

function CatCardBLL:GetDailyDateId()
    return self.daily_date_id
end

function CatCardBLL:GetSubId()
    return self.sub_id
end

function CatCardBLL:GetEnterType()
    return self.enter_type
end

---获取特殊行为
function CatCardBLL:GetSPAction(player_type)
    local sp_action = self.stateData:GetSPAction()
    if not sp_action and player_type and player_type == CatCardConst.PlayerType.PLAYER then
        if self.stateData:GetPopState() ~= CatCardConst.PopCardState.PopNum then
            return
        end
        sp_action = self.stateData:GetMiaoCardDiff().SPAction
        if sp_action then
            local id = sp_action[1]
            --女主自身特殊行为
            if id == CatCardConst.SpecialType.ROB
                    or id == CatCardConst.SpecialType.EXCHANGE
            then
                sp_action = { id = id }
            end
        end
    end
    if sp_action == nil or sp_action.id == nil then
        return nil
    end
    return sp_action
end

---@param spType CatCardConst.SpecialType
function CatCardBLL:IsInSpecialAction(spType)
    if not self.stateData then
        return false
    end
    if self.stateData:GetSpState() == 0 then
        return false
    end
    return CatCardConst.SpecialTypeToRole[spType] == self.stateData:GetMiaoCardDiff().ManType
end

---@return bool
function CatCardBLL:IsExchange()
    return self.is_exchange
end

---@param value bool
function CatCardBLL:SetIsExchange(value)
    self.is_exchange = value
end

function CatCardBLL:GetEventGroup()
    return self.stateData:GetMiaoCardDiff().EventGroup
end

---是否正在进行中
function CatCardBLL:IsRunning()
    return self.is_running
end

function CatCardBLL:SetIsRunning(is_running)
    if is_running == self.is_running then
        return
    end
    self.is_running = is_running
    self:SetTouchEnable(not is_running)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_CARD_CAN_SELECT)
end

---@param is_dirty boolean
function CatCardBLL:SetIsRunningDirty(is_dirty)
    self.is_running_dirty = is_dirty
    self.frame_count = GameMgr.GetFrameCount()
end

function CatCardBLL:GetFrameCount()
    return self.frame_count
end

function CatCardBLL:IsGlobalTouchEnable()
    return self.is_global_touch_enable
end

---@param is_enable boolean
---@param block_type string
function CatCardBLL:SetGlobalTouchEnable(is_enable, block_type)
    block_type = block_type or self.__cname
    self.touch_block_ctrl:SetIsRunning(block_type, not is_enable)
    is_enable = not self.touch_block_ctrl:IsRunning()
    if is_enable ~= self.is_global_touch_enable then
        self.is_global_touch_enable = is_enable
        if not is_enable then
            EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SET_WND_TOUCH_ENABLE, self:IsGlobalTouchEnable())
        else
            self:SetIsRunningDirty(true)
        end
    end
end

---检测是否正在进行中
function CatCardBLL:CheckRunning()
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_RUNNIG)
end

function CatCardBLL:GetStateName(state)
    for k, v in pairs(CatCardConst.State) do
        if v == state then
            return k
        end
    end
end

function CatCardBLL:GetActionName(action_type)
    for k, v in pairs(CatCardConst.SpecialType) do
        if v == action_type then
            return k
        end
    end
end

function CatCardBLL:GetAnimationName(ani_type)
    for k, v in pairs(CatCardConst.AnimationType) do
        if v == ani_type then
            return k
        end
    end
end

function CatCardBLL:GetLocalStateName(st)
    for k, v in pairs(CatCardConst.LocalState) do
        if st == v then
            return k
        end
    end
end

---检测当前状态
function CatCardBLL:CheckState(is_special, ...)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========CheckState===========", self:GetStateName(self.stateData:GetState()), is_special)
    end
    if self.is_pause then
        local param = { ... }
        self.pause_action = function()
            self:CheckState(is_special, table.unpack(param))
        end
        return
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CHECK_STATE, self.stateData:GetState(), is_special, ...)
end

---检测当前Action
function CatCardBLL:CheckAction(action_type, ...)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========CheckAction===========", self:GetActionName(action_type), ":", self:GetStateName(self.stateData:GetState()))
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_ACTION, action_type, ...)
end

---检测当前Action
---@param action_data CatCard.BaseActionData
function CatCardBLL:ExecuteAction(action_data)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========ExecuteAction===========", action_data:GetActionType(), ":", self:GetStateName(self.stateData:GetState()))
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_EXECUTE_ACTION, action_data:GetActionType(), action_data)
end

---检测当前Animation
function CatCardBLL:CheckAnimation(ani_type, ...)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========CheckAnimation===========", self:GetAnimationName(ani_type), ":", self:GetStateName(self.stateData:GetState()))
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_ANIMATION, ani_type, ...)
end

function CatCardBLL:CheckSound(sound_type, ...)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========CheckSound===========", ...)
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_SOUND, sound_type, ...)
end

function CatCardBLL:CheckEffect(effect_type, ...)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========CheckEffect===========", ...)
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_EFFECT, effect_type, ...)
end

---@param pipeline_type CatCard.PipelineType
---@vararg any
function CatCardBLL:CheckPipeline(pipeline_type, ...)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========CheckPipeline===========", ...)
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_PIPELINE, pipeline_type, ...)
end

---修改当前的动画的运行状态
---@param running_state CatCardConst.AniRunningState
---@param ani_type CatCardConst.AnimationType
function CatCardBLL:ChangeAnimationState(ani_type, running_state, ...)
    if self:IsDebugMode() then
        self:Log(os.clock(), "  =========ChangeAnimationState===========", self:GetAnimationName(ani_type), ":", self:GetStateName(self.stateData:GetState()), ":", running_state)
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHANGE_ANIMATION_RUNNING_STATE, ani_type, running_state, ...)
end

function CatCardBLL:QuitCheck(ok, cancel)
    local msg_box_conf = CatCardConst.Message_box_conf
    self:Pause()
    UICommonUtil.ShowMessageBox(msg_box_conf.content, {
        { btn_type = GameConst.MessageBoxBtnType.CONFIRM, btn_text = msg_box_conf.ok, btn_call = function()
            if ok then
                ok()
            end
            self:Resume(true)
            self:QuitConfirm()
        end },
        { btn_type = GameConst.MessageBoxBtnType.CANCEL, btn_text = msg_box_conf.cancel, btn_call = function()
            if cancel then
                cancel()
            end
            self:Resume()
            self:QuitCancel()
        end },

    })
end

function CatCardBLL:QuitConfirm()
    GamePlayMgr.ClearDialogue()
    ErrandMgr.SetDelay(true)
    self:CheckAction(CatCardConst.SpecialType.NET_WORK, CatCardConst.NetworkType.GETMIAOREWARD, nil, true, Miao.MiaoPlayerPos.MiaoPlayerPosNope)
    self:SetIsExit(true)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_STOP_PIPE_LINE)
end

function CatCardBLL:QuitCancel()
end

---投降
---@param pos Miao.MiaoPlayerPos
function CatCardBLL:OnSurrender(pos)
    pos = pos == nil and Miao.MiaoPlayerPos.MiaoPlayerPosNope or pos
    GamePlayMgr.ClearDialogue()
    ErrandMgr.SetDelay(true)
    self:CheckAction(CatCardConst.SpecialType.NET_WORK, CatCardConst.NetworkType.GETMIAOREWARD, nil, false, pos)
    self:SetIsExit(true)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_STOP_PIPE_LINE)
end

function CatCardBLL:Pause()
    self.is_pause = true
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SET_ALL_RUNNING_MODELS_LAYER, true, CatCardConst.CardType.SLOT)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_GAME_PAUSE)
    if not self.is_ani_pause then
        self:ChangeAnimationState(nil, CatCardConst.AniRunningState.PAUSE)
    end
end

function CatCardBLL:Resume(is_exit)
    self.is_pause = false
    if not is_exit then
        EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SET_ALL_RUNNING_MODELS_LAYER, false, CatCardConst.CardType.SLOT)
        EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_GAME_RESUME)
        if not self.is_ani_pause then
            self:ChangeAnimationState(nil, CatCardConst.AniRunningState.RESUME)
        end
    else
        GamePlayMgr.GetController():GamePlayResume()
    end
    if self.pause_action then
        self.pause_action()
        self.pause_action = nil
    end
end

---@param is_ani_pause bool 是否动画暂停状态
function CatCardBLL:SetAniPause(is_ani_pause)
    self.is_ani_pause = is_ani_pause
end

---@return boolean
function CatCardBLL:IsPause()
    return self.is_pause
end

---根据当前状态获取本地配置
function CatCardBLL:GetStateConfByState(state)
    return CatCardConst.StateConf[state ~= nil and state or self.stateData:GetState()]
end

---新手引导跳过事件
function CatCardBLL:GuideSkipEvent()
    self:SetGuideSkipState(true)
    self:Pause()
    self:QuitConfirm()
end

function CatCardBLL:GetGuideSkipState()
    return self.is_guide_skip
end

function CatCardBLL:SetGuideSkipState(value)
    self.is_guide_skip = value
end
---根据位置信息获取数据
---获取卡牌数据
---pos_index ，数据顺序1-10
---获取Slot数据
---pos_index 数据顺序 1-8 ---服务器数据 0--7
---@param card_type CatCardConst.CardType
---@param pos_index int
---@param player_type CatCardConst.PlayerType
---@return CatCardData
function CatCardBLL:GetData(card_type, pos_index, player_type)
    if not card_type or not pos_index then
        return nil
    end
    if card_type == CatCardConst.CardType.CARD then
        if self:GetCardMode() == CatCardConst.CardMode.Old then
            return self:GetOldData(card_type, pos_index, player_type)
        end
    end
    local map = self.data_map[card_type]
    if player_type then
        for k, v in pairs(map) do
            if v:GetPlayerType() == player_type and pos_index == v:GetIndex() then
                return v
            end
        end
        return nil
    end
    return map[pos_index]
end

---根据类型创建数据
---@param card_type CatCardConst.CardType
---@param card_id int
---@param pos_index int
---@return CatCardData
function CatCardBLL:GenData(card_type, card_id, pos_index, ...)
    local pool = self.data_pool[card_type]
    ---@type CatCardData
    local data = pool:Get()
    local server_data = PoolUtil.GetTable()
    server_data.Id = card_id
    server_data.PosIndex = pos_index
    data:Refresh(server_data)
    PoolUtil.ReleaseTable(server_data)
    return data
end

---release 数据
---@param data CatCardData
function CatCardBLL:ReleaseData(data)
    if not data then
        return
    end
    local pool = self.data_pool[data:GetType()]
    pool:Release(data)
end

---根据功能卡牌类型获得cardid
---@param func_card_type CatCardConst.FuncCardType
---@param player_type CatCardConst.PlayerType
function CatCardBLL:GetCardIdByFuncType(func_card_type, player_type)
    ---@type CatCardData[]
    local data_list = self:GetDataList(CatCardConst.CardType.CARD, player_type or CatCardConst.PlayerType.PLAYER)
    if data_list then
        for i, v in pairs(data_list) do
            if v:GetEffectId() == func_card_type then
                return v:GetId()
            end
        end
    end
    PoolUtil.ReleaseTable(data_list)
    return 0
end

---根据功能卡牌类型获得功能牌数据
---@param func_card_type CatCardConst.FuncCardType
---@param player_type CatCardConst.PlayerType
function CatCardBLL:GetCardDataByFuncType(func_card_type, player_type)
    ---@type CatCardData[]
    local data_list = self:GetDataList(CatCardConst.CardType.CARD, player_type or CatCardConst.PlayerType.PLAYER)
    if data_list then
        for i, v in pairs(data_list) do
            if v:GetEffectId() == func_card_type then
                return v
            end
        end
    end
    PoolUtil.ReleaseTable(data_list)
    return nil
end

---根据卡牌类型获得功能牌/数字牌数据列表
---@param playerType CatCardConst.PlayerType
---@param cardSubType CatCardConst.SubType
---@param res table
function CatCardBLL:GetCardDataListBySubType(playerType, cardSubType, res)
    ---@type CatCardData[]
    local dataList = self:GetDataList(CatCardConst.CardType.CARD, playerType or CatCardConst.PlayerType.PLAYER)
    if dataList then
        for _, cardData in pairs(dataList) do
            if cardSubType == CatCardConst.SubType.FUNCCARD then
                if cardData:IsFuncCard() then
                    table.insert(res, cardData)
                end
            elseif cardSubType == CatCardConst.SubType.NORMALCARD then
                if not cardData:IsFuncCard() then
                    table.insert(res, cardData)
                end
            end

        end
    end
    PoolUtil.ReleaseTable(dataList)
end

---获取当前格子杯垫模型
function CatCardBLL:GetCupMatModel(tag, pos)
    if tag ~= 1 then
        return string.concat(self.stateData:GetMiaoCardDiff().OwnerModel[tag and tag or 2], "_", pos - 1)
    else
        return self.stateData:GetMiaoCardDiff().OwnerModel[tag and tag or 2]
    end
end

function CatCardBLL:SetSlotInfo(ResultList)
    local card_type = CatCardConst.CardType.SLOT
    self:ClearDataList(card_type)
    local map = self.data_map[card_type]
    if ResultList and #ResultList > 0 then
        for k, v in ipairs(ResultList) do
            local data = self:GenData(card_type, nil, k)
            data:Refresh(v)
            table.insert(map, data)
        end
    end

end

function CatCardBLL:SetCardInfo(card_list)
    local card_type = CatCardConst.CardType.CARD
    self:ClearDataList(card_type)
    if #card_list == 0 then
        return
    end
    ---@type CatCardData
    local card
    local server_data = PoolUtil.GetTable()
    local map = self.data_map[card_type]
    local is_local = true
    local default_num_id = CatCardConst.DEFAULT_CARD_ID
    local default_func_id = CatCardConst.DEFAULT_FUNC_CARD_ID
    local count = 0
    local pos_index = 1
    local num_count = 0
    for k, v in pairs(card_list) do
        pos_index = 1
        server_data.PlayerType = v.PlayerType > 0 and CatCardConst.PlayerType.ENEMY or v.PlayerType
        local is_enemy = server_data.PlayerType == CatCardConst.PlayerType.ENEMY
        is_local = #v.NumCardList == 0
        count = 0
        if not is_local then
            for index, id in ipairs(v.NumCardList) do
                card = self:GenData(card_type, is_enemy and default_num_id or id, pos_index)
                card:Refresh(server_data)
                card:SetRealId(id)
                pos_index = pos_index + 1
                table.insert(map, card)
            end
        else
            count = v.NumCardCount or 0
            num_count = count
        end
        is_local = #v.FuncCardList == 0
        if not is_local then
            for index, id in ipairs(v.FuncCardList) do
                card = self:GenData(card_type, is_enemy and default_func_id or id, pos_index)
                card:Refresh(server_data)
                card:SetRealId(id)
                pos_index = pos_index + 1
                table.insert(map, card)
            end
        else
            count = count + (v.FuncCardCount or 0)
        end
        if count > 0 then
            for index = 1, count do
                server_data.IsLocal = true
                card = self:GenData(CatCardConst.CardType.CARD, index <= num_count and default_num_id or default_func_id, pos_index)
                card:Refresh(server_data)
                pos_index = pos_index + 1
                table.insert(map, card)
            end
        end
        self.stateData:SetBuffData(server_data.PlayerType, v.BuffList)
    end
    PoolUtil.ReleaseTable(server_data)
end

---查看男主是否有功能牌
function CatCardBLL:CheckRoleHasFuncCard()
    ---@type CatCardData[]
    local cardData = self:GetDataList(CatCardConst.CardType.CARD, CatCardConst.PlayerType.ENEMY)
    local is_func = false
    for i, v in pairs(cardData) do
        if v:IsFuncCard() then
            is_func = true
            break
        end
    end
    PoolUtil.ReleaseTable(cardData)
    return is_func
end

---重新排序数据
---@param card_type CatCardConst.CardType
---@param player_type CatCardConst.PlayerType
function CatCardBLL:ResetDataIndex(card_type, player_type)
    local data_list = self:GetDataList(card_type, player_type)
    if #data_list >= 2 then
        table.sort(data_list, self.SortDataByTypeAndIndex)
    end
    for k, v in ipairs(data_list) do
        v:SetIndex(k)
    end
    PoolUtil.ReleaseTable(data_list)
end

---@param a CatCardData
---@param b CatCardData
function CatCardBLL.SortDataByTypeAndIndex(a, b)
    if a:GetSubType() ~= b:GetSubType() then
        return a:GetSubType() < b:GetSubType()
    end
    return a:GetIndex() < b:GetIndex()
end

---@param a CatCardData
---@param b CatCardData
function CatCardBLL.OnSortDataByIndex(a, b)
    return a:GetIndex() < b:GetIndex()
end

---@param data CatCardData | SlotData
function CatCardBLL:AddData(data)
    local card_type = data:GetType()
    local map = self.data_map[card_type]
    table.insert(map, data)
    self:ResetDataIndex(card_type, data:GetPlayerType())
end

---@param card_type CatCardConst.CardType
---@param index int
---@param player_type CatCardConst.PlayerType
---@return CatCardData | SlotData
function CatCardBLL:RemoveData(card_type, index, player_type)
    ---@type CatCardData[]
    local map = self.data_map[card_type]
    local data = nil
    if player_type then
        for k, v in pairs(map) do
            if v:GetPlayerType() == player_type and index == v:GetIndex() then
                data = table.remove(map, k)
                break
            end
        end
    else
        data = table.remove(map, index)
    end
    return data
end

---@param card_type CatCardConst.CardType
---@param player_type CatCardConst.PlayerType
---@param card_id int
---@return CatCardData | SlotData
function CatCardBLL:RemoveDataById(card_id, card_type, player_type)
    local idx = self:GetDataIndex(card_id, card_type, player_type)
    return idx and self:RemoveData(card_type, idx, player_type) or nil
end

---@param card_id int
---@param card_type CatCardConst.CardType
---@param player_type CatCardConst.PlayerType
---@return int
function CatCardBLL:GetDataIndex(card_id, card_type, player_type)
    local map = self.data_map[card_type]
    if not map then
        return nil
    end
    local idx = -1
    if player_type == CatCardConst.PlayerType.ENEMY then
        if card_type == CatCardConst.CardType.CARD then
            local data = self:GenData(card_type, card_id, 0)
            if data:IsFuncCard() then
                card_id = CatCardConst.DEFAULT_FUNC_CARD_ID
            else
                card_id = CatCardConst.DEFAULT_CARD_ID
            end
            self:ReleaseData(data)
        end
    end
    if player_type then
        for k, v in pairs(map) do
            if v:GetPlayerType() == player_type and card_id == v:GetId() then
                if v:GetIndex() > idx then
                    idx = v:GetIndex()
                end
            end
        end
    else
        for k, v in pairs(map) do
            if v:GetId() == card_id then
                if v:GetIndex() > idx then
                    idx = v:GetIndex()
                end
            end
        end
    end
    return idx >= 0 and idx or nil
end

--- 根据类型获取数据列表
---@param card_type CatCardConst.CardType
---@param player_type CatCardConst.PlayerType
---@return CatCardData[] | SlotData[]
function CatCardBLL:GetDataList(card_type, player_type)
    local data_map = self.data_map[card_type]
    local res = PoolUtil.GetTable()
    for k, v in pairs(data_map) do
        if v:IsValid() then
            if not player_type or player_type == v:GetPlayerType() then
                table.insert(res, v)
            end
        end
    end
    return res
end

---是否已占满格子
---@return bool
function CatCardBLL:IsFullSlot()
    local data_list = self:GetDataList(CatCardConst.CardType.SLOT)
    local count = 0
    for i, v in pairs(data_list) do
        if v:IsOccupied() then
            count = count + 1
        end
    end
    return count == CatCardConst.SLOT_COUNT
end

---@param index int
---@param card_id int
---@param player_type CatCardConst.PlayerType
function CatCardBLL:SaveOldCard(index, card_id, player_type)
    local map = self.old_card_map[player_type]
    if not map then
        map = PoolUtil.GetTable()
        self.old_card_map[player_type] = map
    end
    map[index] = card_id
end

---根据位置信息获取数据
---获取卡牌数据
---pos_index ，数据顺序1-10
---获取Slot数据
---pos_index 数据顺序 1-8 ---服务器数据 0--7
---@param card_type CatCardConst.CardType
---@param pos_index int
---@param player_type CatCardConst.PlayerType
---@return CatCardData
function CatCardBLL:GetOldData(card_type, pos_index, player_type)
    if not card_type or not pos_index or not player_type then
        return nil
    end
    if card_type == CatCardConst.CardType.CARD then
        local cardId = self:GetOldCardId(player_type, pos_index)
        if cardId and cardId ~= 0 then
            local map = self.old_data_map[player_type]
            if not map then
                map = PoolUtil.GetTable()
                self.old_data_map[player_type] = map
            end
            ---@type CatCardData
            local data = map[pos_index]
            if not data then
                data = self:GenData(card_type, cardId, pos_index)
                data:SetPlayerType(player_type)
                map[pos_index] = data
            end
            return data
        end
    end
    return nil
end

---@param card_type CatCardConst.CardType
---@param pos_index int
---@param player_type CatCardConst.PlayerType
function CatCardBLL:ClearOldData(card_type, pos_index, player_type)
    if not card_type or not pos_index or not player_type then
        return nil
    end
    if card_type == CatCardConst.CardType.CARD then
        local map = self.old_data_map[player_type]
        if map then
            local data = map[pos_index]
            if data then
                self:ReleaseData(data)
                map[pos_index] = nil
            end
        end
    end
    return nil
end

---@param card_id int
---@param player_type CatCardConst.PlayerType
---@return int
function CatCardBLL:GetOldCardIndex(card_id, player_type)
    local map = self.old_card_map[player_type]
    local idx = 0
    if map then
        for k, v in pairs(map) do
            if v == card_id then
                if k > idx then
                    idx = k
                end
            end
        end
    end
    return idx
end

---@param player_type CatCardConst.PlayerType
---@return int
function CatCardBLL:GetOldCardId(player_type, index)
    local map = self.old_card_map[player_type]
    return map and map[index] or 0
end

---@param player_type CatCardConst.PlayerType
function CatCardBLL:GetOldCardList(player_type)
    if not self.old_card_map or not player_type then
        return
    end
    return self.old_card_map[player_type]
end

function CatCardBLL:ClearOldCards()
    for k, v in pairs(self.old_card_map) do
        for m, n in pairs(v) do
            self:ClearOldData(CatCardConst.CardType.CARD, m, k)
        end
        table.clear(v)
    end
end

function CatCardBLL:ClearDataList(card_type)
    if not card_type then
        for k, v in pairs(CatCardConst.CardType) do
            self:ClearDataList(v)
        end
        return
    end
    local data_list = self:GetDataList(card_type)
    local is_card = card_type == CatCardConst.CardType.CARD
    if is_card then
        self:ClearOldCards()
    end
    for k, v in pairs(data_list) do
        if is_card then
            self:SaveOldCard(v:GetIndex(), v:GetId(), v:GetPlayerType())
        else
            self.old_slot_map[v:GetIndex()] = v:GetId()
        end
        self:ReleaseData(v)
    end
    PoolUtil.ReleaseTable(data_list)
    table.clear(self.data_map[card_type])
end

function CatCardBLL:GetOldSlotIdByIndex(slot_index)
    return self.old_slot_map[slot_index]
end

---获取已经被占用的格子数
function CatCardBLL:GetOccupiedNum(player_type)
    local count = 0
    local slot_data_list = self:GetDataList(CatCardConst.CardType.SLOT)
    for k, v in pairs(slot_data_list) do
        if v:IsOccupied(player_type) then
            count = count + 1
        end
    end
    PoolUtil.ReleaseTable(slot_data_list)
    return count
end

---切換选牌方
function CatCardBLL:ChangeToSelect(player_type)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_SPECIAL_STATE)
end

---获取名称
function CatCardBLL:GetName(player_type, is_string)
    if player_type == CatCardConst.PlayerType.ENEMY then
        local name = LuaCfgMgr.Get("RoleInfo", self.stateData:GetMiaoCardDiff().ManType).Name
        if is_string and type(name) ~= "string" then
            name = UITextHelper.GetUIText(name)
        end
        return name
    end
    return SelfProxyFactory.GetPlayerInfoProxy():GetName()
end

---获取对方头像
function CatCardBLL:GetHeadIcon(player_type)
    if player_type == CatCardConst.PlayerType.ENEMY then
        return LuaCfgMgr.Get("RoleInfo", self.stateData:GetMiaoCardDiff().ManType).RoleIconDialogueLeft
    end
    if not self.player_icon then
        local headId = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PLDEFAULTDIALOGUEHEADRIGHT)
        local data = LuaCfgMgr.Get("DialogueHeadImg", headId)
        self.player_icon = data and data.ImgName
    end
    return self.player_icon
end

---根据玩家类型获取玩家分数
function CatCardBLL:GetScore(player_type, is_from_cache)
    local score = 0
    if is_from_cache then
        score = self.save_score_map[player_type]
        return score and score or self:GetScore(player_type)
    end
    local data_list = self:GetDataList(CatCardConst.CardType.SLOT)
    for k, v in pairs(data_list) do
        score = score + v:GetScore(player_type)
    end
    PoolUtil.ReleaseTable(data_list)
    return score
end

function CatCardBLL:GetScoreBySlotIdx(slot_idx, player_type)
    local data = self:GetData(CatCardConst.CardType.SLOT, slot_idx)
    player_type = player_type or data:GetOccupyPlayer()
    return data and data:GetScore(player_type) or 0, player_type
end

---设置当前选中的card/slot的index
function CatCardBLL:SetCurSelectIndex(card_type, pos_index, is_enable)
    if not card_type then
        for k, v in pairs(CatCardConst.CardType) do
            self:SetCurSelectIndex(v)
        end
        return
    end
    if pos_index then
        if is_enable == nil then
            is_enable = true
        end
        if is_enable then
            if not self:IsPosIndexSelected(card_type, pos_index) then
                table.insert(self.cur_select_map[card_type], pos_index)
            end
            EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SELECT_SLOT_CHANGE)
        else
            for k, v in pairs(self.cur_select_map[card_type]) do
                if v == pos_index then
                    table.remove(self.cur_select_map[card_type], k)
                end
            end
        end
    else
        table.clear(self.cur_select_map[card_type])
    end
end

---获取当前选中的card/slot的index
function CatCardBLL:GetCurSelectIndex(card_type)
    return card_type and self.cur_select_map[card_type][#self.cur_select_map[card_type]] or nil
end

function CatCardBLL:SetChangeSlotEvent(changeSlot)
    self.changeSlot = changeSlot
end

function CatCardBLL:GetChangeSlot()
    return self.changeSlot
end

---@param playerType CatCardConst.PlayerType
function CatCardBLL:DoChangeSlotEvent(playerType)
    local changeScore = self:GetScore(playerType) - self:GetScore(playerType, true)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SHOW_SCORE, self.changeSlot, changeScore, playerType, function()
        EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_REFRESH_SCORE)
    end)
    self.changeSlot = nil
end

---获取当前所有的选中的列表
function CatCardBLL:GetSelectIndexs(card_type)
    return card_type and self.cur_select_map[card_type] or nil
end

---当前格子是否被选中
function CatCardBLL:IsPosIndexSelected(card_type, pos_index)
    local select_list = self:GetSelectIndexs(card_type)
    if select_list and #select_list > 0 then
        for k, v in pairs(select_list) do
            if v == pos_index then
                return true
            end
        end
    end
    return false
end

---当前选中的数量
function CatCardBLL:GetCurSelectCount(card_type)
    local select_table = self:GetSelectIndexs(card_type)
    return select_table and #select_table or 0
end

---获取卡牌数量
---@param player_type CatCardConst.PlayerType
---@param sub_type CatCardConst.CardSubType
function CatCardBLL:GetCardCount(player_type, sub_type)
    local data_list = self:GetDataList(CatCardConst.CardType.CARD, player_type)
    local count = #data_list
    if sub_type then
        count = 0
        for i, v in pairs(data_list) do
            if v:GetSubType() == sub_type then
                count = count + 1
            end
        end
    end
    PoolUtil.ReleaseTable(data_list)
    return count
end

---是否可以换牌
function CatCardBLL:IsCanSwitch(card_type)
    return self:GetCurSelectCount(card_type) >= CatCardConst.TypeConf[card_type].SWITCH_COUNT
end

---是否可以悔牌
function CatCardBLL:IsCanRegret(card_type)
    if not card_type then
        local is_ok = true
        for k, v in pairs(CatCardConst.CardType) do
            is_ok = self:IsCanRegret(v)
            if not is_ok then
                break
            end
        end
        return is_ok
    end
    return self:GetCurSelectCount(card_type) >= CatCardConst.TypeConf[card_type].REGRET_COUNT
end

---当前是否可以摸牌
function CatCardBLL:IsCanGetCard(player_type)
    return self:GetCardCount(player_type) < CatCardConst.MAX_CARD_COUNT
end

function CatCardBLL:IsCurRoundOver()
    return self.stateData:GetState() == CatCardConst.State.END
end

function CatCardBLL:GetModelRt(rt)
    return self.model_rt
end

function CatCardBLL:SetModelRt(rt)
    self.model_rt = rt
end

---获取当前论结果
---@param player_type CatCardConst.PlayerType
---@return CatCardConst.RoundRes
function CatCardBLL:GetRoundRes(player_type)
    local player_score = self:GetScore(CatCardConst.PlayerType.PLAYER)
    local enemy_score = self:GetScore(CatCardConst.PlayerType.ENEMY)
    local player_res, enemy_res
    if player_score == enemy_score then
        player_res = CatCardConst.RoundRes.DRAW
        enemy_res = CatCardConst.RoundRes.DRAW
    elseif player_score > enemy_score then
        player_res = CatCardConst.RoundRes.WIN
        enemy_res = CatCardConst.RoundRes.LOSS
    else
        player_res = CatCardConst.RoundRes.LOSS
        enemy_res = CatCardConst.RoundRes.WIN
    end
    if self.is_guide_skip and player_res ~= CatCardConst.RoundRes.WIN then
        player_res = CatCardConst.RoundRes.WIN
        enemy_res = CatCardConst.RoundRes.LOSS
    end
    if player_type then
        if player_type == CatCardConst.PlayerType.PLAYER then
            return player_res
        else
            return enemy_res
        end
    end
    return player_res, enemy_res
end

---获取剩余轮数
function CatCardBLL:GetRemainRound()
    return self.stateData:GetMaxRoundCount() - self.stateData:GetCurRound()
end

function CatCardBLL:IsTouchEnableByState(st)
    local is_enable = false
    if st == CatCardConst.State.P1_PRE or st == CatCardConst.State.P2_PRE then
        is_enable = true
    end
    return is_enable
end

---设置全局点击
function CatCardBLL:SetTouchEnable(is_enable)
    if is_enable then
        local st = self.stateData:GetState()
        is_enable = self:IsTouchEnableByState(st)
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SET_TOUCH_ENABLE, is_enable)
end

---@return CatCard.ModeType
function CatCardBLL:GetMode()
    return self.stateData:GetMode()
end

--- 获取一个空的卡位置
---如果是摸牌的话，都放在最后面，如果是出牌的话，针对于玩家，是根据选择查找，针对于npc是随机一个位置
function CatCardBLL:GetValidPosIndex(player_type, action_type, card_id)
    if action_type == CatCardConst.SpecialType.GET_CARD then
        return self:GetCardCount(player_type)
    elseif action_type == CatCardConst.SpecialType.POP_CARD then
        if player_type == CatCardConst.PlayerType.PLAYER then
            return self:GetCurSelectIndex(CatCardConst.CardType.CARD)
        else
            return math.random(1, self:GetCardCount(player_type) + 1)
        end
    elseif action_type == CatCardConst.SpecialType.REGRET then
        if player_type == CatCardConst.PlayerType.ENEMY then
            if card_id then
                return math.random(1, self:GetCardCount(player_type))
            else
                return self:GetCardCount(player_type) + 1
            end
        end
    end
    return 0
end

---获取出牌等待时间
function CatCardBLL:GetWaitingTime(player_type)
    if player_type == CatCardConst.PlayerType.PLAYER then
        return 0
    else
        return math.random(self.stateData:GetMiaoCardDiff().MaleActWaitMinTime, self.stateData:GetMiaoCardDiff().MaleActWaitMaxTime) / 1000
    end
end

---获取偷牌前思考时间
function CatCardBLL:GetStealWaitingTime()
    local dt = 0
    local sp_action = self.stateData:GetMiaoCardDiff().SPAction
    if sp_action then
        local id = sp_action[1]
        local sp_conf = LuaCfgMgr.Get("MiaoCardSPAction", id)
        if sp_conf then
            local FucPara4 = sp_conf.FucPara4
            if FucPara4 then
                local min = sp_conf.FucPara4[1] or 0
                local max = sp_conf.FucPara4[2] or 0
                dt = math.random(min, max) / 1000
            end

        end
    end
    return dt
end

---是否已经成功过
function CatCardBLL:HasActionSuccess(action_type, count)
    local sp_records = self.stateData:GetSPRecords()
    if sp_records then
        for k, v in pairs(sp_records) do
            if v.id == action_type then
                if not table.isnilorempty(v.args) then
                    if v.args and v.args[1] > 0 then
                        if count then
                            return v.args[1] >= count
                        end
                        return true
                    end
                end
            end
        end
    end
    return false
end

---清理当前播放的剧情
function CatCardBLL:ClearDialogue()
    GamePlayMgr.GetController():ForceEndDialogue(false)
end

---是否可以执行某个action
function CatCardBLL:IsCanAction(player_type, action_type)
    if action_type == CatCardConst.SpecialType.REGRET then
        local card_count = self:GetCardCount(player_type)
        if card_count == 0 then
            return false
        end
        if self:GetOccupiedNum(player_type) == 0 then
            return false
        end
    end
    return true
end

---@param round number 轮数
---@return CatCardConst.RoundRes
function CatCardBLL:GetRoundResByRound(round)
    local res = self.stateData:GetResultByRound(round)
    return res
end

-----------------------------服务器数据交互-----------------------------------------------------------

function CatCardBLL:GetReqParam()
    if not self.req_param then
        self.req_param = PoolUtil.GetTable()
    end
    return self.req_param
end

function CatCardBLL:ClearReqParam()
    PoolUtil.ReleaseTable(self.req_param)
    self.req_param = nil
end

function CatCardBLL:RewardViewCall()
    if self:IsInLocalState(CatCardConst.LocalState.IN_ROUNDENDING) then
        self:SetLocalState(CatCardConst.LocalState.ROUNDENDING_END_ON_VIEW_CLOSE)
    else
        self:Exit()
    end
end

---显示结算
function CatCardBLL:ShowReward(msg, dialogue_call)
    local data = {}
    local daily_id = self:GetDailyDateId()
    local sub_id = self:GetSubId()
    data.clickHandler = handler(self, self.RewardViewCall)
    data.dialogue_call = dialogue_call
    data.dailyDateEntryId = daily_id
    data.subId = sub_id
    data.rewardList = msg.RewardList
    data.resultList = msg.ResultList
    UIMgr.Open(CatCardConst.WND_REWARD_VIEW_TAG, data)
end

---初始化或者是Roll
function CatCardBLL:CheckRoll()
    if self:IsNeedRoll() then
        self:CheckAction(CatCardConst.SpecialType.NET_WORK, CatCardConst.NetworkType.ROLLMIAO)
    else
        self:CheckAction(CatCardConst.SpecialType.NET_WORK, CatCardConst.NetworkType.INITMIAOHAND)
    end
end

---解析数据
function CatCardBLL:ParseInfo(msg)
    self.stateData:ParseInfo(msg)
    self:SetSlotInfo(msg.ChessBoard and msg.ChessBoard.SlotList)
    self:SetCardInfo(msg.MiaoPlayers)
end

-----保存消息数据
--function CatCardBLL:SaveMsg(msg)
--    self.savedMsg = msg
--end

-----应有已保存的消息数据
--function CatCardBLL:ApplySavedMsg()
--    if self.savedMsg then
--        self:ParseInfo(self.savedMsg)
--        self:ClearSavedMsg()
--    end
--end

-----清除已保存的消息数据
--function CatCardBLL:ClearSavedMsg()
--    self.savedMsg = nil
--end

---播放action之前预处理操作
function CatCardBLL:PrePlayCardSpAction(spAction)
    --目前只有偷牌
    --对npc卡特殊操作
    if not spAction then
        return
    end
    local action_type = spAction and spAction.id or 0
    if action_type == CatCardConst.SpecialType.STEAL then
        local res = self.stateData:GetSPAction().args[1]
        if res == CatCardConst.StealState.STEALCAUGHTENEMYGETCARD then
            local card_count = self:GetCardCount(CatCardConst.PlayerType.ENEMY)
            if card_count > 0 then
                local card_data = self:GetData(CatCardConst.CardType.CARD, self:GetCardCount(CatCardConst.PlayerType.ENEMY), CatCardConst.PlayerType.ENEMY)
                card_data:SetIsValid(false)
                self:SaveServerCards(CatCardConst.PlayerType.ENEMY, card_data)
            else
                Debug.LogError("偷牌之后卡牌数据错误")
            end
        end
    end
end

function CatCardBLL:SaveServerCards(card_type, card)
    if not self.save_cards then
        self.save_cards = {}
    end
    table.insert(self.save_cards, card)
end

function CatCardBLL:RestoreCards()
    if self.save_cards then
        for k, v in pairs(self.save_cards) do
            v:SetIsValid(true)
        end
        table.clear(self.save_cards)
    end

end

---设置出功能牌原始牌
function CatCardBLL:SetSourceFuncCard(card_id)
    self.source_card_id = card_id
end

---获得功能牌原始牌
function CatCardBLL:GetSourceFuncCard()
    return self.source_card_id or 0
end

---清理数据
function CatCardBLL:ClearInfo()
    self.touch_block_ctrl:SetIsRunning(false)
    table.clear(self.select_state_map)
    self.is_running = nil
    self.is_end_func_effect = true
    self.stateData:SetDialogueVariableMap(nil)
    self:SetModelRt(nil)
    self:SetRtCamera(nil)
    self:ClearReqParam()
    self:SetCurSelectIndex()
    self.stateData:ClearActionRes()
    self:ClearDataList()
    self.stateData:ClearRecord()
    self.stateData:ClearCache()
    self:ClearPool()
    --self:ClearSavedMsg()
    self.func_node_list = nil
    for k, pool in pairs(self.data_pool) do
        pool:ClearCache()
    end
end

function CatCardBLL:ClearPool()
    for k, v in pairs(self.action_data_map) do
        if v.pool then
            PoolUtil.Release(v.pool)
        end
        PoolUtil.ReleaseTable(v)
    end
    for k, v in pairs(self.old_card_map) do
        PoolUtil.ReleaseTable(v)
    end
    table.clear(self.action_data_map)
    table.clear(self.data_parser_map)
    table.clear(self.old_card_map)
    table.clear(self.old_slot_map)
end

----------------------------重构逻辑分割线---------------------------------------------

-----------------------------外部任务检测相关------------------------------------------------------------------------------
--region Condition Check
---任务调用检测
function CatCardBLL:CheckCondition(conditionType, datas, iDataProvider)
    return CatCardConditionCheckCtrl.CheckCondition(self, conditionType, datas, iDataProvider)
end

---获取总的成功，或者失败次数
function CatCardBLL:GetWinningInfo(result)
    local WinCount = 0
    local LossCount = 0
    local DrawCount = 0
    local SurrenderCount = 0
    result = result and result or self.stateData:GetResultList()
    if result and #result > 0 then
        for k, v in pairs(result) do
            if v == CatCardConst.RoundRes.WIN then
                WinCount = WinCount + 1
            elseif v == CatCardConst.RoundRes.LOSS then
                LossCount = LossCount + 1
            elseif v == CatCardConst.RoundRes.DRAW then
                DrawCount = DrawCount + 1
            elseif v == CatCardConst.RoundRes.PlayerSurrender then
                LossCount = LossCount + 1
                SurrenderCount = 1
            elseif v == CatCardConst.RoundRes.AISurrender then
                WinCount = WinCount + 1
                SurrenderCount = 1
            end
        end
    end

    return WinCount, LossCount, DrawCount, SurrenderCount
end

---获取连续的成功或者失败次数
function CatCardBLL:GetSuccessiveWinningInfo()
    local WinCount = 0
    local LossCount = 0
    local DrawCount = 0
    local resultList = self.stateData:GetResultList()
    if not resultList or #resultList == 0 then
        return WinCount, LossCount, DrawCount
    end
    local lastRet = 0
    for k, v in pairs(resultList) do
        if v == CatCardConst.RoundRes.WIN then
            if lastRet == CatCardConst.RoundRes.WIN or lastRet == 0 then
                WinCount = WinCount + 1
            end
            lastRet = v
        elseif v == CatCardConst.RoundRes.LOSS then
            if lastRet == CatCardConst.RoundRes.LOSS or lastRet == 0 then
                LossCount = LossCount + 1
            end
            lastRet = v
        elseif v == CatCardConst.RoundRes.DRAW then
            if lastRet == CatCardConst.RoundRes.DRAW or lastRet == 0 then
                LossCount = LossCount + 1
            end
            lastRet = v
        end
    end
    return WinCount, LossCount, DrawCount
end
--endregion Condition Check Over

function CatCardBLL:OnClear()
    EventMgr.RemoveListenerByTarget(self)
end

function CatCardBLL:OnInit()
    ---------------------迭代数据----------------
    self.is_debug = false
    self.is_global_touch_enable = true
    self.isEnableDateDebug = false
    self.is_pause = false
    self.pause_action = nil
    self.data_map = {}
    self.cur_select_map = {}
    self.save_score_map = {}
    self.local_state_check_map = {}
    self.isBreak = false
    self.daily_date_id = 0
    self.sub_id = 0
    self.is_end_func_effect = true
    self.is_brand_mode = false  --是否明牌模式
    self.is_skip_ani = false --是否跳过动画表演
    self.is_ani_pause = false  --是否动画暂停状态
    self.touch_block_ctrl = require("Runtime.System.X3Game.Modules.Common.MultiConditionCtrl").new()
    ---获取卡的模式
    self.card_mode = CatCardConst.CardMode.Current
    for k, v in pairs(CatCardConst.CardType) do
        self.data_map[v] = {}
        self.cur_select_map[v] = {}
    end
    local slot = require("Runtime.System.X3Game.Modules.CatCard.Data.SlotData")
    local card = require("Runtime.System.X3Game.Modules.CatCard.Data.CatCardData")
    local state_data = require("Runtime.System.X3Game.Modules.CatCard.Data.CatCardStateData")
    ---@type CatCardStateData
    self.stateData = state_data.new()
    self.data_pool = {
        [CatCardConst.CardType.SLOT] = PoolUtil.Get(function()
            local data = slot.new()
            data:SetBll(self)
            return data
        end, function(data)
            data:Clear()
            data:SetBll(self)
        end),
        [CatCardConst.CardType.CARD] = PoolUtil.Get(function()
            local data = card.new()
            data:SetBll(self)
            return data
        end, function(data)
            data:Clear()
            data:SetBll(self)
        end),
    }
    self.action_data_create_func = handler(self, self.OnActionDataCreate)
    self.action_data_release_func = handler(self, self.OnActionDataRelease)
    self.action_data_map = {}
    ---@type ActionRecord[]
    self.cur_turn_action_record = {}  --当前回合操作记录
    self.data_parser_map = {}
    self.old_card_map = {}
    self.old_data_map = {}
    self.old_slot_map = {}
    self.select_state_map = {}
    self.func_node_list = nil
    ---已保存的消息数据
    self.savedMsg = nil
    self.is_exit = true
    self.has_exit_execute = false
    ---喵喵牌日志上传的路径列表
    self.ossUpLoadFilePathList = {}
    ---当前上传的日志的Idx
    self.curUpLoadIdx = 0
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_GAME_END_EVENT, self.OnGameEnd, self)
    self:UpLoadMiaoCatCardLog()
end

---@param parserType int
---@return CatCard.BaseDataParser
function CatCardBLL:GetDataParser(parserType)
    local data_parser = self.data_parser_map[parserType]
    if not data_parser then
        local path = CatCardConst.DataParserConf[parserType]
        if string.isnilorempty(path) then
            path = CatCardConst.DataParserConf[CatCardConst.DataParserType.Default]
        end
        data_parser = require(path).new()
        self.data_parser_map[parserType] = data_parser
    end
    return data_parser
end

---@param serverType CatCardConst.MiaoActionType | CatCardConst.FuncEffectType
---@param isAction boolean
function CatCardBLL:GetActionType(serverType, isAction)
    local actionType = nil
    if isAction then
        actionType = CatCardConst.ActionSwitch[serverType]
    else
        actionType = CatCardConst.EffectSwitch[serverType]
    end
    if not actionType then
        Debug.LogWarningFormat("[喵喵牌]未找到对应的action类型[{%s}]:[{%s}]", serverType, isAction and "action" or "effect")
    end
    return actionType
end

---@param seat number
---@return CatCardConst.PlayerType
function CatCardBLL:GetPlayerType(seat)
    return CatCardConst.PlayerTypeSwitch[seat]
end

---@param actionData CatCard.BaseActionData
function CatCardBLL:ReleaseActionData(actionData)
    local action_type = actionData:GetActionType()
    if not action_type then
        return
    end
    local pool = self:GetActionDataPool(actionData:GetActionType())
    pool:Release(actionData)
end

---@param actionType CatCard.ActionType
---@param playerType CatCardConst.PlayerType
---@param finishCall fun():void
---@return CatCard.BaseActionData
function CatCardBLL:GetActionData(actionType, playerType, finishCall)
    if not actionType then
        return
    end
    local pool = self:GetActionDataPool(actionType)
    ---@type CatCard.BaseActionData
    local data = pool:Get(actionType)
    data:SetAction(actionType, playerType, finishCall)
    data:Init()
    return data
end

---@param actionType CatCard.ActionType
---@return CatCard.BaseActionData
function CatCardBLL:OnActionDataCreate(actionType)
    local template = self:GetActionDataTemplate(actionType)
    return template.new()
end

---@param actionData CatCard.BaseActionData
function CatCardBLL:OnActionDataRelease(actionData)
    actionData:Clear()
end

---@param actionType CatCard.ActionType
---@return Pool
function CatCardBLL:GetActionDataPool(actionType)
    local action = self:GetActionDataMap(actionType)
    return action.pool
end

---@param actionType CatCard.ActionType
---@return table
function CatCardBLL:GetActionDataTemplate(actionType)
    local action = self:GetActionDataMap(actionType)
    return action.template
end

---@class CatCard.ActionDataMap
---@field template table
---@field pool Pool
---@param actionType CatCard.ActionType
---@return CatCard.ActionDataMap
function CatCardBLL:GetActionDataMap(actionType)
    local action = self.action_data_map[actionType]
    if not action then
        action = PoolUtil.GetTable()
        action.template = require(CatCardConst.ActionDataConf[actionType] or CatCardConst.BASE_ACTION_DATA_PATH)
        if action.template == nil then
            Debug.LogErrorFormat("[喵喵牌] GetActionDataMap --failed[%s]", actionType)
        end
        action.pool = PoolUtil.Get(self.action_data_create_func, self.action_data_release_func)
        self.action_data_map[actionType] = action
    end
    return action
end

---功能自定义日志
function CatCardBLL:Log(...)
    if not self.is_debug then
        return
    end
    Debug.LogWithTag(GameConst.LogTag.CatCard, "[喵喵牌]:", ...)
end

---Date相关的Log
function CatCardBLL:LogDate(...)
    if not self.isEnableDateDebug then
        return
    end
    Debug.LogWithTag(GameConst.LogTag.CatCard, "【DateLog】 ", ...)
end

---@param formatStr string :格式化数据
function CatCardBLL:LogFormat(formatStr, ...)
    self:Log(string.format(formatStr, ...))
end

---@param formatStr string :格式化数据
function CatCardBLL:LogDateFormat(formatStr, ...)
    self:LogDate(string.format(formatStr, ...))
end

---初始化数据，启动procedure的时候会触发
function CatCardBLL:Init(dateOpenData)
    self.daily_date_id = dateOpenData.dailyDateEntryId
    self.sub_id = dateOpenData.subId
    self.enter_type = dateOpenData.enterType
    self.stateData:SetMiaoCardDiff(self.sub_id)
end

---检测是否可以进入
function CatCardBLL:CheckEnter()
    self:Enter()
end

function CatCardBLL:IsCanSendMsg()
    return not self:IsExited()
end

function CatCardBLL:IsExited()
    return self.is_exit
end

function CatCardBLL:SetIsExit(is_exit)
    self.is_exit = is_exit
end

function CatCardBLL:GetBrandMode()
    self.is_brand_mode = PlayerPrefs.GetBool("BrandMode")
    return self.is_brand_mode
end

function CatCardBLL:SetSkipAniState(is_on)
    self.is_skip_ani = is_on
end

function CatCardBLL:IsSkipAniState()
    return self.is_skip_ani
end

---@param is_end_func_effect bool 是否结束功能牌效果展示
function CatCardBLL:SetFuncEffectEndState(is_end_func_effect)
    self.is_end_func_effect = is_end_func_effect
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_FINISH_LOCK_STATE, self.is_end_func_effect)
end

---@return bool 是否结束功能牌效果展示
function CatCardBLL:GetFuncEffectEndState()
    return self.is_end_func_effect
end

function CatCardBLL:SetDiscardActionState(state)
    self.is_on_discard_action = state
end

function CatCardBLL:GetDiscardActionState()
    return self.is_on_discard_action
end

function CatCardBLL:SetFuncNodeList(func_node_list)
    self.func_node_list = func_node_list
end

function CatCardBLL:GetFuncNodeByIndex(index)
    return self.func_node_list and self.func_node_list[index]
end

---槽位位置记录
---@param slot_pos_map Vector3[]
function CatCardBLL:SetSlotPosMap(slot_pos_map)
    self.slot_pos_map = slot_pos_map
end

---@return Vector3 获得槽位屏幕坐标
function CatCardBLL:GetSlotPosByIndex(pos_index)
    return self.slot_pos_map and self.slot_pos_map[pos_index]
end

---@param input InputComponent
function CatCardBLL:SetSelectActionInputComponent(input)
    self.selectActionInputComponent = input
end

---@return InputComponent
function CatCardBLL:GetSelectActionInputComponent()
    return self.selectActionInputComponent
end

---@return table
function CatCardBLL:GetSelectStateMap()
    return self.select_state_map
end

---检查给定状态或者当前状态是否为非p1p2阶段
---@param state CatCardConst.State
function CatCardBLL:CheckIsNotP1OrP2State(state)
    if not state then
        state = self.stateData:GetState()
    end

    if state < CatCardConst.State.P1_PRE or state > CatCardConst.State.P2_ACT then
        return true
    end

    return false
end

---是否是调试模式
---@return boolean
function CatCardBLL:IsDebugMode()
    self.is_debug = PlayerPrefs.GetBool("CatDebugState")
    return self.is_debug
end

---是否是约会日志调试模式
---@return boolean
function CatCardBLL:IsDateDebugMode()
    self.isEnableDateDebug = PlayerPrefs.GetBool("CatDateDebugState")
    return self.isEnableDateDebug
end

---将targetOwnerType根据playerType转换为selectTargetOwner
---@param targetOwnerType CatCardConst.TargetOwnerType
---@param playerType CatCardConst.PlayerType
---@return CatCardConst.SelectTargetOwner
function CatCardBLL:ConvertSelectTargetOwner(targetOwnerType, playerType)
    local select_target_owner = CatCardConst.SelectTargetOwner.All

    if targetOwnerType == CatCardConst.TargetOwnerType.Opposite then
        if playerType == CatCardConst.PlayerType.PLAYER then
            select_target_owner = CatCardConst.SelectTargetOwner.Enemy
        else
            select_target_owner = CatCardConst.SelectTargetOwner.Player
        end
    elseif targetOwnerType == CatCardConst.TargetOwnerType.Self then
        if playerType == CatCardConst.PlayerType.PLAYER then
            select_target_owner = CatCardConst.SelectTargetOwner.Player
        else
            select_target_owner = CatCardConst.SelectTargetOwner.Enemy
        end
    end

    return select_target_owner
end

---在OldData模式的时候根据index删除当前使用的牌
---@param index number
---@param player_type CatCardConst.PlayerType
function CatCardBLL:RemoveOldCardByIndex(index, player_type)
    local array = PoolUtil.GetTable()
    local map = self.old_card_map[player_type]
    local length = table.nums(map)
    for i = 1, length do
        if index ~= i then
            table.insert(array, map[i])
        end
    end

    table.clear(map)
    for k, v in ipairs(array) do
        map[k] = v
    end
    PoolUtil.ReleaseTable(array)
end

---@param player_type CatCardConst.PlayerType
function CatCardBLL:ReGenOldDataMap(player_type)
    if not self.old_data_map[player_type] then
        self.old_data_map[player_type] = PoolUtil.GetTable()
    else
        ---@param v CatCardData
        for _, v in pairs(self.old_data_map[player_type]) do
            if not table.isnilorempty(v) then
                v:Clear()
                PoolUtil.ReleaseTable(v)
            end
        end
        table.clear(self.old_data_map[player_type])
    end

    for k, v in ipairs(self.old_card_map[player_type]) do
        ---@type CatCardData
        local data = self:GenData(CatCardConst.CardType.CARD, v, k)
        data:SetPlayerType(player_type)
        self.old_data_map[player_type][k] = data
    end
end

---@param actionType CatCard.ActionType
function CatCardBLL:GetActionNameByType(actionType)
    for name, v in pairs(CatCardConst.ActionType) do
        if v == actionType then
            return name
        end
    end
    return ""
end

function CatCardBLL:Enter()
    self.has_exit_execute = false
    self.is_running_dirty = false
    self.frame_count = 0
    self.is_global_touch_enable = true
    self:SetPrepare(true)
    self:SetIsCanRefreshAllModels(true)
    self.is_pause = false
    self:SetIsExit(false)
    self:SetLocalState(CatCardConst.LocalState.NONE)
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_ENTER)
end

function CatCardBLL:HasExit()
    return self.has_exit_execute
end

function CatCardBLL:Exit()
    if self.has_exit_execute then
        return
    end
    self.has_exit_execute = true
    self:SetPrepare(false)
    self.is_pause = false
    self.is_ani_pause = false
    self.pause_action = nil
    self:SetIsExit(true)
    GamePlayMgr.SaveResult(self.stateData:GetResultList())
    DialogueManager.Get("GamePlay"):ExitDialogueAll()
    GamePlayMgr.Finish()
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_EXIT)
    self:ClearInfo()
end

---@param reply pbcmessage.GetMiaoRewardReply
function CatCardBLL:OnGameEnd(reply)
    self.stateData:SetGamePlayRecord(reply.Record)
end

function CatCardBLL:OssUpLoadCallBack(result)
    local filePath = self.ossUpLoadFilePathList[self.curUpLoadIdx]
    Debug.Log("UpLoadOss = %d", result.ret)
    if result.ret == 0 then
        ---上传成功后删除本地文件
        if CS.System.IO.File.Exists(filePath) then
            CS.System.IO.File.Delete(filePath)
        end
    end
    if self.curUpLoadIdx + 1 <= #self.ossUpLoadFilePathList then
        self.curUpLoadIdx = self.curUpLoadIdx + 1
        self:OssUpLoadMiaoCatCardLog(self.curUpLoadIdx, handler(self, self.OssUpLoadCallBack))
    else
        self.ossUpLoadFilePathList = {}
        self.curUpLoadIdx = 0
    end
end

---上传喵喵牌log到oss
function CatCardBLL:UpLoadMiaoCatCardLog()
    if not SDKMgr.IsHaveSDK() then
        return
    end
    self.ossUpLoadFilePathList = {}
    self.curUpLoadIdx = 1
    local path = CS.UnityEngine.Application.persistentDataPath .. "/GamePlayRecord/Miao"
    local outList = CS.System.IO.Directory.GetFiles(path, "*.json")
    if not outList then
        return
    end
    local filePathList = GameHelper.ToTable(outList)
    for i = 1, #filePathList do
        local filePath = filePathList[i]
        local fileName = CS.System.IO.Path.GetFileNameWithoutExtension(filePath)
        if not string.match(fileName, "[%a]") then
            table.insert(self.ossUpLoadFilePathList, filePath)
        end
    end
    if #self.ossUpLoadFilePathList <= 0 then
        return
    end
    self:OssUpLoadMiaoCatCardLog(self.curUpLoadIdx, handler(self, self.OssUpLoadCallBack))
end

function CatCardBLL:OssUpLoadMiaoCatCardLog(idx, callback)
    if self.ossUpLoadFilePathList[idx] == nil then
        return
    end
    local filePath = self.ossUpLoadFilePathList[idx]
    local fileName = CS.System.IO.Path.GetFileName(filePath)
    SDKMgr.OSSUpLoad(GameConst.OSSType.MiaoCardLog, filePath, nil, CatCardConst.OssLogCategory, fileName, callback)
end

return CatCardBLL