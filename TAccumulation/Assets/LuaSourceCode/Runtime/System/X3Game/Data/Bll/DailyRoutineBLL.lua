--- 
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sms.
--- DateTime: 2023/9/22 12:46
--- 男主作息BLL

-- 三层作息 按优先级覆盖 (普通作息表 < 特殊作息 < 主动触发作息)

---@class DailyRoutineBLL
local DailyRoutineBLL = class("DailyRoutineBLL", BaseBll)

---@type DailyRoutineUtil 工具类
local DailyRoutineUtil = require('Runtime.System.X3Game.Modules.DailyRoutine.DailyRoutineUtil')

local MIN_TIME = 60
local HOUR_TIME = MIN_TIME * 60
local DAY_TIME = HOUR_TIME * 24
local WEEK_TIME = DAY_TIME * 7

function DailyRoutineBLL:OnInit()
    -- 叫醒指定男主的Dialogue事件
    EventMgr.AddListener(DailyRoutineEnum.EventMap.WakedByPlayerDialogueEvent, function(self, param)
        if table.isnilorempty(param) then Debug.LogError("EE DialogueConfirmTrigger param is nil !!--------- ") return end
        local closeCallback = param.handler
        local args = param.params
        local roleId = tonumber(args[1])
        
        -- 叫醒男主
        self:WakeRoleUp(roleId)
        
        if closeCallback then closeCallback() end
    end, self)
end

function DailyRoutineBLL:OnClear()
    EventMgr.RemoveListenerByTarget(self)
end

---@public 条件判断
function DailyRoutineBLL:CheckCondition(id, params, iDataProvider)
    if id == X3_CFG_CONST.CONDITION_DAILYROUTINE_STATE then
        ---指定男主（Para1）当前所在的作息是否（Para2）为指定状态（Para3）
        local roleId = tonumber(params[1])
        local flag = tonumber(params[2]) == 1
        local state = tonumber(params[3])
        -- 如果男主未解锁则直接返回false
        if not BllMgr.GetRoleBLL():IsUnlocked(roleId) then return false end
        
        local curState = self:GetCurStateByRoleId(roleId)
        if flag then return curState == state else return curState ~= state end
    end
end

-- 客户端GM： （全小写）
-- "uicmd dailyroutine logon"                      -- 打开日志
-- "uicmd dailyroutine logoff"                     -- 关闭日志
-- "uicmd dailyroutine dump (roleId)"              -- 打印指定男主的四层作息表数据
-- "uicmd dailyroutine dump current"               -- 打印所有男主的当前所在的作息状态数据
-- "uicmd dailyroutine wakeup (roleId)"            -- 叫醒指定男主

---GM指令接管处理
function DailyRoutineBLL:HandleGMCommand(inputList)
    Debug.LogError("【男主作息】GM命令执行: " .. table.dump(inputList))

    -- 男主作息功能测试
    if inputList[3] == "dump" then
        if inputList[4] == "all" then
            local proxy = SelfProxyFactory.GetDailyRoutineProxy()
            Debug.LogError(table.dump({proxy.allRoutineDataMap}))
        elseif inputList[4] == "current" then
            local proxy = SelfProxyFactory.GetDailyRoutineProxy()
            Debug.LogError(table.dump({proxy.curRoutineDataMap}))
        else
            local roleId = tonumber(inputList[4])
            DailyRoutineDebugMgr:DumpTargetTypeRoutineDataByRoleId(roleId)
        end
    elseif inputList[3] == "current" then
        local proxy = SelfProxyFactory.GetDailyRoutineProxy()
        Debug.LogError(table.dump({proxy.curRoutineDataMap}))
    elseif inputList[3] == "getcurstatebyrole" then
        local roleId = tonumber(inputList[4])
        local proxy = SelfProxyFactory.GetDailyRoutineProxy()

        return Debug.LogError(table.dump({proxy.curRoutineDataMap[roleId]}))
    elseif inputList[3] == "wakeup" then
        local roleId = tonumber(inputList[4])
        self:WakeRoleUp(roleId)
    elseif inputList[3] == "mockchangestate" then
        local roleId = tonumber(inputList[4])
        local state = tonumber(inputList[5])
        DailyRoutineDebugMgr:MockChangeState(roleId, state)
    elseif inputList[3] == "logon" then
        DailyRoutineDebugMgr:LogOn()
    elseif inputList[3] == "logoff" then
        DailyRoutineDebugMgr:LogOff()
    end
end

-- 获取指定男主的当前状态
---@param self DailyRoutineBLL
local function __getCurStateByRoleId(self, roleId)
    -- 如果男主未解锁则直接返回
    if not BllMgr.GetRoleBLL():IsUnlocked(roleId) then return end
    
    local curRoleRoutineDataMap = SelfProxyFactory.GetDailyRoutineProxy().curRoutineDataMap
    if curRoleRoutineDataMap and curRoleRoutineDataMap[roleId] and curRoleRoutineDataMap[roleId].state then return curRoleRoutineDataMap[roleId].state end
    
    -- 这里要不要有一个保底状态逻辑 还是有吧 但要有个提示
    Debug.LogError("无法获取男主当前状态 当前为保底逻辑 " .. tostring(roleId or "nil"))
    return DailyRoutineEnum.RoutineState.Awake
end
DailyRoutineBLL.GetCurStateByRoleId = __getCurStateByRoleId

-- 根据指定配置方式的日期字符串格式获取时间戳
local function __getTimeStampByDateTimeStr(dateTimeStr)
    local year, month, day, hour, min, sec = dateTimeStr:match("(%d%d%d%d)(%d%d)(%d%d)=(%d%d):(%d%d):(%d%d)")
    local dateTable = {
        year = tonumber(year),
        month = tonumber(month),
        day = tonumber(day),
        hour = tonumber(hour),
        min = tonumber(min),
        sec = tonumber(sec)
    }
    return os.time(dateTable)
end

-- DailyRoutineSpecialDate表 根据不同类型 获取对应的时间段
---@param specialDateType number 特殊时间类型
---@param typePara number 参数
function DailyRoutineBLL:GetTimeRangeByTypeAndParams(specialDateType, typePara, cfgStartTime, cfgEndTime)
    local startTime, endTime

    if specialDateType == DailyRoutineEnum.SpecialDateType.SpecificTimeRange then       -- 指定配置时间段
        startTime = __getTimeStampByDateTimeStr(cfgStartTime)
        endTime = __getTimeStampByDateTimeStr(cfgEndTime)
    elseif specialDateType == DailyRoutineEnum.SpecialDateType.PlayerBirthday then      -- 玩家生日类型
        -- 生日当天的开始和结束时间
        startTime = SelfProxyFactory.GetPlayerBirthdayProxy():GetBirthdayBeginTime()
        if not startTime or startTime <= 0 then return end
        startTime = DailyRoutineUtil.GetStartDayTimestamp(startTime)
        if startTime and startTime > 0 then
            endTime = DailyRoutineUtil.GetEndDayTimestamp(startTime)
        end
    elseif specialDateType == DailyRoutineEnum.SpecialDateType.TargetActivity then      -- 指定活动类型
        local activityInfo = BllMgr.GetActivityCenterBLL():GetActivityCMSConfig(typePara)
        if not table.isnilorempty(activityInfo) then
            startTime = activityInfo.StartTime
            endTime = activityInfo.EndTime
        else
            Debug.LogError("[男主作息] 指定活动配置找不到  : " .. table.dump({typePara}))
        end
    end
    
    -- 结果检查
    if not startTime or not endTime or startTime <= 0 or endTime <= 0 or startTime > endTime then
        Debug.LogError("DailyRoutineBLL:GetTimeRangeByTypeAndParams 时间计算错误 ： " .. table.dump({startTime, endTime, specialDateType, typePara, cfgStartTime, cfgEndTime}))
    end
    
    return startTime, endTime
end

---@param self DailyRoutineBLL
local function __onLogin(self)
    SelfProxyFactory.GetDailyRoutineProxy():OnLogin()
end
DailyRoutineBLL.OnLogin = __onLogin

local function __getTimeByCfg(self, scheduleCfg)
    local weekIdx = scheduleCfg.Week
    local weekDay = scheduleCfg.DayNum
    local timeStr = scheduleCfg.StateStartTime
    local hour, minute, second = string.match(timeStr, "(%d+):(%d+):(%d+)")
    local curTime = tonumber(second) + tonumber(minute) * MIN_TIME + tonumber(hour) * HOUR_TIME
            + (weekDay + (weekIdx - 1) * 7) * DAY_TIME
    return curTime
end

local function __getAllScheduleCfgById(self, scheduleId)
    local allCfg = LuaCfgMgr.GetListByCondition("DailyRoutineSchedule", {ScheduleID = scheduleId})
    -- 按时间排序
    table.sort(allCfg, function(a, b) return a.ID < b.ID end)
    return allCfg
end

-- 获取这张时间表的最初的配置的时间
---@param self DailyRoutineBLL
---@param scheduleId number
local function __getInitScheduleTimeById(self, scheduleId)
    local allScheduleCfgById = __getAllScheduleCfgById(self, scheduleId)
    local initTime = __getTimeByCfg(self, allScheduleCfgById[1])
    return initTime
end
DailyRoutineBLL.GetInitScheduleTimeById = __getInitScheduleTimeById

-- 根据单条状态配置获取当前配置在整个scheduleId对应的时间表中的初始时间的offset
---@param self DailyRoutineBLL
local function __getTimeOffsetByCfg(self, scheduleCfg)
    local scheduleId = scheduleCfg.ScheduleID
    local initTime = __getInitScheduleTimeById(self, scheduleId)
    local curTime = __getTimeByCfg(self, scheduleCfg)
    return curTime - initTime
end
DailyRoutineBLL.GetTimeOffsetByCfg = __getTimeOffsetByCfg

-- 同步当前男主状态给服务器(在状态变更时发)
---@param self DailyRoutineBLL
local function __syncCurState2Server(self, roleId, routineState)
    -- 如果男主未解锁则直接返回
    if not BllMgr.GetRoleBLL():IsUnlocked(roleId) then return end
    
    local request = {RoleID = roleId, State = routineState}
    GrpcMgr.SendRequestAsync(RpcDefines.SyncRoleStateRequest, request, true)
    
    if DailyRoutineDebugMgr:IsLogOn() then
        DailyRoutineDebugMgr:Log("发送同步男主状态请求 <color=#FF0000> [状态切换] </color> " .. table.dump(request))
    end
end
DailyRoutineBLL.SyncCurState2Server = __syncCurState2Server

-- 叫醒男主
---@param self DailyRoutineBLL
local function __wakeRoleUp(self, roleId, curState)
    -- 如果男主未解锁则直接返回
    if not BllMgr.GetRoleBLL():IsUnlocked(roleId) then return end
    
    local curRoleState = curState or self:GetCurStateByRoleId(roleId)
    -- 检查是否满足叫醒的条件 (前置状态) 策划说后面也可能会加一个 "行为" 类型检查
    local resultState = DailyRoutineEnum.WakeRoleUpType[curRoleState]
    -- 不满足条件直接return
    if not resultState then return end
    
    local wakeCfg = LuaCfgMgr.Get("DailyRoutineSpState", roleId, resultState)
    if not wakeCfg then Debug.LogError("DailyRoutineSpState 叫醒配置没找到 ？ " .. table.dump({roleId, curRoleState, resultState})) return end

    -- 使用math.randomseed初始化随机数种子
    math.randomseed(os.time())

    -- 根据_randomTimeCfg配置生成随机时间
    local function getRandomTime(_randomTimeCfg)
        return math.random(_randomTimeCfg.ID, _randomTimeCfg.Num)
    end

    -- 根据_randomStateCfg配置生成随机状态
    local function getRandomState(_randomStateCfg)
        local totalWeight = 0
        for _, cfg in ipairs(_randomStateCfg) do
            totalWeight = totalWeight + cfg.ID
        end

        local randomValue = math.random(1, totalWeight)
        local accumulatedWeight = 0
        for _, cfg in ipairs(_randomStateCfg) do
            accumulatedWeight = accumulatedWeight + cfg.ID
            if randomValue <= accumulatedWeight then
                return cfg.Num
            end
        end
    end
    
    -- 随机时间
    local randomTime = getRandomTime(wakeCfg.Time)
    Debug.LogError("随机时间结果 : " .. table.dump({randomTime}))
    
    -- 随机下一个作息状态
    local randomState = getRandomState(wakeCfg.NextState)
    Debug.LogError("随机下一个状态结果 : " .. table.dump({randomState}))
    
    -- 首先要根据随机出的时间添加一个被叫醒的状态进去
    local startTime = TimerMgr.GetCurTimeSeconds()
    local endTime = startTime + randomTime
    SelfProxyFactory.GetDailyRoutineProxy():AddTriggerRoutine2Map(roleId, resultState, startTime, endTime, DailyRoutineEnum.TriggerRoutinePriority)
    
    -- 根据不同的作息状态给不同的逻辑
    if randomState == -1 then
        -- 如果是回到原状态, 就不需要做什么处理
    else
        -- 如果是到清醒状态, 需要跳过当前睡觉或补觉状态 (通过高优先级的清醒状态来覆盖)
        -- 找到时间表里下一个清醒状态 这个状态的startTime - 1就是要添加的清醒状态的endTime;
        local nextAwakeRoutineData = SelfProxyFactory.GetDailyRoutineProxy():GetNextTargetStateRoutineData(roleId, DailyRoutineEnum.RoutineState.Awake)
        local awakeStartTime = endTime + 1
        local awakeEndTime = nextAwakeRoutineData and nextAwakeRoutineData.startTime - 1 or SelfProxyFactory.GetDailyRoutineProxy().curMonthEndTimeStamp
        SelfProxyFactory.GetDailyRoutineProxy():AddTriggerRoutine2Map(roleId, DailyRoutineEnum.RoutineState.Awake,
                awakeStartTime, awakeEndTime, DailyRoutineEnum.TriggerRoutinePriority)
    end
    
    -- GetDataFromProxy & SendRequest
    local triggerRoutineDataList = SelfProxyFactory.GetDailyRoutineProxy():GetTriggerRoutineByRoleId(roleId, true) or {}
    local requestDataList = {}
    for _, v in ipairs(triggerRoutineDataList) do
        table.insert(requestDataList, {State = v.state, StartTime = v.startTime, EndTime = v.endTime})
    end
    -- 发协议叫醒
    GrpcMgr.SendRequest(RpcDefines.WakeRoleUpRequest, {RoleID = roleId, StateList = requestDataList}, true)

    if DailyRoutineDebugMgr:IsLogOn() then
        DailyRoutineDebugMgr:Log("发送叫醒 请求 " .. table.dump(requestDataList))
    end
end
DailyRoutineBLL.WakeRoleUp = __wakeRoleUp

return DailyRoutineBLL