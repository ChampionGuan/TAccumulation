---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by aoliao.
--- DateTime: 2022/12/7 11:33
---DailyConfideBll
---------------------------------------------------------------------

---@class DailyConfideBll:BagBLL
local DailyConfideBll = class("DailyConfideBll", BaseBll)
local DailyConfideMgr = require("Runtime.System.X3Game.Modules.DailyConfide.DailyConfideMgr")
local MainHomeConst = require("Runtime.System.X3Game.Modules.MainHome.Data.MainHomeConst")
local DailyConfideConst = require("Runtime.System.X3Game.Modules.DailyConfide.Data.DailyConfideConst")
local DailyConfideBuyPopupItemData = require("Runtime.System.X3Game.UI.UIView.DailyConfideBuyPopup.DailyConfideBuyPopupItemData")

---@param dailyConfide table
---初始倾诉时间
function DailyConfideBll:Init(dailyConfide)
    self:SetDailyConfideData(dailyConfide)
end

function DailyConfideBll:OnInit()
    ---@type DailyConfideProxy
    self.proxy = SelfProxyFactory.GetDailyConfideProxy()
    local bufferTime = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DAILYPHONEMAX)
    ---@type number 男主ID
    self.roleID = nil
    ---@type table DailyConfide配置表
    self.dailyConfideRawCfg = nil
    ---@type table 即时热词
    self.keyWord = nil
    ---@type number 这一次倾诉能持续多久
    self.bufferTime = math.random(bufferTime.ID,bufferTime.Num) * 60 ---ID 最小时长，Num最大时长，单位分,bufferTime单位是秒
    ---@type DailyConfideMgr
    self.dailyConfideMgr = nil
    ---@type bool 是否可以去除白屏
    self.canWhiteScreenOut = nil
    ---@type bool 白屏演出的时间
    self.WhiteScreenTickTime = nil
    ---@type number 白屏演出的最小时间
    self.minTime = nil
    ---@type number 白屏演出的最大时间
    self.maxTime = nil
    ---@type number 白屏演出倒计时ID
    self.WhiteScreenTickID = nil
    ---@type cfg.MainUIAction
    self.actionData = nil
    ---@type boolean 是否强制不校验token有效性
    self.isForceNotCheckToken = nil

    self:AddListener()
end
---@param word string 上报埋点
function DailyConfideBll:RequestDailyConfideRecord(actorID,useTime,isSemantics,emotion,matterType,matterSubType)
    GrpcMgr.SendRequestAsync(RpcDefines.DailyConfideRecordRequest,{
        ActorID = actorID ,
        UseTime = useTime or 0,
        IsSemantics = isSemantics and 1 or 0,
        Emotion = emotion or 0,
        MatterType = matterType or 0,
        MatterSubType = matterSubType or 0,
    })
end
---@public 刷新数据
function DailyConfideBll:RequestDailyConfideData()
    GrpcMgr.SendRequestAsync(RpcDefines.GetDailyConfideDataRequest,{})
end
---@public 上报condition记录的数据，完全信赖客户端
---@param dirtyMap table<int,bool>  脏标记，数据改变了需要告诉服务器，key 男主id，value true则需要更新数据
function DailyConfideBll:RequestDailyConfideConditionRecord(dirtyMap)
    if table.nums(dirtyMap) == 0 then
        return
    end
    local params = {}
    for k, v in pairs(dirtyMap) do
        if v then
            ---@type  X3Data.DailyConfideCompleteRecord
            local dailyConfideCompleteRecordData = self.proxy:GetDailyConfideCompleteRecordDataByRoleId(k)
            params[k] = self:TurnCompleteX3DataToProtoData(dailyConfideCompleteRecordData)
        end
    end
    GrpcMgr.SendRequest(RpcDefines.DailyConfideUpdateRecordRequest,{Records = params})
end
---@param protoData table
---@return X3Data.DailyConfideCompleteRecord
function DailyConfideBll:TurnProtoDataToCompleteX3Data(protoData)
    if table.nums(protoData) == 0 then
        return nil
    end
    ---@type  X3Data.DailyConfideCompleteRecord
    local dailyConfideRecordData = X3DataMgr.Create(X3DataConst.X3Data.DailyConfideCompleteRecord)
    dailyConfideRecordData:DecodeByField(protoData)
    return dailyConfideRecordData
end
---@param X3Data  X3Data.DailyConfideCompleteRecord X3Data转换成协议需要的map
function DailyConfideBll:TurnCompleteX3DataToProtoData(X3Data)
    if not X3Data then
        return nil
    end
    local result = {}
    result.TodayRecord = self:TrueX3DataToProtoData(X3Data:GetTodayRecord())
    result.YesterdayRecord = self:TrueX3DataToProtoData(X3Data:GetYesterdayRecord())
    return result
end

---@param X3Data  X3Data.DailyConfideRecord
function DailyConfideBll:TrueX3DataToProtoData(X3Data)
    if not X3Data then
        return nil
    end
    local result = {}
    if X3Data then
        result.RoleId = X3Data:GetRoleId()
        result.Emotion = X3Data:GetEmotion()
        result.MatterType = X3Data:GetMatterType()
        result.SubMatterType = X3Data:GetSubMatterType()
        result.NewTimestamp = X3Data:GetNewTimestamp()
    end
    return result
end

---@param word string 请求语义识别
function DailyConfideBll:RequestWordVector(word,roleID)
    GrpcMgr.SendRequest(RpcDefines.DailyConfideTalkRequest,{Talk = word,RoleID = roleID},true)
end

---请求token
function DailyConfideBll:RequestToken()
    GrpcMgr.SendRequest(RpcDefines.DailyConfideAliTokenRequest,{})
end
---@param roleID number 男主ID 告诉服务器这次连麦开始
function DailyConfideBll:RequestStart()
    BllMgr.GetMainInteractBLL():Send_InterActiveTimeRequest(self.actionData.ID)
end
---@param roleID number 男主ID
---@param matchID number|nil 玩家命中的语义组ID
---每次有触发语义组ID，并且播完了剧情的时候，把下述两个参数的值发给服务器，服务器记着，成就这边做判断是否满足配置要求，满足了就加计数值
function DailyConfideBll:RequestMatchCount(roleID, matchID )
    if not matchID then return end
    BllMgr.GetCounterBLL():SetCounterUpdateData(X3_CFG_CONST.COUNTER_TYPE_DAILYCONFIDEHITNUM,1,{roleID},matchID)
end
---@return number 某个时间戳之前使用token有效
function DailyConfideBll:GetTokenTime()
    return self.proxy:GetData():GetTokenExpireTime()
end
---@param reply pbcmessage.DailyConfideAliTokenReply
function DailyConfideBll:SetToken(reply)

    self.proxy:GetData():SetToken(reply.Id)
    self.proxy:GetData():SetTokenExpireTime(reply.ExpireTime)
    EventMgr.Dispatch(DailyConfideConst.DailyConfideTokenUpdate)
    self:interEnterDailyPhone()
end
---@return string
function DailyConfideBll:GetToken()
    return self.proxy:GetData():GetToken()
end
---@return table
function DailyConfideBll:GetKeyWord()
    if not self.keyWord then
        self.keyWord = {}
        local config = LuaCfgMgr.GetAll("DailyConfideKeyWord")
        for k, v in pairs(config) do
            self.keyWord[v.KeyWord] = v.Weight
        end
    end
    return self.keyWord
end
---@return boolean 检查token是否有效，是否需要重启token由外部决定
function DailyConfideBll:CheckToken()
    if self:GetIsForceNotCheckToken() then
        return true
    end
    if not self:GetToken() then
        return false
    end
    local curTime = TimerMgr.GetCurTimeSeconds()
    return curTime < self:GetTokenTime()
end

---@return boolean 是否强制不校验token有效性
function DailyConfideBll:GetIsForceNotCheckToken()
    if self.isForceNotCheckToken == nil then
        self.isForceNotCheckToken = PlayerPrefs.GetBool(DailyConfideConst.ForceNotCheckTokenKey, false)
    end
    return self.isForceNotCheckToken
end

---@param isForce boolean 是否强制不校验token有效性
function DailyConfideBll:SetIsForceNotCheckToken(isForce)
    PlayerPrefs.SetBool(DailyConfideConst.ForceNotCheckTokenKey, isForce)
    PlayerPrefs.Save()
    self.isForceNotCheckToken = isForce
end

function DailyConfideBll:AddListener()
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_EXIT, self.OnMainHomeExit, self)
    EventMgr.AddListener("CommonDailyReset", self.OnDailyReset, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_LOCAL_STATE_SUCCESS, self.OnMainExitDailyPhoneSuc, self)
    EventMgr.AddListener(DailyConfideConst.DailyConfideShowReady, self.OnDailyConfideShowReady, self)
end

---每日5点过天刷新彩蛋数据
function DailyConfideBll:OnDailyReset()
    local dirtyMap = self:UpdateRecordTimeStamp()
    self:RequestDailyConfideConditionRecord(dirtyMap)
end
---@param context string 男主ID ,0 代表所有男主
function DailyConfideBll:OnResult(context)
    if not self.dailyConfideMgr then
        return
    end
    self.dailyConfideMgr:OnResult(context)
end
---@return number 这次倾诉持续时间,单位是秒
function DailyConfideBll:GetBufferTime()
    return self.bufferTime
end
---@param min number 分钟，设置倾诉的时长 GM用
function DailyConfideBll:SetBufferTime(min)
    self.bufferTime = min * 60
end
---@param roleID number 男主ID
---@param lastTime number 上一次倾诉的时间戳 GM用
function DailyConfideBll:SetLastDailyPhoneTimeByRoleID(roleID,lastTime)
    self.proxy:GetData():AddOrUpdateLastDailyPhoneTimeValue(roleID,lastTime)
    EventMgr.Dispatch(DailyConfideConst.DataUpdate )
end
---@param roleID number 男主ID ,0 代表所有男主
function DailyConfideBll:GMClearCD(roleID)
    local GMCfg = LuaCfgMgr.GetAll("GM_DEBUG")
    local GMFormatStr
    for k, v in pairs(GMCfg) do
        local Command = v.Command
        if Command then
            local result = string.split(Command, ' ')
            if result then
                if result[1] == "interactive" and result[2] == "clearcd" then
                    GMFormatStr = Command
                    break
                end
            end
        end
    end
    if not GMFormatStr then
        return
    end
    local cfg = LuaCfgMgr.GetAll("MainUIAction")
    for k, v in pairs(cfg) do
        if v.ActionType == MainHomeConst.ActionType.DailyConfide  then
            if roleID == 0 or v.ActorID == roleID then
                BllMgr.GetGMCommandBLL():SendCommand(string.cs_format(GMFormatStr, v.ActorID, v.ID) )
            end
        end
    end
end
---@public 指定男主的语音道具啥时候到期
---@param roleID number 男主id
---@return number|nil 时间戳
function DailyConfideBll:GetDailyConfideExpireTime(roleID)
    local tb = self.proxy:GetData():GetVoiceExpireTime() or {}
    return self:CheckIsNotBanVoice() and tb[roleID] or 0
end

---@public 指定男主的语音道具剩余的时间
---@param roleID number 男主id
---@return number|nil 时间戳
function DailyConfideBll:GetDailyConfideExpireTimeOutTime(roleID)
    local timestamp = self:GetDailyConfideExpireTime(roleID)
    local result = timestamp - TimerMgr.GetCurTimeSeconds()
    if result < 0 then
       result  = 0
    end
    return result
end
---@public 指定男主的语音道具是否未过期
---@param roleID number 男主id
---@param dontCheckVIP bool 不检查vip（收费的权限，是否可以使用语音）
---@return bool true ：未过期 false：已过期
function DailyConfideBll:GetVoiceEnable(roleID,dontCheckVIP)
    if dontCheckVIP then
        return true
    end
    local expireTime = self:GetDailyConfideExpireTime(roleID)
    if not expireTime then
        return false
    end
    local result = expireTime >TimerMgr.GetCurTimeSeconds()
    return result
end
---@param dailyConfide pbcmessage.DailyConfideUpdateReply
function DailyConfideBll:SetDailyConfideExpireTime(dailyConfide)

    self.proxy:GetData():AddOrUpdateVoiceExpireTimeValue(dailyConfide.RoleID,dailyConfide.ExpireTime)
    EventMgr.Dispatch(DailyConfideConst.DataUpdate)
end
---@param DailyConfideData pbcmessage.DailyConfideData
function DailyConfideBll:SetDailyConfideData(DailyConfideData)

    local voiceExpireTime = DailyConfideData and DailyConfideData.ExpireTime or {}
    for k, v in pairs(voiceExpireTime) do
        self.proxy:GetData():AddOrUpdateVoiceExpireTimeValue(k,v)
    end

    local recordDatas = DailyConfideData and DailyConfideData.Records or {}
    for k, v in pairs(recordDatas) do
        self.proxy:UpdateRecordsValue(k,self:TurnProtoDataToCompleteX3Data(v))
    end

    EventMgr.Dispatch(DailyConfideConst.DataUpdate )
end


---@param role number 男主ID
---@return number 上一次倾诉的时间戳，0的话说明没有进行过倾诉
function DailyConfideBll:GetLastDailyPhoneTimeByRole(MainUIAction)
    return SelfProxyFactory.GetMainInteractProxy():GetInteractData():GetCDTimeByType(MainUIAction.ID,MainUIAction.ActorID)
end
---@param MainUIAction cfg.MainUIAction
---@return  number 还差多少时间可以进行倾诉
---@return bool 是否是第一次进入倾诉，是的话需要另外处理
function DailyConfideBll:GetCDLeaveTime(MainUIAction)
    local nextTime = self:GetLastDailyPhoneTimeByRole(MainUIAction)
    local curTime = TimerMgr.GetCurTimeSeconds()
    local result = nextTime - curTime
    return result,result <=0
end
---@param sucCallBack function 成功回调
---@param failCallBack function 失败回调
---开始麦克风检查，放到这里是应为有可能不需要DailyConfideMgr也要进行检查
function DailyConfideBll:StartMicCheck(sucCallBack,failCallBack)
    Debug.Log("【连麦】 检查是否有麦克风权限")
    DevicePermissionUtility.RequestPermissionHaveTips(PlatformConst.PermissionType.RECORD_AUDIO, function(hadPermission)
        self:SetDriveIsOpenMic(hadPermission)
        Debug.Log("【连麦】 麦克风权限 => ",hadPermission and 1 or 0)
        if hadPermission then
            self:SetUserOpenMic(true)
            if sucCallBack then
                sucCallBack()
            end
        else
            if failCallBack then
                failCallBack()
            end
        end
    end,UITextConst.UI_TEXT_11617)
end
---进入倾诉内部接口
function DailyConfideBll:checkInterEnterDailyPhone()
    if self:CheckIsNotBanVoice () then
        BllMgr.GetDailyConfideBll():RequestToken()
    else
        self:interEnterDailyPhone()
    end
end

function DailyConfideBll:interEnterDailyPhone()
    if self.dailyConfideMgr then
        return
    end
    UICommonUtil.WhiteScreenIn(function()
        EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_DAILY_CONFIDE_ENABLE,true)
        self:StartCloseWhiteScreen()
        ---@type cfg.MainUIAction
        local actionData = self:GetActionData()
        self.dailyConfideMgr = DailyConfideMgr.new()
        UIMgr.Open(UIConf.DailyConfideMainWnd, actionData.ActorID) ---要先打开UI，再初始化Mgr,否则mgr里带的dialogue UI会被界面UI顶掉
        ---@type DailyConfideMgr
        self.dailyConfideMgr:Init(actionData)
    end)
end
---开始关闭白屏
function DailyConfideBll:StartCloseWhiteScreen()

    self.WhiteScreenTickTime = 0
    local data = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DAILYCONFIDEWHITEWAITING)
    self.minTime = data[1]
    self.maxTime = data[2]
    self.WhiteScreenTickID = TimerMgr.AddTimer(0.1, handler(self, self.CloseWhiteScreenTick), self, true)

end
---白屏需要做保底的倒计时
function DailyConfideBll:CloseWhiteScreenTick()
    self.WhiteScreenTickTime = self.WhiteScreenTickTime + 0.1
    if self.WhiteScreenTickTime > self.minTime and self.WhiteScreenTickTime < self.maxTime then
        if self.canWhiteScreenOut then
            self:CloseWhiteScreen()
        end
    elseif self.WhiteScreenTickTime >= self.maxTime then
        self:CloseWhiteScreen()
    end
end
---主界面告诉倾诉这边可以关闭白屏了
function DailyConfideBll:OnMainExitDailyPhoneSuc()
    ErrandMgr.SetDelay(false)
    self.canWhiteScreenOut = true
end

---倾诉相机设置好了
function DailyConfideBll:OnDailyConfideShowReady()
    self.canWhiteScreenOut = true
end
---关闭白屏的函数
function DailyConfideBll:CloseWhiteScreen()
    self.canWhiteScreenOut = false
    self.WhiteScreenTickTime = 0
    TimerMgr.Discard(self.WhiteScreenTickID)
    UICommonUtil.WhiteScreenOut(function()
        if self.dailyConfideMgr then
            ---@type DailyConfideMgr
            self.dailyConfideMgr:OnWhiteScreenOut()
        end
    end)
end
---@return DailyConfideMgr
function DailyConfideBll:GetDailyConfideMgr()
    return self.dailyConfideMgr
end
function DailyConfideBll:OnResume()
    if self.dailyConfideMgr then
        self.dailyConfideMgr:OnLogicResume()
        EventMgr.Dispatch(DailyConfideConst.PauseStateChange,false)
    end
end

function DailyConfideBll:OnPause()
    if self.dailyConfideMgr then
        self.dailyConfideMgr:OnLogicPause()
        EventMgr.Dispatch(DailyConfideConst.PauseStateChange,true)
    end
end

---@param state DailyConfideConst.DailyConfideState
function DailyConfideBll:SetDailyPhoneState(state)
    if self.dailyConfideMgr then
        self.dailyConfideMgr:SetDailyPhoneState(state)
    end
end

function DailyConfideBll:OnDailyPhoneExit()
    UICommonUtil.WhiteScreenIn(function ()
        BllMgr.GetMainHomeBLL():StopActionByType(MainHomeConst.ActionType.DailyConfide)
    end)
end

---主界面如果退出了，这边也要终止
function DailyConfideBll:OnMainHomeExit()
    BllMgr.GetMainHomeBLL():StopActionByType(MainHomeConst.ActionType.DailyConfide)
end
---主界面如果退出了，这边也要终止
function DailyConfideBll:DisposeMgr()
    if self.dailyConfideMgr then
        self.dailyConfideMgr:Dispose()
        self.dailyConfideMgr = nil
        EventMgr.Dispatch(DailyConfideConst.Exit)
        EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_DAILY_CONFIDE_ENABLE,false)
    end
end
---@param roleID number 男主ID
function DailyConfideBll:SetDailyPhoneRoleID(roleID)
    self.roleID = roleID

end
---@return cfg.MainUIAction
function DailyConfideBll:GetActionData()
    return self.actionData
end
---@return number
function DailyConfideBll:GetDailyPhoneRoleID()
    return self.roleID
end
---@param actionData cfg.MainUIAction
---参考 https://papergames.feishu.cn/docx/X5MGdFh8MoJRFUxwQhocXXxZnmh
function DailyConfideBll:StartDailyPhone(actionData)
    self.actionData = actionData
    local roleID = actionData.ActorID
    self:SetDailyPhoneRoleID(roleID)
--可以倾诉了
    self:CheckDailyConfidePermissionReady(roleID,handler(self,self.checkInterEnterDailyPhone))
end
---@param roleID number 男主id
---@param callBack function 检查结束的回调
function DailyConfideBll:CheckDailyConfidePermissionReady(roleID,callBack)
    if self:GetVoiceEnable(roleID) then
        if self:GetUserOpenMic() then
            self:StartMicCheck(callBack,callBack)
        else
            if callBack then
                callBack()
            end
        end
    else
        if callBack then
            callBack()
        end
    end
end
---@param Open bool 选择是否是VIP可以用ASR
function DailyConfideBll:SetIsVoiceVIP(value)
    if not value then
        self:SetUserOpenMic(false)
    end
    PlayerPrefs.SetBool(DailyConfideConst.VoiceVIP, value)
    EventMgr.Dispatch(DailyConfideConst.VIPChange)
end
---@return bool 设备是否有权打开mic
function DailyConfideBll:GetDriveIsOpenMic()
    return PlayerPrefs.GetBool(DailyConfideConst.DriveIsOpenMic, false)
end

function DailyConfideBll:SetDriveIsOpenMic(value)
    if not value then
        self:SetUserOpenMic(false)
    end
    PlayerPrefs.SetBool(DailyConfideConst.DriveIsOpenMic, value)
end
---@param dontCheckVIP bool 不检查vip（收费的权限，是否可以使用语音）
---@return bool 是否可以使用Mic vip用户and手机打开Mic权限-，不包括sdk状态
function DailyConfideBll:GetMicEnable(roleID,dontCheckVIP)
    return self:GetDriveIsOpenMic() and self:GetVoiceEnable(roleID,dontCheckVIP)
end


---@return DailyConfideConst.MicState 返回mic按钮的UE状态
---@param dontCheckVIP bool 不检查vip（收费的权限，是否可以使用语音）
function DailyConfideBll:GetMicState(roleID,dontCheckVIP)
    local micEnable =  self.dailyConfideMgr and self.dailyConfideMgr:GetMicState(roleID,dontCheckVIP) or false
    if not self:GetVoiceEnable(roleID,dontCheckVIP) then
        return DailyConfideConst.MicState.Lock
    else
        return  (micEnable and DailyConfideConst.MicState.Open or DailyConfideConst.MicState.Close)
    end
end

---@param Open bool 玩家选择是否打开mic
function DailyConfideBll:SetUserOpenMic(value)
    PlayerPrefs.SetBool(DailyConfideConst.UserOpenMic, value)
end
---@return bool 用户是否选择打开mic
function DailyConfideBll:GetUserOpenMic()
    return PlayerPrefs.GetBool(DailyConfideConst.UserOpenMic, true) and  self:CheckIsNotBanVoice()
end
---@return table DailyConfide配置表
function DailyConfideBll:GetDailyConfideRawCfg()
    if not self.dailyConfideRawCfg then
        self.dailyConfideRawCfg = LuaCfgMgr.GetAll("DailyConfide")
    end
    return self.dailyConfideRawCfg
end
---@return bool 是否禁止使用语音功能（目前非大陆地区不允许）true:允许 false:不允许
function DailyConfideBll:CheckIsNotBanVoice()
    return Locale.Region.ChinaMainland == Locale.GetRegion()
end

---@param MainUIAction cfg.MainUIAction
---@return DailyConfideConst.EntryState
---入口的状态
---@param role number 男主ID
function DailyConfideBll:CheckDailyPhoneCDEnable(MainUIAction)
    return self:GetCDLeaveTime(MainUIAction) <= 0
end

function DailyConfideBll:OpenQuickShop(roleID)
    if not roleID then
        roleID = self.roleID
    end
    local result , tipsID = self:CheckIsHaveShopItemShow(roleID)
    if not result then
        UICommonUtil.ShowMessage(tipsID or UITextConst.UI_TEXT_11602)
        return
    end

    UIMgr.Open(UIConf.DailyConfideBuyPopup,roleID)
end

---@return bool 是否有可显示购买的商品(售罄的也显示)
---@return number 如果第一个参数是false，飘字第二个参数
function DailyConfideBll:CheckIsHaveShopItemShow(roleID)
    local shopIDs = self.proxy:GetShopIDByRoleID(roleID)
    local tipsID
    local tempResult
    for i, v in ipairs(shopIDs) do
        tempResult,tipsID = self:IsCanBuy(v)
        if tempResult then
            return true
        end
    end
    return false,tipsID
end
---@param ShopGoodsID int
---@return bool
---@return int|nil
function DailyConfideBll:IsCanBuy(ShopGoodsID)
    if ShopGoodsID == 0 then
        return false, nil
    end
    local shopGroupData = LuaCfgMgr.Get("ShopGroup", ShopGoodsID)
    if shopGroupData == nil then
        return false, nil
    end
    if not BllMgr.GetShopMallBLL():CheckShopIsOpen(shopGroupData.ShopID) then
        return false, nil
    end
    if not BllMgr.GetShopMallBLL():CheckShopGoodsIsShow(shopGroupData, false) then
        return false, nil
    end
    if not BllMgr.GetShopMallBLL():ShopGoodsIsHave(ShopGoodsID) then
        return false, UITextConst.UI_TEXT_9494
    end
    return ConditionCheckUtil.CheckConditionByIntList(shopGroupData.PurchaseCondition), shopGroupData.PurchaseTips
end

---@return table 获取指定男主的道具商品ID
function DailyConfideBll:GetShopIDByRoleID(roleID)
    return self.proxy:GetShopIDByRoleID(roleID)
end

---@return table<number,DailyConfideBuyPopupItemData> 获取指定男主的道具商品ID
function DailyConfideBll:GetShopDatasByRoleID(roleID)
    local result = {}
    local shopItemIDs = self:GetShopIDByRoleID(roleID)
    for i, v in ipairs(shopItemIDs) do
        if self:IsCanBuy(v) then
            local shopGroupData = LuaCfgMgr.Get("ShopGroup", v)
            local oldConstNum, nowConstNum, moneyTypeIcon, discount = BllMgr.GetShopMallBLL():GetShopGoodsPrice(shopGroupData)
            local itemID = shopGroupData.ItemID[1].ID
            local itemData = LuaCfgMgr.Get("Item", itemID)
            local durationTime = self:GetShopItemDurationTime(itemID,BllMgr.GetItemBLL():IsPackageItem(itemData.Type))
            ---@type cfg.s2int
            local constS2Int = shopGroupData.CostItem[1]
            local payId = constS2Int.ID
            local data = DailyConfideBuyPopupItemData.new(
                    {
                        itemID = itemID,
                        num = 0,
                        shopID = v,
                        name = itemData.Name,
                        price = discount and oldConstNum or nowConstNum,
                        realPrice = nowConstNum,
                        discount = discount,
                        maxNum = shopGroupData.Limit - BllMgr.GetShopMallBLL():GetGoodsBuyNum(shopGroupData.ID),
                        payId = payId,
                        moneyTypeIcon = moneyTypeIcon,
                        durationTime = durationTime,
                        shopGroupCfg = shopGroupData
                    }
            )
            table.insert(result,data)
        end
    end
    return result
end

function DailyConfideBll:GetShopItemDurationTime(itemId,isPack)
    local result = {}
    local rewardIDs = {}
    if isPack then
        local showItemList = BllMgr.GetItemBLL():GetPackItemRewardList(itemId)
        if showItemList then
            for i, v in ipairs(showItemList) do
                table.insert(rewardIDs,v.ID)
            end
        end
    else
        table.insert(rewardIDs,itemId)
    end
    for i, v in ipairs(rewardIDs) do
        local itemData = LuaCfgMgr.Get("Item", v)
        local durationTime = itemData.IntExtra2 * 86400
        if not result[itemData.Role] then
            result[itemData.Role] = 0
        end
        result[itemData.Role] = result[itemData.Role] + durationTime
    end
    return result
end

---@return  table<X3Data.DailyConfideRecord>
function DailyConfideBll:GetRecordDatas(roleId,isToday)
    local dirtyMap = self:UpdateRecordTimeStamp(roleId)
    self:RequestDailyConfideConditionRecord(dirtyMap)
    if roleId ~= DailyConfideConst.RecordDataDefaultValue then
        ---@type  X3Data.DailyConfideCompleteRecord
        local targetData = self.proxy:GetDailyConfideCompleteRecordDataByRoleId(roleId)
        if not targetData then
            return false
        end
        if isToday then
            return {targetData:GetTodayRecord()}
        else
            return {targetData:GetYesterdayRecord()}
        end
    else
        local datas = self.proxy:GetDailyConfideCompleteRecordDataByDate(isToday)
        return datas
    end
end

---@param selectCurTimestamp number 时间戳，不传，传的话是为了测试用
function DailyConfideBll:RecordConditionData(roleId, emotion, matterType, subMatterType,selectCurTimestamp)
    if not selectCurTimestamp then
        selectCurTimestamp = TimerMgr.GetCurTimeSeconds()
    end
    local dirtyMap = self:UpdateRecordTimeStamp(roleId,selectCurTimestamp)
    if not dirtyMap then
        dirtyMap = {}
    end
    ---@type  X3Data.DailyConfideCompleteRecord
    local dailyConfideCompleteRecordData = self.proxy:GetDailyConfideCompleteRecordDataByRoleId(roleId)
    if not dailyConfideCompleteRecordData then
        dailyConfideCompleteRecordData = X3DataMgr.Create(X3DataConst.X3Data.DailyConfideCompleteRecord)
    end
    dirtyMap[roleId] = true
    ---@type  X3Data.DailyConfideRecord
    local dailyConfideRecordData = X3DataMgr.Create(X3DataConst.X3Data.DailyConfideRecord)
    dailyConfideRecordData:SetRoleId(roleId)
    dailyConfideRecordData:SetEmotion(emotion)
    dailyConfideRecordData:SetMatterType(matterType)
    dailyConfideRecordData:SetSubMatterType(subMatterType)
    dailyConfideRecordData:SetNewTimestamp(selectCurTimestamp)
    dailyConfideCompleteRecordData:SetTodayRecord(dailyConfideRecordData)
    self.proxy:UpdateRecordsValue(roleId,dailyConfideCompleteRecordData)
    self:RequestDailyConfideConditionRecord(dirtyMap)
end

---@param id number condition枚举 详情见【LYDJS-37153】
---@param datas table<int,string> 看表吧CommonCondition
---@return bool 检查是否通过
function DailyConfideBll:CheckCondition(id, datas)
    if id == X3_CFG_CONST.CONDITION_MUI_CONFIDE_TODAY then
        return self:innerCheckCondition(datas,true)
    elseif id == X3_CFG_CONST.CONDITION_MUI_CONFIDE_YESTERDAY then
        return self:innerCheckCondition(datas,false)
    end
    return false
end

---@private CheckCondition拆解函数，其他地方不调用
---@param datas table<int,string> 看表吧CommonCondition
---@param isToday boolean true:今天，false:昨天
---@return bool 检查是否通过
function DailyConfideBll:innerCheckCondition(datas,isToday)
    local result = false
    local logicSign = tonumber(datas[1]) == 1  ---是或否
    local roleId = tonumber(datas[2])
    local emotionType = tonumber(datas[3])
    local matterType = tonumber(datas[4])
    local subMatterType = tonumber(datas[5])
    local recordDatas =  self:GetRecordDatas(roleId,isToday)
    if not recordDatas or #recordDatas == 0 then
        return logicSign == result
    end

    for i, v in ipairs(recordDatas) do
        local checkRoleId = roleId == DailyConfideConst.RecordDataDefaultValue or v:GetRoleId() == roleId
        local checkEmotion = emotionType == DailyConfideConst.RecordDataDefaultValue or v:GetEmotion() == emotionType
        local checkMatterType = matterType == DailyConfideConst.RecordDataDefaultValue or v:GetMatterType() == matterType
        local checkSubMatterType = subMatterType == DailyConfideConst.RecordDataDefaultValue or v:GetSubMatterType() == subMatterType
        local check  = checkRoleId and checkEmotion and checkMatterType and checkSubMatterType
        if check then
            result = true
            break
        end
    end
    return logicSign == result
end

---@private 更新时间
---@param recordData X3Data.DailyConfideRecord
---@return table<int,bool> 脏标记，数据改变了需要告诉服务器，key 男主id，value true则需要更新数据
function DailyConfideBll:UpdateRecordTimeStamp(roleId,selectCurTimestamp)
    if not selectCurTimestamp then
        selectCurTimestamp = TimerMgr.GetCurTimeSeconds()
    end
    local dailyConfideCompleteRecordDatas = self.proxy:GetData():GetRecords()
    if not dailyConfideCompleteRecordDatas then
        return
    end
    local dirtyMap = {}
    if roleId and roleId ~= DailyConfideConst.RecordDataDefaultValue then
        ---@type  X3Data.DailyConfideCompleteRecord
        local targetData = self.proxy:GetDailyConfideCompleteRecordDataByRoleId(roleId)
        if targetData then
            local isDirty = self:InnerUpdateRecordTimeStamp(targetData,selectCurTimestamp)
            if isDirty then
                dirtyMap[roleId] = true
            end
        end
    else
        for k, v in pairs(dailyConfideCompleteRecordDatas) do
            local isDirty = self:InnerUpdateRecordTimeStamp(v,selectCurTimestamp)
            if isDirty then
                dirtyMap[k] = true
            end
        end
    end

    return dirtyMap
end

---@param recordData X3Data.DailyConfideCompleteRecord
---@return bool 数据是否改变了
function DailyConfideBll:InnerUpdateRecordTimeStamp(recordData,nowTime)
    local isDirty = false
    local todayRecordData = recordData:GetTodayRecord()
    local yesterdayRecordData = recordData:GetYesterdayRecord()

    local recordTodayTimestamp = todayRecordData and todayRecordData:GetNewTimestamp() or 0
    local recordYesterdayTimestamp = yesterdayRecordData and yesterdayRecordData:GetNewTimestamp() or 0

    if recordTodayTimestamp ~= 0 then
        local interval = BllMgr.GetActivityCenterBLL():GetDaysInterval(nowTime,recordTodayTimestamp)
        if interval ~= 0 then
            isDirty = true
            if interval < 0 then
                Debug.LogError("【倾诉】recordData today 异常，时间戳 => ",recordTodayTimestamp," 当前时间戳 => ",nowTime)
            elseif interval > 1 then ---这个数据都过期了
                recordYesterdayTimestamp = 0
                recordData:SetYesterdayRecord(nil)
            elseif interval == 1 then---记录的今天的数据实际上间隔了1天，所以变成了昨天的数据
                recordYesterdayTimestamp = recordTodayTimestamp
                recordData:SetYesterdayRecord(todayRecordData)
            end
            recordData:SetTodayRecord(nil)
        end
    end

    if recordYesterdayTimestamp ~= 0 then
        local interval = BllMgr.GetActivityCenterBLL():GetDaysInterval(nowTime,recordYesterdayTimestamp)
        if interval ~= 1 then
            isDirty = true
            if interval < 0 then
                Debug.LogError("【倾诉】recordData yesterday 异常，时间戳 => ",recordYesterdayTimestamp," 当前时间戳 => ",nowTime)
            end
            recordData:SetYesterdayRecord(nil)
        end
    end
    return isDirty
end
---统一清理相关数据状态，只会调用一次
function DailyConfideBll:OnClear()
    self:DisposeMgr()

    self.roleID = nil

    self.bufferTime = nil

    self.keyWord = nil

    self.dailyConfideMgr = nil

    self.canWhiteScreenOut = nil

    self.WhiteScreenTickTime = nil

    self.minTime = nil

    self.maxTime = nil

    self.WhiteScreenTickID = nil

    self.dailyConfideRawCfg = nil

    self.actionData = nil

    DailyConfideBll.super.OnClear(self)
end

return DailyConfideBll


