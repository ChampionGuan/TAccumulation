---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2022/11/14 20:39
---

---@class VideoShowCtrl:UICtrl
local VideoShowCtrl = class("VideoShowCtrl", UICtrl)

local RatioType = CS.UnityEngine.Video.VideoAspectRatio
---
function VideoShowCtrl:ctor()
    ---@type bool GameFocus是否暂停视频
    self.gameFocusIsPause = true
end

function VideoShowCtrl:Init()
    if (not self.rawImage) then
        self.rawImage = self:GetComponent("OCX_img_VideoRT", "RawImage")
        self.rawImageRect = self:GetComponent("OCX_img_VideoRT", "RectTransform")
        self.rawImageInitSize = self.rawImageRect.rect.size
    end
    if (not self.videoPlayer) then
        self:SetVideoPlayer(self:GetComponent("OCX_img_VideoPlayer", "VideoPlayer"))
    end
    self.checkTimer = nil
    ---@type number 上次检查视频播放进度的时间
    self.lastCheckTime = -1
    ---@type number 视频播放异常检查计时器
    self.errorCheckTimer = -1
    ---@type number 进入异常时的播放进度
    self.errorCheckStartTime = -1
    ---@type bool 是否可以启动异常检查计时器
    self.isErrorCheckTimerAvailable = true
    ---@type number 错误检查的间隔
    self.errorCheckDelta = 0.5
    ---@type number 错误检查的累计次数 >=3 错误检查机制会自动失效
    self.errorCheckMissCount = 0
    self:AddListener(GameSoundMgr.EVENT_VIDEO_MUTE_CHANGE, self.OnVideoMuteChange)
end

--region 横竖屏部分

---横竖屏模式下，此Ctrl将会有两份（因为UI有两份
---@param videoPlayer UnityEngine.Video.VideoPlayer 视频播放器组件
---@param windowType GameConst.VideoWindowType 视频窗口类型
function VideoShowCtrl:InitWithSwitchType(videoPlayer, isHor, dirCb, closeCb)
    ---@type GameConst.VideoWindowType
    self._windowType = GameConst.VideoWindowType.Switch
    self:SetVideoPlayer(videoPlayer)
    ---@type bool 是否为横屏
    self.isHor = isHor
    ---@type function(bool) 点击更改方向回调
    self.onChangeDirCb = nil
    ---@type function() 关闭界面方法
    self.closeCb = closeCb
    ---@type bool UI是否正在展示
    self.uiShowState = false;
    ---@type int 隐藏UI的计时id
    self.hideUiTimerId = nil
    ---@type bool 是否Awake后立即播放
    self.playOnAwake = false
    ---@type bool 是否正在被拖动
    self._hold = false
    ---@type float 开始拖动时的帧数
    self._dragStartFrame = 0
    ---@type float 触发拖动时X坐标
    self._dragStartPos = nil
    ---@type bool 当前是否触发手势
    self._dragGesture = false
    ---@type bool 是否处于播完等待状态
    self._isEndWait = false
    ---@type float 用于控制拖动的快进幅度
    self.dragBaseLength = 2000
    self.skipOnDrop = false

    self.onUpdateShowState = function(state)
        self:UpdatePlayStateUI()
        ---竖转横时，需要隐藏UI
        if (state) then
            self:ChangeUIState()
        end
    end
    self:SetActive("OCX_Loading", true)
    self:SetInputCtrl()
    self:AddButtonListener("OCX_BackButton", handler(self, self.closeCb))
    self:AddButtonListener("OCX_TouchPanel", handler(self, self.OnTouchPanel))
    self:AddButtonListener("OCX_btn_Play", handler(self, self.OnChangePlayState))
    self:AddButtonListener("OCX_btn_pause", handler(self, self.OnChangePlayState))
    self:AddButtonListener("OCX_EndBtn", handler(self, self.OnChangePlayState))
    self:InitSwitchUI(dirCb)
    self:SetActive("OCX_Play", false)
    self:ChangeWaitEndState(false)
    self:SetActive("OCX_DragSlider", false)
    self:AddVideoListener()
    --self:AddButtonListener("OCX_BackBtn", handler(self, self.CloseSelf))
    self:InitSlider()
end

---仅需横竖屏功能时
--- @param switchFunc function(bool) 切换方向回调
--- @param isHor bool 是否为横屏
--- @param vedioPlayer UnityEngine.Video.VideoPlayer 视频播放器组件
function VideoShowCtrl:InitSwitch(switchFunc, isHor, vedioPlayer)
    self.isHor = isHor
    self:InitSwitchUI(switchFunc)
    self:SetVideoPlayer(vedioPlayer)
    self.videoPlayer.aspectRatio = self.isHor and CS.UnityEngine.Video.VideoAspectRatio.FitVertically or CS.UnityEngine.Video.VideoAspectRatio.FitHorizontally
end
---设置或者改变VideoPlayer
--- @param videoPlayer UnityEngine.Video.VideoPlayer 视频播放器组件
function VideoShowCtrl:SetVideoPlayer(videoPlayer)
    if videoPlayer == nil then
        return
    end
    self.videoPlayer = videoPlayer
    ---@type number 默认的轨道
    self.defaultTrackIndex = 0
    ---@type number prefab上设置的默认音量
    self.defaultVolume = self.videoPlayer:GetDirectAudioVolume()
    self:SetVolumeEnable(true)
end

---横竖屏相关功能
---@param switchFunc function(bool) 切换方向回调
function VideoShowCtrl:InitSwitchUI(switchFunc)
    self.onChangeDirCb = switchFunc
    self:AddButtonListener("OCX_ChangeButton", handler(self, self.ChangeDir))
end

---InitRT相关
function VideoShowCtrl:InitVideoRT()
    local baseRect = self:GetComponent("", "RectTransform").rect
    self.rawImage = self:GetComponent("OCX_img_VideoRT", "RawImage")
    local needWidth = self.isHor and baseRect.height or baseRect.width
    local needHeight = self.isHor and baseRect.width or baseRect.height
    if (self.isHor) then
        local touchNode = self:GetComponent("OCX_Touch", "RectTransform")
        if touchNode then
            local touchRect = touchNode.rect
            GameObjectUtil.SetSizeDeltaXY(self.rawImage.transform, needWidth, needHeight)
            GameObjectUtil.SetSizeDeltaXY(touchNode, needWidth, touchRect.height)
        end
    end
    if (self.isHor) then
        local bgNode = self:GetComponent("OCX_BG", "RectTransform")
        if bgNode then
            GameObjectUtil.SetSizeDeltaXY(bgNode, needWidth, needHeight)
        end
    end
    if self.isAdapter then
        local videoSize = Vector2.new(self.videoPlayer.width, self.videoPlayer.height)
        local curRootSize = UIMgr.GetUIRoot().rect.size
        if self.isHor then
            curRootSize = Vector2.new(curRootSize.y, curRootSize.x)
        else
            curRootSize = Vector2.new(curRootSize.x, curRootSize.y)
        end
        local retSize = ImageCropUtil.GetAdapterSize(curRootSize, videoSize, nil, true)
        self:SetSizeDelta(self:GetComponent("OCX_img_VideoRT"), retSize.x, retSize.y)
    end
    if not self.videoRT then
        if GameObjectUtil.IsNull(self.rawImage.texture) then
            self.videoRT = RenderTextureUtil.GetRtByRawImage(self.rawImage)
            self.videoPlayer.targetTexture = self.videoRT
            self.rawImage.texture = self.videoRT
        else
            self.videoRT = self.rawImage.texture
        end
    end

end

---设置手势输入的Ctrl内容
function VideoShowCtrl:SetInputCtrl()
    self.input = GameObjClickUtil.Get(self.gameObject)
    self.input:SetCtrlType(GameObjClickUtil.CtrlType.DRAG | GameObjClickUtil.CtrlType.CLICK)
    self.input:SetTouchBlockEnableByUI(GameObjClickUtil.TouchType.ON_GESTURE, false)
    --self.input:SetTouchEnable(true)
    self.input:SetDelegate(self)
end

---手指抬起时
function VideoShowCtrl:OnTouchUp(pos)
    self._dragGesture = false
    self._dragStartPos = nil
    if (self.deltaFrame) then
        --Debug.LogError("START ", self.videoPlayer.frame, " ", math.floor(self.deltaFrame))
        self.videoPlayer.frame = self._dragStartFrame + math.floor(self.deltaFrame)
        --Debug.LogError("End ", self.videoPlayer.frame)
    end
    self:SetActive("OCX_DragSlider", false)
    self.deltaFrame = nil
    self._dragStartFrame = 0
end

---拖动时
function VideoShowCtrl:OnDrag(pos, deltaPos, gesture)
    if (self._isEndWait or self._hold) then
        return
    end
    --Debug.LogWarning("pos ", pos.x, " ", self.deltaFrame)
    if (not self._dragGesture) then
        if (not self.isHor) then
            if (gesture == GameObjClickUtil.Gesture.RIGHT or gesture == GameObjClickUtil.Gesture.LEFT) then
                self._dragGesture = true
                self._dragStartFrame = self.videoPlayer.frame
            end
        else
            if (gesture == GameObjClickUtil.Gesture.UP or gesture == GameObjClickUtil.Gesture.DOWN) then
                self._dragGesture = true
                self._dragStartFrame = self.videoPlayer.frame
            end
        end
    end

    if (self._dragGesture) then
        if ((not self._dragStartPos)) then
            self._dragStartPos = self.isHor and pos.y or pos.x
        end
        self:ChangeUIState(true)
        self:SetActive("OCX_DragSlider", true)
    end

    if (self._dragStartPos) then
        local deltaPercent = ((self.isHor and pos.y or pos.x) - self._dragStartPos) / self.dragBaseLength
        local frame = deltaPercent * self.videoPlayer.frameCount
        self.deltaFrame = frame
        self._dragSlider:SetValue((self._dragStartFrame + frame) / self.videoPlayer.frameCount)

    end
end

---点击横竖屏切换时
function VideoShowCtrl:ChangeDir()
    --self:SetActive(nil, false)
    if (self.onChangeDirCb) then
        self.onChangeDirCb(not self.isHor)
    end
end

---点击暂停或恢复时
function VideoShowCtrl:OnChangePlayState()
    if (self.videoPlayer.isPlaying) then
        self.videoPlayer:Pause()
    else
        self.videoPlayer:Play()
    end
    self:UpdatePlayStateUI()
end

function VideoShowCtrl:ChangeWaitEndState(state)
    self._isEndWait = state
    self:SetActive("OCX_End", state)
    if (state) then
        self:ChangeUIState(true)
    end
end

---改变UI显隐状态
function VideoShowCtrl:ChangeUIState(state)
    if (state) then
        if (self.videoPlayer.isPrepared) then
            self:SetActive("OCX_BaseUI", true)
            self:SetActive("OCX_BackButton", true)
            self.uiShowState = true
        end
    else
        if (not self._isEndWait) then
            self.hideUiTimerId = nil
            self:SetActive("OCX_BaseUI", false)
            self:SetActive("OCX_BackButton", false)
            self.uiShowState = false
        end
    end
end

---唤醒UI
function VideoShowCtrl:OnTouchPanel()
    if (self.hideUiTimerId) then
        TimerMgr.Discard(self.hideUiTimerId)
    end
    if (self.uiShowState) then
        self:ChangeUIState(false)
    else
        self:ChangeUIState(true)
        self.hideUiTimerId = TimerMgr.AddTimer(3, self.ChangeUIState, self, 1)
    end
end

---改变播放器UI状态
function VideoShowCtrl:UpdatePlayStateUI()
    local isPlaying = self.videoPlayer.isPlaying
    self:SetValue("OCX_PlayStyle", not isPlaying)

    self:SetActive("OCX_Play", (not isPlaying) and (not self._isEndWait) and (self.videoPlayer.isPrepared))
    if (isPlaying) then
        self:SetActive("OCX_Loading", false)
        self:ChangeWaitEndState(false)
    else

    end
end

---初始化进度条相关
function VideoShowCtrl:InitSlider()
    self.slider = self:GetComponent("OCX_Slider", "Slider")
    self:AddSliderListener("OCX_Slider", handler(self, self.OnProgressUpdate))
    self._uiEvtlistener = CS.EventTriggerListener.Get(self:GetComponent("OCX_Slider"))
    self._uiEvtlistener.onPointerDownEvent = handler(self, self.OnPointerDownEvent)
    self._uiEvtlistener.onPointerUpEvent = handler(self, self.OnPointerUpEvent)
    ---拖动展示
    self._dragSlider = self:GetComponent("OCX_DragSlider", "Slider")
end

function VideoShowCtrl:UpdateShowState(state)
    self:SetActive(nil, state)
    if (state) then
        local curState = self.videoPlayer.isPlaying
        self.videoPlayer.targetTexture = self.videoRT
        self.videoPlayer.aspectRatio = self.isHor and CS.UnityEngine.Video.VideoAspectRatio.FitVertically or CS.UnityEngine.Video.VideoAspectRatio.FitHorizontally
        ---渲染完恢复暂停
        if (not curState) then
            local frame = self.videoPlayer.frame
            self.videoPlayer:StepForward()
            self.videoPlayer.frame = frame
        end
        if (self.onUpdateShowState) then
            self.onUpdateShowState(self.isHor)
        end
    end
end

function VideoShowCtrl:OnTick()
    if (not self._hold) then
        self.slider:SetValue(self.videoPlayer.time / self.videoPlayer.length)
        ---每帧更新文本应该无必要
        --self.videoPlayer.time是一个小数，将其转为整数
        --将self.videoPlayer.time转为整数

        local curTime = math.floor(self.videoPlayer.time)
        local totalTime = math.floor(self.videoPlayer.length)
        self:SetText("OCX_VideoTime", UITextConst.UI_TEXT_9785, curTime // 60, string.format("%02d", curTime % 60),
                totalTime // 60, string.format("%02d", totalTime % 60))

    end
end

---进度条更新时
function VideoShowCtrl:OnProgressUpdate(value)

end

---进度条手指按下时
function VideoShowCtrl:OnPointerDownEvent(isPlay)
    self._hold = true
end

---进度条手指抬起时
function VideoShowCtrl:OnPointerUpEvent()
    self._hold = false
    ---这里需要已经在播放后再启用
    local progress = self.slider.value
    self.videoPlayer.frame = math.floor(progress * self.videoPlayer.frameCount)
    self:OnTick();
end

---是否为横竖屏窗口模式
function VideoShowCtrl:IsSwitchType()
    return self._windowType == GameConst.VideoWindowType.Switch
end

--endregion


---@param videoNameOrUrl
function VideoShowCtrl:PlayVideo(videoNameOrUrl, callback, videoSourceType, startFrame, endFrame, isLooping, videoLoadedCallback, isAdapter, videoSeekCallback, videoErrorCallback)
    if string.isnilorempty(self.videoNameOrUrl) or self.videoNameOrUrl ~= videoNameOrUrl then
        self.isNeedDecryption = true
    else
        self.isNeedDecryption = false
    end
    self.isAdapter = isAdapter
    self.videoNameOrUrl = videoNameOrUrl
    self.callback = callback
    self.videoLoadedCallback = videoLoadedCallback
    self.videoErrorCallback = videoErrorCallback
    self.SeekCompleted = videoSeekCallback
    self.videoSourceType = videoSourceType
    self.startFrame = startFrame and startFrame or 0
    self.endFrame = endFrame and endFrame or 0
    self.videoPlayer.playOnAwake = self.playOnAwake
    self.videoPlayer.skipOnDrop = self.skipOnDrop
    self.videoPlayer.isLooping = isLooping and true or false
    self:ClearVideoListener()
    self:AddVideoListener()
    self.isPlay = false
    self.playbackSpeed = 1
    self:SetActive(nil, true)
    self:ShowVideoPlay()
end

function VideoShowCtrl:OnVideoMuteChange(enable)
    self:SetVolumeEnable(enable)
end

---@param enable boolean 如果Video组件需要切换显隐（SetActive），则要设置playOnAwake为true
function VideoShowCtrl:SetPlayOnAwake(enable)
    self.playOnAwake = enable
end

function VideoShowCtrl:SetGameFocusIsPause(isPause)
    self.gameFocusIsPause = isPause
end

---@param enable boolean 是否静音
function VideoShowCtrl:SetVolumeEnable(enable)
    if self.videoPlayer then
        if enable then
            --self.videoPlayer:SetDirectAudioMute(0,false) SetDirectAudioMute这个函数有bug，不执行，所以用SetDirectAudioVolume替代
            self.videoPlayer:SetDirectAudioVolume(self.defaultTrackIndex, self.defaultVolume)
        else
            self.defaultVolume = self.videoPlayer:GetDirectAudioVolume()
            self.videoPlayer:SetDirectAudioVolume(self.defaultTrackIndex, 0)
        end
    end
end
---@param volume number 设置视频音量大小 0~100
function VideoShowCtrl:SetVideoVolume(volume)
    if not volume then
        volume = 0
    end
    if volume < 0 then
        volume = 0
    elseif volume > 100 then
        volume = 100
    end
    self.videoPlayer:SetDirectAudioVolume(self.defaultTrackIndex, volume)
    self.defaultVolume = volume
end

function VideoShowCtrl:OnPlayEndCallBack()
    Debug.Log("OnPlayEndCallBack!!!")
    if (not self:IsSwitchType()) then
        self.videoPlayer:loopPointReached("-", self.stopCallback)
    else
        self:UpdatePlayStateUI()
        self:ChangeWaitEndState(true)
    end
    self:CarryOutCallBack()
end

function VideoShowCtrl:OnPrepareCompleted()
    Debug.Log("OnPrepareCompleted!!!")
    self:InitVideoRT()
    self:PlayVideoPlayer()
    --self.videoPlayer:prepareCompleted("-", self.onPrepareCompleteCallBack)
end

function VideoShowCtrl:OnSeekCompleted()
    Debug.Log("OnSeekCompleted!!!")
    if self.SeekCompleted then
        self.SeekCompleted()
        self.SeekCompleted = nil
    end
end

function VideoShowCtrl:CarryOutCallBack()
    if self.callback then
        self.callback()
        self.callback = nil
    end
end

function VideoShowCtrl:PlayVideoPlayer()
    if not self.isPlay then
        Debug.Log("PlayVideoPlayer!!!")
        self.videoPlayer:Play()
        self:SetSpeed(self.playbackSpeed)
        if self.startFrame ~= 0 then
            self.videoPlayer.frame = self.startFrame
            self.startFrame = 0
        end
        if self.pauseFrame then
            self.videoPlayer.frame = self.pauseFrame
            self.pauseFrame = nil
        end
        if self.endFrame == 0 then
            self.endFrame = self.videoPlayer.frameCount
        end
        self.isPlay = true
        if self.videoLoadedCallback then
            self.videoLoadedCallback()
            self.videoLoadedCallback = nil
        end
    end

    if (self:IsSwitchType()) then
        self:UpdatePlayStateUI()
    end
end

function VideoShowCtrl:PauseVideoPlayer(recordFrame)
    if self.isPlay then
        self.videoPlayer:Pause()
        if recordFrame then
            self.pauseFrame = self.videoPlayer.frame
        end
        self.isPlay = false
    end

    if (self:IsSwitchType()) then
        self:UpdatePlayStateUI()
    end
end

function VideoShowCtrl:ShowVideoPlay()
    if self.videoSourceType == GameConst.VideoSourceType.VideoClip then
        self.videoPlayer.source = CS.UnityEngine.Video.VideoSource.VideoClip
        self.videoClip = Res.Load(self.videoNameOrUrl, ResType.T_VideoClip)
        self.videoPlayer.clip = self.videoClip
        self.videoPlayer:Prepare()
        self:InternalPlayVideo()
    elseif self.videoSourceType == GameConst.VideoSourceType.WebUrl then
        self.videoPlayer.source = CS.UnityEngine.Video.VideoSource.Url
        self.videoPlayer.url = self.videoNameOrUrl
        self.videoPlayer:Prepare()
        self:InternalPlayVideo()
    else
        self.videoPlayer.source = CS.UnityEngine.Video.VideoSource.Url
        local path = GameHelper.GetPlayVideoPath(self.videoNameOrUrl)
        if not BllMgr.GetVideoBLL():CheckVideoCrc(path) then
            self:CheckVideoFail()
            if CS.System.IO.File.Exists(path) then
                CS.System.IO.File.Delete(path)
            end
            return
        end
        self.videoPlayer.url = path
        if DEBUG_GM then
            if not CS.System.IO.File.Exists(path) then
                Debug.LogError("video path is not Exists path:", path)
            end
        end
        self.videoPlayer:Prepare()
        self:InternalPlayVideo()
    end
end

function VideoShowCtrl:CheckVideoFail()
    if self.videoLoadedCallback then
        self.videoLoadedCallback()
        self.videoLoadedCallback = nil
    end
    if self.callback then
        self.callback()
        self.callback = nil
    end
end

function VideoShowCtrl:InternalPlayVideo()
    self:ClearCheckTimer()
    self:ClearErrorCheckTimer()
    self.checkTimer = TimerMgr.AddTimer(0.1, self.CheckVideo, self, true)
    self:StartErrorCheckTimer()
end

function VideoShowCtrl:ClearCheckTimer()
    if self.checkTimer ~= nil then
        TimerMgr.Discard(self.checkTimer)
        self.checkTimer = nil
    end
end

function VideoShowCtrl:ClearErrorCheckTimer()
    if self.errorCheckTimer ~= -1 then
        TimerMgr.Discard(self.errorCheckTimer)
        self.errorCheckTimer = -1
        self.lastCheckTime = -1
    end
end

function VideoShowCtrl:StartErrorCheckTimer()
    --这里没法用轨道数判断，连这个数据都是异步的，当帧拿不到
    if Application.IsIOSMobile() then
        self.errorCheckTimer = TimerMgr.AddTimer(self.errorCheckDelta, self.CheckVideoError, self, true)
    end
end

function VideoShowCtrl:CheckVideo()
    if self.videoPlayer and self.videoPlayer.isPaused then
        return
    end
    if self.videoPlayer and not self.videoPlayer.isPlaying or self.endFrame - self.videoPlayer.frame <= 2 then
        --self:Close()
        if self.isPlay then
            self:CarryOutCallBack()
        else
            if self.videoPlayer.isPrepared then
                self:PlayVideoPlayer()
            end
        end
    end
end

---检查IOS上视频是否会异常卡住
function VideoShowCtrl:CheckVideoError()
    if not self.videoPlayer or self.videoPlayer.audioTrackCount < 1 or self.videoPlayer.isPaused then
        return
    end

    local time = self.videoPlayer.time
    if not self.isErrorCheckTimerAvailable then
        --保证进度有变化才继续检查
        if math.abs(self.errorCheckStartTime - time ) > self.errorCheckDelta then
            self.errorCheckStartTime = -1
            self.isErrorCheckTimerAvailable = true
            self.errorCheckMissCount = 0
        else
            self.errorCheckMissCount = self.errorCheckMissCount + 1
            if self.errorCheckMissCount >= 3 then
                self:ClearErrorCheckTimer()
                self.errorCheckMissCount = 0
                Debug.LogFatalFormat("VideoShowCtrl 错误检查机制彻底失效")
            end
        end
        
        return
    end
    
    --防止一上来就出错
    if self.lastCheckTime <= 0 then
        self.lastCheckTime = time
        return
    end
    
    if self.videoPlayer.isPlaying and math.abs(self.lastCheckTime - time ) < 0.05 then
        self.isErrorCheckTimerAvailable = false
        self.errorCheckStartTime = time
        self:PauseVideoPlayer(true)
        self:PlayVideoPlayer()
    else
        self.lastCheckTime = time
    end
end

---设置视频速度
---@param speed float
function VideoShowCtrl:SetSpeed(speed)
    self.playbackSpeed = speed
    if self.videoPlayer then
        self.videoPlayer.playbackSpeed = speed
    end
end

---@param value boolean
function VideoShowCtrl:SetSkipOnDrop(value)
    self.skipOnDrop = value
end

function VideoShowCtrl:OnAddListener()
    -- 在重启Lua虚拟机之前 移除cs事件
    self:AddListener("BeforeLuaEnvReboot", self.ClearVideoListener)
    EventMgr.AddListener("Game_Focus", self.OnGameFocus, self)
end

function VideoShowCtrl:OnRemoveListener()

end

function VideoShowCtrl:ClearVideoListener()
    if (self.stopCallback) then
        self.videoPlayer:loopPointReached("-", self.stopCallback)
    end
    if (self.onPrepareCompleteCallBack) then
        self.videoPlayer:prepareCompleted("-", self.onPrepareCompleteCallBack)
    end
    if (self.onErrorReceivedCallBack) then
        self.videoPlayer:errorReceived("-", self.onErrorReceivedCallBack)
    end
    if (self.onSeekCompleteCallBack) then
        self.videoPlayer:seekCompleted("-", self.onSeekCompleteCallBack)
    end
end

function VideoShowCtrl:OnGameFocus(isFocus)
    if UNITY_EDITOR or (not Application.IsIOSMobile() and not self.gameFocusIsPause) then
        return
    end
    if isFocus then
        self:PlayVideoPlayer()
    else
        self:PauseVideoPlayer(true)
    end
end

function VideoShowCtrl:OnHide()
    self:PauseVideoPlayer(true)
end

function VideoShowCtrl:OnShow()
    if self.pauseFrame ~= nil then
        self:PlayVideoPlayer()
    end
end

function VideoShowCtrl:AddVideoListener()
    self.stopCallback = handler(self, self.OnPlayEndCallBack)
    self.onPrepareCompleteCallBack = handler(self, self.OnPrepareCompleted)
    self.onErrorReceivedCallBack = handler(self, self.OnErrorReceivedCallBack)
    self.onSeekCompleteCallBack = handler(self, self.OnSeekCompleted)
    self.videoPlayer:loopPointReached("+", self.stopCallback)
    self.videoPlayer:prepareCompleted("+", self.onPrepareCompleteCallBack)
    self.videoPlayer:errorReceived("+", self.onErrorReceivedCallBack)
    self.videoPlayer:seekCompleted("+", self.onSeekCompleteCallBack)
end

function VideoShowCtrl:OnErrorReceivedCallBack(videoPlayer, message)
    if self.videoErrorCallback then
        self.videoErrorCallback()
    end
    if self.callback then
        Debug.LogError("OnErrorReceivedCallBack", "message:", message)
        self:CarryOutCallBack()
    end
end

function VideoShowCtrl:ClearAll()
    self:ClearCheckTimer()
    self:ClearErrorCheckTimer()
    if self.hideUiTimerId then
        TimerMgr.Discard(self.hideUiTimerId)
    end
    self:ClearVideoListener()

    if self.videoClip then
        Res.Unload(self.videoClip)
    end

    if self.videoRT then
        RenderTextureUtil.ReleaseRt(self.videoRT)
    end
    self.rawImageRect.rect.size = self.rawImageInitSize
    self.videoRT = nil
    self.videoLoadedCallback = nil
    self.isErrorCheckTimerAvailable = true
    self.errorCheckMissCount = 0
    self.errorCheckStartTime = -1
    self.videoPlayer.targetTexture = nil
    self.rawImage.texture = nil
end

function VideoShowCtrl:OnClose()
    self:ClearAll()
end

function VideoShowCtrl:StopVideo()
    self.videoPlayer:Stop()
end

return VideoShowCtrl