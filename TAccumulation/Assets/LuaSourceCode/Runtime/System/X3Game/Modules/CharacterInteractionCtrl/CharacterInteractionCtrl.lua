---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by doudou.
--- DateTime: 2023/5/23 17:28
---@class CharacterInteractionCtrl:GameObjectCtrl
local CharacterInteractionCtrl = class("CharacterInteractionCtrl", GameObjectCtrl)
local CharacterInteractionConst = require("Runtime.System.X3Game.Modules.CharacterInteractionCtrl.CharacterInteractionConst")
local CharacterInteractionMgr = require("Runtime.System.X3Game.Modules.CharacterInteractionCtrl.CharacterInteractionMgr")
local MainHomeConst = require("Runtime.System.X3Game.Modules.MainHome.Data.MainHomeConst")

function CharacterInteractionCtrl:ctor()
    ---@type DialogueController
    self.dialogueCtrl = nil
    self.dialogueInfoId = 0
    self.endCallBack = nil
    self.waitingForInit = true
    self.currentDialogue = nil

    self.lastClickTime = -1 -- 上次点击的时间
    self.clickDt = 0 -- 两次点击的时间间隔
    self.lastSendEventTime = -1 -- 上一次生效的点击，并发送事件的时间
    self.sendEventDt = 0 -- 两次生效的点击时间间隔

    self.progress = 0
    self.curStateId = 0
    self.isProgressFinish = false
    self.isFinish = false
    self.targets = nil

    self.timer = TimerMgr.AddTimer(0.2, self.Update, self, true)
    self.camera = nil
    self.cameraCtrl = nil

    self.isCrazy = false
    self.crazyTime = nil
end

---启动自由互动
---@param character GameObject
---@param dialogueCtrlName string
---@param endCallBack fun
function CharacterInteractionCtrl:InitData(dialogueCtrlName, dialogueInfoId, endCallBack)
    ---@type DialogueController
    self.dialogueCtrl = DialogueManager.Get(dialogueCtrlName)
    self.dialogueInfoId = dialogueInfoId
    self.endCallBack = endCallBack

    self.signatureCallback = handler(self, self.SignatureCallback)
    CutSceneMgr.RegisterEventCallback(self.signatureCallback)
    local x3Animator = GameObjectUtil.EnsureCSComponent(self.gameObject, typeof(CS.X3Game.X3Animator))
    x3Animator:AddState(CharacterInteractionConst.CutSceneName, CharacterInteractionConst.CutSceneName, true)
    x3Animator:Crossfade(CharacterInteractionConst.CutSceneName)

    self.targets = {}
    for _,v in pairs(CharacterInteractionConst.TargetsBones) do
        table.insert(self.targets, CharacterMgr.GetBoneByName(self.gameObject, v))
    end

    EventMgr.AddListener(CharacterInteractionConst.EVENT_PROGRESS_FINISH, self.OnProgressFinished, self)
    Debug.Log(JsonUtil.Encode(CharacterInteractionConst))
end

---事件帧回调
---@param evtData PapeGames.CutScene.CutSceneEventData
function CharacterInteractionCtrl:SignatureCallback(evtData)
    if evtData.EventType == CutSceneEventType.KeyFrame then
        self.waitingForInit = false
        CutSceneMgr.Pause(evtData.PlayId)
        self:AddCharacterClick()
        self:InitCamera()
    elseif self.waitingForInit == false and
            (evtData.EventType == CutSceneEventType.Stop) then
        self.isFinish = true
        self:CheckReturn()
    end
end

function CharacterInteractionCtrl:InitCamera()
    self.camera = CS.PapeGames.X3.Res.LoadGameObject(CharacterInteractionConst.CameraPath)
    self.camera.transform.position = self.camera.transform.localPosition
    self.camera.transform.rotation = self.camera.transform.localRotation
    self.camera.transform.parent = GlobalCameraMgr.GetRoot().transform
    self.cameraCtrl = self.camera:GetComponent(typeof(CS.X3Game.CharacterInteractionCamera))
    self.cameraCtrl.targets = self.targets
end
function CharacterInteractionCtrl:AddCharacterClick()
    UIMgr.Open(UIConf.FreeMotionInteractionWnd)
    self.clickObj = GameObjClickUtil.GetOrAddCharacterClick(self.gameObject, CharacterInteractionConst.BodyGroup, handler(self, self.OnCharacterClick), nil, true)
    self.clickObj:SetMoveThresholdDis(200) -- 修改判断点击和拖拽的阈值
    self.clickObj:SetTargetEffect(table.unpack(MainHomeConst.InputEffect))
end

function CharacterInteractionCtrl:OnCharacterClick(partType, collider, touchPos)
    if self.isProgressFinish then
        return
    end

    local addProgress = (CharacterInteractionConst.PartScore[partType] or 5)
    EventMgr.Dispatch(CharacterInteractionConst.EVENT_PROGRESS_CHANGE, addProgress, touchPos)

    local curTime = TimerMgr.GetRealTimeSeconds()
    if self.lastClickTime > 0 then
        self.clickDt = curTime - self.lastClickTime
    end
    self.lastClickTime = curTime

    if self.lastSendEventTime > 0 then
        self.sendEventDt = curTime - self.lastSendEventTime
    end

    if self.sendEventDt > 0 and self.sendEventDt < CharacterInteractionConst.CDTime then
        return
    end
    self.lastSendEventTime = curTime

    self.isCrazy = self.clickDt > 0 and self.clickDt < CharacterInteractionConst.CrazyHitThresholdTime
    if self.isCrazy then
        self.crazyTime = curTime
    end
    self.curStateId = self:GetStateId(partType, self.isCrazy)
    local localPos = CommonUtil.GetHitLocalPosition(touchPos, nil, collider, self.gameObject.transform)
    CutSceneMgr.SendEventWithParam("Click", "Effector_Hand_L", localPos)
    CutSceneMgr.SendEventWithParam("Click", "StateId", self.curStateId)
    CutSceneMgr.SendEventWithParam("Click", "IsCrazyHit", self.isCrazy)
    CutSceneMgr.SendEventWithParam("Click", "IsHit", true)
    self:PlayDialogue(partType, self.isCrazy)
end

function CharacterInteractionCtrl:OnProgressFinished()
    self.isProgressFinish = true
end

--region anim
function CharacterInteractionCtrl:GetStateId(partType, isCrazy)
    local newState = self.curStateId
    local randomList = {}

    if not isCrazy then
        if CharacterInteractionConst.NormalState[partType] then
            for _,v in pairs(CharacterInteractionConst.NormalState[partType])  do
                if v ~= self.curStateId then
                    table.insert(randomList, v)
                end
            end
        end
    else
        if CharacterInteractionConst.CrazyState[partType] then
            for _,v in pairs(CharacterInteractionConst.CrazyState[partType])  do
                if v ~= self.curStateId then
                    table.insert(randomList, v)
                end
            end
        end
    end

    if randomList and #randomList > 0 then
        newState = randomList[math.random(1, #randomList)]
    end

    return newState
end
--endregion

--region Dialogue
function CharacterInteractionCtrl:PlayDialogue(partType, isCrazy)
    if self.currentDialogue == nil then
        local conversationId = 6
        local nodeIds = CharacterInteractionConst.NodeId[isCrazy and 1 or 0][partType]
        if nodeIds then
            local index = math.random(1, #nodeIds)
            self.currentDialogue = self.dialogueCtrl:StartDialogueById(self.dialogueInfoId, conversationId, nodeIds[index], "CharacterInteraction", handler(self, self.OnFinishDialogue))
        else
            Debug.LogError("Invalid Part type:%d",partType)
        end
   end
end

function CharacterInteractionCtrl:OnFinishDialogue()
    self.currentDialogue = nil
    self:CheckReturn()
end
--endregion

function CharacterInteractionCtrl:Update(dt)
    if self.isFinish then
        return
    end
    if self.isCrazy and self.crazyTime then
        local curTime = TimerMgr.GetRealTimeSeconds()
        if curTime - self.crazyTime > 0.5 then -- 当进入 Crazy 模式后 0.5s 没有点击，自动退出疯狂模式
            self.isCrazy = false
            self.crazyTime = nil
            CutSceneMgr.SendEventWithParam("Click", "IsCrazyHit", self.isCrazy)
        end
    end
end

function CharacterInteractionCtrl:CheckReturn()
    if self.isFinish and self.currentDialogue == nil then
        if self.endCallBack then
            self.endCallBack()
        end
        CutSceneMgr.UnregisterEventCallback(self.signatureCallback)
        CharacterInteractionMgr.Remove(self.gameObject)
        UICommonUtil.BlackScreenOut()
    end
end

function CharacterInteractionCtrl:OnDestroy()
    CutSceneMgr.UnregisterEventCallback(self.signatureCallback)
    GameObjClickUtil.Remove(self.gameObject)
    self.gameObject = nil
    ---@type DialogueController
    self.dialogueCtrl = nil
    self.endCallBack = nil
    self.waitingForInit = true;
    self.currentDialogue = nil
    self.targets = nil
    GameObjectUtil.Destroy(self.camera)
    self.camera = nil
    self.cameraCtrl = nil

    UIMgr.Close(UIConf.FreeMotionInteractionWnd)

    self.gameObject = nil
    GameObjectCtrl.OnDestroy(self)
end

return CharacterInteractionCtrl