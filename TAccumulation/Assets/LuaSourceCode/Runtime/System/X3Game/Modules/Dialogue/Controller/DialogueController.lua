---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2021/12/6 11:44
---

---每个业务系统可以有自己的Controller，互不干扰
---@class DialogueController
local DialogueController = class("DialogueController")

local DialogueSettingData = require("Runtime.System.X3Game.Modules.Dialogue.Controller.DialogueSettingData")
local DialogueSystem = require("Runtime.System.X3Game.Modules.Dialogue.DialogueSystem")
local DialoguePipeline = require("Runtime.System.X3Game.Modules.Dialogue.DialoguePipeline")

---@class DialogueSavingData
---@field systemSavingData table<int, DialogueSystemSavingData>

---@class DialogueSystemSavingData
---@field randomTimesCache table<int, int>

---构造函数
---@param name string
function DialogueController:ctor(name)
    ---@type string controller名字
    self.name = name
    ---@type table<int, DialogueSystem> 拥有的剧情系统缓存，可以起多个Dialogue
    self.dialogueSystemDict = {}
    ---@type table<int, int>
    self.variableStateDict = {}
    ---@type table<int, fun> 侦听变量修改
    self.variableStateChangeListener = {}
    ---@type table<string|int, DialoguePipeline>
    self.pipelineDict = {}
    ---@type table<DialoguePipeline> 搞一个Pipeline池减少GC
    self.pipelinePool = {}
    ---@type table<int|string, GameObject> 外部注入的资产实例
    self.injectedGameObjectDict = {}
    ---@type DialogueSettingData 剧情系统设置数据
    self.defaultSettingData = DialogueSettingData.new()
    ---@type boolean 启动Dialogue时是否使用Controller的默认设置
    self.dialogueUseDefaultSetting = false
    ---@type boolean 剧情系统自动记录（随机次数）
    self.autoSave = false
    ---@type boolean 初始化剧情时读取记录（随机次数）
    self.autoLoad = false
    ---@type table<int, int> 随机种子注入
    self.randomSeedDict = {}
    ---@type boolean 可以显示剧情UI
    self.canShowDialogueUI = true
    ---@type table<int, string>
    self.semanticDict = {}
    ---@type table<string, int> 需要复写的Conversation
    self.overrideConversations = {}
end

--region Getter/Setter
---返回创建过的DialogueSystem
---@param dialogueInfoId int
---@return DialogueSystem
function DialogueController:GetDialogueSystem(dialogueInfoId)
    return self.dialogueSystemDict[dialogueInfoId]
end

---播放Dialogue时是否使用Controller默认设置
---@param value boolean
function DialogueController:SetDialogueUseDefaultSetting(value)
    self.dialogueUseDefaultSetting = value
end

---返回剧情设置
---@return DialogueSettingData
function DialogueController:GetSettingData()
    return self.defaultSettingData
end

---立即同步并且覆盖设置
function DialogueController:SyncSettingDataToSystem()
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        dialogueSystem:SyncSettingFromController()
    end
end

---设置是否需要自动记录
---@param value boolean
function DialogueController:SetAutoSave(value)
    self.autoSave = value
end

---设置是否需要读取记录
---@param value boolean
function DialogueController:SetAutoLoad(value)
    self.autoLoad = value
end

--endregion

---是否显示剧情UI
---@param isShow boolean
function DialogueController:ShowOrHideDialogueUI(isShow)
    self.canShowDialogueUI = isShow
    EventMgr.Dispatch("DialogueWndActive", isShow)
end

---返回是否能显示剧情UI
---@return boolean
function DialogueController:GetCanShowDialogueUI()
    return self.canShowDialogueUI
end

---是否显示选项UI
---@param isShow boolean
function DialogueController:ShowOrHideChoiceUI(isShow)
    EventMgr.Dispatch("DialoguePanelChoiceActive", isShow)
end

--region Save/Load
function DialogueController:CheckSave()
    if self.autoSave then
        ---@type DialogueSavingData
        local savingData = {systemSavingData = {}}
        for id, dialogueSystem in pairs(self.dialogueSystemDict) do
            savingData.systemSavingData[tostring(id)] = dialogueSystem:GetSaveData()
        end
        PlayerPrefs.SetString(string.concat("DialogueSave_", self.name), JsonUtil.Encode(savingData))
        PlayerPrefs.Save()
    end
end

---
---@param id int
function DialogueController:CheckLoad(id)
    if self.autoLoad then
        local savingDataString = PlayerPrefs.GetString(string.concat("DialogueSave_", self.name))
        if string.isnilorempty(savingDataString) == false then
            local savingData = JsonUtil.Decode(savingDataString)
            if savingData then
                self.dialogueSystemDict[id]:Load(savingData.systemSavingData[tostring(id)])
            end
        end
    end
end

---清除记录
function DialogueController:ClearSavingData()
    PlayerPrefs.DeleteKey(string.concat("DialogueSave_", self.name))
end
--endregion

--region RandomSeed
---@param dialogueInfoId int
---@param randomSeed int
function DialogueController:ChangeRandomSeed(dialogueInfoId, randomSeed)
    self.randomSeedDict[dialogueInfoId] = randomSeed
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    if dialogueSystem ~= nil then
        return dialogueSystem:ChangeRandomSeed(randomSeed)
    end
end

---返回随机种子
---@param dialogueInfoId int 剧情Id
---@return int
function DialogueController:GetRandomSeed(dialogueInfoId)
    local randomSeed = self.randomSeedDict[dialogueInfoId]
    if randomSeed == nil then
        randomSeed = Mathf.Random(0, 10000)
    end
    return randomSeed
end
--endregion

--region ProcessSave
function DialogueController:ClearProcessNode()
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        dialogueSystem:ClearProcessNode()
    end
end

---是否有节点记录需要发送
---@return boolean
function DialogueController:HasSavedProcessNode()
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        if dialogueSystem:HasSavedProcessNode() then
            return true
        end
    end
    return false
end

---返回记录过的节点，用于给后端校验
---@param dialogueInfoId int
---@return pbcmessage.DialogueCheck[]
function DialogueController:PopProcessNodes(dialogueInfoId)
    local checkData = {}
    if dialogueInfoId == nil then
        for _,dialogueSystem in pairs(self.dialogueSystemDict) do
            local dialogueCheck = dialogueSystem:PopProcessNodes()
            if dialogueCheck ~= nil then
                table.insert(checkData, #checkData + 1, dialogueCheck)
            end
        end
    else
        local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
        if dialogueSystem then
            local dialogueCheck = dialogueSystem:PopProcessNodes()
            if dialogueCheck ~= nil then
                table.insert(checkData, #checkData + 1, dialogueCheck)
            end
        end
    end

    return checkData
end
--endregion

---同步Controller的设置
---@param settingData DialogueSettingData
function DialogueController:SyncSetting(settingData)
    if self.dialogueUseDefaultSetting then
        settingData:CopyFrom(self.defaultSettingData)
    end
end

---Tick函数
---@param deltaTime float
function DialogueController:Update(deltaTime)
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        dialogueSystem:Update(deltaTime)
    end
end

---判断有没有初始化过该剧情
---@param dialogueInfoId int
---@return boolean
function DialogueController:DialogueInited(dialogueInfoId)
    if self.dialogueSystemDict[dialogueInfoId] then
        return true
    end
    return false
end

---DialogueManager自动播放接口，传入DialogueInfo表Id
---@param dialogueInfoId int 剧情Id 对应DialogueInfoId
---@param dialogueEndCallback fun 播放完成回调
---@return DialogueSystem
function DialogueController:InitAndAutoPlay(dialogueInfoId, dialogueEndCallback)
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    if dialogueSystem == nil then
        dialogueSystem = DialogueSystem.new()
        dialogueSystem:OnInit(self)
        self.dialogueSystemDict[dialogueInfoId] = dialogueSystem
    end
    dialogueSystem:InitAndAutoPlay(dialogueInfoId, dialogueEndCallback)
    return self.dialogueSystemDict[dialogueInfoId]
end

---初始化剧情的接口，加载DialogueDatabase，预加载资源
---@param dialogueInfoId int 剧情Id 对应DialogueInfoId
---@param randomSeed int 剧情里使用的随机种子
---@param needCreateActors boolean 是否需要初始化角色
---@param onInitComplete fun 初始化完成回调
---@param uiProgressWeight float UI进度条权重
---@return DialogueSystem
function DialogueController:InitDialogue(dialogueInfoId, randomSeed, needCreateActors, onInitComplete, uiProgressWeight)
    if needCreateActors == nil then
        needCreateActors = true
    end
    if uiProgressWeight == nil then
        uiProgressWeight = 1
    end
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    if dialogueSystem == nil then
        dialogueSystem = DialogueSystem.new()
        dialogueSystem:OnInit(self)
        self.dialogueSystemDict[dialogueInfoId] = dialogueSystem
    end
    dialogueSystem:InitDialogue(dialogueInfoId, randomSeed, needCreateActors, onInitComplete, uiProgressWeight)
    self.randomSeedDict[dialogueInfoId] = randomSeed
    return self.dialogueSystemDict[dialogueInfoId]
end

---使用ConversationId启动剧情
---@param dialogueInfoId int 剧情Id
---@param conversationId int ConversationId
---@param pipelineKey string Pipeline指定Key,可以为nil
---@param dialogueEndCallback fun 播放完成回调
---@return int|string
function DialogueController:StartDialogueById(dialogueInfoId, conversationId, nodeId, pipelineKey, dialogueEndCallback)
    if self.dialogueSystemDict[dialogueInfoId] == nil then
        Debug.Log("[DialogueSystem]剧情未初始化，请先调用InitDialogue")
        return
    end
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    return dialogueSystem:StartDialogueById(conversationId, nodeId, pipelineKey, dialogueEndCallback)
end

---使用ConversationName启动剧情
---@param dialogueInfoId int 剧情Id
---@param conversationName string 剧情Name
---@param pipelineKey string Pipeline指定Key,可以为nil
---@param dialogueEndCallback fun 播放完成回调
---@return int|string
function DialogueController:StartDialogueByName(dialogueInfoId, conversationName, nodeId, pipelineKey, dialogueEndCallback)
    if self.dialogueSystemDict[dialogueInfoId] == nil then
        Debug.Log("[DialogueSystem]剧情未初始化，请先调用InitDialogue")
        return
    end
    local playDialogueInfoId = dialogueInfoId
    if self.overrideConversations[conversationName] ~= nil then
        playDialogueInfoId = self.overrideConversations[conversationName]
        if self.dialogueSystemDict[playDialogueInfoId] == nil then
            self:InitDialogue(playDialogueInfoId, self:GetRandomSeed(dialogueInfoId), false)
        end
        Debug.LogFormat("[DialogueSystem]剧情复写，播放%s-%s", playDialogueInfoId, conversationName)
    end
    local dialogueSystem = self.dialogueSystemDict[playDialogueInfoId]
    return dialogueSystem:StartDialogueByName(conversationName, nodeId, pipelineKey, dialogueEndCallback)
end

---播放某一段Conversation
---@param dialogueInfoId int 剧情Id
---@param startConversationId int 起始ConversationId
---@param startNodeId int 起始节点Id
---@param endConversationId int 结束ConversationId
---@param endNodeId int 结束节点Id
---@param dialogueEndCallback fun 播放完成回调
---@return int|string
function DialogueController:StartDialogueRange(dialogueInfoId, startConversationId, startNodeId, endConversationId,
                                               endNodeId, dialogueEndCallback)
    if self.dialogueSystemDict[dialogueInfoId] == nil then
        Debug.Log("[DialogueSystem]剧情未初始化，请先调用InitDialogue")
        return
    end
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    return dialogueSystem:StartDialogueRange(startConversationId, startNodeId, endConversationId,
            endNodeId, dialogueEndCallback)
end

---根据配置数据重新播放一个剧情
---@param dialogueInfoId int 剧情Id
---@param replayData table 重播数据
---@param recoverUpdateCallback fun 恢复过程回调
---@param dialogueEndCallback fun 播放完成回调
---@return int|string
function DialogueController:ReplayDialogue(dialogueInfoId, replayData, recoverUpdateCallback, dialogueEndCallback)
    if self.dialogueSystemDict[dialogueInfoId] == nil then
        Debug.Log("[DialogueSystem]剧情未初始化，请先调用InitDialogue")
        return
    end
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    return dialogueSystem:ReplayDialogue(replayData, recoverUpdateCallback, dialogueEndCallback)
end

---根据配置数据恢复一个剧情并且继续播放
---@param dialogueInfoId int 剧情Id
---@param dialogueRecordList table 恢复数据
---@param recoverUpdateCallback fun 恢复过程回调
---@param dialogueEndCallback fun 播放完成回调
---@return int|string
function DialogueController:RecoverDialogue(dialogueInfoId, dialogueRecordList, recoverUpdateCallback, dialogueEndCallback)
    if self.dialogueSystemDict[dialogueInfoId] == nil then
        Debug.Log("[DialogueSystem]剧情未初始化，请先调用InitDialogue")
        return
    end
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    return dialogueSystem:RecoverDialogue(dialogueRecordList, recoverUpdateCallback, dialogueEndCallback)
end

---复写Conversation
---@param dialogueId int
---@param conversationKeys string[]
function DialogueController:OverrideConversation(dialogueId, conversationKeys)
    for _, v in pairs(conversationKeys) do
        self.overrideConversations[v] = dialogueId
    end
end

---结束剧情
---@param dialogueInfoId int
function DialogueController:EndDialogue(dialogueInfoId)
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    if dialogueSystem ~= nil then
        dialogueSystem:EndDialogue()
    end
end

---结束剧情
function DialogueController:EndDialogueAll()
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        dialogueSystem:EndDialogue()
    end
end

---退出剧情
---@param dialogueInfoId int
function DialogueController:ExitDialogue(dialogueInfoId)
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    if dialogueSystem ~= nil then
        dialogueSystem:ExitDialogue()
    end
end

---退出Dialogue
function DialogueController:ExitDialogueAll()
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        dialogueSystem:ExitDialogue()
    end
end

---Dialogue的清理
---@param dialogueInfoId int
function DialogueController:ClearDialogue(dialogueInfoId)
    local dialogueSystem = self.dialogueSystemDict[dialogueInfoId]
    if dialogueSystem ~= nil then
        dialogueSystem:ClearDialogue()
        dialogueSystem:Dispose()
        self.dialogueSystemDict[dialogueInfoId] = nil
    end
end

---Dialogue的清理
function DialogueController:ClearDialogueAll()
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        dialogueSystem:ClearDialogue()
    end
    table.clear(self.dialogueSystemDict)
    table.clear(self.variableStateDict)
    table.clear(self.pipelineDict)
    table.clear(self.pipelinePool)
end

---有DialogueSystem被清除了
function DialogueController:SystemCleared()
    local needClearVariable = true
    for _, system in pairs(self.dialogueSystemDict) do
        if system:GetDialogueId() > 0 then
            needClearVariable = false
            return
        end
    end
    if needClearVariable then
        table.clear(self.variableStateDict)
    end
end

---pipeline播放完毕
---@param pipelineKey string
function DialogueController:PipelineDialogueEnded(pipelineKey)
    local pipeline = self.pipelineDict[pipelineKey]
    self.pipelineDict[pipelineKey] = nil
    if pipeline then
        table.insert(self.pipelinePool, #self.pipelinePool + 1, pipeline)
    end
end

---返回一个Pipeline
---@return DialoguePipeline
function DialogueController:CreatePipeline()
    if #self.pipelinePool > 1 then
        return table.remove(self.pipelinePool, #self.pipelinePool)
    end
    return DialoguePipeline.new()
end

---暂停Pipeline
---@param pipelineKey string 管线Key
---@param exitKey string 退出方式Key
---@param callback fun 完成回调
function DialogueController:PausePipeline(pipelineKey, exitKey, callback)
    local pipeline = self.pipelineDict[pipelineKey]
    if pipeline then
        pipeline:PauseWithExitKey(exitKey, callback)
    else
        Debug.LogFormat("[DialogueSystem]暂停失败，没有找到对应Pipeline:%s", pipelineKey)
        if callback then
            callback()
        end
    end
end

---继续Pipeline
---@param pipelineKey string
function DialogueController:ResumePipeline(pipelineKey)
    local pipeline = self.pipelineDict[pipelineKey]
    if pipeline then
        pipeline:Resume()
    end
end

---使用PipelineKey停止剧情
---@param pipelineKey string 管线Key
---@param exitKey string 退出方式Key
---@param callback fun 完成回调
function DialogueController:StopPipeline(pipelineKey, exitKey, callback)
    local pipeline = self.pipelineDict[pipelineKey]
    if pipeline then
        pipeline:StopWithExitKey(exitKey, callback)
    else
        if callback then
            callback()
        end
    end
end

---暂停时间，会修改TimeScale，因为ParticleSystem和动效都需要停
---@param reason string 暂停Key
function DialogueController:PauseTime(reason)
    for _, system in pairs(self.dialogueSystemDict) do
        system:PauseTime(reason)
    end
end

---继续时间
---@param reason string
function DialogueController:ResumeTime(reason)
    for _, system in pairs(self.dialogueSystemDict) do
        system:ResumeTime(reason)
    end
end

---暂停剧情，不会修改TimeScale，不会修改TimeScale，会调用Wwise，Cts，X3Animator等对应方法
---@param reason string 暂停Key
function DialogueController:PauseDialogue(reason)
    for _, system in pairs(self.dialogueSystemDict) do
        system:PauseDialogue(reason)
    end
end

---继续剧情
---@param reason string 暂停Key
function DialogueController:ResumeDialogue(reason)
    for _, system in pairs(self.dialogueSystemDict) do
        system:ResumeDialogue(reason)
    end
end

---仅暂停剧情Tick
---@param reason string 暂停Key
function DialogueController:PauseUpdate(reason)
    for _, system in pairs(self.dialogueSystemDict) do
        system:PauseUpdate(reason)
    end
end

---继续剧情Tick
---@param reason string 暂停Key
function DialogueController:ResumeUpdate(reason)
    for _, system in pairs(self.dialogueSystemDict) do
        system:ResumeUpdate(reason)
    end
end

---是否有Pipeline正在播放(包括暂时停止等待玩家输入的
---@return boolean
function DialogueController:IsPlayingConversation()
    for _, system in pairs(self.dialogueSystemDict) do
        if system:IsPlayingConversation() then
            return true
        end
    end
    return false
end

---是否有激活的Pipeline
---@param pipelineKey string 管线Key
---@return boolean
function DialogueController:PipelineExisted(pipelineKey)
    return self.pipelineDict[pipelineKey] ~= nil
end

---创建默认的DialogueSystem
function DialogueController:CreateDefaultSystem()
    if self.dialogueSystemDict[-1] == nil then
        local dialogueSystem = DialogueSystem.new()
        dialogueSystem:OnInit(self)
        self.dialogueSystemDict[-1] = dialogueSystem
    end
end

---返回创建过的DialogueSystem
---@return DialogueSystem
function DialogueController:GetDefaultSystem()
    return self.dialogueSystemDict[-1]
end

---获取一条Pipeline
---@param system DialogueSystem
---@param pipelineKey string
---@return DialoguePipeline
function DialogueController:GetPipeline(system, pipelineKey)
    local uniqueId = nil
    local pipeline = nil
    if string.isnilorempty(pipelineKey) then
        pipeline = self:CreatePipeline()
        uniqueId = DialogueManager.GetPipelineUniqueId()
        pipeline:SetUniqueId(uniqueId)
        self.pipelineDict[uniqueId] = pipeline
    else
        uniqueId = pipelineKey
        if self.pipelineDict[uniqueId] then
            pipeline = self.pipelineDict[uniqueId]
        else
            pipeline = self:CreatePipeline()
            pipeline:SetUniqueId(uniqueId)
            self.pipelineDict[uniqueId] = pipeline
        end
    end
    return pipeline
end

---注入一个GameObject
---@param name string
---@param gameObject GameObject
function DialogueController:InjectGameObject(name, gameObject)
    local key = tostring(name)
    self.injectedGameObjectDict[key] = gameObject
    --CutSceneMgr.InjectAssetInsPermanently(key, gameObject)
    for _, dialogueSystem in pairs(self.dialogueSystemDict) do
        dialogueSystem:AddActor(key, gameObject)
    end
end

---获得注入过的一个GameObject
---@param name string
---@return GameObject
function DialogueController:GetInjectedGameObject(name)
    local key = tostring(name)
    return self.injectedGameObjectDict[key]
end

---取消注入一个GameObject
---@param name string
---@param gameObject GameObject
function DialogueController:RemoveGameObject(name, gameObject)
    local key = tostring(name)
    --CutSceneMgr.RemoveAssetInsPermanently(gameObject)
    self.injectedGameObjectDict[key] = nil
end

---返回
---@return table<int>
function DialogueController:GetSemanticGroupIDList()
    table.clear(self.semanticDict)
    for _,pipeline in pairs(self.pipelineDict) do
        pipeline:PackSemanticGroupIDList(self.semanticDict)
    end
    return table.clone(self.semanticDict)
end

---命中语义组
---@param id int
function DialogueController:HitSemanticGroupID(id)
    local pipelineKey = self.semanticDict[id]
    if string.isnilorempty(pipelineKey) == false then
        local pipeline = self.pipelineDict[pipelineKey]
        if pipeline then
            pipeline:HitSemanticGroupID(id)
        end
    end
end

---销毁逻辑
function DialogueController:Destroy()
    local cloneKeys = table.keys(self.injectedGameObjectDict)
    for i = 1, #cloneKeys do
        self:RemoveGameObject(cloneKeys[i], self.injectedGameObjectDict[cloneKeys[i]])
    end
    table.clear(self.injectedGameObjectDict)
    table.clear(self.overrideConversations)
    CutSceneBlackBoardMgr.Reset()
end

--region Variable
---修改变量值
---@param variableKey int
---@param variableValue int
function DialogueController:ChangeVariableState(variableKey, variableValue)
    if variableKey == 0 then
        return
    end
    self.variableStateDict[variableKey] = variableValue
    for i, handler in pairs(self.variableStateChangeListener) do
        handler(variableKey, variableValue)
    end
end

---恢复变量
---@param variableChanges table<int, int>
function DialogueController:RecoverVariableState(variableChanges)
    if not variableChanges then
        return
    end
    for k, v in pairs(variableChanges) do
        self:ChangeVariableState(k, v)
    end
end

---检查变量
---@param variableKey int
---@param variableValue int
---@return boolean
function DialogueController:CheckVariableState(variableKey, variableValue)
    if self.variableStateDict[variableKey] ~= nil then
        return variableValue == self.variableStateDict[variableKey]
    end

    return variableValue == 0
end

---获取变量值
---@param variableKey int
---@return int
function DialogueController:GetVariableState(variableKey)
    if self.variableStateDict[variableKey] ~= nil then
        return self.variableStateDict[variableKey]
    end

    return 0
end

---注册事件侦听
---@param listener fun
function DialogueController:SetVariableChangeListener(listener)
    table.insert(self.variableStateChangeListener, #self.variableStateChangeListener + 1, listener)
end

---移除事件侦听
------@param listener fun
function DialogueController:RemoveVariableChangeListener(listener)
    table.removebyvalue(self.variableStateChangeListener, listener)
end
--endregion

return DialogueController