---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- 剧情节点控制器
--- Created by 峻峻
--- Date: 2020-08-17 17:11:26

---@class NodeController
local NodeController = class("NodeController", nil, true, true)
local NodeTextController = require("Runtime.System.X3Game.Modules.Dialogue.NodeController.NodeTextController")
local DialogueTextUtil = require("Runtime.System.X3Game.Modules.Dialogue.Util.DialogueTextUtil")
local CharacterInteractionMgr = require("Runtime.System.X3Game.Modules.CharacterInteractionCtrl.CharacterInteractionMgr")

---初始化数据
function NodeController:OnInit()
    ---@type DialogueEnum.DialogueConditionType
    self.nodeControllerType = DialogueEnum.DialogueConditionType.Dialogue
    ---@type Link 用于Recover模式下指定Link
    self.settedNextLink = nil
    ---@type boolean 是否是Dialogue的开始节点，如果为True则必须把此节点发给后端校验
    self.isDialogueStartNode = false
    ---@type boolean 剧情快速播放模式
    self.quickSequenceMode = false
    ---@type boolean CTS快照模式
    self.cutSceneFastMode = false
    ---@type string 说话人名字
    self.actorName = nil
    ---@type string 当前字幕
    self.mainDialogue = nil
    ---@type float 字幕速度，字幕长度/速度为该节点字幕的时间
    self.textSpeed = tonumber(LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUETEXTSPEED))
    ---@type table 字幕控制器列表，逐个执行播放
    self.nodeTextControllerList = PoolUtil.GetTable()
    ---@type NodeTextController
    self.curNodeTextController = nil
    ---@type DialogueWwiseData 从随机组里随机出的Wwise数据
    self.randomWwiseGroup = nil

    ---@type boolean 节点是否收到了开始事件帧
    self.nodeStarted = false
    ---@type boolean 音效是已停止
    self.soundStopped = false
    ---@type boolean 是否已经播放过行为
    self.sequencePlayed = false
    ---@type boolean 是否已经播放过Wwise
    self.wwisePlayed = false
    ---@type boolean wwise正在播放
    self.wwisePlaying = false
    ---@type boolean 文本隐藏了
    self.textHided = false

    ---@type DialogueSystem
    self.system = nil
    ---@type DialoguePipeline
    self.pipeline = nil
    ---@type DialogueNodePlayer
    self.nodePlayer = nil
    ---@type int 当前播放的剧情Id
    self.dialogueId = 0
    ---@type DialogueDatabase 当前正在播放的剧情
    self.database = nil
    ---@type DialogueEntry 当前节点的配置数据
    self.dialogueEntry = nil

    ---@type float 节点运行时间，从进入节点开始
    self.nodeTime = 0
    ---@type float 节点开始时间，从nodeStarted变为true开始
    self.nodeStartedTime = 0
    ---@type float 对话已运行时长
    self.dialogueTime = 0
    ---@type float 对话结束等待时长
    self.nodeEndWaitedTime = 0
    ---@type float 语音时长
    self.voiceDuration = 0
    ---@type float 语音已运行时长
    self.voiceTime = 0
    ---@type float 语音额外时长
    self.voiceExtraTime = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUEVOICEEXTRADURATION)

    ---@type boolean 文字字幕结束
    self.dialogueEnd = false
    ---@type boolean 语音播放结束
    self.voiceEnd = false
    ---@type boolean 业务事件结束
    self.eventEnd = false
    ---@type boolean 自身行为已经结束
    self.selfActionEnd = false
    ---@type boolean 文字点击继续用的标记位
    self.selfActionExceptAfterTextEnd = false
    ---@type boolean 所有行为已经结束
    self.allActionsEnd = false
    ---@type boolean CTS事件帧结束
    self.CTSEventEnd = false
    ---@type boolean 节点等待结束
    self.nodeWaitEnd = false
    ---@type boolean 对话文本Moveout结束
    self.textMoveoutEnd = false

    ---@type table<int> 已执行过的EventIndex列表
    self.eventStartedIndex = {}
    ---@type int 已经完成的事件Index数量
    self.eventEndedCount = 0
    ---@type int
    self.endCTSEventTimeStamp = -1
    ---@type float 收到结束事件帧
    self.endDuration = 0
    ---@type float
    self.sequenceDelay = 0

    ---@type NodeWaitSetting
    self.startWaitSetting = nil
    ---@type NodeWaitSetting
    self.endWaitSetting = nil
    ---@type int 事件帧偏移，同一节点如果有消耗，需要累加
    self.ctsEventOffset = 0

    ---@type float 对话框Moveout时长，有些情况需要扣除
    self.moveoutOffset = 0
    ---@type GameObject
    self.interactionGO = nil
    ---@type int 自动化测试Timer
    self.autoTestTimer = 0
    ---@type int 记录CTS事件帧的INDEX
    self.eventIndex = 0
end

--region 节点标记位
---节点是否已完成
---@return boolean
function NodeController:IsNodeEnd()
    return self.dialogueEnd and self.eventEnd and self.CTSEventEnd
            and self.voiceEnd and self.selfActionEnd and self.allActionsEnd
            and self.nodeWaitEnd and self.textMoveoutEnd
end

---是否等待节点结束
---@return boolean
function NodeController:IsWaitForEnd()
    return self.dialogueEnd and self.eventEnd
            and self.voiceEnd and self.selfActionEnd and self.allActionsEnd
            and self.CTSEventEnd
end

---是否可以消耗事件帧
---@return boolean
function NodeController:CanCostCTSEvent()
    return self.dialogueEnd and self.voiceEnd and self.eventEnd and self.CTSEventEnd and self.nodeWaitEnd
end

---是否可以隐藏Text
---@return boolean
function NodeController:CanHideText()
    return self.dialogueEnd and self.voiceEnd and (self.CTSEventEnd or self.dialogueEntry.moveOutDontWaitCTSEvent)
            and self.eventEnd and self.selfActionEnd and self.allActionsEnd
end

---节点强制结束
function NodeController:ForceEnd()
    self:SetDialogueEnd()
    self:SetVoiceEnd()
    self:SetEventEnd()
    self:SetSelfActionEnd()
    self:SetActionExceptAfterTextEnd()
    self:SetAllActionsEnd()
    self:SetCTSEventEnd()
    self:SetNodeWaitEnd()
    self:SetTextMoveoutEnd()
end

---字幕结束
function NodeController:SetDialogueEnd()
    if self.dialogueEnd == false then
        self.pipeline:SaveNodeTextEndTime(self.dialogueEntry.uniqueID)
        self.dialogueEnd = true
        self:CheckCostCTSEvent()
        self:CheckHideText()
    end
end

---语音结束
function NodeController:SetVoiceEnd()
    if self.voiceEnd == false then
        self.voiceEnd = true
        if self.curNodeTextController then
            self.curNodeTextController:SetVoiceEnd()
        end
        self:StopSound()
        self:CheckCostCTSEvent()
        self:CheckHideText()
    end
end

---业务事件结束
function NodeController:SetEventEnd()
    if self.eventEnd == false then
        self.eventEnd = true
        self.pipeline:NeedReceiveCTSEvent(true)
        self:CheckClickToResume()
        self:CheckCostCTSEvent()
        self:CheckHideText()
    end
end

---自身Action结束
function NodeController:SetSelfActionEnd()
    if self.selfActionEnd == false then
        self.selfActionEnd = true
        self.selfActionExceptAfterTextEnd = true
        self:CheckClickToResume()
        self:CheckHideText()
    end
end

---自身Action结束
function NodeController:SetActionExceptAfterTextEnd()
    if self.selfActionExceptAfterTextEnd == false then
        self.selfActionExceptAfterTextEnd = true
        self:CheckClickToResume()
        self:CheckHideText()
    end
end

---所有Action结束
function NodeController:SetAllActionsEnd()
    if self.allActionsEnd == false then
        self.allActionsEnd = true
        self:CheckClickToResume()
        self:CheckHideText()
    end
end

---CTS事件帧结束
function NodeController:SetCTSEventEnd()
    if self.CTSEventEnd == false then
        self.CTSEventEnd = true
        self:CheckClickToResume()
        self:CheckCostCTSEvent()
        self:CheckHideText()
    end
end

---节点结束
function NodeController:SetNodeWaitEnd()
    if self.nodeWaitEnd == false then
        self.nodeWaitEnd = true
        self:CheckCostCTSEvent()
        self:CheckHideText()
    end
end

---对话文本Moveout结束
function NodeController:SetTextMoveoutEnd()
    if self.textMoveoutEnd == false then
        self.textMoveoutEnd = true
    end
end

---节点自身结束
function NodeController:CheckCostCTSEvent()
    if self:CanCostCTSEvent() then
        if self.endWaitSetting.costCTSEvent and self.eventIndex > 0 then
            self.system:ResumeCTS(self.eventIndex)
        end
    end
end

---检查隐藏Text
function NodeController:CheckHideText()
    if self:CanHideText() then
        self:HideText()
    end
end
--endregion

---设置行为的上下文
---@param system DialogueSystem
---@param pipeline DialoguePipeline
---@param nodePlayer DialogueNodePlayer
function NodeController:SetContext(system, pipeline, nodePlayer)
    self.system = system
    self.pipeline = pipeline
    self.nodePlayer = nodePlayer
    self.dialogueId = self.pipeline:GetDialogueId()
    self.database = self.pipeline:GetDatabase()
end

---节点初始化
---@param dialogueEntry DialogueEntry 单节点配置数据
function NodeController:InitFromEntry(dialogueEntry)
    self.ctsEventOffset = self.pipeline:GetCostedCTSEventCnt()
    self.dialogueEntry = dialogueEntry
    self.startWaitSetting = self.dialogueEntry.startWaitSetting
    self.endWaitSetting = self.dialogueEntry.endWaitSetting
    self:RegisterEventListener()
    if self.startWaitSetting.nodeWaitType == DialogueEnum.NodeWaitType.None then
        self:StartNode()
    elseif self.startWaitSetting.nodeWaitType == DialogueEnum.NodeWaitType.CTSEvent then
        self:RegisterCTSEvent(self.StartCTSEventCallback, self, self.startWaitSetting.waitCTSEventCnt, self.startWaitSetting.costCTSEvent)
    end
end

---注册事件
function NodeController:RegisterEventListener()
    EventMgr.AddListener("DialoguePanelClicked", self.OnDialogueClicked, self)
    EventMgr.AddListener("DialoguePanelAutoClicked", self.OnDialogueAutoClicked, self)
    EventMgr.AddListener("DialoguePanelLongPress", self.OnDialogueLongPress, self)
    EventMgr.AddListener("DialogueTextMoveoutCpl", self.OnDialogueTextMoveoutCpl, self)
    EventMgr.AddListener("DialogueActionCpl", self.OnDialogueActionEnd, self)
    EventMgr.AddListener("DialogueActionCplExceptAfterText", self.OnDialogueActionExceptAfterTextEnd, self)
    EventMgr.AddListener("DialogueBubbleTextManualScrolling", self.OnBubbleTextManualScrolling, self)
end

---取消注册事件
function NodeController:UnregisterEventListener()
    EventMgr.RemoveListenerByTarget(self)
end

--region BeforeStart
---节点开始时CutScene事件回调，如无需等待事件则直接执行回调
---@param playId int
---@param needPause boolean
function NodeController:StartCTSEventCallback(playId, eventIndex, needPause, timeStamp)
    if self.startWaitSetting.costCTSEvent then
        self.system:ResumeCTS(eventIndex)
    elseif needPause then
        self:PauseTimelineAndCTS(playId, eventIndex)
    end
    self:StartNode()
end
--endregion

--region Start && Running
---节点开始播放
function NodeController:StartNode()
    self.nodeStarted = true
    self.sequenceDelay = self.dialogueEntry.sequenceDelay and self.dialogueEntry.sequenceDelay or 0
    self.pipeline:ResetNodeTextEndTime(self.dialogueEntry.uniqueID)

    if self.dialogueEntry.dialogueActive then
        local text = DialogueTextUtil.GetDialogueText(self.system, self.dialogueId, self.dialogueEntry)
        if text ~= nil then
            self.mainDialogue = text
            self.actorName = DialogueTextUtil.GetActorName(self.dialogueId, self.dialogueEntry)
        end
        local dialogueStyleSetting = self.database:GetDialogueStyleSetting(self.dialogueEntry.dialogueTypeSetting)
        if dialogueStyleSetting.dialogueType == DialogueEnum.DialogueType.Bubble
                or dialogueStyleSetting.dialogueType == DialogueEnum.DialogueType.Avg then
            local bubblePrefabID = dialogueStyleSetting.bubblePrefabID
            local dialogueBubble = LuaCfgMgr.Get("DialogueBubble", bubblePrefabID)
            if string.isnilorempty(dialogueBubble.MoveoutKey) or string.isnilorempty(text) then
                self:SetTextMoveoutEnd()
            else
                self.moveoutOffset = self.dialogueEntry.moveOutDontWaitCTSEvent and dialogueBubble.MoveoutTime / 30 or 0
            end
        else
            self:SetTextMoveoutEnd()
        end
        self:CalculateVoiceDuration()
        --快播模式不需要气泡显示
        self:InitNodeTextController()
        if self.quickSequenceMode then
            self:SetTextMoveoutEnd()
        end
        self:AddToReviewData()
    else
        self:SetTextMoveoutEnd()
        self:SetDialogueEnd()
        self:SetVoiceEnd()
    end
    if self.dialogueEntry.eventActive == false then
        self:SetEventEnd()
    end
    if self.endWaitSetting.nodeWaitType == DialogueEnum.NodeWaitType.None then
        self:SetCTSEventEnd()
        self:SetNodeWaitEnd()
    elseif self.endWaitSetting.nodeWaitType == DialogueEnum.NodeWaitType.CTSEvent then
        self:SetNodeWaitEnd()
        self:RegisterCTSEvent(self.EndCTSEventCallback, self, self.endWaitSetting.waitCTSEventCnt, self.endWaitSetting.costCTSEvent)
    elseif self.endWaitSetting.nodeWaitType == DialogueEnum.NodeWaitType.Time then
        self:SetCTSEventEnd()
    end
end

---节点的Tick
---@param deltaTime float update函数传过来的时长
function NodeController:ProcessFrame(deltaTime)
    self.nodeTime = self.nodeTime + deltaTime
    if self.nodeStarted == false then
        if self.startWaitSetting.nodeWaitType == DialogueEnum.NodeWaitType.Time and
                self.nodeTime >= self.startWaitSetting.waitTime then
            self:StartNode()
        end
    end
    if self.nodeStarted == true then
        self.nodeStartedTime = self.nodeStartedTime + deltaTime
        self:ActionProcessFrame()
        self:TextProcessFrame(deltaTime)
        self:EventProcessFrame(deltaTime)
    end

    if self:IsWaitForEnd() and self.endWaitSetting.nodeWaitType == DialogueEnum.NodeWaitType.Time then
        self.nodeEndWaitedTime = self.nodeEndWaitedTime + deltaTime
        if self.nodeEndWaitedTime >= self.endWaitSetting.waitTime then
            self:SetNodeWaitEnd()
        end
    end

    if self:CheckExitData(DialogueEnum.ExitFinishType.Stop) then
        self:ForceEnd()
    end

    if self.pipeline:GetRecoverDialogueMode() == false then
        if self.endCTSEventTimeStamp > 0 and self.dialogueEntry.waitForAllActionsOver == false
                and self.dialogueEntry.waitForActionOver == false then
            self.endDuration = self.endDuration + deltaTime
            if self.endDuration > 1 then
                self.endDuration = 0
                Debug.LogErrorFormat("[DialogueSystem]绿色黄色事件帧已收到但节点未完成，请检查:%s", self.dialogueEntry.uniqueID)
            end
        end
    end
end

--region Text
---初始化节点文本管理器，主要控制文字的Tick逻辑
function NodeController:InitNodeTextController()
    local multiDialogueText = DialogueTextUtil.GetMultiDialogueText(self.dialogueId, self.dialogueEntry)
    local dialoguePool = {}
    local useMultiDialogueFullText = false
    local costWwiseEvent = false
    local costCTSEvent = false
    local needInheritPause = false
    if string.isnilorempty(multiDialogueText) == false then
        dialoguePool = string.split(multiDialogueText, "||")
        if #dialoguePool == 1 then
            dialoguePool = string.split(multiDialogueText, "|!|")
            if self.dialogueEntry.useMultiDialogueFullText == nil then
                useMultiDialogueFullText = true
            else
                useMultiDialogueFullText = self.dialogueEntry.useMultiDialogueFullText
            end
            if string.find(multiDialogueText, "|!|") then
                costWwiseEvent = self.voiceDuration > 0 and self.voiceEnd == false --表示有语音
                needInheritPause = true
            end
        else
            costCTSEvent = true
        end
    else
        table.insert(dialoguePool, #dialoguePool + 1, self.mainDialogue and self.mainDialogue or "")
    end
    for i = 1, #dialoguePool do
        local nodeTextController = NodeTextController.new()
        nodeTextController.quickSequenceMode = self.quickSequenceMode
        nodeTextController.cutSceneFastMode = self.cutSceneFastMode
        nodeTextController.costWwiseEvent = costWwiseEvent
        nodeTextController.costCTSEvent = costCTSEvent and i ~= #dialoguePool
        if (i == #dialoguePool and string.isnilorempty(self.mainDialogue) == false) or needInheritPause then
            nodeTextController.needPause = self.dialogueEntry.needPause
        else
            nodeTextController.needPause = false
        end
        nodeTextController.owner = self
        nodeTextController:SetContext(self.system, self.pipeline, self.nodePlayer)
        nodeTextController:InitText(self.dialogueEntry, self.moveoutOffset, dialoguePool, i, useMultiDialogueFullText)
        table.insert(self.nodeTextControllerList, #self.nodeTextControllerList + 1, nodeTextController)
    end
    self:GotoNextTextController()
end

---执行下一个字幕控制器
function NodeController:GotoNextTextController()
    if self.curNodeTextController then
        self.curNodeTextController:End()
        self.curNodeTextController = nil
    end
    if #self.nodeTextControllerList > 0 then
        self.curNodeTextController = table.remove(self.nodeTextControllerList, 1)
        self.curNodeTextController:Start(self.dialogueEntry.duration, self.dialogueTime)
    end
end

--检测是否显示点击继续
function NodeController:CheckClickToResume()
    if self.curNodeTextController then
        self.curNodeTextController:CheckClickToResume()
    end
end

--是否是否可以点击继续
---@return boolean
function NodeController:CanShowClickToResume()
    return self.CTSEventEnd == true
            and self.selfActionExceptAfterTextEnd == true
            and self.allActionsEnd == true
            and self.eventEnd == true
end

---文字ProcessFrame
---@param deltaTime float update函数传过来的时长
function NodeController:TextProcessFrame(deltaTime)
    if self.dialogueEntry.dialogueDelay == nil or (self.nodeStartedTime >= math.abs(self.dialogueEntry.dialogueDelay)) then
        self.dialogueTime = self.dialogueTime + deltaTime
        if self.wwisePlaying then
            self.voiceTime = self.voiceTime + deltaTime
        end
    end
    if self.dialogueEntry.dialogueActive then
        if self.dialogueEntry.dialogueDelay == nil or (self.nodeStartedTime >= math.abs(self.dialogueEntry.dialogueDelay)) then
            if self.wwisePlayed == false then
                self:WwiseLogic()
            end
            if self.voiceTime >= self.voiceDuration then
                self:SetVoiceEnd()
            end
            if self.curNodeTextController ~= nil then
                self.curNodeTextController:ProcessFrame(deltaTime)
                if self.curNodeTextController:IsEnd() then
                    self:GotoNextTextController()
                end
            end
            --NodeTextController已经全部播放完毕
            if self.curNodeTextController == nil then
                self:SetDialogueEnd()
            end
        end
    end
end

---剧情UI上的点击回调
function NodeController:OnDialogueClicked()
    if self.curNodeTextController then
        self.curNodeTextController:OnDialogueClicked()
    elseif self.dialogueEntry.needPause then
        self:SetVoiceEnd()
    end
end

---剧情文本框手动滚动
function NodeController:OnBubbleTextManualScrolling()
    if self.curNodeTextController then
        self.curNodeTextController:OnBubbleTextManualScrolling()
    end
end

---计算语音时长，wwise时长取最大值
function NodeController:CalculateVoiceDuration()
    if self.dialogueEntry.wwiseDatas then
        for _, wwiseData in pairs(self.dialogueEntry.wwiseDatas) do
            if wwiseData.voiceType == DialogueEnum.WwiseVoiceType.Voice then
                local wwiseDuration = DialogueUtil.GetWwiseDuration(wwiseData, self.dialogueEntry.needExtraWwiseTime, self.voiceExtraTime)
                self.voiceDuration = math.max(self.voiceDuration, wwiseDuration)
            end
        end
    end
    if self.randomWwiseGroup then
        local wwiseDuration = DialogueUtil.GetWwiseDuration(self.randomWwiseGroup, self.dialogueEntry.needExtraWwiseTime, self.voiceExtraTime)
        self.voiceDuration = math.max(self.voiceDuration, wwiseDuration)
    end
    self.voiceDuration = self.voiceDuration - self.moveoutOffset
end

---自动点击
function NodeController:OnDialogueAutoClicked()
    if self.curNodeTextController then
        self.curNodeTextController:OnDialogueAutoClicked()
    end
end

---剧情UI上的长按回调
function NodeController:OnDialogueLongPress()
    if self.curNodeTextController then
        self.curNodeTextController:OnDialogueLongPress()
    else
        self.system:StartLongPressSkipMode()
    end
end

---剧情气泡MoveOut完成
---@param dialogueTextData DialogueTextData
function NodeController:OnDialogueTextMoveoutCpl(dialogueTextData)
    if dialogueTextData.nodePlayerId == self.nodePlayer:GetPlayerId() then
        self:SetTextMoveoutEnd()
    end
end

---
---@param uniqueId int 节点唯一Id
function NodeController:OnDialogueActionEnd(uniqueId)
    if self.dialogueEntry.uniqueID == uniqueId then
        self:SetSelfActionEnd()
    end
end

---@param uniqueId int 节点唯一Id
function NodeController:OnDialogueActionExceptAfterTextEnd(uniqueId)
    if self.dialogueEntry.uniqueID == uniqueId then
        self:SetActionExceptAfterTextEnd()
    end
end

---Wwise逻辑
function NodeController:WwiseLogic()
    self.wwisePlayed = true
    self.wwisePlaying = true
    local voiceGroup = {}
    if self.dialogueEntry.wwiseDatas then
        for _, wwiseData in pairs(self.dialogueEntry.wwiseDatas) do
            if wwiseData.voiceType == DialogueEnum.WwiseVoiceType.Voice then
                self.system:PlayVoice(wwiseData)
            else
                table.insert(voiceGroup, #voiceGroup + 1, wwiseData)
            end
        end
        if #voiceGroup > 0 then
            local randomIndex = math.random(1, #voiceGroup)
            self.randomWwiseGroup = voiceGroup[randomIndex]
            self.system:PlayVoice(self.randomWwiseGroup)
        end
    end
end

---
---@param value boolean
function NodeController:SetWwisePlaying(value)
    self.wwisePlaying = value
end
--endregion

--region 业务事件
---@param deltaTime float update函数传过来的时长
function NodeController:EventProcessFrame(deltaTime)
    if self.dialogueEntry.eventActive then
        if self.dialogueEntry.eventDatas ~= nil then
            for i, v in pairs(self.dialogueEntry.eventDatas) do
                if table.indexof(self.eventStartedIndex, i) == false then
                    if self.nodeStartedTime >= v.eventDelay then
                        table.insert(self.eventStartedIndex, #self.eventStartedIndex + 1, i)
                        self:DoEvent(v)
                    end
                end
            end
        else
            self:RegisterEventListener()
            self:SetEventEnd()
        end
    end
end

---执行一个业务事件
---@param eventData EventData
function NodeController:DoEvent(eventData)
    ---@type DialogueEventData
    local arg = {}
    --希望传的是UITextID
    local nodeData = LuaCfgMgr.Get("Dialogue", self.dialogueId, self.dialogueEntry.uniqueID)
    if nodeData then
        arg.dialogueText = nodeData.DialogueText
        arg.menuText = nodeData.MenuText
    end
    local dialogueFucEvent = LuaCfgMgr.Get("DialogueFucEvent", eventData.eventId)
    if dialogueFucEvent then
        if eventData.waitForEvent then
            --业务事件暂停时，不记录Process
            self.system:SetIgnoreProcessSave(true)
            self.system:StopSkipMode()
            self:UnregisterEventListener()
            arg.handler = handler(self, self.EventCplHandle)
        else
            if dialogueFucEvent.EventName == DialogueConst.EventName.OpenUI then
                --UI开启由于会晚一帧开启，所以晚一帧结束
                self:LateEventCplHandle()
            else
                self:EventCplHandle()
            end
        end
        if eventData.hasEventTarget then
            arg.targetGameObject = self.system:GetDynamicTarget(eventData.eventTransformTarget)
            arg.offsetPosition = eventData.eventTransformOffsetPosition and eventData.eventTransformOffsetPosition or Vector3.zero
            arg.offsetEulerAngles = eventData.eventTransformOffsetEulerAngles and eventData.eventTransformOffsetEulerAngles or Vector3.zero
        end
        if dialogueFucEvent.FucType == DialogueEnum.DialogueFucType.Special then
            if dialogueFucEvent.EventName == DialogueConst.EventName.OpenUI then
                if not (eventData.waitForEvent and self.quickSequenceMode) and DialogueManager.GetAutoTestMode() == false then
                    arg.params = { dialogueFucEvent.Para0, dialogueFucEvent.Para1, dialogueFucEvent.Para2, dialogueFucEvent.Para3, dialogueFucEvent.Para4 }
                    self.pipeline:OpenWindow(dialogueFucEvent.Para0, arg)
                else
                    self:EventCplHandle()
                end
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.CloseUI then
                self.pipeline:CloseWindow(dialogueFucEvent.Para0)
                if eventData.waitForEvent then
                    self:EventCplHandle()
                end
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.OpenUIPrefab then
                if not (eventData.waitForEvent and self.quickSequenceMode) and DialogueManager.GetAutoTestMode() == false then
                    arg.params = { dialogueFucEvent.Para0, dialogueFucEvent.Para1, dialogueFucEvent.Para2, dialogueFucEvent.Para3, dialogueFucEvent.Para4 }
                    self.pipeline:OpenUIPrefab(dialogueFucEvent.Para0, arg)
                else
                    self:EventCplHandle()
                end
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.CloseUIPrefab then
                self.pipeline:CloseUIPrefab(dialogueFucEvent.Para0)
                if eventData.waitForEvent then
                    self:EventCplHandle()
                end
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.CutScene_Event then
                CutSceneMgr.SendEvent(dialogueFucEvent.Para0)
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.QuestCount then
                local counterUpdateCount = SelfProxyFactory.GetUserRecordProxy():GetUserRecordValue(
                        DataSaveRecordType.DataSaveRecordTypePlayerTagRefuseNum, tonumber(dialogueFucEvent.Para1), tonumber(dialogueFucEvent.Para0))
                if counterUpdateCount < LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUEEVENTQUESTCOUNTLIMIT) then
                    BllMgr.GetCounterBLL():SetCounterUpdateData(dialogueFucEvent.Para0, 1, { dialogueFucEvent.Para1, dialogueFucEvent.Para2, dialogueFucEvent.Para3, dialogueFucEvent.Para4 })
                end
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.CharacterInteraction then
                self.interactionGO = arg.targetGameObject
                CharacterInteractionMgr.StartInteraction(arg.targetGameObject, self.system.controller.name, self.dialogueId, handler(self, self.EventCplHandle))
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.FreeMotionStart then
                if not (eventData.waitForEvent and self.quickSequenceMode) and DialogueManager.GetAutoTestMode() == false then
                    self.pipeline:NeedReceiveCTSEvent(false)
                    self.system:FreeMotionStart(tonumber(dialogueFucEvent.Para0), handler(self, self.EventCplHandle), arg.targetGameObject, self.system.controller.name, self.dialogueId, { dialogueFucEvent.Para1, dialogueFucEvent.Para2, dialogueFucEvent.Para3, dialogueFucEvent.Para4 })
                else
                    self:EventCplHandle()
                end
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.PhysicsCloth then
                if arg.targetGameObject then
                    local ctrl = CharacterCtrlMgr.GetCtrl(arg.targetGameObject)
                    if dialogueFucEvent.Para0 == "1" then
                        ctrl:StartPhysicsClothShake(dialogueFucEvent.Para1, dialogueFucEvent.Para2, tonumber(dialogueFucEvent.Para3), tonumber(dialogueFucEvent.Para4))
                    else
                        ctrl:StopPhysicsClothShake()
                    end
                end
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.OpenUIButton then
                self.system:GetSettingData():SetShowAllBaseButton(true)
                self:EventCplHandle()
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.HideUIButton then
                self.system:GetSettingData():SetShowAllBaseButton(false)
                self:EventCplHandle()
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.DialogueBaseUI_Open then
                self.system:GetSettingData():SetShowButtonByKey(tonumber(dialogueFucEvent.Para0), true, "Event")
                self:EventCplHandle()
            elseif dialogueFucEvent.EventName == DialogueConst.EventName.DialogueBaseUI_Hide then
                self.system:GetSettingData():SetShowButtonByKey(tonumber(dialogueFucEvent.Para0), false, "Event")
                self:EventCplHandle()
            end
        elseif dialogueFucEvent.FucType == DialogueEnum.DialogueFucType.Event then
            arg.eventID = eventData.eventId
            arg.params = { dialogueFucEvent.Para0, dialogueFucEvent.Para1, dialogueFucEvent.Para2, dialogueFucEvent.Para3, dialogueFucEvent.Para4 }
            arg.exitClickHandler = self.system:GetSettingData():GetExitClickHandler()
            arg.exitHandler = self.system:GetSettingData():GetExitHandler()
            arg.exitString = self.system:GetSettingData():GetExitString()
            EventMgr.Dispatch(dialogueFucEvent.EventName, arg)
        end
    else
        self:EventCplHandle()
    end
end

---延迟业务事件回调
function NodeController:LateEventCplHandle()
    TimerMgr.AddTimer(0, self.EventCplHandle, self, 1, TimerMgr.UpdateType.FINAL_UPDATE)
end

---业务事件结束回调
function NodeController:EventCplHandle()
    if self.eventEndedCount then
        self.eventEndedCount = self.eventEndedCount + 1
        if self.eventEndedCount >= #self.dialogueEntry.eventDatas then
            --业务事件暂停时，不记录Process
            self.system:SetIgnoreProcessSave(false)
            self:RegisterEventListener()
            self:SetEventEnd()
        end
    end
end
--endregion

--region 行为
---当前时长大于行为延迟时间开始播放Timeline
function NodeController:ActionProcessFrame()
    if self.sequenceDelay <= 0 or (self.nodeStartedTime > self.sequenceDelay) then
        if self.sequencePlayed == false then
            self.sequencePlayed = true
            self:PlayAction()
        end
        if self.allActionsEnd == false then
            if self.pipeline:GetCurPlayingActionCount() <= 0 then
                self:SetAllActionsEnd()
            end
        end
    end
end

---播放节点的行为
function NodeController:PlayAction()
    if self.dialogueEntry.actions then
        if not self.dialogueEntry.waitForActionOver then
            self:SetSelfActionEnd()
        end
        self.pipeline:PlayAction(self.dialogueEntry.uniqueID, self.dialogueEntry.actions)
    else
        self:SetSelfActionEnd()
    end
    if not self.dialogueEntry.waitForAllActionsOver then
        self:SetAllActionsEnd()
    end
end
--endregion
--endregion

--region AfterRunning
---分析Link，判断节点结束后需要去哪个节点
function NodeController:AnalyzeLink()
    if self.settedNextLink == nil then
        if self.dialogueEntry.outgoingLinks then
            for _, link in pairs(self.dialogueEntry.outgoingLinks) do
                self:AddWaitNode(link)
            end
            self:ProcessSave(self.dialogueEntry.outgoingLinks[#self.dialogueEntry.outgoingLinks])
        else
            self:ProcessSave()
        end
    else
        ---QuickSequenceController也会走这里
        if DialogueUtil.IsBranchNode(self.dialogueEntry.conditionType) then
            self:AddWaitNode(self.settedNextLink)
        else
            for _, link in pairs(self.dialogueEntry.outgoingLinks) do
                self:AddWaitNode(link)
            end
        end
        self:ProcessSave(self.settedNextLink)
    end
    self:ResumeUpdate()
end

---队列中增加一个节点
---@param link Link
function NodeController:AddWaitNode(link)
    self.nodePlayer:AddWaitNode(link)
end

---队列中增加一个节点
---@param entry DialogueEntry
function NodeController:AddWaitNodeByEntry(entry)
    self.nodePlayer:AddWaitNodeByEntry(entry)
end

---链接是否有效
---@param link Link
---@param isSatisfiedCondition bool 是否满足条件
---@return bool
function NodeController:IsValidLink(link, isSatisfiedCondition)
    local conditionValid = (self.dialogueEntry.qteCount == 0 and (isSatisfiedCondition or link.conditionData.falseConditionHide == false)) or isSatisfiedCondition
    local debugMutedValid = DialogueManager.IsMutedLink(self.database.name, link) == false
    local loopSelectionValild = not self.dialogueEntry.loopSelection or self.nodePlayer:IsLinkSelected(self.dialogueEntry, link) == false
    return conditionValid and debugMutedValid and loopSelectionValild
end

---是否选完了所有的必要选项
---@return bool, Link
function NodeController:SelectedAllKeySelections()
    local selectedAll = true
    local fallbackLink = nil
    if self.dialogueEntry.outgoingLinks then
        for _, link in pairs(self.dialogueEntry.outgoingLinks) do
            local isSatisfiedCondition = ConditionCheckUtil.CheckConditionCheckData(link.conditionData.conditionCheckDatas, self.system:GetDataProvider())
            if link.conditionData.keySelection and self.nodePlayer:IsLinkSelected(self.dialogueEntry, link) == false and isSatisfiedCondition then
                selectedAll = false
            end
            if link.conditionData.isFallback then
                fallbackLink = link
            end
        end
    end
    return selectedAll, fallbackLink
end

---选项选择记录
---@param link Link
function NodeController:RecordSelection(link)
    self.nodePlayer:RecordSelection(self.dialogueEntry, link)
end

---清除选项记录
function NodeController:ClearSelectionRecord()
    self.nodePlayer:ClearSelectionRecord(self.dialogueEntry)
end
--endregion

--region End
---检查是否需要隐藏UI
function NodeController:End()
    if self.dialogueEntry.endActions then
        self.pipeline:PlayAction(self.dialogueEntry.uniqueID, self.dialogueEntry.endActions)
    end
    ---检查播放完成退出事件
    if self:CheckExitData(DialogueEnum.ExitFinishType.FinishSelf) then
        local exitData = self.pipeline:GetExitData()
        local link = self.dialogueEntry.exitLinks[exitData.exitKey]
        ---播完本节点立刻退出：收到退出消息后播完本节点并立刻结束Dialogue（已判定完下一个节点但未执行），
        ---如为暂停，则恢复时以下一个节点继续恢复运行
        if link.exitLinkType == DialogueEnum.ExitLinkType.Exit then
            self:AnalyzeLink()
            self.pipeline:ExitCpl()
        else
            ---播完本节点并连接至另一节点：收到退出消息后播完本节点并走另一个分支至下一个节点，
            ---下一个节点依旧按照自身退出方式同样逻辑再次判定处理
            self:AddWaitNode(link)
            self:ProcessSave(link)
        end
    elseif self:CheckExitData(DialogueEnum.ExitFinishType.Stop) then
        local exitData = self.pipeline:GetExitData()
        local link = self.dialogueEntry.exitLinks[exitData.exitKey]
        ---不播完本节点立刻退出：在当前节点立刻结束Dialogue（需要该节点执行至少1帧，不执行Linkto），
        ---如为暂停，则恢复时以当前节点继续恢复运行（该节点再重播一次）
        if link.exitLinkType == DialogueEnum.ExitLinkType.Exit then
            self:AddWaitNodeByEntry(self.dialogueEntry)
            self.pipeline:ExitCpl()
        else
            ---不播完本节点并连接至另一节点：收到退出消息后立刻结束本节点并走另一个分支至下一个节点，
            ---下一个节点依旧按照自身退出方式同样逻辑再次判定处理
            self:AddWaitNode(link)
        end
    else
        self:AnalyzeLink()
    end
end

---隐藏文本
function NodeController:HideText()
    if self.textHided == false then
        self.textHided = true
        if self.dialogueEntry.dialogueActive and
                string.isnilorempty(self.mainDialogue) == false then
            local tempTable = PoolUtil.GetTable()
            local actor = self.database:GetActor(self.dialogueEntry.actorID)
            tempTable.isPlayer = actor ~= nil and actor.isPlayer or false
            tempTable.manType = actor ~= nil and actor.manType or 0
            tempTable.actorId = self.dialogueEntry.actorID
            tempTable.pipelineKey = self.pipeline:GetUniqueId()
            tempTable.nodePlayerId = self.nodePlayer:GetPlayerId()
            tempTable.dialogueStyleSetting = self.database:GetDialogueStyleSetting(self.dialogueEntry.dialogueTypeSetting)
            EventMgr.Dispatch("DialoguePanelTextHide", tempTable)
            PoolUtil.ReleaseTable(tempTable)
        end
    end
end

---停止该节点播放过的Wwise
function NodeController:StopSound()
    if self.soundStopped == false then
        self.soundStopped = true
        if self.dialogueEntry.wwiseDatas then
            for _, wwiseData in pairs(self.dialogueEntry.wwiseDatas) do
                if wwiseData.voiceType == DialogueEnum.WwiseVoiceType.Voice and not wwiseData.autoStopWhenNodeEnd then
                    self.system:StopWwise(wwiseData)
                end
            end
        end
        if self.randomWwiseGroup and not self.randomWwiseGroup.autoStopWhenNodeEnd then
            self.system:StopWwise(self.randomWwiseGroup)
            self.randomWwiseGroup = nil
        end
    end
end
--endregion

---CTS事件帧回调
---@param playId int CTS播放id
---@param needPause boolean CTS需不需要idle
---@param timeStamp int 收到事件帧的时间戳
function NodeController:EndCTSEventCallback(playId, eventIndex, needPause, timeStamp)
    self.eventIndex = needPause and eventIndex or 0
    self:SetCTSEventEnd()
    if needPause then
        if self:CanCostCTSEvent() == false or self.endWaitSetting.costCTSEvent == false then
            self:PauseTimelineAndCTS(playId, eventIndex)
        end
    else
        --记录下收到事件帧的时间，如果超过1秒节点还没结束就给个Error
        self.endCTSEventTimeStamp = timeStamp
    end
end

---暂停Dialogue
---@param reason string
function NodeController:PauseUpdate(reason)
    reason = (reason ~= nil) and reason or "NodeController"
    self.pipeline:PauseUpdate(reason)
end

---继续Dialogue
function NodeController:ResumeUpdate(reason)
    reason = (reason ~= nil) and reason or "NodeController"
    self.pipeline:ResumeUpdate(reason)
end

---暂停Timeline并且执行CTS的Loop
---@param playId int
---@param needPause boolean
function NodeController:PauseTimelineAndCTS(playId, eventIndex)
    self.system:PauseCTS(playId, eventIndex)
end

---随机函数
---@param min number 最小值
---@param max number 最大值
---@return number
function NodeController:GetRandom(min, max)
    local random = self.system:GetRandom(min, max)
    --table.insert(self.randomUsedList, #self.randomUsedList + 1, random)
    return random
end

---添加一条回顾数据
function NodeController:AddToReviewData()
    local actor = self.database:GetActor(self.dialogueEntry.actorID)
    if string.isnilorempty(self.mainDialogue) == false then
        ---@type DialogueReviewData
        local reviewData = {}
        reviewData.actorName = self.actorName
        reviewData.text = self.mainDialogue
        reviewData.canFavorite = self.system:GetSettingData():GetCanFavorite()
        reviewData.roleId = actor ~= nil and actor.manType or 0
        reviewData.dialogueId = self.dialogueId
        reviewData.nodeId = self.dialogueEntry.uniqueID
        reviewData.isPlayer = actor ~= nil and actor.isPlayer or false
        if string.isnilorempty(self.dialogueEntry.voiceName) == false then
            reviewData.voiceName = self.dialogueEntry.voiceName
        else
            if self.dialogueEntry.wwiseDatas then
                for _, wwiseData in pairs(self.dialogueEntry.wwiseDatas) do
                    if wwiseData.voiceType == DialogueEnum.WwiseVoiceType.Voice then
                        reviewData.voiceName = wwiseData.eventName
                    end
                end
            end
        end
        self.pipeline:AddReviewList(reviewData)
    end
end

--region ProcessSave
---节点流程记录
---@param nextLink Link 该节点的下一个
function NodeController:ProcessSave(nextLink)
    local node = {}
    node.Id = self.dialogueEntry.uniqueID
    local nextDialogueEntry = self.database:GetDialogueEntryByLink(nextLink)
    node.NextId = nextDialogueEntry ~= nil and nextDialogueEntry.uniqueID or 0
    node.VariableMap = self:ProcessNodeVariableChange()
    if self.isDialogueStartNode then
        self.nodePlayer:AddProcessNode(node)
        self.isDialogueStartNode = false
    else
        if self.dialogueEntry.variableChanges then
            self.nodePlayer:AddProcessNode(node)
        else
            self.nodePlayer:SetLastProcessNode(node)
        end
    end
end

---节点Variable变化记录
---@return table<int, int>
function NodeController:ProcessNodeVariableChange()
    local protoChange = {}
    if self.dialogueEntry.variableChanges then
        for _, variableChange in pairs(self.dialogueEntry.variableChanges) do
            protoChange[variableChange.variableID] = variableChange.variableValue
        end
    end
    return protoChange
end
--endregion

---检查这个节点是否需要处理退出事件
---@param exitFinishType DialogueEnum.ExitFinishType
---@return boolean
function NodeController:CheckExitData(exitFinishType)
    local exitData = self.pipeline:GetExitData()
    if exitData and self.dialogueEntry.exitLinks and self.dialogueEntry.exitLinks[exitData.exitKey] ~= nil
            and self.dialogueEntry.exitLinks[exitData.exitKey].exitFinishType == exitFinishType then
        return true
    else
        return false
    end
end

---帮玩家执行点击
function NodeController:CheckPlayerOperation()
    --Virtual函数，子类复写
end

---语音识别相关
function NodeController:PackSemanticGroupIDList(semanticDict)
    --需要的逻辑自己复写
end

---语音识别相关
---@param id int 命中的语义组Id
function NodeController:HitSemanticGroupID(id)
    --需要的逻辑自己复写
end

---自动测试的选择功能
function NodeController:AutoTestSelect()

end

---侦听CTS事件帧
---@param callback fun
---@param target table
---@param waitCnt int
---@param isCostEvent boolean 是否消耗事件帧
function NodeController:RegisterCTSEvent(callback, target, waitCnt, isCostEvent)
    local waitEventOffset = self.ctsEventOffset + waitCnt
    if isCostEvent then
        self.ctsEventOffset = self.ctsEventOffset + waitCnt
    end
    self.pipeline:RegisterCTSEvent(callback, target, waitEventOffset, isCostEvent)
end

---销毁
function NodeController:Dispose()
    self:HideText()
    self:StopSound()
    self.pipeline:UnregisterCTSEvent(self.StartCTSEventCallback, self)
    self.pipeline:UnregisterCTSEvent(self.EndCTSEventCallback, self)
    for _, textController in pairs(self.nodeTextControllerList) do
        textController:Dispose()
    end
    PoolUtil.ReleaseTable(self.nodeTextControllerList)
    self.nodeTextControllerList = nil
    self.startWaitSetting = nil
    self.endWaitSetting = nil

    if self.interactionGO then
        CharacterInteractionMgr.Remove(self.interactionGO)
        self.interactionGO = nil
    end
    EventMgr.RemoveListenerByTarget(self)
    DialogueManager.ReleaseNodeController(self)
end

return NodeController