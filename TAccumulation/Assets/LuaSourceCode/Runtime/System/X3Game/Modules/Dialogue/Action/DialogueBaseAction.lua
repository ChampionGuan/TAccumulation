---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2021/12/2 17:21
---

---Dialogue基础行为
---@class DialogueBaseAction
local DialogueBaseAction = class("DialogueBaseAction", nil, nil, true)

---设置行为的上下文
---@param system DialogueSystem
---@param pipeline DialoguePipeline
---@param nodeUniqueId int
function DialogueBaseAction:SetContext(system, pipeline, nodeUniqueId, ownerGroup)
    ---@type DialogueSystem
    self.system = system
    ---@type DialoguePipeline
    self.pipeline = pipeline
    ---@type int action所属的节点唯一Id
    self.nodeUniqueId = nodeUniqueId
    ---@type int 当前播放的剧情Id
    self.dialogueId = self.pipeline:GetDialogueId()
    ---@type DialogueDatabase 当前正在播放的剧情
    self.database = self.pipeline:GetDatabase()
    ---@type DialogueActionGroup 所属行为组(用来做行为的相对延迟用)
    self.ownerGroup = ownerGroup
    ---@type DialogueActionHelper
    self.actionHelper = self.system:GetActionHelper()
end

---行为的基础属性，不跟随使用的模板行为变化
---@param baseCfg DialogueActionCfg
function DialogueBaseAction:OnInitBaseProperty(baseCfg)
    ---@type int 行为Id
    self.id = baseCfg.id
    ---@type float 行为延迟
    self.delay = baseCfg.delay
    ---@type int 相对的行为Id
    self.relativeActionId = baseCfg.relativeActionId
    ---@type DialogueEnum.DelayType
    self.delayType = baseCfg.delayType and baseCfg.delayType or DialogueEnum.DelayType.Absolute
end

---行为的其他属性，会被模板行为属性覆盖
---@param cfg DialogueActionCfg
function DialogueBaseAction:OnInit(cfg)
    ---@type float 当前时长(从Enter开始计算)
    self.curTime = 0
    ---@type float 节点已经Update的时长，包括Delay的时间
    self.startedTime = 0
    ---@type DialogueEnum.DialogueActionState
    self.state = DialogueEnum.DialogueActionState.None
    if cfg then
        ---@type float 行为持续时长
        self.duration = cfg.duration
        ---@type DialogueEnum.DialogueActionType
        self.actionType = cfg.type
    end
end

---ActionPreload
function DialogueBaseAction:OnPreload()

end

---ActionUpdate
---@param deltaTime float
function DialogueBaseAction:Update(deltaTime)
    if self.state ~= DialogueEnum.DialogueActionState.Complete then
        self:UpdateDuration(deltaTime)
    end
    if self.state == DialogueEnum.DialogueActionState.None then
        self:CheckEnter()
    end

    if self.state == DialogueEnum.DialogueActionState.Update then
        local progress = 0
        if self.duration == 0 then
            progress = 1
        else
            progress = self.curTime / self.duration
        end
        local updateProgress = math.min(progress, 1)
        updateProgress = math.max(updateProgress, 0)
        local result = self:OnProcess(updateProgress)
        if result == DialogueEnum.UpdateActionState.Complete then
            self:Exit()
        end
    end
end

---检查是否需要开始行为
function DialogueBaseAction:CheckEnter()
    if self.delayType == DialogueEnum.DelayType.Absolute then
        if self.startedTime >= self.delay then
            self:Enter()
        end
    elseif self.delayType == DialogueEnum.DelayType.Relative then
        if self.id == self.relativeActionId or self.ownerGroup:CheckCanStart(self.relativeActionId, self.delay) then
            self:Enter()
        end
    elseif self.delayType == DialogueEnum.DelayType.AfterText then
        if self.delay >= 0 then
            local nodeTextEndTime = self.pipeline:GetNodeTextEndTime(self.nodeUniqueId)
            if nodeTextEndTime ~= 0 and self.pipeline:GetPipelineRunningTime() - nodeTextEndTime >= self.delay then
                self:Enter()
            end
        else
            ---暂时不支持负延迟
            self:Enter()
        end
    else
        self:Enter()
    end
end

---
---@return float 返回行为预计剩余时间
function DialogueBaseAction:GetLeftTime()
    return self.duration - self.curTime
end

---Action进入会在行为正式开始Update前进入一次
function DialogueBaseAction:Enter()
    if self.ownerGroup and self.ownerGroup.id then
        Debug.LogFormat("[DialogueSystem]行为开始-%s-%s-%s", self.nodeUniqueId, self.ownerGroup.id, self.id)
    elseif self.id then
        Debug.LogFormat("[DialogueSystem]行为开始-%s-%s", self.nodeUniqueId, self.id)
    end
    if self.state == DialogueEnum.DialogueActionState.None then
        self.state = DialogueEnum.DialogueActionState.Update
        self:OnEnter()
    end
end

---Action进入会在行为正式开始Update前进入一次
function DialogueBaseAction:OnEnter()

end

---更新Duration
---@param deltaTime
function DialogueBaseAction:UpdateDuration(deltaTime)
    if self.state == DialogueEnum.DialogueActionState.Update then
        self.curTime = deltaTime + self.curTime
    end
    self.startedTime = deltaTime + self.startedTime
end

---Process函数
---@param progress float
---@return DialogueEnum.UpdateActionState
function DialogueBaseAction:OnProcess(progress)
    if self.curTime >= self.duration then
        return DialogueEnum.UpdateActionState.Complete
    else
        return DialogueEnum.UpdateActionState.Running
    end
end

---Action退出，会在退出时执行一次
function DialogueBaseAction:Exit()
    if self.ownerGroup and self.ownerGroup.id then
        Debug.LogFormat("[DialogueSystem]行为结束-%s-%s-%s", self.nodeUniqueId, self.ownerGroup.id, self.id)
    elseif self.id then
        Debug.LogFormat("[DialogueSystem]行为结束-%s-%s", self.nodeUniqueId, self.id)
    end
    if self.state == DialogueEnum.DialogueActionState.Update then
        self.state = DialogueEnum.DialogueActionState.Complete
        self:OnExit()
    end
end

---Action退出，会在退出时执行一次
function DialogueBaseAction:OnExit()

end

---获取当前状态
function DialogueBaseAction:GetState()
    return self.state
end

---延迟类型是否是字幕结束后
---@return boolean
function DialogueBaseAction:IsAfterText()
    return self.delayType == DialogueEnum.DelayType.AfterText
end

---
function DialogueBaseAction:OnDestroy()
    DialogueManager.ReleaseAction(self)
end

return DialogueBaseAction