---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2021/12/2 12:03
---

---独立的剧情系统，可以起多个DialoguePipeline播放
---@class DialogueSystem
local DialogueSystem = class("DialogueSystem")

local DialogueSettingData = require("Runtime.System.X3Game.Modules.Dialogue.Controller.DialogueSettingData")
local DialogueActorData = require("Runtime.System.X3Game.Modules.Dialogue.Data.DialogueActorData")
local AnimCacheData = require("Runtime.System.X3Game.Modules.Dialogue.Data.AnimCacheData")

---@type CS.PapeGames.CutScene.CutSceneManager
local CTS = CS.PapeGames.CutScene.X3CutSceneManager
---@type CS.X3Game.X3Animator
local X3Animator = CS.X3Game.X3Animator
---@type CS.PapeGames.X3.LipSyncWwiseUtility
local CS_LipSyncWwiseUtil = CS.PapeGames.X3.LipSyncWwiseUtility

local FaceEditConst = require("Runtime.System.X3Game.GameConst.FaceEditConst")
local FaceFilter = nil --2023/6/26修改 捏脸需要用玩家数据

local DialogueActionHelper = require("Runtime.System.X3Game.Modules.Dialogue.Action.DialogueActionHelper")

---@class DialogueReviewData
---@field actorName string 说话人名字
---@field text string 对话文本
---@field canFavorite bool 可否收藏
---@field roleId int 男主Id
---@field dialogueId int 剧情Id
---@field nodeId int 节点Id
---@field isPlayer boolean 是否是玩家
---@field voiceName string 语音Event

---@class TempGameObjectData
---@field gameObject GameObject 临时对象的GameObject实例
---@field isInUI boolean 是否创建在了UI里

---构造函数
function DialogueSystem:ctor()
    ---@type DialogueController
    self.controller = nil
    ---@type boolean 区别于isActive状态
    self.isUpdating = true
    ---@type int 剧情Id
    self.dialogueInfoId = 0
    ---@type DialogueDatabase
    self.database = nil
    ---@type cfg.DialogueInfo 剧情静态配置表，对应DialogueInfo
    self.dialogueInfo = nil
    ---@type table<int|string, DialoguePipeline>
    self.usingPipelineDict = {}
    ---@type table<string>
    self.usingPipelineKeys = {}
    ---@type fun 加载回调
    self.preloadCallback = nil
    ---@type int 剧情BatchId
    self.dialogueBatchId = 0
    ---@type int 需要加载的资源数量
    self.needPreloadCount = 0
    ---@type int 已加载的资源数量
    self.loadedCount = 0
    ---@type boolean 是否需要根据配置创建角色实例
    self.needCreateActors = true
    ---@type table<string, GameObject> 预加载完毕的角色池，结束后做释放
    self.charactorPool = {}
    ---@type table<string, GameObject> 预加载完毕的物件池，结束后做释放
    self.gameObjectPool = {}
    ---@type table<string, DialogueActorData> 保存一个引用关系，包括外部注入的GameObject，不实例化也不销毁
    self.actorGameObjectDict = {}
    ---@type table<int, table<TempGameObjectData>> 临时Actor字典
    self.tempGameObjectDict = {}
    ---@type DialogueSettingData 剧情系统设置数据
    self.settingData = DialogueSettingData.new()
    ---@type table<string, boolean> 暂停TimeReason，当为空时才能继续
    self.pausingTimeReason = {}
    ---@type table<string, boolean> 暂停DialogueReason，当为空时才能继续
    self.pausingDialogueReason = {}
    ---@type table<string, boolean> 暂停DialogueReason，当为空时才能继续
    self.pausingUpdateReason = {}
    ---@type boolean 是否在跳过模式中
    self.isInSkipMode = false
    ---@type boolean 是否是长按跳过
    self.isInLongPressSkip = false
    ---@type PlayedWwiseData[]
    self.playedWwiseDataList = {}
    ---@type pbcmessage.DialogueProcessNode[]
    self.processNodeList = {}
    ---@type DialogueEntry
    self.lastProcessNode = nil
    ---@type boolean
    self.ignoreProcessSave = false
    ---@type table<int, int> 随机次数记录
    self.randomTimesCache = {}
    ---@type DialogueConditionDataProvider
    self.dataProvider = require("Runtime.System.X3Game.Modules.Dialogue.DialogueConditionDataProvider").new(self)
    ---@type int 剧情播放速度设置
    self.dialoguePlaySpeedIndex = 0
    ---@type float 剧情播放速度
    self.dialogueSpeed = 1
    ---@type boolean 结束剧情时是否关闭UI,主线要用,给个标记位
    self.closeUIWhenEndDialogue = true
    ---@type int 暂停LoopDialogue时的PlayId
    self.pausingPlayId = 0
    ---@type MultiConditionCtrl
    self.pausingIndexCtrl = require("Runtime.System.X3Game.Modules.Common.MultiConditionCtrl").new()
    ---@type boolean
    self.autoClickToResume = false
    ---@type int
    self.autoId = 0
    ---@type int[]
    self.ctsPlayingIdList = {}
    ---@type int[]
    self.ctsPlayedIdList = {}
    ---@type boolean
    self.autoReleaseMode = true
    ---@type boolean 初始化完成
    self.initCpl = false
    ---@type VirtualCameraBase
    self.virtualCamera = nil
    ---@type fun 场景切换回调
    self.changeSceneCallback = nil
    ---@type table<int, Vector3> 角色显隐使用设置位置替代SetActive
    self.actorPosDict = {}
    ---@type DialogueActionHelper
    self.actionHelper = DialogueActionHelper.new()
    ---@type GameObject 需要挂在DialogUI界面的外部UI结点
    self.outerUIObject = nil
    ---@type function DialogUI处理外部UI结点的回调
    self.outerCallBack = nil
    ---@type int RelativeRestCtrl的Id
    self.mainUIRelativeRestCtrlId = 0
    ---@type table<int, fun>
    self.playedFreeMotionIdList = {}
    --region Recover用
    self.recoverDialogueMode = false
    --endregion
    --region QuickSequence
    ---@type int
    self.voiceVolume = 0
    ---@type int
    self.soundVolume = 0
    ---@type string
    self.quickSequenceBGMCache = nil
    ---@type string
    self.quickSequenceAmbientCache = nil
    ---@type table<GameObject, AnimCacheData>
    self.quickSequenceAnimCache = {}
    --endregion
    --region FaceHair
    ---@type Define.FaceChangeType
    self.playerFaceHairType = nil
    ---@type int
    self.playerFaceHairId = nil
    --endregion
end

---DialogueSystem初始化
---@param controller DialogueController
function DialogueSystem:OnInit(controller)
    self.controller = controller
end

---@return bool
function DialogueSystem:IsPlayingConversation()
    for _, _ in pairs(self.usingPipelineDict) do
        return true
    end
    return false
end

---是否在Tick状态
---@return boolean
function DialogueSystem:IsUpdating()
    return self.isUpdating
end

---返回当前剧情Id
---@return int
function DialogueSystem:GetDialogueId()
    return self.dialogueInfoId
end

---返回当前剧情配置
---@return DialogueDatabase
function DialogueSystem:GetDatabase()
    return self.database
end

---设置资源卸载模式
---@param value boolean
function DialogueSystem:SetAutoReleaseMode(value)
    self.autoReleaseMode = value
end

---获取资源卸载模式
---@return boolean
function DialogueSystem:GetAutoReleaseMode()
    return self.autoReleaseMode
end

---ConditionCheck的数据提供
---@return DialogueConditionDataProvider
function DialogueSystem:GetDataProvider()
    return self.dataProvider
end

---获取剧情变速Index
---@return int
function DialogueSystem:GetDialogueSpeedIndex()
    return self.dialoguePlaySpeedIndex
end

---获得剧情播放速度
---@return float
function DialogueSystem:GetDialoguePlaySpeed()
    local gears = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUEPLAYBUTTONSPEED)
    return gears[self.dialoguePlaySpeedIndex + 1]
end

---切换下一档剧情播放速度
function DialogueSystem:ChangeNextDialoguePlaySpeed()
    local gears = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUEPLAYBUTTONSPEED)
    self.dialoguePlaySpeedIndex = (self.dialoguePlaySpeedIndex + 1) % #gears
    self:ChangeDialogueSpeed(self:GetDialoguePlaySpeed())
    EventMgr.Dispatch("DialoguePlaySpeedChanged")
end

---换随机种子
---@param randomSeed int
function DialogueSystem:ChangeRandomSeed(randomSeed)
    if randomSeed == nil then
        randomSeed = self.controller:GetRandomSeed(self.dialogueInfoId)
    end
end

---DialogueManager自动播放接口，传入DialogueInfo表Id
---@param dialogueInfoId int 剧情Id 对应DialogueInfoId
---@param dialogueEndCallback fun 播放完成回调
---@param uiProgressWeight float 进度权重 0~1
---@param uiInitProgress float 进度初始权重0~1
function DialogueSystem:InitAndAutoPlay(dialogueInfoId, dialogueEndCallback, uiProgressWeight, uiInitProgress)
    self:InitDialogue(dialogueInfoId, math.random(0, 10000), true,
            function()
                self:AutoPlay(dialogueEndCallback)
            end, uiProgressWeight, uiInitProgress)
end

---@private
---加载完自动播放接口
---@param dialogueInfoId int 剧情Id
---@param dialogueEndCallback fun 播放完成回调
function DialogueSystem:AutoPlay(dialogueEndCallback)
    self:StartDialogueById(self.dialogueInfo.StartConversation, nil, nil, dialogueEndCallback)
end

---初始化剧情的接口，加载DialogueDatabase，预加载资源
---@param dialogueInfoId int 剧情ID 对应DialogueInfoID
---@param randomSeed int 剧情里使用的随机种子
---@param needCreateActors boolean 是否需要初始化角色
---@param onInitComplete fun 初始化完成回调
---@param uiProgressWeight float 进度权重 0~1
---@param uiInitProgress float 进度初始权重0~1
function DialogueSystem:InitDialogue(dialogueInfoId, randomSeed, needCreateActors, onInitComplete, uiProgressWeight, uiInitProgress)
    if self.database then
        self:ClearDialogue()
    end
    Debug.LogFormat("[DialogueSystem]InitDialogue:%s-%s", dialogueInfoId, TimerMgr.RealtimeSinceStartup())
    local dialogueInfo = LuaCfgMgr.Get('DialogueInfo', dialogueInfoId)
    if nil == dialogueInfo then
        Debug.LogErrorFormat("[DialogueSystem]剧情Id不存在:%s", dialogueInfoId)
        if onInitComplete ~= nil then
            onInitComplete(self)
        end
        return
    end
    self:SyncSettingFromController()
    self.dialogueInfoId = dialogueInfoId
    self.database = DialogueManager.LoadDatabase(dialogueInfo.Name)
    DialogueManager.RegisterDialogueUsing(dialogueInfo.Name, self)
    self.database:AppendBatchLink()
    self.dialogueInfo = LuaCfgMgr.Get("DialogueInfo", dialogueInfoId)
    if self.dialogueInfo.HideSpeed then
        self.settingData:SetShowPlaySpeedButton(self.dialogueInfo.HideSpeed == 1, "Event")
    end
    if self.dialogueInfo.NoVoiceCollection and self.dialogueInfo.NoVoiceCollection == 1 then
        self.settingData:SetCanFavorite(false)
    end
    self.needCreateActors = needCreateActors
    self:ChangeRandomSeed(randomSeed)
    self.controller:CheckLoad(self.dialogueInfoId)
    self:PreloadActorAndTempObject(onInitComplete, uiProgressWeight, uiInitProgress)
end

---使用ConversationId启动剧情
---@param conversationId int 剧情Id
---@param nodeId int 节点Id
---@param pipelineKey string Pipeline指定Key
---@param dialogueEndCallback fun 播放完成回调
---@return int
function DialogueSystem:StartDialogueById(conversationId, nodeId, pipelineKey, dialogueEndCallback)
    local conversation = self.database:GetConversation(conversationId)
    if conversation == nil then
        Debug.LogFormat("[DialogueSystem]没有找到对应剧情:%s", conversationId)
        if dialogueEndCallback then
            dialogueEndCallback()
        end
        return 0
    end
    return self:StartDialogue(conversation, nodeId, pipelineKey, dialogueEndCallback)
end

---使用ConversationName启动剧情
---@param conversationName string 剧情Name
---@param nodeId int 节点Id
---@param pipelineKey string Pipeline指定Key
---@param dialogueEndCallback fun 播放完成回调
---@return int
function DialogueSystem:StartDialogueByName(conversationName, nodeId, pipelineKey, dialogueEndCallback)
    local conversation = self.database:GetConversationByDescription(conversationName)
    if conversation == nil then
        Debug.LogFormat("[DialogueSystem]没有找到对应剧情:%s", conversationName)
        if dialogueEndCallback then
            dialogueEndCallback()
        end
        return 0
    end
    return self:StartDialogue(conversation, nodeId, pipelineKey, dialogueEndCallback)
end

---开始播放一个Conversation
---@private
---@param startConversation Conversation 开始Conversation
---@param nodeId int 节点Id
---@param pipelineKey string Pipeline指定Key,可以为空
---@param dialogueEndCallback fun 剧情结束回调
---@return int|string
function DialogueSystem:StartDialogue(startConversation, nodeId, pipelineKey, dialogueEndCallback)
    self:SyncSettingFromController()
    local pipeline = self:GetPipeline(pipelineKey)
    pipeline:StartDialogue(startConversation, nodeId, dialogueEndCallback)
    return pipeline:GetPlayId()
end

---播放某一段Conversation
---@param startConversationId int 起始ConversationID
---@param startNodeId int 起始节点ID
---@param endConversationId int 结束ConversationID
---@param endNodeId int 结束节点ID
---@param dialogueEndCallback fun 播放完成回调
---@return int|string
function DialogueSystem:StartDialogueRange(startConversationId, startNodeId,
                                           endConversationId, endNodeId, dialogueEndCallback)
    self:SyncSettingFromController()
    local pipeline = self:GetPipeline()
    pipeline:StartDialogueRange(startConversationId, startNodeId, endConversationId,
            endNodeId, dialogueEndCallback)
    return pipeline:GetPlayId()
end

---根据配置数据重新播放一个剧情
---@param replayData pbcmessage.DialogueRecord[]
---@param recoverUpdateCallback fun 恢复过程回调
---@param dialogueEndCallback fun 播放完成回调
---@return int|string
function DialogueSystem:ReplayDialogue(replayData, recoverUpdateCallback, dialogueEndCallback)
    self:SyncSettingFromController()
    local pipeline = self:GetPipeline()
    pipeline:ReplayDialogue(replayData, recoverUpdateCallback, dialogueEndCallback)
    return pipeline:GetPlayId()
end

---根据配置数据恢复一个剧情并且继续播放
---@param dialogueRecordList pbcmessage.DialogueRecord[]
---@param recoverUpdateCallback fun 恢复过程回调
---@param endCallback fun 播放完成回调
---@return int|string
function DialogueSystem:RecoverDialogue(dialogueRecordList, recoverUpdateCallback, endCallback)
    self.recoverDialogueMode = true
    self:SyncSettingFromController()
    self:SaveVolume()
    local pipeline = self:GetPipeline()
    pipeline:RecoverDialogue(dialogueRecordList, recoverUpdateCallback, endCallback)
    return pipeline:GetPlayId()
end

---剧情恢复结束
function DialogueSystem:RecoverDialogueComplete()
    self.recoverDialogueMode = false
    self:ChangeDialogueSpeed(self:GetDialoguePlaySpeed())
    self:LoadVolume()
    self:PlayCachedWwise()
    self:PlayCachedAnim()
end

---退出剧情
function DialogueSystem:ExitDialogue()
    self:EndDialogue(true)
    if self.settingData.exitHandler ~= nil then
        self.settingData.exitHandler()
        self.settingData.exitHandler = nil
    end
end

---结束Dialogue
---@param isExit boolean
function DialogueSystem:EndDialogue(isExit)
    if table.nums(self.usingPipelineDict) > 0 then
        local cloneKeys = table.keys(self.usingPipelineDict)
        for i = 1, #cloneKeys do
            local pipeline = self.usingPipelineDict[cloneKeys[i]]
            self.usingPipelineDict[cloneKeys[i]] = nil
            pipeline:EndDialogue(isExit)
        end
        self:CheckAllPipelineEnded()
    end
end

---停止某一条固定的Pipeline
function DialogueSystem:EndDialogueByPipelineKey(pipelineKey)
    local pipeline = self.usingPipelineDict[pipelineKey]
    if pipeline then
        pipeline:EndDialogue()
    end
end

---pipeline播放完毕
---@param pipelineKey string
---@param forceEnd boolean
function DialogueSystem:PipelineDialogueEnded(pipelineKey, forceEnd)
    self.usingPipelineDict[pipelineKey] = nil
    if not forceEnd then
        self.controller:PipelineDialogueEnded(pipelineKey)
    end
end

---检查是不是所有Pipeline都结束了
function DialogueSystem:CheckAllPipelineEnded()
    if table.nums(self.usingPipelineDict) == 0 then
        self.pausingPlayId = 0
        self:ResetDialogueSpeed()
        self:LoadVolume()
        self:EndAutoTimer()
        self:ResetTimescale()
        self:ResumeWwise()
        if self.closeUIWhenEndDialogue then
            self:CloseUI()
        end
    end
end

---
function DialogueSystem:ResetTimescale()
    table.clear(self.pausingTimeReason)
    table.clear(self.pausingDialogueReason)
    table.clear(self.pausingUpdateReason)
    self.isUpdating = true
    self:SetTimescale(TimescaleMgr.TimescaleLayer.DialoguePause, "Dialogue", 1)
end

---Dialogue的清理
function DialogueSystem:ClearDialogue()
    self:EndDialogue(true)
    for _, v in pairs(self.ctsPlayedIdList) do
        CutSceneMgr.Stop(v)
    end
    self.autoClickToResume = false
    self.pausingIndexCtrl:Clear()
    self.actionHelper:DestroyAll()
    table.clear(self.ctsPlayedIdList)
    table.clear(self.ctsPlayingIdList)
    table.clear(self.usingPipelineDict)
    table.clear(self.randomTimesCache)
    table.clear(self.actorPosDict)
    if self.settingData:GetUseNodeGraph() then
        DialogueManager.ClearWarmupSVC()
    end
    self.settingData:SetToDefault()
    self:ResetTimescale()
    self:ClearProcessNode()
    self:ReleaseIns()
    self:ClearPlayedWwiseData()
    self:ClearFreeMotion()
    self:ClearTempGameObject()
    self:ClearActors()
    self:CloseUI()
    self:DeactiveLookAtCamera()
    if self.dialogueBatchId ~= 0 then
        PreloadBatchMgr.Unload(self.dialogueBatchId)
        self.dialogueBatchId = 0
    end
    if self.database then
        DialogueManager.UnregisterDialogueUsing(self.database.name)
    end
    if self.dialogueInfoId then
        DialogueManager.ResumePlot(self.dialogueInfoId)
    end
    self.dialogueInfoId = 0
    self.database = nil
    self.dialogueInfo = nil
    EventMgr.RemoveListenerByTarget(self)
    self:RemoveRelativeCtrl()
    --直接调用不太合适
    self.controller:SystemCleared()
    self:ClearPlayerFaceHair()
end

---暂停时间
---@param reason string 只做暂停Dialogue的逻辑
function DialogueSystem:PauseTime(reason)
    if reason == nil then
        reason = "PauseTime"
    end
    local reasonCnt = table.nums(self.pausingTimeReason)
    if reasonCnt == 0 then
        self:PauseDialogue(reason)
        self:SetTimescale(TimescaleMgr.TimescaleLayer.DialoguePause, "Dialogue", 0)
    end
    self.pausingTimeReason[reason] = true
end

---继续时间
---@param reason string
function DialogueSystem:ResumeTime(reason)
    if reason == nil then
        reason = "PauseTime"
    end
    self.pausingTimeReason[reason] = nil
    local reasonCnt = table.nums(self.pausingTimeReason)
    if reasonCnt == 0 then
        self:ResumeDialogue(reason)
        self:SetTimescale(TimescaleMgr.TimescaleLayer.DialoguePause, "Dialogue", 1)
    end
end

---继续时间
---@param reason string
function DialogueSystem:PauseDialogue(reason)
    if reason == nil then
        reason = "Default"
    end
    local reasonCnt = table.nums(self.pausingDialogueReason)
    if reasonCnt == 0 then
        self:PauseUpdate(reason)
        for _, playId in pairs(self.ctsPlayingIdList) do
            CutSceneMgr.Pause(playId, false)
        end
        self:PauseWwise()
        for _, v in pairs(self.actorGameObjectDict) do
            local x3Animator = v.gameObject:GetComponent("X3Animator")
            if x3Animator ~= nil then
                x3Animator:Pause()
            end
        end
    end
    self.pausingDialogueReason[reason] = true
end

---继续时间
---@param reason string
function DialogueSystem:ResumeDialogue(reason)
    if reason == nil then
        reason = "Default"
    end
    local lastValue = self.pausingDialogueReason[reason]
    self.pausingDialogueReason[reason] = nil
    local reasonCnt = table.nums(self.pausingDialogueReason)
    if reasonCnt == 0 and lastValue ~= nil then
        self:ResumeUpdate(reason)
        for _, playId in pairs(self.ctsPlayingIdList) do
            CutSceneMgr.Resume(playId, false)
        end
        for _, v in pairs(self.actorGameObjectDict) do
            local x3Animator = v.gameObject:GetComponent("X3Animator")
            if x3Animator ~= nil then
                x3Animator:Resume()
            end
        end
        self:ResumeWwise()
    end
end

---暂停剧情
---@param reason string 暂停原因
function DialogueSystem:PauseUpdate(reason)
    if reason == nil then
        reason = "Default"
    end
    for _, pipeline in pairs(self.usingPipelineDict) do
        pipeline:PauseUpdate(reason)
    end
    local reasonCnt = table.nums(self.pausingUpdateReason)
    if reasonCnt == 0 then
        self.isUpdating = false
    end
    self.pausingUpdateReason[reason] = true
end

---继续剧情
---@param reason string 暂停原因
function DialogueSystem:ResumeUpdate(reason)
    if reason == nil then
        reason = "Default"
    end
    self.pausingUpdateReason[reason] = nil
    for _, pipeline in pairs(self.usingPipelineDict) do
        pipeline:ResumeUpdate(reason)
    end
    local reasonCnt = table.nums(self.pausingUpdateReason)
    if reasonCnt == 0 then
        self.isUpdating = true
    end
end

---以某种退出方式暂停播放
---@param pipelineKey string
---@param exitKey string 退出方式Key
---@param callback fun 结束回调
function DialogueSystem:PauseWithExitKey(pipelineKey, exitKey, callback)
    local pipeline = self.usingPipelineDict[pipelineKey]
    if pipeline then
        pipeline:PauseWithExitKey(exitKey, callback)
    end
end

---以某种退出方式停止播放
---@param pipelineKey string
---@param exitKey string 退出方式Key
---@param callback fun 结束回调
function DialogueSystem:StopWithExitKey(pipelineKey, exitKey, callback)
    local pipeline = self.usingPipelineDict[pipelineKey]
    if pipeline then
        pipeline:StopWithExitKey(exitKey, callback)
    end
end

---@return float
function DialogueSystem:GetDialogueSpeed()
    return self.dialogueSpeed
end

--TODO跳过和UI间的处理
---开始长按跳过模式
function DialogueSystem:StartLongPressSkipMode()
    if DialogueManager.GetDebugCanLongPressSkip() then
        self.isInLongPressSkip = true
        self:StartSkipMode(tonumber(LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUEJUMPSPEED)))
    end
end

---停止长按跳过模式
---长按抬起判断用，不会停住点击跳过按钮的跳过模式
function DialogueSystem:StopLongPressSkipMode()
    if self.isInLongPressSkip then
        self:StopSkipMode()
    end
end

---剧情跳过
---@param speed float 跳过速度
function DialogueSystem:StartSkipMode(speed)
    if self.isInSkipMode == false then
        self.isInSkipMode = true
        self:ChangeDialogueSpeed(speed)
        EventMgr.Dispatch("DialogueStartSkip")
    end
end

---停止跳过模式
function DialogueSystem:StopSkipMode()
    if self.isInSkipMode then
        self.isInSkipMode = false
        self.isInLongPressSkip = false
        self:ChangeDialogueSpeed(self:GetDialoguePlaySpeed())
        EventMgr.Dispatch("DialogueStopSkip")
    end
end

---是否在跳过模式中
---@return boolean
function DialogueSystem:IsInSkipMode()
    return self.isInSkipMode
end

---获取一条Pipeline
---@param pipelineKey string
---@return DialoguePipeline
function DialogueSystem:GetPipeline(pipelineKey)
    local pipeline = self.controller:GetPipeline(self, pipelineKey)
    pipeline:OnInit(self, self.dialogueInfoId)
    self.usingPipelineDict[pipeline:GetUniqueId()] = pipeline
    return pipeline
end

---切换场景
---@param sceneName string
---@param callback fun
function DialogueSystem:ChangeScene(sceneName, callback)
    if SceneMgr.GetCurScene() ~= sceneName then
        self.changeSceneCallback = callback
        self:PauseUpdate("ChangeScene")
        self:DeactiveActorsAndItems()
        SceneMgr.LoadScene(sceneName, nil, GameConst.LoadingType.None, handler(self, self.ChangeSceneEnded))
    else
        pcall(callback)
    end
end

---@private
---场景切换结束
function DialogueSystem:ChangeSceneEnded()
    self:ActiveActorsAndItems()
    pcall(self.changeSceneCallback)
    self.changeSceneCallback = nil
    self:ResumeUpdate("ChangeScene")
end

--region Setting
---@return DialogueSettingData
function DialogueSystem:GetSettingData()
    return self.settingData
end

---返回是否能显示剧情UI
---@return boolean
function DialogueSystem:GetCanShowDialogueUI()
    return self.controller:GetCanShowDialogueUI()
end

---注册剧情退出回调
---@param handler fun
---@param exitString string
function DialogueSystem:RegisterExitHandler(handler, exitString)
    self.settingData:SetShowExitButton(true)
    self.settingData.exitHandler = handler
    self.settingData.exitString = exitString
end

---注册剧情退出回调
function DialogueSystem:UnregisterExitHandler()
    self.settingData:SetShowExitButton(false)
    self.settingData.exitHandler = nil
    self.settingData.exitString = nil
end

---注册退出按钮点击回调
---@param handler fun
function DialogueSystem:RegisterExitClickHandler(handler)
    self.settingData:SetShowExitButton(true)
    self.settingData.exitClickHandler = handler
end

---取消注册退出按钮点击回调
function DialogueSystem:UnregisterExitClickHandler()
    self.settingData:SetShowExitButton(false)
    self.settingData.exitClickHandler = nil
end

---是否注册过退出点击回调
---@return boolean
function DialogueSystem:HasRegisteredExitClickHandler()
    return self.settingData.exitClickHandler ~= nil
end

---返回注册的点击回调
function DialogueSystem:GetExitClickHandler()
    return self.settingData.exitClickHandler
end

---执行注册的点击回调
function DialogueSystem:DoExitClickHandler()
    if self.settingData.exitClickHandler ~= nil then
        self.settingData.exitClickHandler()
    end
end

---获得注册的点击回调
---@return string
function DialogueSystem:GetExitString()
    return self.settingData.exitString
end

---从Controller同步设置
function DialogueSystem:SyncSettingFromController()
    self.controller:SyncSetting(self.settingData)
end

---从二维数组同步设置
---@param settingList
function DialogueSystem:OverrideSettingFromList(settingList)
    self.settingData:OverrideSettingFromList(settingList)
end
--endregion

---修改剧情速度
---@param speed float
function DialogueSystem:ChangeDialogueSpeed(speed)
    self.dialogueSpeed = speed
    --CutSceneMgr.SetHypeSpeed(speed)
    CutSceneMgr.SetCutSceneSoundSpeed(speed)
    for _, wwiseData in pairs(self.playedWwiseDataList) do
        if wwiseData.isPlaying then
            WwiseMgr.SetSpeed(wwiseData.eventName, speed)
        end
    end
    --背景音不能暂停，但是要随着倍速生效
    if speed ~= 0 and self.settingData:GetSpeedUpBGM() then
        WwiseMgr.SetSpeed(GameSoundMgr.GetCurMusicEventName(), speed)
    end
    self:SetTimescale(TimescaleMgr.TimescaleLayer.Dialogue, "Dialogue", speed)
    --[[    for _, data in pairs(self.actorGameObjectDict) do
            if GameObjectUtil.IsNull(data.gameObject) == false then
                CS_LipSyncWwiseUtil.SetLipsyncSpeed(data.gameObject, speed)
            end
        end]]
end

---重置剧情播放速度
function DialogueSystem:ResetDialogueSpeed()
    self.dialoguePlaySpeedIndex = 0
    self:ChangeDialogueSpeed(self:GetDialoguePlaySpeed())
    EventMgr.Dispatch("DialoguePlaySpeedChanged")
end

---
function DialogueSystem:OnShowSpeedChanged()
    if self.settingData:GetShowPlaySpeedButton() == false and self.recoverDialogueMode == false then
        self:ResetDialogueSpeed()
    end
end

---设置Timescale
---@param layer int
---@param key string
---@param value float
function DialogueSystem:SetTimescale(layer, key, value)
    TimescaleMgr.SetTimescale(layer, key, value)
    EventMgr.Dispatch("DialogueTimescaleChanged", TimescaleMgr.GetLayerGlobalTimescale(TimescaleMgr.TimescaleLayer.Dialogue))
end

---PauseCTS的功能
---@param playId int CTS唯一Id
---@param eventIndex int 事件帧暂停的Index
function DialogueSystem:PauseCTS(playId, eventIndex)
    self.pausingIndexCtrl:SetIsRunning(eventIndex, true)
    if playId > 0 and self.pausingPlayId ~= playId then
        CTS.PauseX3(playId)
        self.pausingPlayId = playId
        Debug.LogFormat("[DialogueSystem]PauseCTS:%s", playId)
    end
end

---CTS继续
---@param eventIndex int 事件帧暂停的Index
function DialogueSystem:ResumeCTS(eventIndex)
    if eventIndex == nil then
        self.pausingIndexCtrl:Clear()
    else
        self.pausingIndexCtrl:SetIsRunning(eventIndex, false)
    end
    if self.pausingPlayId > 0 and self.pausingIndexCtrl:IsRunning() == false then
        CTS.ResumeX3(self.pausingPlayId)
        Debug.LogFormat("[DialogueSystem]ResumeX3:%s", self.pausingPlayId)
        self.pausingPlayId = 0
    end
end

---Tick函数
---@param deltaTime float
function DialogueSystem:Update(deltaTime)
    if self.isUpdating == false or self.initCpl == false then
        return
    end
    ---防止Update里触发了结束影响到Dict的内容
    for key, _ in pairs(self.usingPipelineDict) do
        table.insert(self.usingPipelineKeys, #self.usingPipelineKeys + 1, key)
    end
    for _, key in pairs(self.usingPipelineKeys) do
        local pipeline = self.usingPipelineDict[key]
        if pipeline then
            --如果未来业务系统还有一层加速，那这里的DialogueSpeed就需要处理
            pipeline:Update(deltaTime * self.dialogueSpeed)
        end
    end
    table.clear(self.usingPipelineKeys)
end

---暂停系统Tick
------@param pipelineId int 管线Id
function DialogueSystem:Pause(pipelineId)
    local pipeline = self.usingPipelineDict[pipelineId]
    if pipeline then
        pipeline:Pause()
    end
end

---继续系统Tick
---@param pipelineId int 管线Id
function DialogueSystem:Resume(pipelineId)
    local pipeline = self.usingPipelineDict[pipelineId]
    if pipeline then
        pipeline:Resume()
    end
end

---剧情预加载接口
---@private
---@param callback fun
---@param uiProgressWeight float 进度权重 0~1
---@param uiInitProgress float 进度初始权重0~1
function DialogueSystem:PreloadActorAndTempObject(callback, uiProgressWeight, uiInitProgress)
    self.preloadCallback = callback
    self.dialogueBatchId = PreloadBatchMgr.LoadAsync(PreloadBatchType.Dialogue, self.dialogueInfoId,
            handler(self, self.PreloadComplete), GameConst.LoadingType.None, false, nil, uiProgressWeight, uiInitProgress)
end

---预加载完毕
---@private
---@param collector CS.PapeGames.DialogueResourceCollector
function DialogueSystem:PreloadComplete(collector)
    --处理异常情况
    self.dialogueBatchId = collector.ownerBatchId
    if self.database == nil then
        PreloadBatchMgr.Unload(self.dialogueBatchId)
        self.dialogueBatchId = 0
        return
    end
    if self.needCreateActors then
        self.needPreloadCount = self.database:GetPreloadActorCount() + self.database:GetPreloadTempObjectCount()
    else
        self.needPreloadCount = self.database:GetPreloadTempObjectCount()
    end
    self.loadedCount = 0
    if self.needCreateActors then
        local actors = self.database.data.actors
        if actors ~= nil then
            for i = 1, #actors do
                local syncActor = self.database:GetActor(actors[i].syncActor)
                if not syncActor and (actors[i].dontInitOnStart == false) then
                    if string.isnilorempty(actors[i].assetKey) == false then
                        if actors[i].actorType == DialogueEnum.ActorType.RoleClothSuit then
                            --需要先查一下业务逻辑有没有注入，有注入就不加载了
                            if self.controller:GetInjectedGameObject(actors[i].assetID) == nil then
                                self:GetInsWithSuitKey(actors[i].assetID, actors[i].assetKey, actors[i].faceChangeType, actors[i].faceHair)
                            else
                                self.loadedCount = self.loadedCount + 1
                                self:CheckPreloadComplete()
                            end
                        elseif actors[i].actorType == DialogueEnum.ActorType.RoleBaseModel then
                            --需要先查一下业务逻辑有没有注入，有注入就不加载了
                            if self.controller:GetInjectedGameObject(actors[i].assetID) == nil then
                                self:GetIns(actors[i].assetID, actors[i].assetKey, actors[i].clothList, actors[i].faceChangeType, actors[i].faceHair)
                            else
                                self.loadedCount = self.loadedCount + 1
                                self:CheckPreloadComplete()
                            end
                        else
                            local modelAssetPath = CharacterUtil.GetAssetPathWithModelKey(actors[i].assetKey)
                            if modelAssetPath ~= nil then
                                self:InjectGameObject(actors[i].assetID, 0, collector:GetAsset(modelAssetPath))
                            end
                        end
                    end
                    if actors[i].alternateGameObjects ~= nil then
                        for j = 1, #actors[i].alternateGameObjects do
                            if string.isnilorempty(actors[i].alternateGameObjects[j].assetKey) == false then
                                if actors[i].actorType == DialogueEnum.ActorType.ModelAsset then
                                    local modelAssetPath = CharacterUtil.GetAssetPathWithModelKey(actors[i].alternateGameObjects[j].assetKey)
                                    if modelAssetPath ~= nil then
                                        self:InjectGameObject(actors[i].assetID, actors[i].alternateGameObjects[j].id, collector:GetAsset(modelAssetPath))
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --添加TempObject资源
    local tempObject = self.database.data.tempObjects
    if tempObject ~= nil then
        for i = 1, #tempObject do
            if string.isnilorempty(tempObject[i].resKey) == false then
                if not tempObject[i].loadDirectly then
                    local cfg = LuaCfgMgr.Get("ModelAsset", tempObject[i].resKey)
                    self:InjectGameObject(tempObject[i].assetID, tempObject[i].resKey, collector:GetAsset(cfg.PrefabPath))
                end
            end
        end
    end
    self:CheckPreloadComplete()
end

---加载GameObject
---@private
---@param assetId int
---@param key string
---@param gameObject GameObject
function DialogueSystem:InjectGameObject(assetId, key, gameObject)
    self.loadedCount = self.loadedCount + 1
    if gameObject ~= nil then
        CS.UnityEngine.Object.DontDestroyOnLoad(gameObject)
        GameObjectUtil.SetActive(gameObject, false)
        GameObjectUtil.SetParent(gameObject, nil)
        local data = {}
        data.gameObject = gameObject
        data.fromPool = true
        local resKey = DialogueUtil.GetResKey(assetId, key)
        self.gameObjectPool[resKey] = data
    end
    self:CheckPreloadComplete()
end

---加载角色
---@private
---@param assetId int
---@param suitKey string
function DialogueSystem:GetInsWithSuitKey(assetId, suitKey, faceChangeType, faceHair)
    CharacterMgr.GetInsWithSuitKey(suitKey,
            function(gameObject)
                self:CharacterLoadCpl(gameObject, assetId, 0)
            end, faceChangeType, faceHair, nil, FaceFilter)
end

---根据裸模+部件获得角色
---@param roleBaseKey String 基础模型
---@param partKeys String[] 部件数组
function DialogueSystem:GetIns(assetId, roleBaseKey, partKeys, faceChangeType, faceHair)
    CharacterMgr.GetIns(roleBaseKey, partKeys, nil,
            function(gameObject)
                self:CharacterLoadCpl(gameObject, assetId, 0)
            end, faceChangeType, faceHair, nil, FaceFilter)
end

---人物加载完毕回调
---@param gameObject
---@param assetId int
---@param key string
function DialogueSystem:CharacterLoadCpl(gameObject, assetId, key)
    if self.database == nil then
        return
    end
    self.loadedCount = self.loadedCount + 1
    if gameObject ~= nil then
        CS.UnityEngine.Object.DontDestroyOnLoad(gameObject)
        GameObjectUtil.SetActive(gameObject, false)
        GameObjectUtil.SetParent(gameObject, nil)
        local resKey = DialogueUtil.GetResKey(assetId, key)
        if self.charactorPool[resKey] then
            --TODO 未来有逻辑需要保留的话再议
            CharacterCtrlMgr.DestroyByGameObject(self.charactorPool[resKey])
            CharacterMgr.ReleaseIns(self.charactorPool[resKey])
        end
        self.charactorPool[resKey] = gameObject
    end
    self:CheckPreloadComplete()
end

---检查是否都加载完毕
function DialogueSystem:CheckPreloadComplete()
    if self.loadedCount == self.needPreloadCount then
        Debug.LogFormat("[DialogueSystem]PreloadComplete:%s", TimerMgr.RealtimeSinceStartup())
        if self.needCreateActors then
            self:InitActors()
        end
        self.initCpl = true
        if self.preloadCallback ~= nil then
            self.preloadCallback()
            self.preloadCallback = nil
        end
    end
end

---初始化角色
function DialogueSystem:InitActors()
    if self.database ~= nil then
        local actors = self.database.data.actors
        if actors ~= nil then
            for i = 1, #actors do
                local syncActor = self.database:GetActor(actors[i].syncActor)
                if not syncActor then
                    if string.isnilorempty(actors[i].assetKey) == false and actors[i].dontInitOnStart == false then
                        self:InitActor(actors[i], 0, true)
                    else
                        local key = self.database:GetActorUniqueKey(actors[i])
                        self:AddActor(key, self.controller:GetInjectedGameObject(key))
                    end
                end
            end
        end
    end
end

---初始化单个角色
---@param actor Actor
---@param gameObjectId int 角色套装Id，可在剧情编辑器里配置角色多套衣服
---@param needInitPos boolean 是否需要初始化位置
---@return GameObject
function DialogueSystem:InitActor(actor, gameObjectId, needInitPos)
    local actorData = self.database:GetActorData(actor, gameObjectId)
    local actorGameObject = nil
    local uniqueKey = tonumber(self.database:GetActorUniqueKey(actor))
    local resKey = DialogueUtil.GetResKey(uniqueKey, actorData.id)
    ---有提前注入的角色就从注入的拿，只能注入默认衣服
    local data = DialogueActorData.new()
    data.name = tostring(self.database:GetActorUniqueKey(actor))
    data.gameObjectID = gameObjectId
    if gameObjectId == 0 and self.controller:GetInjectedGameObject(self.database:GetActorUniqueKey(actor)) ~= nil then
        actorGameObject = self.controller:GetInjectedGameObject(self.database:GetActorUniqueKey(actor))
        needInitPos = false
    elseif actor.actorType ~= DialogueEnum.ActorType.ModelAsset then
        data.isCreatedByDialogueSystem = true
        actorGameObject = self.charactorPool[resKey]
        --DontInitOnStart的角色使用到再实例化
        if actorGameObject == nil then
            if actor.actorType == DialogueEnum.ActorType.RoleClothSuit then
                actorGameObject = CharacterMgr.GetInsWithSuitKeySync(actorData.assetKey, nil, actorData.faceChangeType, actorData.faceHair, nil, FaceFilter)
            else
                actorGameObject = CharacterMgr.GetInsSync(actorData.assetKey, actorData.clothList, nil, actorData.faceChangeType, actorData.faceHair, nil, FaceFilter)
            end
            self:CharacterLoadCpl(actorGameObject, uniqueKey, actorData.id)
        end
    else
        data.isCreatedByDialogueSystem = true
        actorGameObject = self.gameObjectPool[resKey] and self.gameObjectPool[resKey].gameObject
        --DontInitOnStart的角色使用到再实例化
        if actorGameObject == nil then
            local modelAssetPath = CharacterUtil.GetAssetPathWithModelKey(actorData.assetKey)
            actorGameObject = Res.LoadGameObject(modelAssetPath)
            if actorGameObject then
                CS.UnityEngine.Object.DontDestroyOnLoad(actorGameObject)
                actorGameObject:SetActive(false)
                GameObjectUtil.SetPosition(actorGameObject, 0, -1000, 0)
                local gameObjectData = {}
                gameObjectData.gameObject = actorGameObject
                gameObjectData.fromPool = true
                self.gameObjectPool[resKey] = gameObjectData
            end
        end
    end
    if actorGameObject ~= nil then
        data.gameObject = actorGameObject
        if self.actorGameObjectDict[data.name] ~= nil then
            self:ClearActor(data.name)
        end
        if uniqueKey ~= nil and uniqueKey > 0 then
            CutSceneMgr.InjectAssetInsPermanently(uniqueKey, actorGameObject)
        end
        if needInitPos then
            GameObjectUtil.SetPosition(actorGameObject, 0, -1000, 0)
        end
        actorGameObject:SetActive(true)
        if actorGameObject:GetComponent("CutSceneActor") == nil then
            actorGameObject:AddComponent("CutSceneActor")
        end
        if string.isnilorempty(uniqueKey) == false and actorGameObject:GetComponent("Animator") ~= nil then
            X3Animator.Add(uniqueKey, actorGameObject)
            data.needRemoveAnimator = true
        end
        self.actorGameObjectDict[data.name] = data
    end
    return actorGameObject
end

---清除角色
function DialogueSystem:ClearActors()
    local cloneKeys = table.keys(self.actorGameObjectDict)
    for _, key in pairs(cloneKeys) do
        self:ClearActor(key)
    end
    table.clear(self.actorGameObjectDict)
end

---清除某个角色
---@param uniqueKey string
function DialogueSystem:ClearActor(uniqueKey)
    if self.actorGameObjectDict[uniqueKey] ~= nil then
        local data = self.actorGameObjectDict[uniqueKey]
        if GameObjectUtil.IsNull(data.gameObject) == false then
            local x3Animator = data.gameObject:GetComponent("X3Animator")
            if x3Animator ~= nil then
                x3Animator.Speed = 1
                x3Animator:Resume()
            end
        end
        --TODO 口型动画加速恢复
        if data.isCreatedByDialogueSystem then
            if data.gameObject ~= nil and data.needRemoveAnimator then
                X3Animator.Remove(data.name)
            end
            CutSceneMgr.RemoveAssetInsPermanently(data.gameObject)
            if GameObjectUtil.IsNull(data.gameObject) == false then
                GameObjectUtil.SetActive(data.gameObject, false)
            end
        end
        self.actorGameObjectDict[uniqueKey] = nil
    end
end

---设置人物特写
---@param exclude boolean
function DialogueSystem:ExcludeFromBlur(exclude)
    for _, v in pairs(self.actorGameObjectDict) do
        CharacterMgr.ExcludeFromBlur(v.gameObject, exclude)
    end
    CutSceneMgr.SetDisableExcludeFromDOF(not exclude)
end

---清除对象
function DialogueSystem:ReleaseIns()
    for _, v in pairs(self.charactorPool) do
        --TODO 未来有逻辑需要保留的话再议
        CharacterCtrlMgr.DestroyByGameObject(v)
        CharacterMgr.ReleaseIns(v)
    end
    table.clear(self.charactorPool)
    for _, data in pairs(self.gameObjectPool) do
        if data.fromPool == false then
            if GameObjectUtil.IsNull(data.gameObject) == false then
                Res.DiscardGameObject(data.gameObject)
            end
        end
    end
    table.clear(self.gameObjectPool)
end

---添加一个演员
---@param name string
---@param any Actor
function DialogueSystem:AddActor(name, actor)
    local key = tostring(name)
    if GameObjectUtil.IsNull(actor) == false then
        ---此函数不做CutSceneMgr的注入，自行注入自行移除
        if self.actorGameObjectDict[key] ~= nil then
            self:ClearActor(key)
        end
        X3Animator.Add(key, actor)
        local data = DialogueActorData.new()
        data.name = key
        data.gameObject = actor
        self.actorGameObjectDict[data.name] = data
    end
end

---获取一个演员
---@param name string
---@param childTransformPath string
---@return GameObject
function DialogueSystem:GetActor(name, childTransformPath)
    local key = tostring(name)
    local target = nil
    if self.actorGameObjectDict[key] then
        target = self.actorGameObjectDict[key].gameObject
    end
    if GameObjectUtil.IsNull(target) then
        target = self.controller:GetInjectedGameObject(key)
    end
    if GameObjectUtil.IsNull(target) then
        target = self:GetFromCts(tonumber(name))
    end
    --这里再找不到只能去X3Animator里找了
    if GameObjectUtil.IsNull(target) then
        for _, v in pairs(self.actorGameObjectDict) do
            if GameObjectUtil.IsNull(v.gameObject) == false then
                local x3Animator = v.gameObject:GetComponent(typeof(CS.X3Game.X3Animator))
                if x3Animator and CTS.GetAssetInsWithTag then
                    target = CTS.GetAssetInsWithTag(x3Animator.Tag, tonumber(name))
                    if GameObjectUtil.IsNull(target) == false then
                        break
                    end
                end
            end
        end
    end
    if GameObjectUtil.IsNull(target) == false and string.isnilorempty(childTransformPath) == false then
        local childTransform = self:GetChild(target.transform, childTransformPath)
        target = childTransform and childTransform.gameObject or nil
    end
    return target
end

---获取一个TempObject
---@param name string
---@param childTransformPath string
---@return GameObject
function DialogueSystem:GetTempObject(name, childTransformPath)
    local target = nil
    if self.tempGameObjectDict[name] then
        target = self.tempGameObjectDict[name][1].gameObject
    end
    if GameObjectUtil.IsNull(target) then
        target = self:GetFromCts(tonumber(name))
    end
    if GameObjectUtil.IsNull(target) == false and string.isnilorempty(childTransformPath) == false then
        local childTransform = self:GetChild(target.transform, childTransformPath)
        target = childTransform and childTransform.gameObject or nil
    end
    return target
end

---@param assetId int
---@return GameObject
function DialogueSystem:GetFromCts(assetId)
    if not assetId then
        return nil
    end
    local target = nil
    local curCtsPlayId = #self.ctsPlayingIdList > 0 and self.ctsPlayingIdList[#self.ctsPlayingIdList] or 0
    if assetId > 0 and curCtsPlayId > 0 then
        target = CTS.GetAssetIns(curCtsPlayId, assetId)
    end
    return target
end

---获取childTransform
---@param parentTF transform
---@param childName string
---@return Transform
function DialogueSystem:GetChild(parentTF, childName)
    local childTF = parentTF:Find(childName)
    if childTF ~= nil then
        return childTF
    end
    local count = parentTF.childCount
    for i = 0, count - 1 do
        childTF = self:GetChild(parentTF:GetChild(i), childName)
        if childTF ~= nil then
            return childTF
        end
    end
    return nil
end

---获取动态目标
---@param dynamicTarget DynamicTarget
---@return GameObject
function DialogueSystem:GetDynamicTarget(dynamicTarget)
    local name = self.database:GetDynamicTargetName(dynamicTarget)
    if dynamicTarget.targetType == DialogueEnum.DynamicTargetType.Actor then
        return self:GetActor(name, dynamicTarget.childTransformPath)
    elseif dynamicTarget.targetType == DialogueEnum.DynamicTargetType.ActorTag then
        return self:GetActor(name, dynamicTarget.childTransformPath)
    else
        return self:GetTempObject(name, dynamicTarget.childTransformPath)
    end
end

---显隐所有角色
---@param dynamicTarget DynamicTarget
---@param value boolean
function DialogueSystem:SetDynamicTargetActive(dynamicTarget, value)
    local name = self.database:GetDynamicTargetName(dynamicTarget)
    if value then
        if self.actorPosDict[name] ~= nil then
            local go = self:GetDynamicTarget(dynamicTarget)
            if GameObjectUtil.IsNull(go) == false then
                GameObjectUtil.SetPosition(go, self.actorPosDict[name])
            end
            self.actorPosDict[name] = nil
        end
    else
        if self.actorPosDict[name] == nil then
            local go = self:GetDynamicTarget(dynamicTarget)
            if GameObjectUtil.IsNull(go) == false then
                self.actorPosDict[name] = GameObjectUtil.GetPosition(go)
                GameObjectUtil.SetPosition(go, 0, -1000, 0)
            end
        end
    end
end

---换Actor
---@param actorPropChange ActorPropChange
function DialogueSystem:ChangeActor(actorPropChange)
    local actor = self.database:GetActor(actorPropChange.actorID)
    local uniqueKey = self.database:GetActorUniqueKey(actor)
    local curActiveActor = self.actorGameObjectDict[tostring(uniqueKey)]
    local nextActorData = self.database:GetActorData(actor, actorPropChange.gameObjectID)
    if nextActorData then
        if nextActorData.actorType == DialogueEnum.ActorType.RoleClothSuit then
            CharacterMgr.RebuildPartsWithSuitKeySync(curActiveActor and curActiveActor.gameObject or nil, nextActorData.assetKey,
                    nextActorData.faceChangeType, nextActorData.faceHair, FaceFilter)
        elseif nextActorData.actorType == DialogueEnum.ActorType.RoleBaseModel then
            CharacterMgr.RebuildParts(curActiveActor and curActiveActor.gameObject or nil, nextActorData.assetKey, nextActorData.clothList,
                    nextActorData.faceChangeType, nextActorData.faceHair, FaceFilter)
        else
            self:ReplaceActor(actorPropChange)
        end
    end
end

---底板不同，直接换Actor的GameObject
---@param actorPropChange ActorPropChange
function DialogueSystem:ReplaceActor(actorPropChange)
    local actor = self.database:GetActor(actorPropChange.actorID)
    local uniqueKey = self.database:GetActorUniqueKey(actor)
    local curActiveActor = self.actorGameObjectDict[tostring(uniqueKey)]
    local activeState = true
    local position = nil
    local rotation = nil
    local actorGameObject
    if curActiveActor ~= nil then
        activeState = curActiveActor.gameObject.activeSelf
        position = curActiveActor.gameObject.transform.position
        rotation = curActiveActor.gameObject.transform.rotation
    end
    CTS.ReplaceInsPrefab(
            function(string)
                self:ClearActor(self.database:GetActorUniqueKey(actor))
                actorGameObject = self:InitActor(actor, actorPropChange.gameObjectID, false)
                local x3Animator = actorGameObject:GetComponent(typeof(CS.X3Game.X3Animator))
                local x3Character = actorGameObject:GetComponent(typeof(CS.X3.Character.X3Character))
                if x3Animator then
                    x3Animator:ClearStates()
                end
                if actorGameObject then
                    actorGameObject:SetActive(activeState)
                    actorGameObject.transform.position = position
                    actorGameObject.transform.rotation = rotation
                end
                --TODO 需要在CtsPlay前调用一下才能保证当帧灯光不闪，详见2-7
                if x3Character then
                    x3Character:Update()
                end
            end)
    CutSceneMgr.SetBlendingGroupWeight(EStaticSlot.Timeline, 1);
end

---切换场景时隐藏所有角色和物件
function DialogueSystem:DeactiveActorsAndItems()
    for _, data in pairs(self.actorGameObjectDict) do
        CS.UnityEngine.Object.DontDestroyOnLoad(data.gameObject)
    end

    for _, itemList in pairs(self.tempGameObjectDict) do
        for _, item in pairs(itemList) do
            if item.isInUI == false then
                CS.UnityEngine.Object.DontDestroyOnLoad(item.gameObject)
            end
        end
    end
end

---切换完场景时显示所有角色和物件
function DialogueSystem:ActiveActorsAndItems()
    for _, data in pairs(self.actorGameObjectDict) do
        if data.isCreatedByDialogueSystem == false then
            data.gameObject.transform:SetParent(GlobalCameraMgr.GetUnityMainCamera().transform, true)
            data.gameObject.transform:SetParent(nil, true)
        end
    end

    for _, itemList in pairs(self.tempGameObjectDict) do
        for _, item in pairs(itemList) do
            if item.isInUI == false then
                item.gameObject.transform:SetParent(GlobalCameraMgr.GetUnityMainCamera().transform, true)
                item.gameObject.transform:SetParent(nil, true)
            end
        end
    end
end

---UI上初始化物体
---@param id int
---@param uiNodeName string
---@param position Vector3
---@param eulerAngles Vector3
function DialogueSystem:InstantiateGameObjectToUI(id, uiNodeName, position, eulerAngles)
    local tempGameObject, tempGameObjectData = self:InstantiateGameObject(id)
    if tempGameObject then
        tempGameObject:SetActive(true)
        tempGameObjectData.isInUI = true
        EventMgr.Dispatch("DialogueUIAddGameObject", tempGameObject, uiNodeName, position, eulerAngles)
    end
end

---注册UI物体到Dialogue界面
---@param object GameObject
---@param closeCallBall function
function DialogueSystem:AddOuterUIObject(object, closeCallBall)
    self.outerUIObject = object
    self.outerCallBack = closeCallBall
end

function DialogueSystem:ClearOuterUIObject()
    self.outerUIObject = nil
    self.outerCallBack = nil
end

function DialogueSystem:GetOuterUIObject()
    return self.outerUIObject
end

---初始化物件
---@param id int
---@param parent Transform
---@return GameObject, TempGameObjectData
function DialogueSystem:InstantiateGameObject(id, parent)
    local tempObjectData = self.database:GetTempObject(id)
    local tempGameObject = nil
    local tempGameObjectData = nil
    if tempObjectData ~= nil then
        if string.isnilorempty(tempObjectData.resKey) == false then
            local resKey = DialogueUtil.GetResKey(tempObjectData.assetID, tempObjectData.resKey)
            if not self.gameObjectPool[resKey] or GameObjectUtil.IsNull(self.gameObjectPool[resKey].gameObject) then
                --到了这里表示是非LoadDirectly模式或者是加载过的已经被销毁了
                tempGameObject = Res.LoadGameObject(tempObjectData.resKey)
                if tempGameObject ~= nil then
                    local data = {}
                    data.gameObject = tempGameObject
                    data.fromPool = false
                    self.gameObjectPool[resKey] = data
                end
            else
                tempGameObject = self.gameObjectPool[resKey].gameObject
            end
        end
        if tempGameObject ~= nil then
            local hasComponent, rigidBody = tempGameObject:TryGetComponent(typeof(CS.UnityEngine.Rigidbody))
            if hasComponent then
                rigidBody.useGravity = false
            end
            tempGameObject:AddComponent("CutSceneProp")
            tempGameObjectData = self:AddTempGameObjectToList(id, tempGameObject)
            GameObjectUtil.SetActive(tempGameObject, true)
            if tempObjectData.assetID > 0 then
                CutSceneMgr.InjectAssetInsPermanently(tempObjectData.assetID, tempGameObject)
            end
            if parent ~= nil then
                tempGameObject.transform:SetParent(parent.transform)
            end
        end
    end
    return tempGameObject, tempGameObjectData
end

---销毁一个物件
---@param id int
function DialogueSystem:DestroyGameObject(id)
    local gameObjects = self.tempGameObjectDict[id]
    if gameObjects ~= nil then
        for _, data in pairs(gameObjects) do
            if GameObjectUtil.IsNull(data.gameObject) == false then
                CutSceneMgr.RemoveAssetInsPermanently(data.gameObject)
                --直接销毁，不要进池
                GameObjectUtil.Destroy(data.gameObject)
            end
        end
        table.clear(gameObjects)
    end
end

---清除一个临时物件
function DialogueSystem:ClearTempGameObject()
    for i, v in pairs(self.tempGameObjectDict) do
        for j = 1, #v do
            if GameObjectUtil.IsNull(v[j].gameObject) == false then
                v[j].gameObject:SetActive(false)
            end
        end
        self.tempGameObjectDict[i] = nil
    end
    self.tempGameObjectDict = {}
end

---添加一个物件
---@param id int
---@param gameObject GameObject
---@return TempGameObjectData
function DialogueSystem:AddTempGameObjectToList(id, gameObject)
    local gameObjectList
    if self.tempGameObjectDict[id] == nil then
        gameObjectList = {}
        self.tempGameObjectDict[id] = gameObjectList
    end
    gameObjectList = self.tempGameObjectDict[id]
    local tempObjectData = {}
    tempObjectData.gameObject = gameObject
    tempObjectData.isInUI = false
    table.insert(gameObjectList, #gameObjectList + 1, tempObjectData)
    return tempObjectData
end

---打开UI
function DialogueSystem:OpenUI()
    EventMgr.AddListener("DialogueBLL.showPlaySpeedButton", self.OnShowSpeedChanged, self)
    DialogueManager.OpenUI(self)
end

---关闭UI
function DialogueSystem:CloseUI()
    EventMgr.RemoveListener("DialogueBLL.showPlaySpeedButton", self.OnShowSpeedChanged, self)
    ---处理外部UI
    if self.outerCallBack then
        self.outerCallBack(self.outerUIObject)
    end
    self:ClearOuterUIObject()
    DialogueManager.CloseUI(self)
end

---开启自动
---@param isAuto boolean
function DialogueSystem:SwitchAuto(isAuto)
    self.autoClickToResume = isAuto
    EventMgr.Dispatch("DialogueSwitchAuto", isAuto)
    if isAuto then
        self:StartAutoTimer()
    else
        self:EndAutoTimer()
    end
end

---检查自动播放模式
function DialogueSystem:CheckAutoMode()
    if self.autoClickToResume or DialogueManager.GetAutoTestMode() then
        self:StartAutoTimer()
    end
end

---是否自动
---@return boolean
function DialogueSystem:IsAuto()
    return self.autoClickToResume
end

---启动自动Timer
function DialogueSystem:StartAutoTimer()
    self:EndAutoTimer()
    local deltaTime = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUEAUTOTIME)
    self.autoId = TimerMgr.AddTimer(deltaTime, self.AutoClick, self)
end

---结束自动Timer
function DialogueSystem:EndAutoTimer()
    if self.autoId ~= 0 then
        TimerMgr.Discard(self.autoId)
        self.autoId = 0
    end
end

---自动点击
function DialogueSystem:AutoClick()
    self.autoId = 0
    EventMgr.Dispatch("DialoguePanelAutoClicked")
end

---关闭Dialogue时关闭UI
---@value boolean
function DialogueSystem:CloseUIWhenEndDialogue(value)
    self.closeUIWhenEndDialogue = value
end

---获得历史记录
---@return table<DialogueReviewData>
function DialogueSystem:GetReviewList(pipelineKey)
    local pipeline = self.usingPipelineDict[pipelineKey]
    if pipeline then
        return pipeline:GetReviewList()
    end
    return nil
end

---添加一个CTSPlayId
---@param value int
function DialogueSystem:AddCtsPlayId(value)
    table.insert(self.ctsPlayedIdList, #self.ctsPlayedIdList + 1, value)
    table.insert(self.ctsPlayingIdList, #self.ctsPlayingIdList + 1, value)
end

---移除一个CTSPlayId
---@param value int
function DialogueSystem:RemoveCtsPlayingId(value)
    table.removebyvalue(self.ctsPlayingIdList, value)
end

---激活跟随相机
---@param cameraPath string
---@return VirtualCameraBase
function DialogueSystem:ActiveLookAtCamera(cameraPath)
    if self.virtualCamera then
        GlobalCameraMgr.DestroyVirtualCamera(self.virtualCamera)
    end
    self.virtualCamera = GlobalCameraMgr.CreateVirtualCamera(CameraModePath.LookAtActorMode, cameraPath)
    return self.virtualCamera
end

---销毁跟随相机
function DialogueSystem:DeactiveLookAtCamera()
    if self.virtualCamera then
        GlobalCameraMgr.DestroyVirtualCamera(self.virtualCamera)
        GlobalCameraMgr.SetDefaultBlend(CameraDefaultBlendStyle.Cut, 0)
    end
    self.virtualCamera = nil
end

--region Variable
---修改变量值
---@param variableKey int
---@param variableValue int
function DialogueSystem:ChangeVariableState(variableKey, variableValue)
    self.controller:ChangeVariableState(variableKey, variableValue)
end

---恢复变量
---@param variableChanges table<int, int>
function DialogueSystem:RecoverVariableState(variableChanges)
    self.controller:RecoverVariableState(variableChanges)
end

---检查变量
---@param variableKey int
---@param variableValue int
---@return boolean
function DialogueSystem:CheckVariableState(variableKey, variableValue)
    return self.controller:CheckVariableState(variableKey, variableValue)
end

---获取变量值
---@param variableKey int
---@param variableValue int
---@return int
function DialogueSystem:GetVariableState(variableKey)
    return self.controller:GetVariableState(variableKey)
end
--endregion

--region Random
---检查随机次数是否已达上限，需要重置
---@param links table<Link>
function DialogueSystem:CheckResetRandomTimes(links)
    if links then
        for _, link in pairs(links) do
            if DialogueManager.IsMutedLink(self.database.name, link) == false then
                local entry = self.database:GetDialogueEntryByLink(link)
                if self:HasLeftRandomTimes(entry) and ConditionCheckUtil.CheckConditionCheckData(link.conditionData.conditionCheckDatas, self:GetDataProvider()) then
                    return
                end
            end
        end

        --走到这里表示都没有随机次数了
        for _, link in pairs(links) do
            local entry = self.database:GetDialogueEntryByLink(link)
            self:ResetRandomTimes(entry)
        end
        self.controller:CheckSave()
    end
end

---判断是否还有剩余随机次数
---@param entry DialogueEntry
---@return boolean
function DialogueSystem:HasLeftRandomTimes(entry)
    if self.randomTimesCache[entry.uniqueID] == nil then
        self.randomTimesCache[entry.uniqueID] = 0
    end
    return entry.randomTimes == nil or entry.randomTimes < 0 or self.randomTimesCache[entry.uniqueID] < entry.randomTimes
end

---重置随机次数
---@param entry DialogueEntry
function DialogueSystem:ResetRandomTimes(entry)
    self.randomTimesCache[entry.uniqueID] = 0
end

---增加一次随机次数
---@param entry DialogueEntry
function DialogueSystem:AddRandomTimes(entry)
    if self.randomTimesCache[entry.uniqueID] == nil then
        self.randomTimesCache[entry.uniqueID] = 0
    end
    self.randomTimesCache[entry.uniqueID] = self.randomTimesCache[entry.uniqueID] + 1
    self.controller:CheckSave()
end

---获取一个随机数
---@param min float
---@param max float
---@return float
function DialogueSystem:GetRandom(min, max)
    local random
    random = math.random(min, max - 1)
    return random
end
--endregion

--region Save/Load
---@return DialogueSystemSavingData
function DialogueSystem:GetSaveData()
    ---@type DialogueSystemSavingData
    local savingData = { randomTimesCache = {} }
    for k, v in pairs(self.randomTimesCache) do
        savingData.randomTimesCache[tostring(k)] = v
    end
    return savingData
end

---读取记录
---@param savingData DialogueSystemSavingData
function DialogueSystem:Load(savingData)
    if savingData then
        for k, v in pairs(savingData.randomTimesCache) do
            self.randomTimesCache[tonumber(k)] = v
        end
    end
end
--endregion

--region ProcessSave
---添加一个节点记录
---@param node pbcmessage.DialogueProcessNode
function DialogueSystem:AddProcessNode(node)
    if self.ignoreProcessSave then
        return
    end
    self.lastProcessNode = nil
    table.insert(self.processNodeList, #self.processNodeList + 1, node)
end

---记录剧情播放的最后一个节点
---@param node pbcmessage.DialogueProcessNode
function DialogueSystem:SetLastProcessNode(node)
    if self.ignoreProcessSave then
        return
    end
    self.lastProcessNode = node
end

---忽略记录
---@param value boolean
function DialogueSystem:SetIgnoreProcessSave(value)
    self.ignoreProcessSave = value
end

---是否忽略记录节点
---@return boolean
function DialogueSystem:GetIgnoreProcessSave()
    return self.ignoreProcessSave
end

---清除节点记录
function DialogueSystem:ClearProcessNode()
    table.clear(self.processNodeList)
    self.lastProcessNode = nil
end

---返回记录过的节点，用于给后端校验
---@return table<pbcmessage.DialogueProcessNode>
function DialogueSystem:PopProcessNodes()
    local dialogueProcessNodes = {}
    if #self.processNodeList > 200 then
        Debug.LogError("[DialogueSystem]剧情校验出现超过200条数据，不予发送校验，请检查。")
    else
        if #self.processNodeList > 0 then
            for _, dialogueProcessNode in pairs(self.processNodeList) do
                table.insert(dialogueProcessNodes, #dialogueProcessNodes + 1, dialogueProcessNode)
            end
        end

        if self.lastProcessNode ~= nil then
            table.insert(dialogueProcessNodes, #dialogueProcessNodes + 1, self.lastProcessNode)
        end
    end
    self:ClearProcessNode()
    if #dialogueProcessNodes > 0 then
        return { DialogueID = self.dialogueInfoId, NodeList = dialogueProcessNodes }
    end
    return nil
end

---是否有节点记录需要发送b
---@return boolean
function DialogueSystem:HasSavedProcessNode()
    --GM命令里的不校验剧情
    if BllMgr.GetDialogueBLL():GetNotCheckDialogue() then
        self:ClearProcessNode()
    end
    return #self.processNodeList > 0 or self.lastProcessNode ~= nil
end
--endregion

--region Wwise
---播放Wwise
---@param wwiseData DialogueWwiseData 剧情Lua中的字段格式
function DialogueSystem:PlayVoice(wwiseData)
    local speaker = self:GetDynamicTarget(wwiseData.dynamicTarget)
    local bnkName = WwiseMgr.GetBankNameWithEventName(wwiseData.eventName)
    if string.isnilorempty(bnkName) == false then
        self:LoadWwiseBnk(bnkName)
        if GameObjectUtil.IsNull(speaker) == false then
            if string.isnilorempty(wwiseData.lipSyncAsset) == false then
                local lipSyncData = Res.LoadWithAssetPath(wwiseData.lipSyncAsset, AutoReleaseMode.EndOfFrame)
                local X3Character = speaker:GetComponentInChildren(typeof(CS.X3.Character.X3Character))
                local lipSync = X3Character:GetSubsystem(CS.X3.Character.ISubsystem.Type.LipSync)
                if lipSyncData ~= nil and lipSync ~= nil then
                    local weight = LuaCfgMgr.Get("DialogueLipSyncWeight", 0).LipSyncWeight
                    local cfg = LuaCfgMgr.Get("DialogueLipSyncWeight", self.database:GetDynamicTargetAssetId(wwiseData.dynamicTarget))
                    if cfg then
                        weight = cfg.LipSyncWeight
                    end
                    if wwiseData.weight and wwiseData.weight ~= 0 then
                        weight = wwiseData.weight
                    end
                    Res.AddRefObj(lipSyncData, speaker)
                    CS_LipSyncWwiseUtil.PlaySoundWithLipsync(speaker, wwiseData.eventName, lipSyncData, weight, handler(self, self.WwiseOnComplete))
                    --保护，防止有业务停止了口型
                    CS_LipSyncWwiseUtil.ResumeLipsync(speaker)
                    --CS_LipSyncWwiseUtil.SetLipsyncSpeed(speaker, self.dialogueSpeed)
                    Debug.LogFormat("[DialogueSystem]播放口型动画-%s-%s-%s", speaker.name, wwiseData.eventName, lipSyncData)
                else
                    WwiseMgr.PlaySound3D(wwiseData.eventName, speaker, handler(self, self.WwiseOnComplete))
                end
            else
                WwiseMgr.PlaySound3D(wwiseData.eventName, speaker, handler(self, self.WwiseOnComplete))
            end
            self:AddPlayedWwiseData(wwiseData.eventName, false, speaker)
        else
            WwiseMgr.PlaySound2D(wwiseData.eventName, handler(self, self.WwiseOnComplete))
            self:AddPlayedWwiseData(wwiseData.eventName, false, nil)
        end
        WwiseMgr.SetSpeed(wwiseData.eventName, self.dialogueSpeed)
    end
end

---播放声音
---@param wwiseData WwiseActionData
function DialogueSystem:PlaySound(wwiseData)
    if wwiseData.soundType == DialogueEnum.WwiseSoundType.Background then
        local musicContext = GameSoundMgr.PlayMusic(wwiseData.eventName)
        if musicContext then
            self:AddPlayedWwiseData(musicContext.eventName, true)
            WwiseMgr.SetSpeed(musicContext.eventName, self.dialogueSpeed)
        end
    else
        local bnkName = WwiseMgr.GetBankNameWithEventName(wwiseData.eventName)
        if string.isnilorempty(bnkName) == false then
            self:LoadWwiseBnk(bnkName)
            WwiseMgr.PlaySound2D(wwiseData.eventName)
        end
        self:AddPlayedWwiseData(wwiseData.eventName, false)
        WwiseMgr.SetSpeed(wwiseData.eventName, self.dialogueSpeed)
    end
end

---Wwise播放完毕
---@param eventName string
function DialogueSystem:WwiseOnComplete(eventName)
    if self.playedWwiseDataList then
        local length = #self.playedWwiseDataList
        for i = length, 1, -1 do
            if self.playedWwiseDataList[i].eventName == eventName then
                PoolUtil.ReleaseTable(table.remove(self.playedWwiseDataList, i))
            end
        end
    end
end

---停止播放Wwise
---@param wwiseData DialogueWwiseData 剧情Lua中的字段格式
function DialogueSystem:StopWwise(wwiseData)
    local speaker = self:GetDynamicTarget(wwiseData.dynamicTarget)
    if GameObjectUtil.IsNull(speaker) == false then
        if string.isnilorempty(wwiseData.lipSyncAsset) == false then
            local lipSyncAsset = Res.LoadWithAssetPath(wwiseData.lipSyncAsset, AutoReleaseMode.EndOfFrame)
            local X3Character = speaker:GetComponentInChildren(typeof(CS.X3.Character.X3Character))
            local lipSync = X3Character:GetSubsystem(CS.X3.Character.ISubsystem.Type.LipSync)
            if lipSyncAsset ~= nil and lipSync ~= nil then
                Res.RemoveRefObj(lipSyncAsset, speaker)
                CS_LipSyncWwiseUtil.StopSoundWithLipsync(speaker, wwiseData.eventName, lipSyncAsset)
            else
                WwiseMgr.StopSound3D(wwiseData.eventName, speaker)
            end
        else
            WwiseMgr.StopSound3D(wwiseData.eventName, speaker)
        end
    else
        WwiseMgr.StopSound2D(wwiseData.eventName)
    end
    for i = 1, #self.playedWwiseDataList do
        if self.playedWwiseDataList[i].eventName == wwiseData.eventName then
            self.playedWwiseDataList[i].isPlaying = false
        end
    end
end

---停止所有播放过的Wwise
function DialogueSystem:ClearPlayedWwiseData()
    for i = 1, #self.playedWwiseDataList do
        if self.playedWwiseDataList[i].isMusic and WwiseMgr.GetPlayingMusic() == self.playedWwiseDataList[i].eventName then
            --GameSoundMgr.StopMusic()
        else
            if GameObjectUtil.IsNull(self.playedWwiseDataList[i].speaker) == false then
                WwiseMgr.StopSound3D(self.playedWwiseDataList[i].eventName, self.playedWwiseDataList[i].speaker)
            else
                WwiseMgr.StopSound2D(self.playedWwiseDataList[i].eventName)
            end
        end
        PoolUtil.ReleaseTable(self.playedWwiseDataList[i])
    end
    table.clear(self.playedWwiseDataList)
end

---暂停Wwise及口型动画
function DialogueSystem:PauseWwise()
    Debug.LogFormat("[DialogueSystem]PauseWwise")
    self:PauseLipSync()
    --添加了这个会导致点返回按钮的声音听不到，测试快播音效没有停止的问题 2022/1/11
    --WwiseMgr.PauseSoundVoice()
    DialogueManager.PausePlot(self.dialogueInfoId)
end

---继续Wwise及口型动画
function DialogueSystem:ResumeWwise()
    Debug.LogFormat("[DialogueSystem]ResumeWwise")
    self:ResumeLipSync()
    --添加了这个会导致点返回按钮的声音听不到，测试快播音效没有停止的问题 2022/1/11
    --WwiseMgr.ResumeSoundVoice()
    WwiseMgr.ResumeMusic()
    DialogueManager.ResumePlot(self.dialogueInfoId)
end

--暂停口型动画
function DialogueSystem:PauseLipSync()
    for i = 1, #self.playedWwiseDataList do
        if GameObjectUtil.IsNull(self.playedWwiseDataList[i].speaker) == false then
            CS_LipSyncWwiseUtil.PauseLipsync(self.playedWwiseDataList[i].speaker)
        end
    end
end

--继续口型动画
function DialogueSystem:ResumeLipSync()
    for i = 1, #self.playedWwiseDataList do
        if GameObjectUtil.IsNull(self.playedWwiseDataList[i].speaker) == false then
            CS_LipSyncWwiseUtil.ResumeLipsync(self.playedWwiseDataList[i].speaker)
        end
    end
end

---加载WwiseBnk
---@param bnkName string
function DialogueSystem:LoadWwiseBnk(bnkName)
    if string.isnilorempty(bnkName) == false then
        WwiseMgr.LoadBank(bnkName)
    end
end

---记录播放过的Wwise，在Dialogue销毁时需要清理
---@param eventName string Wwise事件名
---@param isMusic bool 是否是背景音
---@param speaker GameObject 说话人，口型动画用
function DialogueSystem:AddPlayedWwiseData(eventName, isMusic, speaker)
    ---@type PlayedWwiseData
    local wwiseData = PoolUtil.GetTable()
    wwiseData.eventName = eventName
    wwiseData.speaker = speaker
    wwiseData.isMusic = isMusic
    wwiseData.isPlaying = true
    table.insert(self.playedWwiseDataList, #self.playedWwiseDataList + 1, wwiseData)
end
--endregion

--region PreloadBatch
---剩余时间评估
---@param name string
---@param params table 预留参数
---@return float 预估剩余时间，单位秒
function DialogueSystem:EstimateRemainingTime(name, params)
    local remainingTime = Mathf.Infinity
    for _, pipeline in pairs(self.usingPipelineDict) do
        local pipelineRemainTime = pipeline:EstimateRemainingTime(name, params)
        if pipelineRemainTime < remainingTime then
            remainingTime = pipelineRemainTime
        end
    end
    return remainingTime
end
--endregion

--region Action调用接口
---根据Id清除角色
---@param actorId int
function DialogueSystem:ClearActorById(actorId)
    local actor = self.database:GetActor(actorId)
    if actor ~= nil then
        self:ClearActor(self.database:GetActorUniqueKey(actor))
    end
end

---根据Id初始化角色
---@param actorId int
---@return GameObject
function DialogueSystem:InitActorById(actorId)
    local actor = self.database:GetActor(actorId)
    if actor ~= nil then
        return self:InitActor(actor, 0, true)
    end
    return nil
end

---销毁固定物件【客户端】新增业务事件：打开除返回按钮外的其他剧情系统ui
---@param id int
---@param go GameObject
function DialogueSystem:DestroyAssignedGameObject(id, go)
    local gameObjects = self.tempGameObjectDict[id]
    if gameObjects ~= nil then
        if GameObjectUtil.IsNull(go) == false then
            table.removebyvalue(gameObjects, go)
            --直接销毁，不要进池
            GameObjectUtil.Destroy(go)
        end
    end
end

---
---@return DialogueActionHelper
function DialogueSystem:GetActionHelper()
    return self.actionHelper
end

---添加Reletive绑定关系
---@param target Transform
---@param alignTo Transform
function DialogueSystem:AddRelativeCtrl(target, alignTo)
    self:RemoveRelativeCtrl()
    self.mainUIRelativeRestCtrlId = CS.X3Game.RelativeRestCtrl.AddRelativeRestPair(target, alignTo)
end

---移除Relative绑定关系
function DialogueSystem:RemoveRelativeCtrl()
    if self.mainUIRelativeRestCtrlId ~= 0 then
        CS.X3Game.RelativeRestCtrl.RemoveRelativeRestPair(self.mainUIRelativeRestCtrlId, true)
        self.mainUIRelativeRestCtrlId = 0
    end
end
--endregion

--region QuickSequence
---缓存Wwise在Loading完了后恢复，目前BGM和环境音分开缓存
---@param wwiseData WwiseActionData
function DialogueSystem:CacheWwise(wwiseData)
    if wwiseData.soundType == DialogueEnum.WwiseSoundType.Background then
        self.quickSequenceBGMCache = wwiseData
    end
    if wwiseData.soundType == DialogueEnum.WwiseSoundType.Ambient then
        self.quickSequenceAmbientCache = wwiseData
    end
end

---清除BGM缓存
---@param wwiseData WwiseActionData
function DialogueSystem:RemoveCacheBGM()
    self.quickSequenceBGMCache = nil
end

---清楚环境音缓存
---@param eventName string
function DialogueSystem:RemoveCacheAmbient(eventName)
    if self.quickSequenceAmbientCache ~= nil and self.quickSequenceAmbientCache.eventName == eventName then
        self.quickSequenceAmbientCache = nil
    end
end

---缓存音量值
function DialogueSystem:SaveVolume()
    self.voiceVolume = WwiseMgr.GetVoiceVolume()
    self.soundVolume = WwiseMgr.GetSoundVolume()
    WwiseMgr.SetVoiceVolume(0)
    WwiseMgr.SetSoundVolume(0)
end

---恢复音量值
function DialogueSystem:LoadVolume()
    if self.voiceVolume ~= 0 then
        WwiseMgr.SetVoiceVolume(self.voiceVolume)
        self.voiceVolume = 0
    end
    if self.soundVolume ~= 0 then
        WwiseMgr.SetSoundVolume(self.soundVolume)
        self.soundVolume = 0
    end
end

---播放在Recover模式下缓存的Wwise
function DialogueSystem:PlayCachedWwise()
    if self.quickSequenceBGMCache ~= nil then
        GameSoundMgr.PlayMusic(self.quickSequenceBGMCache.eventName)
        self:AddPlayedWwiseData(self.quickSequenceBGMCache.eventName, true, nil)
    else
        GameSoundMgr.StopMusic()
    end
    self.quickSequenceBGMCache = nil
    if self.quickSequenceAmbientCache ~= nil then
        local bnkName = WwiseMgr.GetBankNameWithEventName(self.quickSequenceAmbientCache.eventName)
        if string.isnilorempty(bnkName) == false then
            self:LoadWwiseBnk(bnkName)
            WwiseMgr.PlaySound2D(self.quickSequenceAmbientCache.eventName)
            self:AddPlayedWwiseData(self.quickSequenceAmbientCache.eventName, false, nil)
        end
    end
    self.quickSequenceAmbientCache = nil
end

---
---@param ins GameObject
---@param stateName string
---@param assetPath string
---@param useComAnimState bool
---@param directorWrapMode DirectorWrapMode
---@param setDefault bool
---@param setPerformPosition bool
---@return bool
function DialogueSystem:CacheAnim(ins, ...)
    if self.quickSequenceAnimCache[ins] == nil then
        local data = AnimCacheData.new()
        self.quickSequenceAnimCache[ins] = data
    end
    return self.quickSequenceAnimCache[ins]:CacheAnim(ins, ...)
end

---
function DialogueSystem:PlayCachedAnim()
    for ins, v in pairs(self.quickSequenceAnimCache) do
        v:ResetCachedAnim(ins)
        table.clear(v)
    end
    table.clear(self.quickSequenceAnimCache)
end

---
---@param ins GameObject
function DialogueSystem:ClearCachedAnim(ins)
    if self.quickSequenceAnimCache[ins] ~= nil then
        self.quickSequenceAnimCache[ins]:ClearCachedAnim()
    end
end
--endregion

--region FreeMotion
---从外部启动自由互动
---@param id int 自由互动Id
---@param callback fun 播放完毕的回调
function DialogueSystem:FreeMotionStart(id, callback, ...)
    self:ResetDialogueSpeed()
    self:SwitchAuto(false)
    local playId = FreeMotionMgr.Start(id, callback, ...)
    if playId ~= 0 then
        table.insert(self.playedFreeMotionIdList, playId)
    end
end

---
function DialogueSystem:ClearFreeMotion()
    for _, v in ipairs(self.playedFreeMotionIdList) do
        FreeMotionMgr.Stop(v)
    end
    table.clear(self.playedFreeMotionIdList)
end
--endregion

--region FaceHair

function DialogueSystem:GetPlayerFaceHair()
    return self.playerFaceHairType, self.playerFaceHairId
end

function DialogueSystem:SetPlayerFaceHair(faceHairType, faceHairId)
    self.playerFaceHairType = faceHairType
    self.playerFaceHairId = faceHairId
    if self.playerFaceHairId and self.playerFaceHairId > 0 then
        --应用女主自定义发型
        CharacterMgr.SetPlayerChangeHairCb(handler(self, self.GetPlayerFaceHair))
    else
        --取消女主自定义发型
        CharacterMgr.SetPlayerChangeHairCb(nil)
    end
end

function DialogueSystem:ClearPlayerFaceHair()
    self.playerFaceHairType = nil
    self.playerFaceHairId = nil
    CharacterMgr.SetPlayerChangeHairCb(nil)
end

--endregion

---重载剧情数据
function DialogueSystem:ReloadDatabase()
    if self.database then
        self.database:Reload()
    end
end

---销毁
function DialogueSystem:Dispose()
    self.settingData:Dispose()
    self.settingData = nil
end
return DialogueSystem