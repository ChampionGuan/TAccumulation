---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- 剧情节点字幕控制器
--- Created by 峻峻.
--- DateTime: 2021/6/15 17:37

---@class NodeTextController
local NodeTextController = class("NodeTextController", nil, nil, true)
local DialogueTextUtil = require("Runtime.System.X3Game.Modules.Dialogue.Util.DialogueTextUtil")

---@class DialogueTextData
---@field actorName string 说话人
---@field isPlayer bool 是否是女主
---@field manType int 男主Id
---@field actorId int 说话人Id
---@field dialogue string 文本
---@field useMultiDialogueFullText boolean 是否显示所有文本
---@field dialoguePool string[] 分段字幕所有的文本
---@field index int 分段字幕的index
---@field textLen int 文本长度
---@field dialogueStyleSetting DialogueStyleSetting
---@field followTarget GameObject 如果为目标跟随则需要给GameObject
---@field pipelineKey string|int
---@field nodePlayerId int

function NodeTextController:Init()
    ---@type boolean 文字字幕播放完成
    self.dialogueCpl = false
    ---@type boolean 文字字幕结束
    self.dialogueEnd = false
    ---@type boolean CTS事件帧结束
    self.CTSEventEnd = false
    ---@type boolean 语音结束
    self.voiceEnd = false
    ---@type boolean 点击继续，只有最后一个节点需要继承点击继续的设置
    self.needPause = false
    ---@type string 当前字幕文本
    self.mainDialogue = nil
    ---@type string 分段字幕保留前面文本
    self.multiDialogue = nil
    ---@type string[] 分段字幕的所有文本
    self.dialoguePool = nil
    ---@type int 分段字幕的Index
    self.index = 0
    ---@type boolean 剧情快速播放模式
    self.quickSequenceMode = false
    ---@type boolean CTS快照模式
    self.cutSceneFastMode = false
    ---@type float 节点时长
    self.dialogueDuration = 0
    ---@type float 当前已运行时长
    self.curDuration = 0
    ---@type DialogueEnum.TextClickState
    self.clickState = DialogueEnum.TextClickState.None
    ---@type float 文本显示速度
    self.textSpeed = tonumber(LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUETEXTSPEED))
    ---@type boolean 是否是最后一段文本
    self.isLastText = false
    ---@type boolean 分段字幕中间的需要消耗事件帧
    self.costCTSEvent = false
    ---@type boolean 文本是否初始化
    self.textInited = false
    ---@type DialogueSystem
    self.system = nil
    ---@type DialoguePipeline
    self.pipeline = nil
    ---@type DialogueNodePlayer
    self.nodePlayer = nil
    ---@type int
    self.ctsEventTimeStamp = -1
    ---@type float 收到结束事件帧
    self.endDuration = 0
    ---@type DialogueTextData
    self.textData = nil
    ---@type float 对话框Moveout时长，有些情况需要扣除
    self.moveoutOffset = 0
    ---@type boolean 是否需要显示全部文本，有些分段字幕会需要保留之前的文本
    self.useMultiDialogueFullText = false
    ---@type boolean 消耗Wwise事件
    self.costWwiseEvent = false
    ---@type int 记录CTS事件帧的INDEX
    self.eventIndex = 0
end

--对话要结束
--1、没有文字的
--2、配了点击继续并且玩家已经点出了所有文字，不用等语音结束
--3、没有配点击继续的需要等时长走完
---@return boolean
function NodeTextController:IsEnd()
    return self.dialogueEnd and self.CTSEventEnd and self.voiceEnd
end

---
function NodeTextController:SetVoiceEnd()
    self.voiceEnd = true
end

---设置上下文信息
---@param system DialogueSystem
---@param pipeline DialoguePipeline
---@param nodePlayer DialogueNodePlayer
function NodeTextController:SetContext(system, pipeline, nodePlayer)
    self.system = system
    self.pipeline = pipeline
    self.nodePlayer = nodePlayer
    self.dialogueId = self.pipeline:GetDialogueId()
    self.database = self.pipeline:GetDatabase()
end

---节点初始化
---@param dialogueEntry DialogueEntry 当前节点数据
---@param moveoutOffset float 对话框Moveout时长，有些情况需要扣除
---@param dialoguePool string[] 文本
---@param index int 是否是最后一段文本
---@param useMultiDialogueFullText
function NodeTextController:InitText(dialogueEntry, moveoutOffset, dialoguePool, index, useMultiDialogueFullText)
    local isLastText = index == #dialoguePool
    self.moveoutOffset = moveoutOffset
    local tempPool = PoolUtil.GetTable()
    for i = 1, index do
        table.insert(tempPool, #tempPool + 1, dialoguePool[i])
    end
    self.multiDialogue = table.concat(tempPool)
    PoolUtil.ReleaseTable(tempPool)
    self.dialoguePool = dialoguePool
    self.dialogueEntry = dialogueEntry
    self.mainDialogue = dialoguePool[index]
    self.index = index
    self.useMultiDialogueFullText = useMultiDialogueFullText
   --[[ --是最后一段节点或者分段字幕没有音频的情况下才需要继承点击继续
    if (isLastText and string.isnilorempty(self.mainDialogue) == false)
            or (self.useMultiDialogueFullText and self.costWwiseEvent == false) then
        self.needPause = dialogueEntry.needPause
    else
        self.needPause = false
    end]]
    self.actorName = DialogueTextUtil.GetActorName(self.dialogueId, self.dialogueEntry)
    self.isLastText = isLastText
    if self.costCTSEvent and self.cutSceneFastMode == false then
        self.owner:RegisterCTSEvent(self.CTSEventCallback, self, 1,true)
    else
        self.CTSEventEnd = true
    end
    if self.costWwiseEvent == false or isLastText or self.system:IsInSkipMode() then
        self.voiceEnd = true
    else
        self.pipeline:RegisterWwiseEvent(self.WwiseEventCallback, self)
    end
    if self.quickSequenceMode then
        self:SetDialogueEnd()
    end
    self:CalculateTotalDuration()
end

--region CTSEvent
---CTS事件帧回调
---@param playId int
---@param needPause boolean
---@param timeStamp int 收到事件帧的时间戳
function NodeTextController:CTSEventCallback(playId, eventIndex, needPause, timeStamp)
    self.CTSEventEnd = true
    if needPause then
        if self:IsEnd() == false then
            self:PauseTimelineAndCTS(playId, eventIndex)
        end
        self.eventIndex = eventIndex
    else
        --记录下收到事件帧的时间，如果超过1秒节点还没结束就给个Error
        self.ctsEventTimeStamp = timeStamp
    end
    if self.isLastText == false then
        self.clickState = DialogueEnum.TextClickState.None
    end
end

---暂停Timeline并且执行CTS的Loop
---@param playId int
---@param eventIndex int
function NodeTextController:PauseTimelineAndCTS(playId, eventIndex)
    self.system:PauseCTS(playId, eventIndex)
end
--endregion

--region WwiseEvent
function NodeTextController:WwiseEventCallback()
    self.voiceEnd = true
    if self.dialogueEnd == false then
        WwiseMgr.PausePlotVo()
        self.system:PauseLipSync()
        self.owner:SetWwisePlaying(false)
    end
end
--endregion

---文本节点启动
---@param nodeDuration float 节点配置时长
---@param dialogueTime float 当前节点对话经过时间
function NodeTextController:Start(nodeDuration, dialogueTime)
    if nodeDuration ~= 0 then
        if not self.isLastText then
            self.dialogueDuration = math.min(self.dialogueDuration, nodeDuration - dialogueTime)
        else
            ---最后一个节点跑完所有剩余时长
            self.dialogueDuration = nodeDuration - dialogueTime
        end
    end
end

---节点的Tick
---@param deltaTime float update函数传过来的时长
function NodeTextController:ProcessFrame(deltaTime)
    if self.clickState == DialogueEnum.TextClickState.None then
        self.clickState = DialogueEnum.TextClickState.WaitForClickToEndDialogue
    end
    self.curDuration = self.curDuration + deltaTime
    if self.dialogueEnd == false then
        if self.textInited == false then
            self.textInited = true
            if string.isnilorempty(self.mainDialogue) == false then
                EventMgr.Dispatch("DialoguePanelTextShow", self:GetTextData())
            end
        end

        if self.dialogueCpl == false then
            if self.dialogueDuration > 0 then
                self:UpdateBubbleMaskProgress(self.curDuration / self.dialogueDuration)
            end
            if self.quickSequenceMode == false then
                if self.curDuration >= self.dialogueDuration then
                    self:SetDialogueCpl()
                end
            else
                self:SetDialogueEnd()
            end
        end
    end
    if self.pipeline:GetRecoverDialogueMode() == false then
        if self.ctsEventTimeStamp > 0 then
            self.endDuration = self.endDuration + deltaTime
            if self.endDuration > 1 then
                self.endDuration = 0
                Debug.LogErrorFormat("[DialogueSystem]绿色黄色事件帧已收到但节点未完成，请检查:%s", self.dialogueEntry.uniqueID)
            end
        end
    end
end

---文字字幕播放完成
function NodeTextController:SetDialogueCpl()
    if self.dialogueCpl == false then
        self.dialogueCpl = true
        self:UpdateBubbleMaskProgress(1)
        ---如果有点击继续，需要显示
        if self.needPause then
            self:CheckClickToResume()
        else
            self:SetDialogueEnd()
        end
    end
end

---
---@param progress float
function NodeTextController:UpdateBubbleMaskProgress(progress)
    EventMgr.Dispatch("UpdateBubbleMaskProgress", self:GetTextData().actorId, progress)
end

--检测是否显示点击继续
function NodeTextController:CheckClickToResume()
    if self.owner:CanShowClickToResume() and self.dialogueCpl == true and self.dialogueEnd == false then
        EventMgr.Dispatch("DialoguePanelShowClickToResume", self:GetTextData())
        self.clickState = DialogueEnum.TextClickState.WaitForClickToResume
        if self.system:IsInSkipMode() then
            self:OnDialogueClicked()
        else
            self.system:CheckAutoMode()
        end
    end
end

---传给UI的初始化数据
---@return DialogueTextData
function NodeTextController:GetTextData()
    if self.textData == nil then
        local actor = self.database:GetActor(self.dialogueEntry.actorID)
        self.textData = {}
        self.textData.actorName = self.actorName
        self.textData.isPlayer = actor ~= nil and actor.isPlayer or false
        self.textData.manType = actor ~= nil and actor.manType or 0
        self.textData.actorId = self.dialogueEntry.actorID
        if self.useMultiDialogueFullText then
            self.textData.dialogue = self.multiDialogue
        else
            self.textData.dialogue = self.mainDialogue
        end
        self.textData.useMultiDialogueFullText = self.useMultiDialogueFullText
        self.textData.index = self.index
        self.textData.dialoguePool = self.dialoguePool
        self.textData.textLen = self.textLen
        self.textData.pipelineKey = self.pipeline:GetUniqueId()
        self.textData.nodePlayerId = self.nodePlayer:GetPlayerId()
        self.textData.dialogueStyleSetting = self.database:GetDialogueStyleSetting(self.dialogueEntry.dialogueTypeSetting)
        if self.textData.dialogueStyleSetting.dialoguePositionType == DialogueEnum.DialoguePositionType.Target then
            self.textData.followTarget = self.system:GetDynamicTarget(self.textData.dialogueStyleSetting.dialogueTarget)
        end
    end
    return self.textData
end

---文字字幕结束
function NodeTextController:SetDialogueEnd()
    if self.voiceEnd == false then
        self.voiceEnd = true
        self.pipeline:UnregisterWwiseEventCallback(self.WwiseEventCallback, self)
    elseif self.costWwiseEvent then
        WwiseMgr.ResumePlotVo()
        self.system:ResumeLipSync()
        self.owner:SetWwisePlaying(true)
    end
    self.system:EndAutoTimer()
    self.dialogueEnd = true
    self.pipeline:ResumeUpdate()
end

---计算节点时间
function NodeTextController:CalculateTotalDuration()
    self.textLen = DialogueUtil.GetStrLength(self.mainDialogue)
    if not self.textLen then
        self.textLen = 0
    end
    if self.dialogueDuration == 0 and (self.textLen > 0) then
        local offset = 0
        if self.isLastText then
            offset = (self.needPause or (self.dialogueEntry.conditionType == DialogueEnum.DialogueConditionType.Choice)) and 0 or
                    LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.DIALOGUEAUTOTIME)
        end
        self.dialogueDuration = self.textLen / self.textSpeed + offset
    end
    self.dialogueDuration = self.dialogueDuration - self.moveoutOffset
end

---剧情文本框手动滚动
function NodeTextController:OnBubbleTextManualScrolling()
    if self.clickState == DialogueEnum.TextClickState.WaitForClickToEndDialogue then
        if self.needPause then
            self:SetDialogueCpl()
        end
    end
end

---剧情UI上的点击回调
function NodeTextController:OnDialogueClicked()
    if self.clickState == DialogueEnum.TextClickState.WaitForClickToEndDialogue then
        if self.needPause then
            self:SetDialogueCpl()
        end
    elseif self.clickState == DialogueEnum.TextClickState.WaitForClickToResume then
        if self.isLastText then
            self.owner:SetVoiceEnd()
        end
        self:SetDialogueEnd()
    end
end

---自动点击不可以点掉语音，只能等时长过
function NodeTextController:OnDialogueAutoClicked()
    if self.clickState == DialogueEnum.TextClickState.WaitForClickToResume then
        self:SetDialogueEnd()
    end
end

---剧情UI上的长按回调
function NodeTextController:OnDialogueLongPress()
    if self.clickState ~= DialogueEnum.TextClickState.None then
        self.system:StartLongPressSkipMode()
        self:OnDialogueClicked()
    end
end

---文本节点结束
function NodeTextController:End()
    if self.costCTSEvent and self.eventIndex > 0 then
        self.system:ResumeCTS(self.eventIndex)
    end
    self:Dispose()
end

---销毁逻辑
function NodeTextController:Dispose()
    self.pipeline:UnregisterCTSEvent(self.CTSEventCallback, self)
    self.pipeline:UnregisterWwiseEvent(self.WwiseEventCallback, self)
    self:ReleaseToPool()
end

return NodeTextController