---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2021/12/30 11:40
---

---@class DialogueActionGroup : DialogueBaseAction
local DialogueActionGroup = class("DialogueActionGroup", require("Runtime.System.X3Game.Modules.Dialogue.Action.DialogueBaseAction"), nil, true)

---@class DialogueActionCfg
---@field actionType int
---@field delay float
---@field duration float

---从节点播放行为组
---@param actions DialogueActionCfg[]
---@param endCallback fun
function DialogueActionGroup:InitFromNode(actions, endCallback)
    self.super.OnInit(self)
    ---@type float 行为持续时长
    self.duration = 0
    ---@type DialogueEnum.DialogueActionType
    self.actionType = DialogueEnum.DialogueActionType.ActionGroup
    self:InternalInit(actions, endCallback)
end

---行为里的行为组
---@param cfg DialogueActionCfg
---@param templateCfg DialogueActionCfg
function DialogueActionGroup:OnInit(cfg, templateCfg)
    self.super.OnInit(self, cfg)
    local actions = nil
    local needRelease = false
    if templateCfg and templateCfg.overrideActions then
        needRelease = true
        actions = PoolUtil.GetTable()
        local actionCount = #cfg.dialogueActions
        for i = 1, actionCount do
            local cfgAction = templateCfg.overrideActions[cfg.dialogueActions[i].id] or cfg.dialogueActions[i]
            local realAction = nil
            if templateCfg.mutedAction and table.indexof(templateCfg.mutedAction, cfgAction.id) ~= false then
                realAction = PoolUtil.GetTable()
                realAction.id = cfgAction.id
                realAction.type = DialogueEnum.DialogueActionType.Muted
                realAction.relativeActionId = cfgAction.relativeActionId
                realAction.delayType = cfgAction.delayType
                realAction.delay = cfgAction.delay
                realAction.duration = 0
            else
                realAction = templateCfg.overrideActions[cfg.dialogueActions[i].id] or cfg.dialogueActions[i]
            end
            table.insert(actions, #actions + 1, realAction)
        end
    else
        actions = cfg.dialogueActions
    end
    self:InternalInit(actions)
    if needRelease then
        for _, v in pairs(actions) do
            if v.type == DialogueEnum.DialogueActionType.Muted then
                PoolUtil.ReleaseTable(v)
            end
        end
        PoolUtil.ReleaseTable(actions)
    end
end

---ActionInit
---@param actions DialogueActionCfg[]
---@param endCallback fun
function DialogueActionGroup:InternalInit(actions, endCallback)
    ---@type DialogueBaseAction[] 行为顺序序列，保序执行Action，不能根据Id调换
    self.actionList = PoolUtil.GetTable()
    ---@type table<int, DialogueBaseAction>
    self.actionDict = PoolUtil.GetTable()
    ---@type table<int, float>
    self.actionCplTimeStamp = PoolUtil.GetTable()
    ---@type fun
    self.preloadCallback = nil
    ---@type fun
    self.endCallback = nil
    ---@type int
    self.batchId = 0
    ---@type boolean
    self.cplExceptAfterText = false
    for _, actionCfg in pairs(actions) do
        local realActionCfg = self.database:GetAction(actionCfg)
        local action = DialogueManager.CreateAction(realActionCfg.type)
        if action then
            action:SetContext(self.system, self.pipeline, self.nodeUniqueId, self)
            action:OnInitBaseProperty(actionCfg)
            action:OnInit(realActionCfg, actionCfg.type == DialogueEnum.DialogueActionType.Template and actionCfg or nil)
            self.actionDict[actionCfg.id] = action
            table.insert(self.actionList, action)
        end
    end
    self.endCallback = endCallback
    --初始化完统一开始
    for _, action in pairs(self.actionDict) do
        action:OnPreload()
    end
end

---资源预加载
---@param preloadCallback fun
function DialogueActionGroup:OnPreload(preloadCallback)
    --[[    for _, action in pairs(self.actionList) do
            action:OnPreload()
        end]]
    self.preloadCallback = preloadCallback
    self.batchId = -1
    self:PreloadCpl()
    --[[    self.batchId = ResBatchLoader.LoadAsyncWithoutUI(handler(self, self.PreloadCpl))
        ---非法
        if self.batchId == -1 then
            self:PreloadCpl()
        end]]
end

---预加载回调
function DialogueActionGroup:PreloadCpl()
    if self.batchId == 0 then
        --表示已经被销毁了，即使调用了Unload回调也会来
        return
    end
    if self.state == DialogueEnum.DialogueActionState.None then
        if self.preloadCallback then
            pcall(self.preloadCallback)
            self.preloadCallback = nil
        end
        ---保证能在当帧做OnEnter
        self:Update(0)
    end
end

---ActionUpdate
---@param deltaTime float
function DialogueActionGroup:Update(deltaTime)
    if self.state ~= DialogueEnum.DialogueActionState.Complete then
        self:UpdateDuration(deltaTime)
    end
    if self.state == DialogueEnum.DialogueActionState.None then
        self:CheckEnter()
    end
    if self.state == DialogueEnum.DialogueActionState.Update then
        local allCpl = true
        local cplExceptAfterText = true
        for _, action in pairs(self.actionList) do
            action:Update(deltaTime)
            if action:GetState() == DialogueEnum.DialogueActionState.Complete then
                if self.actionCplTimeStamp[action.id] == nil then
                    self.actionCplTimeStamp[action.id] = self.curTime
                end
            else
                allCpl = false
                if action:IsAfterText() == false then
                    cplExceptAfterText = false
                end
            end
        end
        if allCpl then
            self:Exit()
        end
        if cplExceptAfterText then
            self:CplExceptAfterText()
        end
    end
end

---行为组用来判断行为是否能开始
---@param relativeActionId int 相对的行为id
---@param delay float 相对的延迟
---@return boolean
function DialogueActionGroup:CheckCanStart(relativeActionId, delay)
    local relativeAction = self.actionDict[relativeActionId]
    if relativeAction then
        ---正延迟，只要判断状态+时间就行
        if delay >= 0 then
            return self.actionCplTimeStamp[relativeAction.id] ~= nil and
                    (self.curTime - self.actionCplTimeStamp[relativeAction.id]) >= delay
        else
            return relativeAction:GetLeftTime() <= -delay
        end
    else
        Debug.LogErrorFormat("找不到ActionId,NodeId:%s,RelativeActionId:%s, 直接开始！", tostring(self.nodeUniqueId), tostring(relativeActionId))
    end
    return true
end

---ActionExit
function DialogueActionGroup:OnExit()
    for _, action in pairs(self.actionList) do
        action:Exit()
    end
    if self.batchId ~= 0 then
        ResBatchLoader.UnloadAsync(self.batchId)
        self.batchId = 0
        if self.preloadCallback then
            pcall(self.preloadCallback)
        end
        self.preloadCallback = nil
    end
    if self.endCallback then
        pcall(self.endCallback, self)
    end
    self.endCallback = nil
end

---
function DialogueActionGroup:CplExceptAfterText()
    if self.cplExceptAfterText == false then
        self.cplExceptAfterText = true
        EventMgr.Dispatch("DialogueActionCplExceptAfterText", self.nodeUniqueId)
    end
end

---ActionOnDestroy
function DialogueActionGroup:OnDestroy()
    for _, v in pairs(self.actionList) do
        v:OnDestroy()
    end
    PoolUtil.ReleaseTable(self.actionList)
    self.actionList = nil
    PoolUtil.ReleaseTable(self.actionDict)
    self.actionDict = nil
    PoolUtil.ReleaseTable(self.actionCplTimeStamp)
    self.actionCplTimeStamp = nil
    self.super.OnDestroy(self)
end

return DialogueActionGroup