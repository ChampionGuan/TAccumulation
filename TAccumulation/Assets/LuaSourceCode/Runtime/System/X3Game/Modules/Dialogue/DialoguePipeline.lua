---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2021/12/2 15:09
---

---一条剧情播放Pipeline，可拥有多个Node栈同时播放
---@class DialoguePipeline
local DialoguePipeline = class("DialoguePipeline")
local DialogueNodePlayer = require("Runtime.System.X3Game.Modules.Dialogue.DialogueNodePlayer")

---@type float 显示“资源加载中”的延迟时间
local delayShowIndicatorTime = 1

---@class DialogueCTSEventData
---@field playId int CTS的PlayId
---@field needPause boolean 是否需要暂停，只有Pink和Red需要暂停
---@field timeStamp int 获得事件帧的时间戳
---@field ctsEventIndex int 全局事件帧Index

---@class CTSEventCallbackData
---@field isCostEvent bool 是否需要消耗CTS
---@field callBack fun 注册的回调
---@field target table 注册的目标
---@field waitIndex int 等待的事件帧Index

---@class WwiseEventData
---@field playId int Wwise的PlayId

---@class WwiseEventCallbackData
---@field needCallback bool 是否需要执行回调
---@field callBack fun 注册的回调
---@field target table 注册的目标

---@class DialogueExitData
---@field exitKey string 退出Key
---@field isStop boolean 是否是退出
---@field callback fun 完成回调

---@class DialogueEventData
---@field dialogueText string
---@field menuText string
---@field handler fun 事件结束需要调的回调，用以继续剧情
---@field params string[] 事件配置的参数，对应DialogueFucEvent表
---@field eventID int
---@field exitClickHandler fun
---@field exitHandler fun
---@field exitString string
---@field targetGameObject GameObject 事件绑定的角色
---@field offsetPosition Vector3 偏移坐标
---@field offsetEulerAngles Vector3 偏移角度

---构造函数
function DialoguePipeline:ctor()
    ---@type int|string 播放剧情的唯一Id
    self.uniqueId = 0
    ---@type int
    self.playId = 0
    ---@type DialogueSystem
    self.system = nil
    ---@type DialogueDatabase
    self.database = nil
    ---@type cfg.DialogueInfo
    self.dialogueInfo = nil
    ---@type int
    self.dialogueInfoId = 0
    ---@type boolean 激活状态
    self.isActive = true
    ---@type int pipeline运行时间
    self.pipelineRunningTime = 0
    ---@type table<string, boolean> 暂停DialogueReason，当为空时才能继续
    self.pausingUpdateReason = {}
    ---@type string[] 通过剧情打开的UI列表，清理时需要关闭
    self.openedUICache = {}
    ---@type string[] 通过剧情打开的UIPrefab列表，清理时关闭
    self.openedUIPrefabCache = {}
    ---@type fun
    self.dialogueEndCallback = nil
    ---@type DialogueCTSEventData[] CTS事件的所属PlayId
    self.eventStack = {}
    ---@type CTSEventCallbackData[] CTS事件的Callback
    self.callbackList = {}
    ---@type fun
    self.ctsEventCallback = handler(self, self.SignatureCallback)
    ---@type boolean
    self.needReceiveCTSEvent = true
    ---@type WwiseEventData[]
    self.wwiseEventStack = {}
    ---@type WwiseEventCallbackData[]
    self.wwiseCallbackList = {}
    ---@type fun
    self.wwiseEventCallback = handler(self, self.WwiseEventCallback)
    ---@type int 当前正在播放的行为数量
    self.curPlayingActionCount = 0
    ---@type table<int, DialogueNodePlayer>
    self.nodePlayerDict = {}
    ---@type int
    self.nodePlayerId = 0
    ---@type NodeGraph 当前正在执行的NodeGraph的Key
    self.curNodeGraph = nil
    ---@type int[]
    self.playedActionNodeList = {}
    ---@type int 当前正在执行的剧情子BatchId
    self.nodeBatchId = 0
    ---@type int 资源加载的延迟Timer
    self.delayShowIndicatorTimer = 0
    ---@type int 已经收到的事件帧数量
    self.receivedCTSEventCnt = 0
    ---@type int 已经消耗掉的事件帧数量
    self.costedCTSEventCnt = 0
    ---@type DialogueActionGroup[]
    self.actionGroups = {}
    ---@type boolean
    self.fastForwardMode = false
    ---@type string
    self.captureWndMotionKey = nil
    ---@type table<int, int> 节点循环次数记录
    self.loopedCountDict = {}
    ---@type table<int, float> 节点循环时间记录
    self.loopStartTimeDict = {}
    ---@type DialogueExitData 剧情退出数据
    self.exitData = {}
    ---@type DialogueReviewData[] 剧情历史记录
    self.reviewList = {}
    ---@type GameObject
    self.cameraGO = nil
    ---@type table<int, number> 记录节点字幕结束的时间，用来做行为延迟用
    self.nodeTextEndTime = {}
    --region Recover用
    ---@type boolean 回放模式
    self.recoverDialogueMode = false
    ---@type string Recover模式下缓存的GraphKey
    self.cachedNodeGraphKey = nil
    --endregion
    --region Debug用
    ---@type table<int>
    self.playedRuntimeEntries = {}
    --endregion
end

--region Get/Set
---返回Pipeline唯一Id
---@return int|string
function DialoguePipeline:GetUniqueId()
    return self.uniqueId
end

---设置Pipeline唯一Id
---@param uniqueId int|string
function DialoguePipeline:SetUniqueId(uniqueId)
    self.uniqueId = uniqueId
end

---返回唯一播放Id
---@return int
function DialoguePipeline:GetPlayId()
    return self.playId
end

---获取是否是快照模式
---@return boolean
function DialoguePipeline:GetFastForwardMode()
    return self.fastForwardMode
end

---@param value boolean
function DialoguePipeline:SetFastForwardMode(value)
    self.fastForwardMode = value
end

---返回当前剧情Id
---@return int
function DialoguePipeline:GetDialogueId()
    return self.dialogueInfo and self.dialogueInfo.ID or 0
end

---返回当前剧情配置
---@return DialogueDatabase
function DialoguePipeline:GetDatabase()
    return self.database
end

---返回当前正在运行的Timeline的数量
---@return int
function DialoguePipeline:GetCurPlayingActionCount()
    return self.curPlayingActionCount
end

---返回当前Pipeline已运行的时间
---@return float
function DialoguePipeline:GetPipelineRunningTime()
    return self.pipelineRunningTime
end

---记录节点字幕结束时间
---@param uniqueId
function DialoguePipeline:SaveNodeTextEndTime(uniqueId)
    self.nodeTextEndTime[uniqueId] = self.pipelineRunningTime
end

---记录节点字幕结束时间
---@param uniqueId
function DialoguePipeline:ResetNodeTextEndTime(uniqueId)
    self.nodeTextEndTime[uniqueId] = 0
end

---获取节点字幕结束时间
---@param uniqueId int
function DialoguePipeline:GetNodeTextEndTime(uniqueId)
    if self.nodeTextEndTime[uniqueId] then
        return self.nodeTextEndTime[uniqueId]
    else
        return 0
    end
end

---返回退出数据
---@return DialogueExitData
function DialoguePipeline:GetExitData()
    return self.exitData
end

---是否是回放模式
---@return boolean
function DialoguePipeline:GetRecoverDialogueMode()
    return self.recoverDialogueMode
end

---获取已经消耗的事件帧数量
---@return int
function DialoguePipeline:GetCostedCTSEventCnt()
    return self.costedCTSEventCnt
end
--endregion

---初始化函数
---@param dialogueSystem DialogueSystem
---@param dialogueInfoId int
function DialoguePipeline:OnInit(dialogueSystem, dialogueInfoId)
    ---正在运行中
    if self.dialogueInfoId ~= 0 then
        Debug.LogFormat("[DialogueSystem]Pipeline正在播放，强制结束-%s-%s", self.dialogueInfoId, self.uniqueId)
        if self.exitData.callback then
            pcall(self.exitData.callback)
            table.clear(self.exitData)
        end
        self:EndDialogue(false, true)
    end
    self.system = dialogueSystem
    self.dialogueInfoId = dialogueInfoId
    self.dialogueInfo = LuaCfgMgr.Get("DialogueInfo", dialogueInfoId)
    self.database = DialogueManager.LoadDatabase(self.dialogueInfo.Name)
    CutSceneMgr.RegisterEventCallback(self.ctsEventCallback)
    WwiseMgr.RegisterMarkerEventCallback(self.wwiseEventCallback)
    EventMgr.AddListener("DialoguePanelStopLongPress", self.OnStopDialogueLongPress, self)
end

---开始播放一个Conversation
---@param startConversation Conversation 开始Conversation
---@param nodeId int 节点Id
---@param dialogueEndCallback fun 剧情结束回调
function DialoguePipeline:StartDialogue(startConversation, nodeId, dialogueEndCallback)
    EventMgr.AddListener("CameraTimelinePlayed", self.CameraTimelinePlayed, self)
    self.dialogueEndCallback = dialogueEndCallback
    self.playId = DialogueManager.GetPlayId()
    local nodePlayer = self:GetNewNodePlayer()
    local started = nodePlayer:StartDialogue(startConversation, nodeId)
    if started == false then
        self.dialogueEndCallback = nil
        if nil ~= dialogueEndCallback then
            dialogueEndCallback(self.playId)
        end
    end
end

---收到Timeline播放事件隐藏Loading
---@param uniqueId int
function DialoguePipeline:CameraTimelinePlayed(uniqueId)
    if uniqueId == self.uniqueId then
        UICommonUtil.SetLoadingProgress(1, true)
        self:CloseCaptureWnd()
        if self.system:GetSettingData():GetAutoCloseWhiteScreen() then
            UICommonUtil.CloseScreen()
        end
    end
end

---隐藏截屏
---@param uniqueId int
function DialoguePipeline:HideCaptureWnd(uniqueId)
    if uniqueId == self.uniqueId then
        self:CloseCaptureWnd()
    end
end

---关闭截图界面
function DialoguePipeline:CloseCaptureWnd()
    UICommonUtil.SetCaptureEnable(false, nil, self.captureWndMotionKey)
    self.captureWndMotionKey = nil
end

---设置下次关闭截图界面时的动效
---@param motionKey string
function DialoguePipeline:SetCaptureWndMotion(motionKey)
    Debug.LogFormat("[DialogueSystem]设置MotionKey-%s", motionKey)
    self.captureWndMotionKey = motionKey
end

---根据配置数据重新播放一个剧情
---@param replayData table
---@param recoverUpdateCallback fun 恢复过程回调
---@param dialogueEndCallback fun 播放完成回调
function DialoguePipeline:ReplayDialogue(replayData, recoverUpdateCallback, dialogueEndCallback)
    self.playId = DialogueManager.GetPlayId()
    self.dialogueEndCallback = dialogueEndCallback
    local nodePlayer = DialogueNodePlayer.new()
    local replayStarted = nodePlayer:ReplayDialogue(replayData, recoverUpdateCallback)
    if replayStarted == false then
        self.dialogueEndCallback = nil
        if nil ~= dialogueEndCallback then
            dialogueEndCallback(self.playId)
        end
    end
end

---根据配置数据恢复一个剧情并且继续播放
---@param dialogueRecordList table
---@param recoverUpdateCallback fun 恢复过程回调
---@param endCallback fun 播放完成回调
function DialoguePipeline:RecoverDialogue(dialogueRecordList, recoverUpdateCallback, endCallback)
    EventMgr.AddListener("CameraTimelinePlayed", self.HideCaptureWnd, self)
    self.recoverDialogueMode = true
    self.playId = DialogueManager.GetPlayId()
    self.dialogueEndCallback = endCallback
    local player = self:GetNewNodePlayer()
    player:RecoverDialogue(dialogueRecordList, recoverUpdateCallback, handler(self, self.RecoverDialogueComplete))
end

---播放某一段Conversation
---@param startConversationId int 起始ConversationID
---@param startNodeId int 起始节点ID
---@param endConversationId int 结束ConversationID
---@param endNodeId int 结束节点ID
---@param dialogueEndCallback fun 播放完成回调
function DialoguePipeline:StartDialogueRange(startConversationId, startNodeId,
                                             endConversationId, endNodeId,
                                             dialogueEndCallback)
    self.playId = DialogueManager.GetPlayId()
    self.dialogueEndCallback = dialogueEndCallback
    local player = self:GetNewNodePlayer()
    local started = player:StartDialogueRange(startConversationId, startNodeId,
            endConversationId, endNodeId)
    if started == false then
        self.dialogueEndCallback = nil
        if dialogueEndCallback ~= nil then
            dialogueEndCallback(self.playId)
        end
    end
end

---剧情恢复结束
function DialoguePipeline:RecoverDialogueComplete()
    self.system:RecoverDialogueComplete()
    self.recoverDialogueMode = false
    self:ChangeNodeGraph(self.cachedNodeGraphKey)
    self.cachedNodeGraphKey = nil
    self.fastForwardMode = false
    EventMgr.RemoveListener("CameraTimelinePlayed", self.HideCaptureWnd, self)
    EventMgr.AddListener("CameraTimelinePlayed", self.CameraTimelinePlayed, self)
    EventMgr.Dispatch("RecoverComplete")
end

---结束剧情
---@param isExit boolean 是否是退出
---@param forceEnd boolean 是否是强制结束
function DialoguePipeline:EndDialogue(isExit, forceEnd)
    Debug.LogFormat("[DialogueSystem]EndDialogue:%s-%s", isExit, forceEnd)
    if self.dialogueInfoId ~= 0 then
        if isExit == nil then
            isExit = false
        end
        if forceEnd == nil then
            forceEnd = false
        end
        self.dialogueInfoId = 0
        self.pipelineRunningTime = 0
        for _, actionGroup in pairs(self.actionGroups) do
            actionGroup:Exit()
        end
        table.clear(self.actionGroups)
        self.curPlayingActionCount = 0
        self.needEndDialogueEntry = nil
        self.system:StopSkipMode()
        self.recoverDialogueMode = false
        self.dialogueRecoverUpdateCallback = nil
        for _, nodePlayer in pairs(self.nodePlayerDict) do
            nodePlayer:Dispose()
        end
        table.clear(self.nodePlayerDict)
        self:ClearReviewList()
        table.clear(self.exitData)
        table.clear(self.waitNodeQueue)
        table.clear(self.pausingUpdateReason)
        table.clear(self.loopedCountDict)
        table.clear(self.loopStartTimeDict)
        self.isActive = true
        self:StopNodeGraph()
        table.clear(self.eventStack)
        table.clear(self.callbackList)
        CutSceneMgr.UnregisterEventCallback(self.ctsEventCallback)
        WwiseMgr.UnregisterMarkerEventCallback(self.wwiseEventCallback)
        self.receivedCTSEventCnt = 0
        self.costedCTSEventCnt = 0
        self:StopDelayShowIndicator()
        self:CloseOpenedWindow()
        if UNITY_EDITOR then
            table.clear(self.playedRuntimeEntries)
        end
        EventMgr.RemoveListenerByTarget(self)
        self.system:PipelineDialogueEnded(self.uniqueId, forceEnd)
        if forceEnd == false then
            EventMgr.Dispatch("DialoguePanelHide", self.uniqueId)
        end
        local system = self.system
        self.system = nil
        self.database = nil
        if isExit == false then
            local dialogueEndCallback = self.dialogueEndCallback
            self.dialogueEndCallback = nil
            --这个回调很有可能又开始播放剧情走到了这个Pipeline的OnInit，所以放在最后
            if dialogueEndCallback ~= nil then
                dialogueEndCallback(self.playId)
            end
        else
            self.dialogueEndCallback = nil
        end
        system:CheckAllPipelineEnded()
    end
end

---获取一个新的节点播放器
---@return DialogueNodePlayer
function DialoguePipeline:GetNewNodePlayer()
    local player = DialogueNodePlayer.new()
    self.nodePlayerId = self.nodePlayerId + 1
    player:SetContext(self.nodePlayerId, self.system, self, self.database)
    self.nodePlayerDict[self.nodePlayerId] = player
    return player
end

---@return DialogueNodePlayer
function DialoguePipeline:StartSubPlayer(ownerPlayer, link)
    local dialogueEntry = self.database:GetDialogueEntryByLink(link)
    local subPlayer = self:GetNewNodePlayer()
    subPlayer:NeedSaveProcess(false)
    subPlayer:StartDialogue(self.database:GetConversation(dialogueEntry.conversationID), dialogueEntry.id)
    ownerPlayer:WaitSubPlayer(subPlayer:GetPlayerId())
end

---Player是否播放完毕
---@return boolean
function DialoguePipeline:IsPlayerCpl(playerId)
    local player = self.nodePlayerDict[playerId]
    if player == nil then
        return true
    else
        return player:IsComplete()
    end
end

---返回循环次数
---@param uniqueId int 节点Id
---@return boolean
function DialoguePipeline:GetLoopedCount(uniqueId)
    if self.loopedCountDict[uniqueId] then
        return self.loopedCountDict[uniqueId]
    end
    return 0
end

---设置循环次数
---@param uniqueId int 节点Id
---@param value int 循环次数
function DialoguePipeline:SetLoopedCount(uniqueId, value)
    self.loopedCountDict[uniqueId] = value
end

---返回开始循环的时间
---@param uniqueId int 节点Id
---@return boolean
function DialoguePipeline:GetLoopStartTime(uniqueId)
    return self.loopStartTimeDict[uniqueId]
end

---设置开始循环时间
---@param uniqueId int 节点Id
---@param value int 循环次数
function DialoguePipeline:SetLoopStartTime(uniqueId, value)
    self.loopStartTimeDict[uniqueId] = value
end

---打开UI的接口，记录下所有通过剧情开过的UI
---@param name string wnd名字
---@param arg DialogueEventData 参数
function DialoguePipeline:OpenWindow(name, arg)
    if table.containskey(self.openedUICache, name) == false then
        table.insert(self.openedUICache, #self.openedUICache + 1, name)
    end
    UIMgr.Open(name, arg)
end

---关闭UI
---@param name string wnd名字
function DialoguePipeline:CloseWindow(name)
    table.removebyvalue(self.openedUICache, name)
    UIMgr.Close(name)
end

---打开一个UIPrefab
---@param name string
function DialoguePipeline:OpenUIPrefab(name, arg)
    if table.containskey(self.openedUIPrefabCache, name) == false then
        table.insert(self.openedUIPrefabCache, #self.openedUIPrefabCache + 1, name)
        EventMgr.Dispatch("OpenUIPrefab", name , arg)
    end
end

---关闭一个UIPrefab
---@param name string
function DialoguePipeline:CloseUIPrefab(name, arg)
    if table.indexof(self.openedUIPrefabCache, name) ~= false then
        table.removebyvalue(self.openedUIPrefabCache, name)
        EventMgr.Dispatch("CloseUIPrefab", name , arg)
    end
end

---关闭所有通过剧情打开的Window
function DialoguePipeline:CloseOpenedWindow()
    for i = 1, #self.openedUICache do
        UIMgr.Close(self.openedUICache[i])
    end
    table.clear(self.openedUICache)
    for i = 1, #self.openedUIPrefabCache do
        EventMgr.Dispatch("CloseUIPrefab", self.openedUIPrefabCache[i])
    end
    table.clear(self.openedUIPrefabCache)
end

---切换场景
---@param sceneName string
---@param callback fun
function DialoguePipeline:ChangeScene(sceneName, callback)
    if self.recoverDialogueMode == false and
            string.isnilorempty(sceneName) == false then
        self.system:ChangeScene(sceneName, callback)
    else
        pcall(callback)
    end
end

---PipelineTick
---@param deltaTime float
function DialoguePipeline:Update(deltaTime)
    if self.isActive then
        self.pipelineRunningTime = self.pipelineRunningTime + deltaTime
    end
    self:UpdateAction(deltaTime)
    self:UpdateNode(deltaTime)
end

---节点Tick
---@param deltaTime float
function DialoguePipeline:UpdateNode(deltaTime)
    if self.isActive == false then
        return
    end
    local nodePlayerRunningCnt = 0
    for _, nodePlayer in pairs(self.nodePlayerDict) do
        nodePlayer:UpdateNode(deltaTime)
        if nodePlayer:IsRunning() then
            nodePlayerRunningCnt = nodePlayerRunningCnt + 1
        end
    end
    if nodePlayerRunningCnt == 0 then
        if self.curPlayingActionCount <= 0 then
            self:EndDialogue()
        else
            self.system:ResumeCTS()
        end
    end
    EventMgr.Dispatch("DialogueUpdate")
end

---行为Tick
---@param deltaTime float
function DialoguePipeline:UpdateAction(deltaTime)
    ---等待点击继续，等待QTE,等待选项都会暂停导致不Tick
    --[[    if self.isActive == false then
            return
        end]]
    for _, actionGroup in pairs(self.actionGroups) do
        actionGroup:Update(deltaTime)
    end
end

---暂停播放队列
function DialoguePipeline:Pause()
    self:PauseUpdate("Active")
end

---继续播放队列
function DialoguePipeline:Resume()
    self:ResumeUpdate("Active")
end

---
function DialoguePipeline:IsRunning()
    return self.isActive == true
end

---暂停剧情
---@param reason string 暂停原因
function DialoguePipeline:PauseUpdate(reason)
    if reason == nil then
        reason = "Default"
    end
    local reasonCnt = table.nums(self.pausingUpdateReason, reason)
    if reasonCnt == 0 then
        Debug.LogFormat("[DialogueSystem]PipelinePause:%s-%s", self.uniqueId, reason)
        self.isActive = false
    end
    self.pausingUpdateReason[reason] = true
end

---继续剧情
---@param reason string 暂停原因
function DialoguePipeline:ResumeUpdate(reason)
    if reason == nil then
        reason = "Default"
    end
    self.pausingUpdateReason[reason] = nil
    local reasonCnt = table.nums(self.pausingUpdateReason, reason)
    if reasonCnt == 0 then
        Debug.LogFormat("[DialogueSystem]PipelineResume:%s-%s", self.uniqueId, reason)
        self.isActive = true
    end
end

---以某种退出方式暂停播放
---@param exitKey string 退出方式Key
---@param callback fun 结束回调
function DialoguePipeline:PauseWithExitKey(exitKey, callback)
    if string.isnilorempty(exitKey) or self.isActive == false or self.pausingUpdateReason["Default"] == true then
        for _, nodePlayer in pairs(self.nodePlayerDict) do
            nodePlayer:PauseWithExitKey()
        end
        Debug.LogFormat("[DialogueSystem]退出方式为空或当前正在暂停状态中")
        self:ClearActions()
        self:Pause()
        pcall(callback)
    else
        if string.isnilorempty(self.exitData.exitKey) == false then
            if self.exitData.isStop == false then
                pcall(self.exitData.callback)
                Debug.LogFormat("[DialogueSystem]有退出方式未执行完成，立刻结束")
                self.exitData.exitKey = exitKey
                self.exitData.callback = callback
                self.exitData.isStop = false
            else
                Debug.LogFormat("[DialogueSystem]暂停失败，当前有退出方式'停止'未执行完成，立刻结束-%s", self.exitData.exitKey)
                pcall(callback)
            end
        else
            self.exitData.exitKey = exitKey
            self.exitData.callback = callback
            self.exitData.isStop = false
            Debug.LogFormat("[DialogueSystem]启动退出方式%s暂停剧情%s", exitKey, self.uniqueId)
        end
        for _, nodePlayer in pairs(self.nodePlayerDict) do
            nodePlayer:CheckPlayerOperation()
        end
    end
end

---以某种退出方式停止播放
---@param exitKey string 退出方式Key
---@param callback fun 结束回调
function DialoguePipeline:StopWithExitKey(exitKey, callback)
    if string.isnilorempty(exitKey) or self.isActive == false or self.pausingUpdateReason["Default"] == true then
        self:EndDialogue()
        pcall(callback)
    else
        if string.isnilorempty(self.exitData.exitKey) == false then
            pcall(self.exitData.callback)
            Debug.LogFormat("[DialogueSystem]%s", "有退出方式未执行完成，立刻结束")
        end
        self.exitData.exitKey = exitKey
        self.exitData.callback = callback
        self.exitData.isStop = true
        Debug.LogFormat("[DialogueSystem]启动退出方式%s停止剧情%s", exitKey, self.uniqueId)
        for _, nodePlayer in pairs(self.nodePlayerDict) do
            nodePlayer:CheckPlayerOperation()
        end
    end
end

---根据退出方式退出完毕
function DialoguePipeline:ExitCpl()
    if self.exitData then
        if self.exitData.isStop then
            Debug.LogFormat("[DialogueSystem]退出方式完成%s停止剧情%s", self.exitData.exitKey, self.uniqueId)
            self:EndDialogue()
        else
            Debug.LogFormat("[DialogueSystem]退出方式完成%s暂停剧情%s", self.exitData.exitKey, self.uniqueId)
            self:ClearActions()
            self:Pause()
        end
        pcall(self.exitData.callback)
        table.clear(self.exitData)
    end
end

---从退出方式继续
function DialoguePipeline:ResumeExitKey()
    if string.isnilorempty(self.exitData.exitKey) == false then
        if self.exitData.isStop == false then
            pcall(self.exitData.callback)
            table.clear(self.exitData)
            self:Resume()
        end
    else
        self:Resume()
    end
end

---增加一条历史记录
---@param data DialogueReviewData
function DialoguePipeline:AddReviewList(data)
    table.insert(self.reviewList, #self.reviewList + 1, data)
end

---清理历史记录
function DialoguePipeline:ClearReviewList()
    table.clear(self.reviewList)
end

---获得历史记录
---@return table<DialogueReviewData>
function DialoguePipeline:GetReviewList()
    return self.reviewList
end

---播放行为
---@param uniqueId int
---@param actions table<DialogueActionCfg>
---@param endCallback fun
function DialoguePipeline:PlayAction(uniqueId, actions)
    if actions and #actions > 0 then
        self.curPlayingActionCount = self.curPlayingActionCount + 1
        self:PauseUpdate("LoadAction")
        self:StartDelayShowIndicator()
        local actionGroup = DialogueManager.CreateAction(DialogueEnum.DialogueActionType.ActionGroup)
        table.insert(self.actionGroups, #self.actionGroups + 1, actionGroup)
        actionGroup:SetContext(self.system, self, uniqueId)
        actionGroup:InitFromNode(actions, function(actionGroup)
            self.curPlayingActionCount = self.curPlayingActionCount - 1
            EventMgr.Dispatch("DialogueActionCpl", uniqueId)
            table.removebyvalue(self.actionGroups, actionGroup)
        end)
        actionGroup:OnPreload(handler(self, self.ActionInitedCallback))
    else
        EventMgr.Dispatch("DialogueActionCpl", uniqueId)
    end
end

---清理行为
function DialoguePipeline:ClearActions()
    for _, actionGroup in pairs(self.actionGroups) do
        actionGroup:Exit()
    end
    table.clear(self.actionGroups)
end

---加载行为用的相机
---@return GameObject
function DialoguePipeline:LoadCamera()
    if GameObjectUtil.IsNull(self.cameraGO) then
        self.cameraGO = Res.LoadGameObject("Assets/Build/Res/GameObjectRes/Camera/CameraAnimationState.prefab")
        GameObjectUtil.SetActive(self.cameraGO, true)
    end
    return self.cameraGO
end

---
function DialoguePipeline:DestroyCamera()
    if self.cameraGO then
        GameObjectUtil.SetActive(self.cameraGO, false)
        Res.DiscardGameObject(self.cameraGO)
        self.cameraGO = nil
    end
end

---Action初始化回调
function DialoguePipeline:ActionInitedCallback()
    self:StopDelayShowIndicator()
    self:ResumeUpdate("LoadAction")
end

---显隐资源加载中界面
---@param value boolean 显示或隐藏资源加载中界面
function DialoguePipeline:SetIndicatorEnable(value)
    if value then
        if UIMgr.IsOpened(UIConf.LoadingWnd) == false then
            UIMgr.Open(UIConf.PreloadBatchWnd, true)
        end
    else
        UIMgr.Close(UIConf.PreloadBatchWnd)
    end
end

---延迟显示资源加载中
function DialoguePipeline:StartDelayShowIndicator()
    --重新计时
    if self.delayShowIndicatorTimer ~= 0 then
        TimerMgr.Discard(self.delayShowIndicatorTimer)
        self.delayShowIndicatorTimer = 0
    end
    self.delayShowIndicatorTimer = TimerMgr.AddTimer(delayShowIndicatorTime, function()
        self:SetIndicatorEnable(true)
    end)
end

---停止延迟显示资源加载中
function DialoguePipeline:StopDelayShowIndicator()
    if self.delayShowIndicatorTimer ~= 0 then
        TimerMgr.Discard(self.delayShowIndicatorTimer)
        self.delayShowIndicatorTimer = 0
    end
    self:SetIndicatorEnable(false)
end

---停止长按
function DialoguePipeline:OnStopDialogueLongPress()
    self.system:StopLongPressSkipMode()
end

--region CTSEvent
---注册事件帧回调
---@param callback fun
---@param target table
---@param waitCnt int
---@param isCostEvent boolean 是否消耗事件帧
function DialoguePipeline:RegisterCTSEvent(callback, target, waitCnt, isCostEvent)
    local index = -1
    for i = 1, #self.callbackList do
        if self.callbackList[i].callBack == callback and self.callbackList[i].target == target then
            index = i
            break
        end
    end
    if index == -1 then
        ---@type CTSEventCallbackData
        local data = PoolUtil.GetTable()
        data.isCostEvent = isCostEvent
        data.callBack = callback
        data.target = target
        data.waitIndex = waitCnt
        Debug.LogFormat("[DialogueSystem]注册事件帧回调%s-%s", waitCnt, isCostEvent)
        table.insert(self.callbackList, #self.callbackList + 1, data)
    end
    self:CheckTriggerEvent()
end

---取消注册事件帧回调
---@param callback fun
---@param target table
function DialoguePipeline:UnregisterCTSEvent(callback, target)
    local index = -1
    for i = 1, #self.callbackList do
        if self.callbackList[i].callBack == callback and self.callbackList[i].target == target then
            index = i
            break
        end
    end
    if index ~= -1 then
        table.remove(self.callbackList, index)
    end
end

---事件帧回调
---@param evtData CS.PapeGames.CutScene.CutSceneEventData
function DialoguePipeline:SignatureCallback(evtData)
    if self.needReceiveCTSEvent == false then return end
    if evtData.EventType == CutSceneEventType.KeyFrame then
        self.receivedCTSEventCnt = self.receivedCTSEventCnt + 1
        local evtName = evtData.Data.EventName
        ---@type boolean 本次Pause是否需要同时触发Idle，只有红帧才会触发QTE，关键帧名字分为："YellowEventMarker", "GreenEventMarker", "RedEventMarker", "PinkEventMarker"
        local needPause = (evtName == "RedEventMarker" or evtName == "PinkEventMarker")
        ---@type DialogueCTSEventData
        local eventData = PoolUtil.GetTable()
        eventData.playId = evtData.PlayId
        eventData.needPause = needPause
        eventData.timeStamp = TimerMgr.GetCurTimeSeconds()
        eventData.ctsEventIndex = self.receivedCTSEventCnt
        table.insert(self.eventStack, #self.eventStack + 1, eventData)
        --如果当前没有注册任何事件回调，则需要执行Loop逻辑，不然是否暂停就交给注册事件自己处理
        if self:HasTriggerEvent() == false then
            if needPause then
                self.system:PauseCTS(evtData.PlayId, evtData.ctsEventIndex)
            end
        else
            self:CheckTriggerEvent()
        end
    elseif evtData.EventType == CutSceneEventType.ReachEnd then
        if self.system:GetSettingData():GetCaptureTextureByCTSCpl() then
            self:PauseUpdate("CaptureTexture")
            UICommonUtil.SetCaptureEnable(true, function()
                self:ResumeUpdate("CaptureTexture")
            end)
            self.system:GetSettingData():SetCaptureTextureByCTSCpl(false)
        end
        if self.system:GetSettingData():GetEndDialogueByCTSCpl() then
            self:EndDialogue()
        end
    end
end

---是否有已经注册的事件回调
---@return boolean
function DialoguePipeline:HasTriggerEvent()
    if #self.eventStack > 0 then
        if #self.callbackList > 0 then
            return true
        end
    end
    return false
end

---检查事件帧回调
function DialoguePipeline:CheckTriggerEvent()
    if #self.eventStack > 0 then
        ---@type DialogueCTSEventData
        local ctsEventData = self.eventStack[1]
        local needReleaseEventData = false
        local callbackCnt = #self.callbackList
        local needRemoveCallback = nil
        for i = callbackCnt, 1, -1 do
            local callbackData = self.callbackList[i]
            if callbackData.waitIndex <= ctsEventData.ctsEventIndex then
                if needRemoveCallback == nil then
                    needRemoveCallback = {}
                end
                if callbackData.isCostEvent then
                    needReleaseEventData = true
                end
                table.insert(needRemoveCallback, #needRemoveCallback + 1, table.remove(self.callbackList, i))
            end
            --self:CheckTriggerEvent()
        end
        --扣除事件帧再统一移除
        if needReleaseEventData then
            self.costedCTSEventCnt = self.costedCTSEventCnt + 1
            table.remove(self.eventStack, 1)
            Debug.LogFormat("[DialogueSystem]消耗事件帧%s", self.costedCTSEventCnt)
        end
        if needRemoveCallback then
            for j = 1, #needRemoveCallback do
                local callbackData = needRemoveCallback[j]
                callbackData.callBack(callbackData.target, ctsEventData.playId, ctsEventData.ctsEventIndex, ctsEventData.needPause, ctsEventData.timeStamp)
                PoolUtil.ReleaseTable(callbackData)
            end
        end
        if needReleaseEventData then
            PoolUtil.ReleaseTable(ctsEventData)
        end
    end
end

---当发出事件去玩法时，不侦听事件帧
---@param value boolean
function DialoguePipeline:NeedReceiveCTSEvent(value)
    self.needReceiveCTSEvent = value
end
--endregion

--region WWiseEvent
---注册事件帧回调
---@param callback fun
---@param target table
function DialoguePipeline:RegisterWwiseEvent(callback, target)
    ---@type WwiseEventCallbackData
    local data = PoolUtil.GetTable()
    data.callBack = callback
    data.target = target
    data.needCallback = true
    Debug.LogFormat("[DialogueSystem]注册Wwise事件帧回调")
    table.insert(self.wwiseCallbackList, #self.wwiseCallbackList + 1, data)
    self:CheckWwiseTriggerEvent()
end

---取消注册事件帧回调
---@param callback fun
---@param target table
function DialoguePipeline:UnregisterWwiseEvent(callback, target)
    local index = -1
    for i = 1, #self.wwiseCallbackList do
        if self.wwiseCallbackList[i].callBack == callback and self.wwiseCallbackList[i].target == target then
            index = i
            break
        end
    end
    if index ~= -1 then
        table.remove(self.wwiseCallbackList, index)
    end
end

---仅
---@param callback fun
---@param target table
function DialoguePipeline:UnregisterWwiseEventCallback(callback, target)
    local index = -1
    for i = 1, #self.wwiseCallbackList do
        if self.wwiseCallbackList[i].callBack == callback and self.wwiseCallbackList[i].target == target then
            self.wwiseCallbackList[i].needCallback = false --只占位，不执行回调
            break
        end
    end
end

---
function DialoguePipeline:CheckWwiseTriggerEvent()
    if #self.wwiseEventStack > 0 then
        ---@type WwiseEventData
        local wwiseEventData = table.remove(self.wwiseEventStack, 1)
        ---@type WwiseEventCallbackData
        local callbackData = table.remove(self.wwiseCallbackList, 1)
        if callbackData.needCallback and callbackData.callBack then
            callbackData.callBack(callbackData.target)
        end
        PoolUtil.ReleaseTable(callbackData)
        PoolUtil.ReleaseTable(wwiseEventData)
    end
end

---
function DialoguePipeline:WwiseEventCallback()
    if self:IsRunning() and self:HasWwiseTriggerEvent() then
        ---@type DialogueCTSEventData
        local eventData = PoolUtil.GetTable()
        table.insert(self.wwiseEventStack, #self.wwiseEventStack + 1, eventData)
        self:CheckWwiseTriggerEvent()
    end
end

---是否有Wwise事件需要触发
---@return boolean
function DialoguePipeline:HasWwiseTriggerEvent()
    if #self.wwiseCallbackList > 0 then
        return true
    end
    return false
end
--endregion

---切换剧情子树
---@param nodeGraphKey string
---@param entryId int
function DialoguePipeline:ChangeNodeGraph(nodeGraphKey, entryId)
    if self.system:GetSettingData():GetUseNodeGraph() then
        if self.database:IsNodeGraphStart(nodeGraphKey) then
            if self.recoverDialogueMode then
                self.cachedNodeGraphKey = nodeGraphKey
            else
                self:StopNodeGraph()
                self.nodeBatchId = PreloadBatchMgr.StartNode(PreloadBatchType.Dialogue, nodeGraphKey)
                self.curNodeGraph = self.database:GetNodeGraph(nodeGraphKey)
                local warmupSVCList = self.database:GetWarmupSVCList(nodeGraphKey)
                DialogueManager.WarmupSVC(warmupSVCList)
            end
            table.clear(self.playedActionNodeList)
        else
            if self.curNodeGraph == nil then
                local ownerGraphKey = self.database:GetNodeGraphKey(entryId)
                if ownerGraphKey ~= nil then
                    self.nodeBatchId = PreloadBatchMgr.StartNode(PreloadBatchType.Dialogue, ownerGraphKey)
                    self.curNodeGraph = self.database:GetNodeGraph(ownerGraphKey)
                    local warmupSVCList = self.database:GetWarmupSVCList(ownerGraphKey)
                    DialogueManager.WarmupSVC(warmupSVCList)
                end
            end
        end
    end
end

---添加已经播放过行为的节点
---@param uniqueId int
function DialoguePipeline:AddPlayedActionNodeList(uniqueId)
    table.insert(self.playedActionNodeList, #self.playedActionNodeList + 1, uniqueId)
end

---停止子节点树
function DialoguePipeline:StopNodeGraph()
    if self.nodeBatchId then
        PreloadBatchMgr.Unload(self.nodeBatchId)
        self.nodeBatchId = nil
        self.curNodeGraph = nil
    end
end

---剩余时间评估
---@param name string
---@param params table 预留参数
---@return float 预估剩余时间，单位秒
function DialoguePipeline:EstimateRemainingTime(name, params)
    local dialogueId = tonumber(name)
    local remainingTime = Mathf.Infinity
    if self.curNodeGraph then
        if dialogueId ~= nil then
            --需要返回的是整个Dialogue预计结束的时间
            remainingTime = self.database:EstimateRemainingTimeByNodeGraph(self.playedActionNodeList, self.curNodeGraph.uniqueID)
        elseif self.curNodeGraph.uniqueID == name then
            remainingTime = self.database:EstimateRemainingTime(self.curNodeGraph, self.playedActionNodeList)
        end
    else
        --未开启UseNodeGraph模式或剧情配置没有导出成最新
    end
    return remainingTime
end

---@param semanticDict table<int, string>
function DialoguePipeline:PackSemanticGroupIDList(semanticDict)
    for _, nodePlayer in pairs(self.nodePlayerDict) do
        nodePlayer:PackSemanticGroupIDList(semanticDict)
    end
end

---@param id int 命中的语义组Id
function DialoguePipeline:HitSemanticGroupID(id)
    for _, nodePlayer in pairs(self.nodePlayerDict) do
        nodePlayer:HitSemanticGroupID(id)
    end
end

--region Debug
---@param uniqueId int
function DialoguePipeline:AddPlayedRuntimeEntries(uniqueId)
    if UNITY_EDITOR then
        if table.indexof(self.playedRuntimeEntries, uniqueId) == false then
            table.insert(self.playedRuntimeEntries, #self.playedRuntimeEntries + 1, uniqueId)
        end
    end
end
--endregion

return DialoguePipeline