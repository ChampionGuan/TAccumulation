---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by deling.
--- DateTime: 2022/4/11 11:28
---

---Radio播放逻辑组件，主要用于tick及阶段转换
---@class RadioPlayerCtrlMediumNew
local RadioPlayerCtrlMediumNew = class("RadioPlayerCtrlMedium")

local _CS_UNITY_TIME = CS.UnityEngine.Time ---RealtimeSinceStartup
local _CS_SYSTEM_TIME = CS.System.DateTime
local updateInternal = GameConst.RadioLogicUpdatePeriod * 0.001 ---Tick更新间隔 控制在0.2S

---用于记录状态改变，在主线程中更新observer
---@class StateEnum
local StateEnum = {
    OnPreSubPlayStart = 0,
    OnPlayStart = 1,
    OnPlayResume = 2,
    OnPlayPause = 3,
    OnSubPlayStart = 4,
    OnPlayEnd = 5,
    OnPlayUpdate = 6,
}

function RadioPlayerCtrlMediumNew:ctor()
    ---@type RadioPlayerCtrlNew
    self._distributer = nil
    self._observer = nil
    ---@type number 定时器
    self._radioTimerID = nil
    ---@type number 当前更新位置
    self._curPosition = 0
    ---@type bool 是否进入drymode
    self._runDryMode = false
    ---@type bool 是否占线、被Obtain
    self._isHolded = false
    ---@type number 当前子播放段结束位置
    self._curPlayPeriod = 0
    ---@type number 当前起始点RealtimeSinceStartup
    self._realtimeSinceStartup = 0

    ---@type number 即将开始歌词的索引值
    self._preNextRadioIndex = 0
    ---@type number 上一条歌词的索引值
    self._lastRadioIndex = 0
    ---@type number 当前歌词的索引值
    self._subRadioIndex = 0
    ---@type number 当前播放位置
    self._playPosition = 0
    ---@type bool 是否播放完成
    self._isCompel = false

    ---前台时长(暂停也算)
    self._voiceFrontPlayTime = 0

    ---@type table<StateEnum> 等待执行的状态集合
    self._observerStateSeq = {}
    ---@type table<StateEnum, function> observer状态方法集合
    self._observerStateFuncDic = {}
    ---@type table<StateEnum, function> observer状态获取参数方法集合
    self._observerArgFuncDic = {}

    ---@type number 播放进度的偏移值
    self._offsetArg = 0

end

---退出清理
function RadioPlayerCtrlMediumNew:Exit()
    self:Stop()
    self:_StopTimer()
    self._runDryMode = false
    self._isHolded = false
    self._distributer = nil
    self._observer = nil
    table.clear(self._observerStateFuncDic)
    table.clear(self._observerStateSeq)
    if (self._tempTimerID) then
        TimerMgr.Discard(self._tempTimerID)
    end
end

function RadioPlayerCtrlMediumNew:Init(distributer, observer)
    self._distributer = distributer
    self._observer = observer
    self._offsetArg = 0
    ---填充状态方法
    self:InitStateFunc()

    self:_StopTimer()
    self._radioTimerID = TimerMgr.AddTimer(updateInternal,
            self.OnTimerTick, self, true, 2)
end

----初始化状态函数相关 ---仅在主线程时触发
function RadioPlayerCtrlMediumNew:InitStateFunc()
    local observer = self._observer
    self._observerStateFuncDic[StateEnum.OnPlayStart] = handler(observer, observer.OnPlayStart)
    self._observerStateFuncDic[StateEnum.OnPlayResume] = handler(observer, observer.OnPlayResume)
    self._observerStateFuncDic[StateEnum.OnPlayPause] = handler(observer, observer.OnPlayPause)
    self._observerStateFuncDic[StateEnum.OnSubPlayStart] = handler(observer, observer.OnSubPlayStart)
    self._observerStateFuncDic[StateEnum.OnPlayEnd] = handler(observer, observer.OnPlayEnd)
    self._observerStateFuncDic[StateEnum.OnPlayUpdate] = handler(observer, observer.OnPlayUpdate)
    if (observer.OnPreSubPlayStart) then
        self._observerStateFuncDic[StateEnum.OnPreSubPlayStart] = handler(observer, observer.OnPreSubPlayStart)
    end

    ---获取参数方法
    self._observerArgFuncDic[StateEnum.OnSubPlayStart] = function()
        return self._lastRadioIndex, self._subRadioIndex
    end

    self._observerArgFuncDic[StateEnum.OnPreSubPlayStart] = function()
        return self._lastRadioIndex, self._preNextRadioIndex
    end

    self._observerArgFuncDic[StateEnum.OnPlayUpdate] = function()
        return self._playPosition, self._isCompel
    end

end

function RadioPlayerCtrlMediumNew:OnPlayStart()
    if(self:GetDryMode()) then
        return
    end
    table.insert(self._observerStateSeq, StateEnum.OnPlayStart)
end

---新的一句开始前
function RadioPlayerCtrlMediumNew:OnPreSubPlayStart(nextIndex)
    self._preNextRadioIndex = nextIndex
    if(not self:GetDryMode()) then
        table.insert(self._observerStateSeq, StateEnum.OnPreSubPlayStart)
    end
end

function RadioPlayerCtrlMediumNew:OnPlayResume()
    if(self:GetDryMode()) then
        return
    end
    table.insert(self._observerStateSeq, StateEnum.OnPlayResume)
end

function RadioPlayerCtrlMediumNew:OnPlayPause()
    if(self:GetDryMode()) then
        return
    end
    table.insert(self._observerStateSeq, StateEnum.OnPlayPause)
end

function RadioPlayerCtrlMediumNew:OnSubPlayStart(lastRadioIndex, subRadioIndex)
    self._lastRadioIndex = lastRadioIndex
    self._subRadioIndex = subRadioIndex
    if(not self:GetDryMode()) then
        table.insert(self._observerStateSeq, StateEnum.OnSubPlayStart)
    end
end

function RadioPlayerCtrlMediumNew:OnPlayEnd()
    if(not self:GetDryMode()) then
        table.insert(self._observerStateSeq, StateEnum.OnPlayEnd)
    else
        self:SwitchPlayInDryMode(true)
    end
end

---后台情况下播放下一首或上一首
function RadioPlayerCtrlMediumNew:SwitchPlayInDryMode(isNext)
    if (self._runDryMode and self._observer and self._observer.OnSwitchInDry) then
        self._distributer:Reset()
        self:ResetStartUp()
        self._curPosition = 0
        local radioName, needStop = self._observer:OnSwitchInDry(isNext)
        if (not string.isnilorempty(radioName)) then
            self._distributer:PlayInBackground(radioName)
            self:Seek(0)
            if (needStop) then
                self:Pause()
            end

            if(self._observer.OnSwitchInDryEnd) then
                self._observer:OnSwitchInDryEnd()
            end
        end
    else
        --Debug.LogError("SwitchPlayInDryMode Error")
    end
end

function RadioPlayerCtrlMediumNew:GetDryMode()
    return self._runDryMode
end

function RadioPlayerCtrlMediumNew:OnPlayUpdate(playPosition, isCompel)
    --Debug.LogErrorWithTag(GameConst.LogTag.Radio, "RadioPlayerCtrlMedium-OnPlayUpdate:", self._curPosition, "-", self._runDryMode, "-", self._isHolded)

    self._playPosition = playPosition
    self._isCompel = isCompel

    if (self._observer and (not self._isHolded) and not self:GetDryMode()) then
        table.insert(self._observerStateSeq, StateEnum.OnPlayUpdate)
    end

    if self._distributer then
        self._distributer:OnPlayUpdate(playPosition)
    end
end

---@param subRadioID number 需要播放的subRadioID,字幕索引ID
---@param isForcePlay boolean 是否考虑正在播放的subRadioID==当前的参数subRadioID
---@param isResetPlay boolean 针对第一个subRadio,是否从0开始播放
function RadioPlayerCtrlMediumNew:Play(subRadioID, isForcePlay, isResetPlay)
    ---换歌归零
    self._voiceFrontPlayTime = 0
    if self._distributer then
        if (not isForcePlay) and self._distributer:GetSubIndex() == subRadioID then
            --print("正在播放中，", subRadioID)
            return
        end
        subRadioID = subRadioID or 1
        local curIndex = self._distributer:GetSongIndexByID(subRadioID)
        ---每次开始播放都触发
        self._distributer:Play(curIndex, isForcePlay, isResetPlay)
        self:OnPlayStart()

        self:OnSubPlayStart(nil, curIndex)

        self._curPosition = self._distributer:GetPosition()
        self._curPlayPeriod = self._distributer:GetSubRadioTime()
        self:_StartTimer()

    end
end

function RadioPlayerCtrlMediumNew:Seek(percent, force)
    if (not percent) then
        Debug.LogErrorWithTag(GameConst.LogTag.Radio, "Medium Seek no percent")
        return
    end

    if self._distributer then
        if Mathf.Approximately(percent, 1) then
            self:Stop(true)
            return 1 ---返回到开头位置
        end
        local lastPlaySubID = self._distributer:GetSubIndex()
        local curPlaySubID = self._distributer:Seek(percent, force)
        if curPlaySubID then

            self._curPosition = self._distributer:GetPosition()
            self._curPlayPeriod = self._distributer:GetSubRadioTime()
            if lastPlaySubID ~= curPlaySubID then
                self:OnSubPlayStart(lastPlaySubID, curPlaySubID)
            end
            return curPlaySubID
        end
    end
end

function RadioPlayerCtrlMediumNew:Pause()
    if self._distributer then
        self._distributer:Pause()
        self:OnPlayPause()
    end
end

function RadioPlayerCtrlMediumNew:Resume()
    if self._distributer then
        self:ResetStartUp()
        self._distributer:Resume()
        self:OnPlayResume()
    end
end

function RadioPlayerCtrlMediumNew:Stop(isPlayEnd)
    if self._distributer then
        self._curPosition = 0
        self._curPlayPeriod = 0
        self._distributer:Stop()
        if isPlayEnd then
            self:OnPlayEnd()
        end
    end
end

----用于
function RadioPlayerCtrlMediumNew:ChangeOffset(offset)
    ---取消偏移时
    if (offset == 0 and self._offsetArg ~= 0) then
        self._offsetArg = 0
    elseif (offset ~= 0 and self._offsetArg == 0) then
        self._offsetArg = offset
    end
end

---设置纯逻辑模式
---@param runDryMode boolean 是否设置为纯逻辑模式，比如进入后台
function RadioPlayerCtrlMediumNew:SetDryMode(runDryMode)
    --Debug.LogErrorWithTag(GameConst.LogTag.Radio, " SetDryMode ", runDryMode)
    self._runDryMode = runDryMode or false
end

---设置纯逻辑模式
---@param isHolded boolean 是否占线、被Obtain，比如进入手指按住没有弹起
function RadioPlayerCtrlMediumNew:SetHoldState(isHolded)
    self._isHolded = isHolded or false
end

function RadioPlayerCtrlMediumNew:_GetUpdateDelta()
    return self:GetTimeDelta()
end

function RadioPlayerCtrlMediumNew:_OnPlayUpdateInternal()
    --print("RadioPlayerCtrlMedium:", self._curPosition)

    --Debug.LogError("_OnPlayUpdateInternal ", self._distributer:GetState())
    if not self._distributer then
        return
    end
    if self._distributer:GetState() == GameConst.MusicPlayState.Play then
        local _timeDelta = self:_GetUpdateDelta()
        if (self._offsetArg ~= 0) then
            self:_OnPreUpdateInternal(_timeDelta + self._offsetArg)
        end
        --print("RadioPlayerCtrlMedium:", self._curPosition, "+++", _timeDelta,
        --        "++++", (self._curPosition + _timeDelta))
        self._curPosition = self._curPosition + _timeDelta

        --Debug.LogWarning("RadioPlayerCtrlMediumNew _OnPlayUpdateInternal ", _timeDelta, " cur ", self._curPosition, " length ", self._distributer:GetLength())

        if self._curPosition > self._distributer:GetLength() then
            self._curPosition = self._distributer:GetLength()
        end

        --Debug.LogError("self._distributer:GetSubID() ", self._distributer:GetSubID(), " self._curPosition ", self._curPosition)

        local lastPlaySubIndex = self._distributer:GetSubIndex()
        self:OnPlayUpdate(self._curPosition)
        local curPlaySubIndex = self._distributer:GetSubIndex()
        if not self._isHolded then
            --Debug.LogError("_OnPlayUpdateInternal curPlaySubIndex ", curPlaySubIndex, " self._curPosition ", self._curPosition)

            if lastPlaySubIndex ~= curPlaySubIndex then
                self:OnSubPlayStart(lastPlaySubIndex, curPlaySubIndex)
            end

            if self._curPosition >= self._distributer:GetLength() then
                self:OnPlayUpdate(self._curPosition, true)
                self:Stop(true)
            end
        end
        if(not self._runDryMode) then
            self._voiceFrontPlayTime = self._voiceFrontPlayTime + _timeDelta
        end
        --留作确认，暂停时是否需要计时
    elseif self._distributer:GetState() == GameConst.MusicPlayState.Pause then
        if (not self._runDryMode) then
            self._observer:TryUpdateRadioReadTime()
            self._voiceFrontPlayTime = self._voiceFrontPlayTime + self:_GetUpdateDelta()
        end
    end
end

----用于新的一句开始前的时机，传入offset时才会执行
function RadioPlayerCtrlMediumNew:_OnPreUpdateInternal(_timeDelta)

    local curPos = self._curPosition + _timeDelta
    if curPos > self._distributer:GetLength() then
        curPos = self._distributer:GetLength()
    end

    local lastPlaySubIndex = self._distributer:GetSubIndex()
    local curPlaySubIndex = self._distributer:GetPlayingSubIndex(curPos)

    if not self._isHolded then
        if lastPlaySubIndex ~= curPlaySubIndex then
            self:OnPreSubPlayStart(curPlaySubIndex)
        end
    end
end

function RadioPlayerCtrlMediumNew:_StartTimer()
    --self:_StopTimer()
    self:ResetStartUp()
    --self._radioTimerID = TimerMgr.AddTimer(updateInternal,
    --        self._OnPlayUpdateInternal, self, true)
end

function RadioPlayerCtrlMediumNew:_StopTimer()
    if self._radioTimerID then
        TimerMgr.Discard(self._radioTimerID)
        self._radioTimerID = nil
    end
end

---由timer驱动
function RadioPlayerCtrlMediumNew:OnTimerTick()
    self:_OnPlayUpdateInternal()
    self:_HandleObserverStateFunc()
    --Debug.LogError("RadioPlayerCtrlMediumNew OnTimerTick -- ", #self._observerStateSeq)
    table.clear(self._observerStateSeq)
end

---执行Observer状态函数
function RadioPlayerCtrlMediumNew:_HandleObserverStateFunc()
    local startNum = #self._observerStateSeq
    --Debug.LogError("_HandleObserverStateFunc ", startNum)
    for i = 1, startNum do
        self:_ExeObserverStateFunc(i)
    end
    ---执行中可能会再次产生队列，继续执行一次剩下的内容
    if (#self._observerStateSeq > startNum) then
        for i = startNum + 1, #self._observerStateSeq do
            self:_ExeObserverStateFunc(i)
        end
    end
end

function RadioPlayerCtrlMediumNew:_ExeObserverStateFunc(i)
    ---@type StateEnum
    local state = self._observerStateSeq[i]

    local func = self._observerStateFuncDic[state]
    if func then
        if (self._observerArgFuncDic[state]) then
            func(self._observerArgFuncDic[state]())
        else
            func()
        end
    end
end

---@private
function RadioPlayerCtrlMediumNew:_GetTimeByMode(isSystemTime)
    --if isSystemTime then
    --    return _CS_SYSTEM_TIME.Now.Ticks * 0.0001 * 0.001
    --else
    --    return _CS_UNITY_TIME.realtimeSinceStartup
    --end
    if UNITY_EDITOR then
        return _CS_UNITY_TIME.realtimeSinceStartup
    else
        ---一律使用系统tick
        return _CS_SYSTEM_TIME.Now.Ticks * 0.0001 * 0.001
    end
end

function RadioPlayerCtrlMediumNew:GetVoicePlayTime()
    local time = self._voiceFrontPlayTime
    --次抛型
    self._voiceFrontPlayTime = 0
    return time
end

---@private
function RadioPlayerCtrlMediumNew:GetCurTime()
    return self:_GetTimeByMode(self._runDryMode)
end

function RadioPlayerCtrlMediumNew:ResetStartUp()
    self._realtimeSinceStartup = self:GetCurTime()
end

function RadioPlayerCtrlMediumNew:GetTimeDelta()
    if self._realtimeSinceStartup > 0 then
        local _time = self:GetCurTime()
        local delta = _time - self._realtimeSinceStartup
        self._realtimeSinceStartup = _time
        return delta
    end
    return updateInternal
end

function RadioPlayerCtrlMediumNew:GetCurPosition()
    return self._curPosition
end

---界面关闭时只执行逻辑就好
function RadioPlayerCtrlMediumNew:Reset()
    self._distributer = nil
    self._observer = nil

end

---进入前台时
function RadioPlayerCtrlMediumNew:OnEnterFront()
    ---收到事件的帧会晚一帧，导致队列先被执行，所以这里清应该没什么意义
    self:ClearStateSeq()
    self:OnPlayStart()
    self:_StartTimer()
end

---Native更新
function RadioPlayerCtrlMediumNew:UpdateRemote(needClear)
    self:_OnPlayUpdateInternal()
    --Debug.LogError("RadioPlayerCtrlMediumNew UpdateRemote -- ", #self._observerStateSeq)
end

---
function RadioPlayerCtrlMediumNew:ClearStateSeq()
    table.clear(self._observerStateSeq)
end

return RadioPlayerCtrlMediumNew