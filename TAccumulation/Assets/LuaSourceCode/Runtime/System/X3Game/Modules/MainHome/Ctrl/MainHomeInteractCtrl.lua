---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiaozhu.
--- DateTime: 2022/2/23 10:56
---主界面交互模式
---@type MainHome.MainHomeConst
local MainHomeConst = require("Runtime.System.X3Game.Modules.MainHome.Data.MainHomeConst")
---@type MainHomeBaseCtrl
local BaseCtrl = require(MainHomeConst.BASE_CTRL)
---@class MainHomeInteractCtrl:MainHomeBaseCtrl
local MainHomeInteractCtrl = class("MainHomeInteractCtrl", BaseCtrl)
function MainHomeInteractCtrl:ctor()
    BaseCtrl.ctor(self)
    ---@type table<int,MainHome.BaseInteractAction>
    self.actions = PoolUtil.GetTable()
    self.actionNameMap = PoolUtil.GetTable()
    self.actionTypeMap = PoolUtil.GetTable()
    self.switchSort = handler(self, self.OnSort)
    self.actionRecordMap = PoolUtil.GetTable()
    ---@type MainHome.MainHomeActionProxy
    self.actionDataProxy = nil
    self:InitPool()
end

---初始化pool
function MainHomeInteractCtrl:InitPool()
    local pathFormat = MainHomeConst.ACTION_LUA_PATH_FORMAT
    local createFunc = handler(self, self.OnActionCreate)
    local releaseFunc = handler(self, self.OnActionRelease)
    ---@type cfg.MainUIActionType[]
    local cfg = LuaCfgMgr.GetAll("MainUIActionType")
    for k, v in pairs(cfg) do
        local className = v.ActionClass
        if not string.isnilorempty(className) then
            local map = self.actionNameMap[className]
            if not map then
                map = PoolUtil.GetTable()
                map.template = require(string.format(pathFormat, className))
                map.pool = PoolUtil.Get(createFunc, releaseFunc)
                self.actionNameMap[className] = map

            end
            self.actionTypeMap[v.Key] = map
        end
    end
end

---@param actionType int
---@return Pool
function MainHomeInteractCtrl:GetPool(actionType)
    local map = self.actionTypeMap[actionType]
    return map and map.pool or nil
end

---@param actionType string
---@return MainHome.BaseInteractAction
function MainHomeInteractCtrl:GetTemplate(actionType)
    local map = self.actionTypeMap[actionType]
    return map and map.template or nil
end

---@param actionType string
---@return MainHome.BaseInteractAction
function MainHomeInteractCtrl:OnActionCreate(actionType)
    local temp = self:GetTemplate(actionType)
    ---@type MainHome.BaseInteractAction
    local res = temp and temp.new() or nil
    return res
end

---@param action MainHome.BaseInteractAction
function MainHomeInteractCtrl:OnActionRelease(action)
    if action then
        action:End()
        action:Exit()
    end
end

---@param actionId int
---@param isCreate boolean
---@return MainHome.BaseInteractAction
function MainHomeInteractCtrl:GetAction(actionId, isCreate)
    local action = actionId and self.actions[actionId] or nil
    if not action and isCreate then
        action = self:CreateAction(actionId)
        self.actions[actionId] = action
        action:Enter()
    end
    return action
end

---@param actionId int
---@return MainHome.BaseInteractAction
function MainHomeInteractCtrl:CreateAction(actionId)
    local cfg = self:GetActionCfg(actionId)
    if cfg then
        local actionType = cfg.ActionType
        cfg = self.actionDataProxy:GetActionTypeCfg(actionType)
        if cfg then
            local pool = self:GetPool(actionType)
            if pool then
                ---@type MainHome.BaseInteractAction
                local action = pool:Get(actionType)
                if action then
                    action:SetBll(self.bll)
                    action:SetOwner(self)
                    action:SetType(actionType)
                    action:SetId(actionId)
                    action:SetClearType(MainHomeConst.ActionClearType.Exit)
                    return action
                end
            end
        else
            Debug.LogErrorFormat("[MainHomeInteractCtrl:CreateAction]--failed,actionType=%s", actionType)
        end
    else
        Debug.LogErrorFormat("[MainHomeInteractCtrl:CreateAction]--failed,actionId=%s", actionId)
    end
end

---获取配置
---@param actionId int
---@return cfg.MainUIAction
function MainHomeInteractCtrl:GetActionCfg(actionId)
    return self.actionDataProxy:GetActionCfg(actionId)
end

function MainHomeInteractCtrl:Enter()
    BaseCtrl.Enter(self)
    self.bll:SetRecordMap(self.actionRecordMap)
    self:SetIsRunning(true)
    self.actionDataProxy = self.bll:GetActionDataProxy()
    self:RegisterEvent()
    self:CheckAction()
    self:SetIsRunning(false)
end

function MainHomeInteractCtrl:Exit()
    BaseCtrl.Exit(self)
    self.bll:Resume()
    for k, v in pairs(self.actionRecordMap) do
        PoolUtil.ReleaseTable(v)
    end
    table.clear(self.actionRecordMap)
    self:UnRegisterEvent()
    self:Clear(MainHomeConst.ActionClearType.ALL)
end

function MainHomeInteractCtrl:OnUpdate()
    for _, action in pairs(self.actions) do
        action:OnUpdate()
    end
end

---状态刷新重新检测action
function MainHomeInteractCtrl:CheckAction()
    if not self.bll:IsHandlerRunning(MainHomeConst.HandlerType.ClearActionBeforeCheckAction) then
        self:Clear(MainHomeConst.ActionClearType.State)
    end
    local actionCfgList = self.actionDataProxy:GetCurStateActions()
    for k, v in pairs(actionCfgList) do
        self:GetAction(v.ID, true)
    end
    PoolUtil.ReleaseTable(actionCfgList)
    self.bll:SetHandlerRunning(MainHomeConst.HandlerType.ClearActionBeforeCheckAction, false)
end

---执行action
---@param actionId
function MainHomeInteractCtrl:OnEventActionBegin(actionId)
    local action = self:GetAction(actionId)
    if action then
        if not action:IsRunning() then
            action:Begin(action:GetActionParam())
        end
    else
        Debug.LogWarningFormat("[MainHomeInteractCtrl:OnEventActionBegin]--failed:%s", actionId)
    end
end

---执行action
---@param actionId
---@param breakType ActionClearType
function MainHomeInteractCtrl:OnEventActionEnd(actionId, breakType)
    local action = self:GetAction(actionId)
    if action then
        if action:IsRunning() or action:IsWaiting() then
            breakType = MainHomeConst.ActionClearType.Exit
            action:SetClearType(breakType)
            action:End()
        end
    else
        Debug.LogWarningFormat("[MainHomeInteractCtrl:OnEventActionEnd]--failed:%s", actionId)
    end
end

---点击男主
---@param partType int 男主部位
function MainHomeInteractCtrl:OnEventClickActor(partType)
    if self.bll:IsHandlerRunning(MainHomeConst.HandlerType.ActionDialoguePlaying) then
        return
    end
    for k, v in pairs(self.actions) do
        v:OnClickActor(partType)
    end
end

---男主状态刷新
function MainHomeInteractCtrl:OnEventActorStateChanged()
    for k, v in pairs(self.actions) do
        v:OnActorStateChanged()
    end
end

function MainHomeInteractCtrl:OnActorLoadSuccess()
    for k, v in pairs(self.actions) do
        v:OnActorLoadSuccess()
    end
end

---@param action MainHome.BaseInteractAction
function MainHomeInteractCtrl:ReleaseAction(action)
    local pool = self:GetPool(action:GetType())
    if pool then
        pool:Release(action)
    end
end

---@param breakType int
---@return string
function MainHomeInteractCtrl:GetBreakTypeDes(breakType)
    for k, v in pairs(MainHomeConst.ActionClearType) do
        if v == breakType then
            return k
        end
    end
end

---清理当前的action
---@param clearType ActionClearType
function MainHomeInteractCtrl:Clear(clearType)
    local isDebug = self.bll:IsDebugMode()
    local isPaused = false
    local isNeedCheckPaused = clearType == MainHomeConst.ActionClearType.Focus
    for k, v in pairs(self.actions) do
        if v:IsCanClear(clearType) then
            v:SetClearType(clearType)
            if clearType == MainHomeConst.ActionClearType.Focus then
                local breakType = self.actionDataProxy:GetFocusBreakType(v:GetId())
                if breakType == MainHomeConst.ActionFocusBreakType.Break then
                    self:BreakAction(v, clearType)
                elseif breakType == MainHomeConst.ActionFocusBreakType.Pause then
                    if self:PauseAction(v, clearType) then
                        isPaused = true
                    end
                elseif breakType == MainHomeConst.ActionFocusBreakType.Finish then
                    self:FinishAction(v, clearType)
                end
            elseif MainHomeConst.ActionStopType[clearType] then
                self:BreakAction(v, clearType)
            else
                if isDebug then
                    Debug.LogFormat("[MainHome] action:[%s] 被清理，清理类型[%s(%s)]", self.actionDataProxy:GetActionDebugDes(v:GetId()), self:GetBreakTypeDes(clearType), clearType)
                end
                self.actions[k] = nil
                self:ReleaseAction(v)
            end
        end
    end
    if isNeedCheckPaused then
        if isPaused then
            self.bll:Pause()
        end
    end
    self.bll:SetHandlerRunning(MainHomeConst.HandlerType.ClearActionBeforeCheckAction, clearType == MainHomeConst.ActionClearType.State)
end

---@param action MainHome.BaseInteractAction
---@param clearType ActionClearType
function MainHomeInteractCtrl:BreakAction(action, clearType)
    if not action then
        return
    end
    if self.bll:IsDebugMode() then
        Debug.LogFormat("[MainHome] action:[%s] 被打断，打断类型[%s(%s)]", self.actionDataProxy:GetActionDebugDes(action:GetId()), self:GetBreakTypeDes(clearType), clearType)
    end
    action:End()

    --- 检测当前action被打断之后是否需要恢复假状态
    if self.actionDataProxy:IsNeedRestoreLocalState(action:GetId(), clearType) then
        EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_RESTORE_LOCAL_STATE)
    end
end

---@param action MainHome.BaseInteractAction
---@param clearType ActionClearType
function MainHomeInteractCtrl:FinishAction(action, clearType)
    if not action or not action:IsRunning() then
        return
    end
    if self.bll:IsDebugMode() then
        Debug.LogFormat("[MainHome] action:[%s] 强制完成，类型[%s(%s)]", self.actionDataProxy:GetActionDebugDes(action:GetId()), self:GetBreakTypeDes(clearType), clearType)
    end
    action:SetClearType(MainHomeConst.ActionClearType.Exit)
    EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_FORCE_FINISH_ACTION, action:GetId(), true)
    if not self.bll:IsHandlerRunning(MainHomeConst.HandlerType.ActionDialoguePlaying) then
        action:End()
    end
end

---@param action MainHome.BaseInteractAction
---@param clearType ActionClearType
function MainHomeInteractCtrl:PauseAction(action, clearType)
    if not action or (not action:IsRunning() and not action:IsWaiting()) then
        return false
    end
    if self.bll:IsDebugMode() then
        Debug.LogFormat("[MainHome] action:[%s] 被暂停，暂停类型[%s(%s)]", self.actionDataProxy:GetActionDebugDes(action:GetId()), self:GetBreakTypeDes(clearType), clearType)
    end
    action:OnPause()
    return true
end

---@param action MainHome.BaseInteractAction
---@param clearType ActionClearType
function MainHomeInteractCtrl:ResumeAction(action, clearType)
    if not action or (not action:IsRunning() and not action:IsWaiting()) then
        return
    end
    if self.bll:IsDebugMode() then
        Debug.LogFormat("[MainHome] action:[%s] 被恢复，恢复类型[%s(%s)]", self.actionDataProxy:GetActionDebugDes(action:GetId()), self:GetBreakTypeDes(clearType), clearType)
    end
    action:SetClearType(MainHomeConst.ActionClearType.Exit)
    action:OnResume()
end

---记录action完成的相关数据
---@param actionId int
function MainHomeInteractCtrl:ActionRecord(actionId)
    local conf = self.actionDataProxy:GetActionTypeCfgById(actionId)
    if not conf then
        return
    end
    local id = conf.TaskCountID
    if id == 0 then
        return
    end
    local actorId = self.bll:GetData():GetActorId()
    if actorId ~= 0 then
        if not self.actionRecordMap[actorId] then
            self.actionRecordMap[actorId] = PoolUtil.GetTable()
        end
        self.actionRecordMap[actorId][id] = TimerMgr.GetCurTimeSeconds()
        self:ChangeActionRecordX3Data(actorId, actionId)
    end
end

function MainHomeInteractCtrl:ChangeActionRecordX3Data(actorId, actionId)
    local recordData = X3DataMgr.Get(X3DataConst.X3Data.ActionRecord, actorId)
    if not recordData then
        recordData = X3DataMgr.AddByPrimary(X3DataConst.X3Data.ActionRecord, nil, actorId)
    end
    recordData:SetActionID(actionId)
end

---发送互动完成计数
---@param actionId int
function MainHomeInteractCtrl:SendServerInteractCount(actionId)
    if not self.bll:IsActorExist() then
        return
    end
    local data = self.bll:GetData()
    local roleId = data:GetRoleId()
    local actionTypeConf = self.actionDataProxy:GetActionTypeCfgById(actionId)
    if self.actionDataProxy:IsCanSendInteractCount(roleId, actionTypeConf) then
        local taskCountId = actionTypeConf.TaskCountID
        local needSave = actionTypeConf.DailyMaxRecord == 1
        if taskCountId ~= 0 then
            EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_SEND_REQUEST, MainHomeConst.NetworkType.ADD_ROLE_INTERACT_NUM, roleId, actionTypeConf.Key, 1, needSave)
        end
    end
end

---@param actionId int
---@param endType ActionClearType
function MainHomeInteractCtrl:ActionEnd(actionId, endType)
    if endType == MainHomeConst.ActionClearType.Exit then
        local conf = self.actionDataProxy:GetActionTypeCfgById(actionId)
        if conf.CountReport ~= MainHomeConst.ActionExitType.Auto then
            return
        end
    end
    self:SendServerInteractCount(actionId)
    self:ActionRecord(actionId)
end

---设置action 是否是running
---@param isRunning boolean
---@param actionId int
---@param endType ActionClearType
function MainHomeInteractCtrl:SetActionRunning(actionId, isRunning, endType)
    if not isRunning then
        if endType ~= MainHomeConst.ActionClearType.Exit and endType ~= MainHomeConst.ActionClearType.ExitBySelf then
            self.bll:SetActionShowRunning(actionId, isRunning)
            self.bll:SetActionRunning(actionId, isRunning, nil, endType)
        else
            self.bll:SetActionShowRunning(actionId, isRunning)
            self:ActionEnd(actionId, endType)
        end
    else
        self.bll:SetActionShowRunning(actionId, isRunning)
    end
end

---@param actionId int
---@param clearType ActionClearType
---@return boolean
function MainHomeInteractCtrl:IsActionCanClear(actionId, clearType)
    return self.actionDataProxy:IsActionCanClear(actionId, clearType)
end

---重新检查action，根据状态刷新和停掉正在执行的action
function MainHomeInteractCtrl:OnEventCheckAction()
    self:CheckAction()
end

---@param a MainHome.SwitchRes
---@param b MainHome.SwitchRes
---@return boolean
function MainHomeInteractCtrl:OnSort(a, b)
    return a.SwitchType > b.SwitchType
end

---计算结果
---@param actionId int
---@param list int[]
---@param handlerType MainHomeConst.ActionHandlerType
---@return MainHome.SwitchRes
function MainHomeInteractCtrl:Calculate(actionId, list, handlerType)
    if table.isnilorempty(list) then
        return nil
    end
    local actionType = self.actionDataProxy:GetActionType(actionId)
    if actionType then
        local res = PoolUtil.GetTable()
        for _, id in pairs(list) do
            local runningType = self.actionDataProxy:GetActionType(id)
            local cfg = self.actionDataProxy:GetActionSwitchCfg(runningType)
            if cfg then
                local switchType = cfg[actionType]
                ---@type MainHome.SwitchRes
                local temp = res[switchType]
                if not temp then
                    temp = PoolUtil.GetTable()
                    temp.SwitchType = switchType
                    temp.SwitchList = PoolUtil.GetTable()
                    res[switchType] = temp
                end
                table.insert(temp.SwitchList, id)
            end
        end
        local result = PoolUtil.GetTable()
        for k, v in pairs(res) do
            table.insert(result, v)
        end
        PoolUtil.ReleaseTable(res)
        ---排序
        local length = #result
        if length >= 2 then
            table.sort(result, self.switchSort)
        end
        if length >= 1 then
            ---@type MainHome.SwitchRes
            local res = table.remove(result, 1)
            for k, v in pairs(result) do
                PoolUtil.ReleaseTable(v.SwitchList)
                PoolUtil.ReleaseTable(v)
            end
            PoolUtil.ReleaseTable(result)
            res.HandlerType = handlerType
            res.ActionId = actionId
            return res
        end
        PoolUtil.ReleaseTable(result)
    end
    return nil
end

---根据当前正在执行的检查，action 是否可以执行
---@class MainHome.SwitchRes
---@field SwitchType MainHomeConst.ActionSwitchType
---@field SwitchList int[]
---@field HandlerType MainHomeConst.ActionHandlerType
---@field ActionId int
---@param actionId int
---@param runningList int[] 正在执行的列表
---@param waitingList int[] 正在等待的列表
---@param resCheck fun(type:boolean)
---@return MainHome.SwitchRes[]
function MainHomeInteractCtrl:OnEventCheckActionCanTrigger(actionId, runningList, waitingList, resCheck)
    local actionTypeConf = self.actionDataProxy:GetActionTypeCfgById(actionId)
    if actionTypeConf then
        if not self:IsActionCanTrigger(actionId) then
            return
        end
        ---检测在当前模式下是否可以触发
        if not self.actionDataProxy:IsActionCanRunInMode(actionId) then
            return
        end
        ---@type MainHome.SwitchRes
        local temp = nil
        ---检测主界面非focus下是否可以放入队列
        if not self.bll:IsMainViewFocus() then
            if actionTypeConf.ToPendingList == 1 then
                temp = self:Calculate(actionId, waitingList, MainHomeConst.ActionHandlerType.Waiting)
                if not temp then
                    temp = PoolUtil.GetTable()
                    temp.ActionId = actionId
                    temp.SwitchType = MainHomeConst.ActionSwitchType.Wait
                    temp.HandlerType = MainHomeConst.ActionHandlerType.Waiting
                end
                self:HandlerAction(temp)
                return
            else
                if self.bll:IsDebugMode() then
                    Debug.LogFormat("[MainHome] action[%s] 主界面非focus下不可以放入待处理队列", self.actionDataProxy:GetActionDebugDes(actionId))
                end
                return false
            end
        end
        if not table.isnilorempty(runningList) then
            temp = self:Calculate(actionId, runningList, MainHomeConst.ActionHandlerType.Running)
            if temp then
                if temp.SwitchType == MainHomeConst.ActionSwitchType.Wait and not table.isnilorempty(waitingList) then
                    temp = self:Calculate(actionId, waitingList, MainHomeConst.ActionHandlerType.Waiting)
                end
            end
        end
        if not temp then
            temp = PoolUtil.GetTable()
            temp.ActionId = actionId
            temp.SwitchType = MainHomeConst.ActionSwitchType.Parallel
            temp.HandlerType = MainHomeConst.ActionHandlerType.Running
        end
        self:HandlerAction(temp, resCheck)
    end
end

---@param res MainHome.SwitchRes
function MainHomeInteractCtrl:HandlerAction(res, resCheck)
    if not res then
        return
    end
    local conf = MainHomeConst.ActionHandlerConf[res.SwitchType]
    if conf then
        ---@type MainHomeConst.ActionExecute
        local hType = conf[res.HandlerType]
        if resCheck then
            if hType == MainHomeConst.ActionExecute.Run or hType == MainHomeConst.ActionExecute.Pending then
                resCheck(true)
            end
        else
            EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_AI_CHECK_ACTION, hType, res)
        end

        PoolUtil.ReleaseTable(res.SwitchList)
        PoolUtil.ReleaseTable(res)
    end
end

function MainHomeInteractCtrl:OnEventDialogueEnd(actionId, dialogueId, conversion, pipelineKey)
    local action = self:GetAction(actionId)
    if action then
        action:OnDialogueEnd(dialogueId, conversion, pipelineKey)
    end
end

---根据类型触发action
---@param actionType MainHomeConst.ActionType
function MainHomeInteractCtrl:OnEventStartActionByType(actionType, ...)
    for k, v in pairs(self.actions) do
        if v:GetType() == actionType then
            self.bll:StartAction(v:GetId(), ...)
            break
        end
    end
end

---根据类型触发action
---@param actionType MainHomeConst.ActionType
function MainHomeInteractCtrl:OnEventStopActionByType(actionType, ...)
    for k, v in pairs(self.actions) do
        if v:GetType() == actionType then
            self.bll:StopAction(v:GetId(), ...)
            break
        end
    end
end

---@param actionId int
---@vararg
function MainHomeInteractCtrl:OnEventSetActionParam(actionId, ...)
    local action = self:GetAction(actionId)
    if action then
        action:SetActionParam(...)
    end
end

---模式切换
---@param mode int
---@param isStateChange boolean
function MainHomeInteractCtrl:OnEventModeChanged(mode, isStateChange)
    for k, v in pairs(self.actions) do
        v:OnModeChanged(mode, isStateChange)
    end
end

---@param clearType ActionClearType
function MainHomeInteractCtrl:OnEventClearAction(clearType)
    self:Clear(clearType)
end

---@param focus boolean
function MainHomeInteractCtrl:OnEventWndFocusChanged(focus)
    for k, v in pairs(self.actions) do
        v:OnWndFocusChanged(focus)
    end
    if focus then
        self.bll:Resume()
    end
end

---@param focus boolean
function MainHomeInteractCtrl:OnEventViewFocusChanged(focus)
    for k, v in pairs(self.actions) do
        v:OnViewFocusChanged(focus)
    end
end

---当前action是否可以触发
---@param actionId int
---@return boolean
function MainHomeInteractCtrl:IsActionCanTrigger(actionId)
    local action = self:GetAction(actionId)
    local res = action and action:IsCanTrigger()
    if not res and action and self.bll:IsDebugMode() then
        Debug.LogFormat("[MainHome] action[%s] 不满足该action的相关执行条件！！！", self.actionDataProxy:GetActionDebugDes(actionId))
    end
    return res
end

---@param actionId int
---@vararg any
function MainHomeInteractCtrl:OnEventStartAction(actionId, ...)
    if not self:IsActionCanTrigger(actionId) then
        return
    end
    if select("#", ...) > 0 then
        EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_SET_ACTION_PARAM, actionId, ...)
    end
    EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_AI_START_ACTION, actionId)
end

function MainHomeInteractCtrl:OnEventPauseChanged(isPause)
    if not isPause then
        for k, v in pairs(self.actions) do
            self:ResumeAction(v, MainHomeConst.ActionClearType.Focus)
        end
    end
end

function MainHomeInteractCtrl:OnSceneObjActiveChanged(isActive)
    if not isActive then
        self:Clear(MainHomeConst.ActionClearType.SceneActiveChanged)
        --self.bll:Resume()
    end

end

function MainHomeInteractCtrl:RegisterEvent()
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_BEING_INTERACT, self.OnEventActionBegin, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_END_INTERACT, self.OnEventActionEnd, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_ON_CLICK_ACTOR, self.OnEventClickActor, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_STATE_CHANGE_REFRESH, self.OnEventActorStateChanged, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_ACTOR_LOAD_SUCCESS, self.OnActorLoadSuccess, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_CHECK_ACTION, self.OnEventCheckAction, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_CHECK_ACTION_CAN_TRIGGER, self.OnEventCheckActionCanTrigger, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_DIALOGUE_END, self.OnEventDialogueEnd, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_START_ACTION_BY_TYPE, self.OnEventStartActionByType, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_STOP_ACTION_BY_TYPE, self.OnEventStopActionByType, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_SET_ACTION_PARAM, self.OnEventSetActionParam, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_ON_MODE_CHANGE, self.OnEventModeChanged, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_CLEAR_ACTION, self.OnEventClearAction, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_AI_SET_WND_FOCUS, self.OnEventWndFocusChanged, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_START_ACTION, self.OnEventStartAction, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_AI_SET_VIEW_FOCUS, self.OnEventViewFocusChanged, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_PAUSE_CHANGED, self.OnEventPauseChanged, self)
    EventMgr.AddListener(Const.Event.SCENE_OBJ_ACTIVE_CHANGED, self.OnSceneObjActiveChanged, self)
end

function MainHomeInteractCtrl:OnDestroy()
    PoolUtil.ReleaseTable(self.actions)
    PoolUtil.ReleaseTable(self.actionNameMap)
    PoolUtil.ReleaseTable(self.actionTypeMap)
    PoolUtil.ReleaseTable(self.actionRecordMap)
    BaseCtrl.OnDestroy(self)
end
return MainHomeInteractCtrl