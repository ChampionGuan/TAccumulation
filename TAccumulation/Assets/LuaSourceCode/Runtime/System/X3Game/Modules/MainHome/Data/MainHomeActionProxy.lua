---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiaozhu.
--- DateTime: 2022/3/2 15:03
---@type MainHome.MainHomeConst
local MainHomeConst = require("Runtime.System.X3Game.Modules.MainHome.Data.MainHomeConst")

---@class MainHome.MainHomeActionProxy
local MainHomeActionProxy = class("MainHomeActionProxy")

function MainHomeActionProxy:ctor()
    self.bll = BllMgr.GetMainHomeBLL()
    ---@type cfg.MainUIActionBtn[]
    self.specialList = nil
    ---@type table<int,string>
    self.cacheActionDes = {}
end

---action是否解锁
---@param actionId int
---@param showTips boolean
---@return boolean
function MainHomeActionProxy:IsActionUnlock(actionId, showTips)
    local actionConf = self:GetActionCfg(actionId)
    local ok = true
    local groupId
    if actionConf then
        local condition = actionConf.UnlockCondition
        if condition ~= 0 then
            groupId = condition
            ok = ConditionCheckUtil.CheckConditionByCommonConditionGroupId(groupId)
        end
    end
    if not ok and showTips then
        UICommonUtil.ShowMessage(ConditionCheckUtil.GetConditionDescByGroupId(groupId))
    end
    return ok
end

---是否可以继续发送互动完成协议
---@param roleId int
---@param actionTypeConf cfg.MainUIActionType
---@return boolean
function MainHomeActionProxy:IsCanSendInteractCount(roleId, actionTypeConf)
    return true
    --local data = self.bll:GetData()
    --local limit = actionTypeConf.TaskReportLimit
    --local todayNum = data:GetTodayInteractCount(roleId, actionTypeConf.TaskCountID)
    --return todayNum < limit
end

---调试模式下类型显示日志
---@param actionId int
---@return string
function MainHomeActionProxy:GetActionDebugDes(actionId)
    if self.bll:IsDebugMode() then
        local des = self.cacheActionDes[actionId]
        if not des then
            des = string.format("%s(%d)", self:GetActionType(actionId), actionId)
            self.cacheActionDes[actionId] = des
        end
        return des
    end
    return ""
end

---获取类型配置
---@param actionType string
---@return cfg.MainUIActionType
function MainHomeActionProxy:GetActionTypeCfg(actionType)
    return LuaCfgMgr.Get("MainUIActionType", actionType)
end

---获取配置
---@param actionId int
---@return cfg.MainUIAction
function MainHomeActionProxy:GetActionCfg(actionId)
    return LuaCfgMgr.Get("MainUIAction", actionId)
end

---获取配置
---@param actionType string
---@return cfg.MainUIActionSwitch
function MainHomeActionProxy:GetActionSwitchCfg(actionType)
    return LuaCfgMgr.Get("MainUIActionSwitch", actionType)
end

---获取action type
---@param actionId int
---@return string
function MainHomeActionProxy:GetActionType(actionId)
    local cfg = self:GetActionCfg(actionId)
    if cfg then
        return cfg.ActionType
    end
end

---获取配置
---@param actionId int
---@return cfg.MainUIActionSwitch
function MainHomeActionProxy:GetActionSwitchCfgById(actionId)
    return self:GetActionSwitchCfg(self:GetActionType(actionId))
end

---获取配置
---@param actionId int
---@return cfg.MainUIActionType
function MainHomeActionProxy:GetActionTypeCfgById(actionId)
    return self:GetActionTypeCfg(self:GetActionType(actionId))
end

---把list加入到map中，避免重复
---@param map table
---@param list table
---@param isShow boolean
function MainHomeActionProxy:AddListToMap(map, list, isShow)
    for k, v in pairs(list) do
        if map[v] == nil then
            map[v] = isShow
        end
    end
end

---@param actionId
---@param showList table<int,boolean>
---@param hideList table<int,boolean>
---@param isRunning boolean
function MainHomeActionProxy:CheckView(actionId, showList, hideList, isRunning)
    local conf = self:GetActionTypeCfgById(actionId)
    local hide = conf.HideInteractiveUI
    local show = conf.ShowInteractiveUI
    if isRunning then
        if hide then
            self:AddListToMap(hideList, hide, false)
        end
        if show then
            self:AddListToMap(showList, show, true)
        end
    else
        if hide then
            self:AddListToMap(showList, hide, true)
        end
        if show then
            self:AddListToMap(hideList, show, false)
        end
    end
end

---获取view的显隐列表
---@param actionId int
---@param isRunning boolean
---@return table<string,boolean>
function MainHomeActionProxy:GetViewMap(actionId, isRunning)
    local runningList = self.bll:GetRunningActionShow()
    local showList = PoolUtil.GetTable()
    local hideList = PoolUtil.GetTable()
    for k, _ in pairs(runningList) do
        if k ~= actionId then
            self:CheckView(k, showList, hideList, true)
        end
    end
    self:CheckView(actionId, showList, hideList, isRunning)
    local res = PoolUtil.GetTable()
    table.merge(res, showList)
    table.merge(res, hideList)
    PoolUtil.ReleaseTable(showList)
    PoolUtil.ReleaseTable(hideList)
    return res
end

---获取剧情设置
---@return cfg.s2int[]
function MainHomeActionProxy:GetDialogueSetting()
    local res = PoolUtil.GetTable()
    for actionId, _ in pairs(self.bll:GetRunningActionShow()) do
        local conf = self:GetActionTypeCfgById(actionId)
        ---@type cfg.s2int
        local itemList = conf and conf.DialogueUI
        if itemList then
            for _, item in ipairs(itemList) do
                local v = PoolUtil.GetTable()
                v.x = item.ID
                v.y = item.Num
                table.insert(res, v)
            end
        end
    end
    return res
end

---是否可以显示主界面ui
---@return boolean
function MainHomeActionProxy:IsCanShowMainUI()
    local res = self.bll:GetMode() == MainHomeConst.ModeType.NORMAL
    if res then
        local hideMainUIType = MainHomeConst.HideMainUIType
        local runningList = self.bll:GetRunningActionShow()
        for actionId, _ in pairs(runningList) do
            local conf = self:GetActionTypeCfgById(actionId)
            if conf then
                if conf.HideMainUI == hideMainUIType.Hide then
                    res = false
                    break
                end
            end
        end
    end
    return res
end

---是否可以编辑照片
---@return boolean
function MainHomeActionProxy:IsCanEditPhoto()
    local res = true
    local runningList = self.bll:GetRunningActionShow()
    local hidePhotoEditType = MainHomeConst.HidePhotoEditType
    for actionId, _ in pairs(runningList) do
        local conf = self:GetActionTypeCfgById(actionId)
        if conf then
            if conf.HidePhotoEdit == hidePhotoEditType.Disable then
                res = false
                break
            end
        end
    end
    return res
end

---检测当前是否处于idle状态
---@return boolean
function MainHomeActionProxy:IsActionIdle()
    local runningList = self.bll:GetRunningActionShow()
    for id, v in pairs(runningList) do
        local conf = self:GetActionTypeCfgById(id)
        if conf then
            if conf.ResetIdleTiming == 1 then
                return false
            end
        end
    end
    return true
end

---当前状态下是否可以执行
---@param actionId int
---@return boolean
function MainHomeActionProxy:IsActionCanRunInState(actionId)
    local actionData = self:GetActionCfg(actionId)
    if not actionData then
        return false
    end
    local cfgState = actionData.StateLimit
    local cfgActorId = actionData.ActorID
    local stateData = self.bll:GetData()
    local actorId = stateData:GetActorId()
    local stateId = stateData:GetStateId()
    return (cfgActorId == -1 or actorId == cfgActorId) and (cfgState == nil or table.containsvalue(cfgState, stateId))
end

---当前action是否可以被打断
---@param actionId int
---@param clearType ActionClearType
function MainHomeActionProxy:IsActionCanBreak(actionId, clearType)
    local actionTypeConf = self:GetActionTypeCfgById(actionId)
    if actionTypeConf then
        local list = actionTypeConf.RefuseInterrupt
        if not list then
            return true
        end
        return not table.containsvalue(list, clearType)
    end
    return true
end

---@param actionId int
---@return MainHomeConst.ActionFocusBreakType
function MainHomeActionProxy:GetFocusBreakType(actionId)
    local conf = self:GetActionTypeCfgById(actionId)
    if conf then
        return conf.UnfocusType
    end
    return MainHomeConst.ActionFocusBreakType.Break
end

---状态刷新的时候是否可以清理
---@param actionId int
---@param clearType ActionClearType
---@return boolean
function MainHomeActionProxy:IsActionCanClear(actionId, clearType)
    if clearType == MainHomeConst.ActionClearType.ALL then
        return true
    elseif clearType == MainHomeConst.ActionClearType.State then
        return not self:IsActionCanRunInState(actionId)
    elseif clearType == MainHomeConst.ActionClearType.Focus then
        return self:GetFocusBreakType(actionId) ~= MainHomeConst.ActionFocusBreakType.Ignore
    elseif MainHomeConst.ActionStopType[clearType] then
        return self.bll:IsActionRunning(actionId) and self:IsActionCanBreak(actionId, clearType)
    else
        return self:IsActionCanBreak(actionId, clearType)
    end
end

---@param actionId int
---@param clearType ActionClearType
---@return boolean
function MainHomeActionProxy:IsNeedRestoreLocalState(actionId, clearType)
    local actionConf = self:GetActionCfg(actionId)
    if actionConf and actionConf.FakeStateCheck == 1 then
        return true
    end
    return false
end

---检测action是否可以在当前模式下触发
---如果不可以，当模式切换的时候需要清理
---@param actionId int
---@return boolean
function MainHomeActionProxy:IsActionCanRunInMode(actionId)
    local actionData = self:GetActionCfg(actionId)
    if not actionData then
        return false
    end
    local mode = self.bll:GetMode()
    local actionTypeConf = self:GetActionTypeCfgById(actionId)
    if actionTypeConf then
        ---检测在当前模式下是否可以触发
        if not table.isnilorempty(actionTypeConf.TriggerCondition) and not table.containsvalue(actionTypeConf.TriggerCondition, mode) then
            if self.bll:IsDebugMode() then
                Debug.LogFormat("[MainHome] action[%s]当前模式下(mode:%s)不可以触发", self:GetActionDebugDes(actionId), mode == MainHomeConst.ModeType.NORMAL and "非交互模式" or "交互模式")
            end
            return false
        end
        return true
    end
    return false
end

---获取当前特殊约会列表
---@return cfg.MainUIActionBtn[]
function MainHomeActionProxy:GetSpecialList(force)
    if force or self.specialList then
        if self.specialList then
            PoolUtil.ReleaseTable(self.specialList)
        end
        ---@type cfg.MainUIActionBtn[]
        self.specialList = PoolUtil.GetTable()
        local actionCfgList = self:GetCurStateActions(MainHomeConst.ActionType.ScoreSpecialAction)
        for k, v in pairs(actionCfgList) do
            local cfg = LuaCfgMgr.Get("MainUIActionBtn", v.ID)
            if cfg then
                table.insert(self.specialList, cfg)
            end
        end
        PoolUtil.ReleaseTable(actionCfgList)
        if #self.specialList > 1 then
            table.sort(self.specialList, function(a, b)
                return a.ID < b.ID
            end)
        end
    end
    return self.specialList
end

---@param actionType string
---@return cfg.MainUIAction[]
function MainHomeActionProxy:GetCurStateActions(actionType)
    local res = PoolUtil.GetTable()
    ---@type cfg.MainUIAction[]
    local cfg = LuaCfgMgr.GetAll("MainUIAction")
    for k, v in pairs(cfg) do
        if self:IsActionCanRunInState(v.ID) then
            if not actionType or actionType == v.ActionType then
                table.insert(res, v)
            end
        end
    end
    return res
end

----@return cfg.MainUIActionBtn[]
function MainHomeActionProxy:GetAllBtnCfg()
    return LuaCfgMgr.GetAll("MainUIActionBtn")
end

---@return int
function MainHomeActionProxy:GetAI(actionId)
    local conf = self:GetActionCfg(actionId)
    if conf then
        return conf.AI
    end
    return 0
end

---@param actionId int
---@return string,string,string
function MainHomeActionProxy:GetActionTreeName(actionId)
    local ai = self:GetAI(actionId)
    if ai and ai > 0 then
        local aiConf = LuaCfgMgr.Get("MainUIAI", ai)
        if aiConf then
            return aiConf.PreTree, aiConf.BreakTree, aiConf.PostTree
        end
    end
    return nil
end

return MainHomeActionProxy