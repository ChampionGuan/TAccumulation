---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiaozhu.
--- DateTime: 2022/2/28 20:54
---
---进入主界面状态，完成初始化
---@type MainHome.MainHomeConst
local MainHomeConst = require("Runtime.System.X3Game.Modules.MainHome.Data.MainHomeConst")
local AIAction = require("Runtime.System.X3Game.Modules.AIDesigner.Task.MainHome.Action.MainHomeBaseAIAction")
---检查互动action是否可以执行
---Category:MainHome
---@class MainHomeCheckAction:MainHomeBaseAIAction
local MainHomeCheckAction = class("MainHomeCheckAction", AIAction)

function MainHomeCheckAction:OnAwake()
    AIAction.OnAwake(self)
    ---@type table<int,boolean>
    self.pendingMap = {}
    self.runningMap = {}
    self.waitingMap = {}
    self.tipsType = X3_CFG_CONST.POPUP_SPECIALTYPE_MAINUI
    self.sortFunc = handler(self, self.OnSortAction)
    self.waitErrandMgrFunc = handler(self, self.OnWaitErrandMgr)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_AI_CHECK_ACTION, self.OnEventCheckAction, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_AI_START_ACTION, self.OnEventStartAction, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_AI_STOP_ACTION, self.OnEventStopAction, self)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_AI_SET_ACTION_RUNNING, self.OnEventSetActionRunning, self)
end

function MainHomeCheckAction:OnEnter()
    self:Check()
end

function MainHomeCheckAction:Check()
    if table.isnilorempty(self.pendingMap) then
        return
    end
    local res = PoolUtil.GetTable()
    for actionId, _ in pairs(self.pendingMap) do
        table.insert(res,actionId)
        self:SetActionPending(actionId,false)
    end
    if #res >= 2 then
        table.sort(res, self.sortFunc)
    end
    for k, v in ipairs(res) do
        self:StartAction(v)
    end
    PoolUtil.ReleaseTable(res)
end

---@param actionId int
function MainHomeCheckAction:StopAction(actionId)
    self:SetActionPending(actionId, false)
    self:SetActionWaiting(actionId,false)
    self.bll:SetActionRunning(actionId, false)
end

---开始检测action是否可以执行
---@param actionId
---@param resCheck fun(type:boolean)
function MainHomeCheckAction:StartAction(actionId,resCheck)
    EventMgr.Dispatch(MainHomeConst.Event.MAIN_HOME_CHECK_ACTION_CAN_TRIGGER, actionId, self.runningMap, self.waitingMap,resCheck)
end

---@param a int
---@param b int
function MainHomeCheckAction:OnSortAction(a, b)
    local aData = self.bll:GetActionDataProxy():GetActionCfg(a)
    local bData = self.bll:GetActionDataProxy():GetActionCfg(b)
    return aData.Priority > bData.Priority
end

function MainHomeCheckAction:OnDestroy()
    self:ClearAll()
    AIAction.OnDestroy(self)
end


---检测waiting处理列表
function MainHomeCheckAction:CheckWaitingList()
    for actionId, _ in pairs(self.waitingMap) do
        self:SetActionWaiting(actionId,false)
        self:OnEventStartAction(actionId)
    end
end

---清理所有
function MainHomeCheckAction:ClearAll()
    table.clear(self.runningMap)
    table.clear(self.pendingMap)
    table.clear(self.waitingMap)
end

---@param executeType MainHomeConst.ActionExecute
---@param res MainHome.SwitchRes
function MainHomeCheckAction:OnEventCheckAction(executeType, res)
    local isDebug = self.bll:IsDebugMode()
    if executeType == MainHomeConst.ActionExecute.Run then
        self.bll:SetActionRunning(res.ActionId, true)
    elseif executeType == MainHomeConst.ActionExecute.Break then
        if res.HandlerType == MainHomeConst.ActionHandlerType.Running then
            local list = PoolUtil.GetTable()
            local breakList = PoolUtil.GetTable()
            table.insert(breakList, res.ActionId)
            for k, v in pairs(res.SwitchList) do
                table.insert(list, v)
                self.bll:SetActionRunning(v, false, breakList, MainHomeConst.ActionClearType.Action)
                if isDebug then
                    Debug.LogFormat("[MainHome] [action 在【running列表】中被打断]：[%s] 被 [%s] 打断", self.actionDataProxy:GetActionDebugDes(v), self.actionDataProxy:GetActionDebugDes(res.ActionId))
                end
            end
            self.bll:SetActionRunning(res.ActionId, true, list)
            PoolUtil.ReleaseTable(breakList)
        elseif res.HandlerType == MainHomeConst.ActionHandlerType.Waiting then
            for k, v in pairs(res.SwitchList) do
                if self:SetActionWaiting(v, false) and isDebug then
                    Debug.LogFormat("[MainHome] [action 在【等待列表】中被打断]：[%s] 被 [%s] 打断", self.actionDataProxy:GetActionDebugDes(v), self.actionDataProxy:GetActionDebugDes(res.ActionId))
                end
            end
            if self:SetActionWaiting(res.ActionId, true) and isDebug then
                Debug.LogFormat("[MainHome] action[%s] 被放入等待队列 ", self.actionDataProxy:GetActionDebugDes(res.ActionId))
            end
        end
    elseif executeType == MainHomeConst.ActionExecute.Pending then
        if self:SetActionWaiting(res.ActionId, true) and isDebug then
            Debug.LogFormat("[MainHome] action[%s] 被放入等待队列 ", self.actionDataProxy:GetActionDebugDes(res.ActionId))
        end
    elseif executeType == MainHomeConst.ActionExecute.Discard then
        if isDebug then
            for k, v in ipairs(res.SwitchList) do
                Debug.LogFormat("[MainHome] [action 被互斥丢弃]: [%s] 被 [%s] 互斥 ", self.actionDataProxy:GetActionDebugDes(res.ActionId), self.actionDataProxy:GetActionDebugDes(v))
            end
        end
    else
        Debug.LogWarning("[MainHome] 找不到处理方案[%s]", executeType)
    end
end

---设置running列表
---@param actionId int
---@param isEnable boolean
---@return boolean
function MainHomeCheckAction:SetActionRunning(actionId, isEnable)
    if isEnable then
        if not self.runningMap[actionId] then
            self.runningMap[actionId] = actionId
            return true
        end
    else
        local res = self.runningMap[actionId] ~= nil
        if res then
            self.runningMap[actionId] = nil
            self:CheckWaitingList()
        end
        return res
    end
    return false
end

---设置pending列表
---@param actionId int
---@param isEnable boolean
---@return boolean
function MainHomeCheckAction:SetActionPending(actionId, isEnable)
    if isEnable then
        if not self.pendingMap[actionId] then
            self.pendingMap[actionId] = actionId
            self:SetActionWaiting(actionId,false)
            if self.bll:IsDebugMode() then
                self.editorAction:SetActionPending(actionId, isEnable)
                Debug.LogFormat("[MainHome] action[%s] 被加入到待处理队列", self.actionDataProxy:GetActionDebugDes(actionId))
            end
            return true
        end
    else
        if self.pendingMap[actionId] then
            self.pendingMap[actionId] = nil
            if self.bll:IsDebugMode() then
                self.editorAction:SetActionPending(actionId, isEnable)
                Debug.LogFormat("[MainHomeunity] action[%s] 从待处理队列中被移除", self.actionDataProxy:GetActionDebugDes(actionId))
            end
            return true
        end
    end
    return false
end

---设置等待列表
---@param actionId int
---@param isEnable boolean
---@return boolean
function MainHomeCheckAction:SetActionWaiting(actionId, isEnable)
    if isEnable then
        if not self.waitingMap[actionId] then
            self.waitingMap[actionId] = actionId
            if self.bll:IsDebugMode() then
                self.editorAction:SetActionWaiting(actionId, isEnable)
            end
            return true
        end
    else
        if self.waitingMap[actionId] then
            self.waitingMap[actionId] = nil
            if self.bll:IsDebugMode() then
                self.editorAction:SetActionWaiting(actionId, isEnable)
            end
            return true
        end
    end
    return false
end

---action 执行状态变更
---@param actionId int
---@param isRunning boolean
function MainHomeCheckAction:OnEventSetActionRunning(actionId, isRunning)
    self:SetActionRunning(actionId, isRunning)
    if isRunning then
        self:SetActionPending(actionId,false)
        self:SetActionWaiting(actionId,false)
    end
end

function MainHomeCheckAction:OnWaitErrandMgr()
    ErrandMgr.End(self.tipsType)
    self.bll:SetHandlerRunning(MainHomeConst.HandlerType.WaitingErrandMgr, false)
end

---开启action
---@param actionId int
function MainHomeCheckAction:OnEventStartAction(actionId)
    if not self.actionDataProxy:IsActionUnlock(actionId,true) then
        return
    end
    if self:SetActionPending(actionId, true) then
        if not self.bll:IsHandlerRunning(MainHomeConst.HandlerType.WaitingErrandMgr) then
            self.bll:SetHandlerRunning(MainHomeConst.HandlerType.WaitingErrandMgr, true)
            ErrandMgr.AddWithCallBack(self.tipsType, self.waitErrandMgrFunc)
        end
    end
end

---关闭/停止action
---@param actionId int
function MainHomeCheckAction:OnEventStopAction(actionId)
    self:StopAction(actionId)
end

return MainHomeCheckAction