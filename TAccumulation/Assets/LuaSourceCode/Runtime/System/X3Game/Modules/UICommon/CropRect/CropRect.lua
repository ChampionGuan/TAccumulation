---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by deling.
--- DateTime: 2022/3/10 11:45
---

local CropRect = class("CropRect")
---@type CropRectConst
local CropRectConst = require("Runtime.System.X3Game.Modules.UICommon.CropRect.CropRectConst")
local CropRectMode = CropRectConst.CropRectMode
local CropRectScaleMode = CropRectConst.CropRectScaleMode
local CropSysEntryConfig = CropRectConst.CropSysEntryConfig
--OPEN_CROP_RECT
---初始化
function CropRect:Init()
    --Debug.LogError("CropRect:Init")
    self.view_tag = UIConf.CropRectWnd
    self.is_running = false
    self:RegisterEvent()

    self.basePivot = CS.UnityEngine.Vector2(0, 0);

end

---打开通用裁剪界面
---@param localPath string 本地图片路径
---@param imageCom Image | string 需要取图的Image或图片名称
---@param onCaptureScreen fun():void 当前屏幕截图前的回调
---@param onCaptureScreenEnd fun(Texture2D):void  裁剪完成后的回调。
---@param entry CropSysEntry 裁剪框的模式
---@param biz UrlImgMgr.BizType 业务类型
function CropRect:OpenCropUI(localPath, imageCom, onCaptureScreen, onCaptureScreenEnd, entry, biz)
    UIMgr.Open(self.view_tag, localPath, imageCom, onCaptureScreen, onCaptureScreenEnd, entry, biz)
end

---关闭裁剪界面
function CropRect:CloseCropUI()
    UIMgr.Close(self.view_tag)
end


---背景缩放时
---@param targetRect RectTransform  移動的照片Rect
---@param chooseRect RectTransform  中間裁剪框的Rect
---@param bottomMaskRect RectTransform  下遮罩Rect
---@param topMaskRect RectTransform  上遮罩Rect
function CropRect.OnScaleTouch(bgRect, chooseRect, bottomMaskRect, scale, pivot, minScale, maxScale, isDelta)
    if (isDelta) then
        scale = bgRect.localScale.x + scale;
    end
    scale = math.clamp(scale, minScale, maxScale);
    CropRect.SetRectPivot(bgRect, pivot, true);
    --Debug.LogError(" localScale ", scale)
    bgRect.localScale = CS.UnityEngine.Vector3(scale, scale, 1)--Vector3.Temp(scale, scale, 1);
    --缩放后，按照基础pivot矫正位置
    --Debug.LogError(" bgRect.localScale ", bgRect.localScale)

    local curPos = CropRect.GetTransPosWithPivot(bgRect, CropRect.basePivot, true);
    CropRect.SetRectPos(bgRect, chooseRect, bottomMaskRect, curPos, false);
end

--设置Rect锚点
function CropRect.SetRectPivot(rectTrans, pivot, needScale)
    local tempPos = CropRect.GetTransPosWithPivot(rectTrans, pivot, needScale);
    rectTrans.localPosition = tempPos;
    rectTrans.pivot = pivot;
end

--给予指定的pivot获取Trans位置 --Lua端V2运算符似乎有点问题，先手动计算
function CropRect.GetTransPosWithPivot(rectTrans, pivot, needScale)
    local sizeDelta = needScale and rectTrans.sizeDelta * rectTrans.localScale.x or rectTrans.sizeDelta;
    local luaSizeDelta = CS.UnityEngine.Vector2(sizeDelta.x, sizeDelta.y);
    local baseOffset = (-sizeDelta / 2) + (rectTrans.pivot * sizeDelta);
    local basePos = rectTrans.localPosition - CS.UnityEngine.Vector3(baseOffset.x, baseOffset.y, 0);

    local arg1 = (-luaSizeDelta / 2)
    local arg2 = CS.UnityEngine.Vector2(pivot.x * luaSizeDelta.x, pivot.y * luaSizeDelta.y)--  (pivot * luaSizeDelta)
    local offset = arg1 + arg2
    local result = CS.UnityEngine.Vector3(offset.x + basePos.x, offset.y + basePos.y, 0);
    return result
end

function CropRect.SetRectPos(targetRect, chooseRect, bottomMaskRect, pos, isDelta)
    local curPivot = targetRect.pivot
    if((curPivot.x ~= CropRect.basePivot.x) or (curPivot.y ~= CropRect.basePivot.y)) then

        CropRect.SetRectPivot(targetRect, CropRect.basePivot, true);

    end

    local retY = targetRect.anchoredPosition3D.y
    local retX = targetRect.anchoredPosition3D.x
    local scaleX = targetRect.localScale.x
    pos = isDelta and CS.UnityEngine.Vector3(pos.x + retX, pos.y + retY) or pos

    local chooseSize = chooseRect.rect.size
    local bottomMaxy = bottomMaskRect.rect.size.y
    local curTextureSize = targetRect.rect.size
    local topMaxy = 0 - ((curTextureSize.y * scaleX) - (chooseSize.y + bottomMaskRect.sizeDelta.y))

    if pos.y > 0 then
        if pos.y < bottomMaxy then
            retY = pos.y
        end
    else
        if pos.y > topMaxy then
            retY = pos.y
        end
    end
    local curRootSize = UIMgr.GetUIRoot().sizeDelta
    local xMax = (curTextureSize.x * scaleX) - curRootSize.x
    if xMax > 0 then
        if pos.x < 0 and math.abs(pos.x) < xMax then
            retX = pos.x
        end
    end
    --Debug.LogError("new ", Vector3.new(retX, retY, 0))
    targetRect.anchoredPosition3D = Vector3.new(retX, retY, 0)

end


function CropRect:RegisterEvent()
    EventMgr.AddListener(Const.Event.OPEN_CROP_RECT, self.OpenCropUI, self)
    EventMgr.AddListener(Const.Event.CLOSE_CROP_RECT, self.CloseCropUI, self)

end
CropRect:Init()

return CropRect
