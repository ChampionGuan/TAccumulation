---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2022/7/22 16:23
---

---@class ShaderWarmupMgr
local ShaderWarmupMgr = class("ShaderWarmupMgr")
local Time = CS.UnityEngine.Time
local XResources = CS.XAssetsManager.XResources
local FileUtility = CS.PapeGames.X3.FileUtility

---@type boolean 是否开启ShaderWarmup
local openWarmup = true
---@type boolean 预热是否为异步模式
local isAsyncMode = true
---@type WarmupSyncHelper|WarmupAsyncHelper 预热器
local warmupHelper = nil
---@type table<string, boolean>
local warmupState = {}
---@type fun 完成回调
local onCpl = nil

--region GM接口
---是否开启Warmup
---@param value boolean
function ShaderWarmupMgr.SetOpenWarmup(value)
    openWarmup = value
end

---获取是否开启了Warmup
---@return boolean
function ShaderWarmupMgr.GetOpenWarmup()
    return openWarmup
end

---是否开启Warmup
---@param value boolean
function ShaderWarmupMgr.SetAsyncMode(value)
    ---目前只支持Metal 和 OpenGLES
    if not UNITY_EDITOR then
        isAsyncMode = value
    end
end

---获取是否开启了Warmup
---@return boolean
function ShaderWarmupMgr.GetAsyncMode()
    return isAsyncMode
end
--endregion

---开始预热
---@param progressHandler fun<float>
---@param cplHandler fun
function ShaderWarmupMgr.StartWarmup(progressHandler, cplHandler)
    Debug.LogFormat("【ShaderWarmup】预热启动 ", Time.realtimeSinceStartup, " openWarmup ", openWarmup)
    if openWarmup then
        if warmupHelper then
            Debug.LogFormat("【ShaderWarmup】当前正在预热，继续进行")
            return
        end
        if isAsyncMode then
            warmupHelper = require("Runtime.System.X3Game.Modules.ShaderWarmup.WarmupAsyncHelper").new()
            Debug.LogFormat("【ShaderWarmup】异步预热开启")
        else
            warmupHelper = require("Runtime.System.X3Game.Modules.ShaderWarmup.WarmupSyncHelper").new()
            Debug.LogFormat("【ShaderWarmup】同步预热开启")
        end
        EventTraceMgr:Trace(EventTraceEnum.EventType.StartShaderWarmup)
        onCpl = cplHandler
        warmupHelper:StartWarmup(progressHandler, ShaderWarmupMgr.WarmupCpl)
    else
        Debug.LogFormat("【ShaderWarmup】预热开关关闭")
        pcall(cplHandler)
    end
end

---预热完成
function ShaderWarmupMgr.WarmupCpl()
    if onCpl then
        onCpl()
        onCpl = nil
    end
    EventTraceMgr:Trace(EventTraceEnum.EventType.EndShaderWarmup)
    ShaderWarmupMgr.DestroyHelper()
end

---销毁Helper
function ShaderWarmupMgr.DestroyHelper()
    if warmupHelper then
        warmupHelper:ClearWarmupData()
        GameUtil.ClearTarget(warmupHelper)
        warmupHelper = nil
        Debug.LogFormat("【ShaderWarmup】DestroyHelper")
    end
end

---停止预热
function ShaderWarmupMgr.StopWarmup()
    if warmupHelper then
        warmupHelper:OnStopWarmup()
        ShaderWarmupMgr.DestroyHelper()
        EventTraceMgr:Trace(EventTraceEnum.EventType.EndShaderWarmup)
    end
    Debug.LogFormat("【ShaderWarmup】强制暂停")
end

---放弃预热
function ShaderWarmupMgr.GiveupWarmup()
    if warmupHelper then
        warmupHelper:OnGiveupWarmup()
    end
    ShaderWarmupMgr.StopWarmup()
end

---检查预热的状态
---@param svcPath string
---@return boolean
function ShaderWarmupMgr.CheckWarmupState(svcPath)
    if UNITY_EDITOR then
        return false
    end
    local tempStr = string.split(svcPath, "/")
    local svcName = tempStr[#tempStr]
    if warmupState[svcName] == nil then
        warmupState[svcName] = PlayerPrefs.GetBool(string.concat("WarmUp_", svcName), false)
    end
    return warmupState[svcName]
end

---更新预热状态
---@param svcPath string
---@param state boolean
function ShaderWarmupMgr.ChangeWarmupState(svcPath, state)
    local tempStr = string.split(svcPath, "/")
    local svcName = tempStr[#tempStr]
    warmupState[svcName] = state
    PlayerPrefs.SetBool(string.concat("WarmUp_", svcName), state)
    PlayerPrefs.Save()
end

---添加一个清除预热标记位的接口
function ShaderWarmupMgr.ClearWarmupState()
    local shaderInfo = XResources.GetShaderInfo()
    if shaderInfo ~= nil and shaderInfo.ShaderItemInfos ~= nil then
        for i = 0, shaderInfo.ShaderItemInfos.Length - 1 do
            local itemInfo = shaderInfo.ShaderItemInfos[i]
            local path = itemInfo.SVCPath
            if itemInfo.VariantCount > 0 then
                ShaderWarmupMgr.ChangeWarmupState(path, false)
            end
        end
    end
end

---清理ShaderCodeCache
function ShaderWarmupMgr.ClearShaderCode()
    local folderPath = CS.UnityEngine.Rendering.GraphicsSettings.GetShaderCodeCacheFolder()
    --文件夹下的这个文件需要保留，不然重启后引擎会判断ShaderCodeCache异常重新生成
    local srcPath = folderPath .. "/version"
    local desPath = CS.UnityEngine.Application.persistentDataPath.."/version"
    FileUtility.FileMove(srcPath, desPath)
    FileUtility.DirectoryDelChildren(folderPath)
    FileUtility.FileMove(desPath, srcPath)
end

--[[---检查是否需要预热
---@return boolean
function ShaderWarmupMgr.CheckNeedWarmup()
    local shaderInfo = XResources.GetShaderInfo()
    if shaderInfo ~= nil and shaderInfo.ShaderItemInfos ~= nil then
        for i = 0, shaderInfo.ShaderItemInfos.Length - 1 do
            local itemInfo = shaderInfo.ShaderItemInfos[i]
            local path = itemInfo.AssetPath
            if itemInfo.VariantCount > 0 and not ShaderWarmupMgr.CheckWarmupState(path) then
                local tempStr = string.split(itemInfo.AssetPath, "/")
                if not string.startswith(tempStr[#tempStr], "UI_") and
                        not string.startswith(tempStr[#tempStr], "TextMeshPro_") then
                    return true;
                end
            end
        end
    end
    return false
end]]

return ShaderWarmupMgr