---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2023/6/27 14:55
---

---@class WarmupAsyncHelper
local WarmupAsyncHelper = class("WarmupAsyncHelper")
local ResUpdateManager = require("Runtime.System.X3Game.Modules.ResUpdate.ResUpdateManager")
local ResUpdateConst = require("Runtime.System.X3Game.Modules.ResUpdate.ResUpdateConst")
local XResources = CS.XAssetsManager.XResources
local Resources = CS.UnityEngine.Resources
local Time = CS.UnityEngine.Time

local SVCGetBackgroundJobCount = CS.UnityEngine.ShaderVariantCollection.GetBackgroundJobCount
local StopBackgroundJob = CS.UnityEngine.ShaderVariantCollection.StopBackgroundJob
local AsyncPolicy = CS.UnityEngine.ShaderVariantCollection.AsyncPolicy
local AsyncWarmupState = CS.UnityEngine.ShaderVariantCollection.AsyncWarmupState
local HasFallbackTextures = CS.UnityEngine.VFX.VisualEffect.hasFallbackTextures

---@class ShaderItemInfo
---@field svc CS.UnityEngine.ShaderVariantCollection
---@field svcPath string
---@field shader CS.UnityEngine.Shader
---@field shaderPath string

---异步预热器
function WarmupAsyncHelper:ctor()
    ---@type int
    self.timerId = 0
    ---@type string[] 待加载的SVC路径
    self.loadQueue = {}
    ---@type ShaderItemInfo[]
    self.shaderItemCache = {}
    ---@type string[]
    self.svcPathCache = {}
    ---@type table<string, string>
    self.shaderPathCache = {}
    ---@type CS.UnityEngine.Shader[] 缓存Shader在销毁时Unload用
    self.shaderCache = {}
    ---@type float 总共需要预热的数量
    self.totalWarmupCount = 0
    ---@type fun(float)
    self.onProgress = nil
    ---@type fun()
    self.onCpl = nil

    ---@type int 异步更新间隔
    self.asyncUpdateInterval = 1
    ---@type CS.UnityEngine.ShaderVariantCollection[] 等待启动预热的svc集合
    self.asyncWaitCache = {}
    ---@type int 异步预热的变体总数量
    self.completedVariantCnt = 0
    ---@type int 正在预热的SVC总数
    self.warmingVariantCnt = 0
    ---@type int 异步预热的变体总数量
    self.totalVariantCnt = 0
    ---@type int 异步完成预热的数量
    self.asyncCompletedCnt = 0
    ---@type int 防止进度回退所需
    self.asyncLastProgress = 0
    ---@type float
    self.freeTime = 0
    ---@type int
    self.totalCount = 0
    ---@type int
    self.leftCount = 0
    ---@type string[] 需要卸载Shader的白名单
    self.unloadShaderList = {
        "Scene.shader",
        "SceneTransparent.shader",
        "SceneTransparent2S.shader",
        "ClothStandard.shader",
        "MonsterCrystalEffect.shader",
        "Fur15.shader",
        "MonsterStandardEffect.shader",
        "Vegetation.shader",
        "SceneSoftEdge.shader",
        "Mirror.shader",
        "BattleCommon.shader",
        "ClothAnisotropic.shader",
        "HairScreenDoor.shader",
        "HairTransparent.shader",
        "CustomNewSky.shader",
        "ClothStandardArray.shader",
        "SkinSSS.shader",
        "ClothRimLight.shader",
        "SceneFar.shader",
        "SceneMonster.shader",
        "Standard Lit.shader"
    }

    --region Debug
    ---@type int[] 记录异步shader预热启动时间
    self.asyncSvcTimeCache = {}
    ---@type float 已预热的时间
    self.warmupedTime = 0
    ---@type table Debug数据
    self.warmupRecord = nil
    ---@type float 单变体最高耗时
    self.highestSVCTime = 0
    ---@type string 最高耗时所属SVC
    self.highestOwnerSVC = nil
    --endregion
end

---开始预热
---@param progressHandler fun<float>
---@param cplHandler fun
function WarmupAsyncHelper:StartWarmup(progressHandler, cplHandler)
    self.onProgress = progressHandler
    self.onCpl = cplHandler
    if DEBUG_GM and self.warmupRecord == nil then
        self.warmupRecord = {}
        self.warmupRecord["deviceModel"] = tostring(CS.UnityEngine.SystemInfo.deviceModel)
        self.warmupRecord["graphicsDeviceName"] = tostring(CS.UnityEngine.SystemInfo.graphicsDeviceName)
        self.warmupRecord["graphicsDeviceType"] = tostring(CS.UnityEngine.SystemInfo.graphicsDeviceType)

        self.warmupRecord["asyncMode"] = tostring(self.isAsyncMode)
        self.warmupRecord["warmupTime"] = {}
    end
    self:CheckWarmupList()
    self:InternalWarmup()
end

---
function WarmupAsyncHelper:InternalWarmup()
    if self.timerId == 0 then
        Debug.LogFormat("【ShaderWarmup】预热开始")
        if self.totalWarmupCount > 0 then
            self.timerId = TimerMgr.AddTimer(self.asyncUpdateInterval, self.WarmupUpdateAsync, self, -1)
            self:LoadAssetAsync()
        else
            self:WarmupCpl()
        end
    end
end

---开始加载SVC
function WarmupAsyncHelper:LoadAssetAsync()
    if #self.loadQueue > 0 then
        local curPath = table.remove(self.loadQueue)
        Debug.LogFormat("【ShaderWarmup】SVC加载开始%s", curPath)

        Res.LoadWithAssetPathAsync(curPath, AutoReleaseMode.None, typeof(CS.UnityEngine.ShaderVariantCollection),
                nil, function(asset)
                    self:OnAssetLoadCplAsync(asset, curPath)
                end)
    end
end

---检测Shader变更
function WarmupAsyncHelper:CheckShaderAssetModified()
    local modifiedFiles = ResUpdateManager.GetModifiedFiles(ResUpdateConst.NotificationResType.SVC)
    if modifiedFiles and #modifiedFiles > 0 then
        for _, path in pairs(modifiedFiles) do
            Debug.LogFormat("【ShaderWarmup】检测到Shader变更-%s", path)
            ShaderWarmupMgr.ChangeWarmupState(path, false)
        end
        ResUpdateManager.ClearModifiedFiles(ResUpdateConst.NotificationResType.SVC)
        return true
    end
    return false
end

---异步预热Tick
function WarmupAsyncHelper:WarmupUpdateAsync()
    for i = #self.asyncWaitCache, 1, -1 do
        self.warmingVariantCnt = self.warmingVariantCnt + self.asyncWaitCache[i].variantCount
        self.asyncWaitCache[i]:WarmUpAsync(AsyncPolicy.Background) -- Fullpower
        table.remove(self.asyncWaitCache)
    end

    if not ShaderWarmupMgr.GetOpenWarmup() then
        Debug.LogFormat("【ShaderWarmup】检测到预热开关关闭，放弃预热。")
        ShaderWarmupMgr.GiveupWarmup()
        return
    end

    for i = #self.shaderItemCache, 1, -1 do
        if not ShaderWarmupMgr.CheckWarmupState(self.svcPathCache[i]) then
            local curSVCItem = self.shaderItemCache[i].svc
            if curSVCItem.isWarmedUp then
                Debug.LogFormat("【ShaderWarmup】单个shader预热完成，对应路径:。%s", self.svcPathCache[i], " i ", i)
                ShaderWarmupMgr.ChangeWarmupState(self.svcPathCache[i], true)
                self.asyncCompletedCnt = self.asyncCompletedCnt + 1
                self.completedVariantCnt = self.completedVariantCnt + curSVCItem.variantCount
                self.warmingVariantCnt = self.warmingVariantCnt - curSVCItem.variantCount
                ---统计使用
                if DEBUG_GM and self.asyncSvcTimeCache[i] then
                    local costTime = Time.realtimeSinceStartup - self.asyncSvcTimeCache[i]
                    self.warmupRecord["warmupTime"][curSVCItem.name] = costTime
                    if (costTime > self.highestSVCTime) then
                        self.highestSVCTime = costTime
                        self.highestOwnerSVC = curSVCItem.name
                    end
                end
                self:UnloadShaderItem(self.shaderItemCache[i])
                table.remove(self.shaderItemCache, i)
                table.remove(self.svcPathCache, i)
            else
                if DEBUG_GM then
                    ---统计单个耗时 ---每秒执行一次，统计会有些误差
                    if ((not self.asyncSvcTimeCache[i]) and curSVCItem.asyncWarmupState == AsyncWarmupState.Warming) then
                        self.asyncSvcTimeCache[i] = Time.realtimeSinceStartup
                    end
                end
            end
        end
    end

    local leftCount, totalCount;
    leftCount, totalCount = SVCGetBackgroundJobCount()
    local progress = 0

    --[[if (#self.svcPathCache ~= self.asyncTempTotalCnt) or totalCount == 0 then
        ---变体数量与后台任务数没有稳定的关系，为了防止进度闪烁，做如下处理
        progress = (totalCount - leftCount) / self.totalVariantCnt
    else
        progress = (totalCount - leftCount) / totalCount
    end]]

    if totalCount == 0 or leftCount == 0 then
        progress = self.completedVariantCnt / self.totalVariantCnt
    else
        progress = (self.completedVariantCnt + self.warmingVariantCnt * (totalCount - leftCount) / totalCount) / self.totalVariantCnt
    end

    ---防止进度回退
    if (progress < self.asyncLastProgress and self.asyncLastProgress < 0.99) then
        progress = self.asyncLastProgress
    else
        self.asyncLastProgress = progress
    end

    Debug.Log("【ShaderWarmup】预热情况 Background 数量 ", leftCount, " max ", totalCount,
            " time ", self.warmupedTime, "CompletedVariantCnt ", self.completedVariantCnt, "TotalVariantCnt ", self.totalVariantCnt, "Progress ", self.asyncLastProgress)

    Debug.Log("【ShaderWarmup】预热结果 未完成SVC数量： ", #self.shaderItemCache, " 已完成SVC数量： ", self.asyncCompletedCnt, " 剩余加载队列数量： ", #self.loadQueue, " 预热SVC总数： ", self.totalWarmupCount)
    self.warmupedTime = self.warmupedTime + self.asyncUpdateInterval
    if self.warmupedTime > 600 then
        Debug.LogFormat("【ShaderWarmup】变体预热总时长超时，放弃预热。")
        ShaderWarmupMgr.GiveupWarmup()
        return
    end
    pcall(self.onProgress, progress)

    if self.totalWarmupCount == self.asyncCompletedCnt and #self.loadQueue == 0 and (leftCount == 0) then
        Debug.Log("【ShaderWarmup】All Shader Load complete ", Time.realtimeSinceStartup)
        if DEBUG_GM and self.warmupRecord ~= nil then
            self.warmupRecord["totalTime"] = self.warmupedTime
            self.warmupRecord["highestSVCTime"] = self.highestSVCTime
            self.warmupRecord["highestOwnerSVC"] = self.highestOwnerSVC
            GameHelper.StoreLog("ShaderWarmup", JsonUtil.Encode(self.warmupRecord))
            self.warmupRecord = nil
        end
        self:WarmupCpl()
    else
        --如果剩余次数和总数
        if self.leftCount == leftCount and self.totalCount == totalCount then
            self.freeTime = self.freeTime + self.asyncUpdateInterval
            if self.freeTime > 10 then
                if #self.loadQueue > 0 then
                    self:LoadAssetAsync()
                    self.freeTime = 0
                    Debug.LogWarningFormat("【ShaderWarmup】出现异常情况，后台LeftCount持续10秒没有改变且没有预热完成，发起一个新的SVC加载。")
                else
                    Debug.LogWarningFormat("【ShaderWarmup】出现异常情况，后台LeftCount持续10秒没有改变且没有预热完成，放弃预热。")
                    for i = #self.shaderItemCache, 1, -1 do
                        if not ShaderWarmupMgr.CheckWarmupState(self.svcPathCache[i]) then
                            local curSVCItem = self.shaderItemCache[i].svc
                            if not curSVCItem.isWarmedUp then
                                Debug.LogFormat("【ShaderWarmup】预热未完成，对应路径:%s", self.svcPathCache[i], " i ", i)
                            end
                        end
                    end
                    ShaderWarmupMgr.GiveupWarmup()
                end
            end
        else
            self.freeTime = 0
            self.leftCount = leftCount
            self.totalCount = totalCount
        end
    end
end

---异步测试接口
---@param asset CS.UnityEngine.ShaderVariantCollection
---@param path string 路径
function WarmupAsyncHelper:OnAssetLoadCplAsync(asset, path)
    Debug.LogFormat("【ShaderWarmup】SVC加载异步结束%s", path)
    if self.timerId and self.timerId ~= 0 then
        if (asset and asset.variantCount > 0) then
            local shaderItemInfo = { svc = asset, svcPath = path, shader = nil, shaderPath = nil }
            local shaderPath = self:GetShaderPath(path)
            if string.isnilorempty(shaderPath) == false then
                shaderItemInfo.shader = Res.LoadWithAssetPath(shaderPath, AutoReleaseMode.None, typeof(CS.UnityEngine.Shader))
                shaderItemInfo.shaderPath = shaderPath
            end
            table.insert(self.shaderItemCache, shaderItemInfo)
            table.insert(self.svcPathCache, path)
            table.insert(self.asyncWaitCache, asset)
        end
        self:LoadAssetAsync()
    end
end

---预热结束
function WarmupAsyncHelper:WarmupCpl()
    --保护机制，即使完成了也调用一下这个
    StopBackgroundJob()
    TimerMgr.Discard(self.timerId)
    self.timerId = 0
    Debug.LogFormat("【ShaderWarmup】预热完成-耗时%s秒", tostring(self.warmupedTime))
    pcall(self.onProgress, 1)
    pcall(self.onCpl) --回调一定要在最后，更新界面那里会销毁lua虚拟机，导致不可控的问题
end

---检查需要预热的列表
function WarmupAsyncHelper:CheckWarmupList()
    --[[if not HasFallbackTextures then
        local vfxCommon = Res.LoadWithAssetPath("Assets/Build/Art/SVC/Vfx/vfx_common.shadervariants", AutoReleaseMode.Scene, typeof(CS.UnityEngine.ShaderVariantCollection))
        if vfxCommon then
            self:AddWarmupToList("Assets/Build/Art/SVC/Vfx/vfx_common.shadervariants", vfxCommon.variantCount)
        end
    else
        local vfxHw = Res.LoadWithAssetPath("Assets/Build/Art/SVC/Vfx/vfx_hw.shadervariants", AutoReleaseMode.Scene, typeof(CS.UnityEngine.ShaderVariantCollection))
        if vfxHw then
            self:AddWarmupToList("Assets/Build/Art/SVC/Vfx/vfx_hw.shadervariants", vfxHw.variantCount)
        end
    end]]
    self:CheckShaderAssetModified()
    local shaderInfo = XResources.GetShaderInfo()
    if shaderInfo ~= nil and shaderInfo.ShaderItemInfos ~= nil then
        for i = 0, shaderInfo.ShaderItemInfos.Length - 1 do
            local itemInfo = shaderInfo.ShaderItemInfos[i]
            self:AddWarmupToList(itemInfo)
        end
    end
    Debug.LogFormat("【ShaderWarmup】预热队列完成%s", #self.loadQueue)
end

---添加一个预热
---@param itemInfo CS.XAssetsManager.XShaderItemInfo
function WarmupAsyncHelper:AddWarmupToList(itemInfo)
    if itemInfo.VariantCount > 0 then
        local svcPath = itemInfo.SVCPath
        if Res.IsAssetFileExist(svcPath) and not ShaderWarmupMgr.CheckWarmupState(svcPath) then
            local tempStr = string.split(svcPath, "/")
            local needWarmup = true
            ---跳过UI,TextMeshPro
            if not string.startswith(tempStr[#tempStr], "UI_") and
                    not string.startswith(tempStr[#tempStr], "TextMeshPro_") then
                --not string.find(tempStr[#tempStr], "vfx_") then
                if tempStr[#tempStr] == "vfx_common.shadervariants" then
                    needWarmup = not HasFallbackTextures
                elseif tempStr[#tempStr] == "vfx_hw.shadervariants" then
                    needWarmup = HasFallbackTextures
                else
                    needWarmup = true
                end

                if needWarmup then
                    if self:IsVFX(tempStr[#tempStr]) then
                        --非fx优先预热
                        table.insert(self.loadQueue, 1, svcPath)
                    else
                        table.insert(self.loadQueue, svcPath)
                    end
                    self.totalWarmupCount = self.totalWarmupCount + 1
                    self.totalVariantCnt = self.totalVariantCnt + itemInfo.VariantCount
                    if string.isnilorempty(itemInfo.AssetPath) == false then
                        local shaderNameArray = string.split(itemInfo.AssetPath, "/")
                        local shaderName = shaderNameArray[#shaderNameArray]
                        if table.indexof(self.unloadShaderList, shaderName) ~= false then
                            self.shaderPathCache[svcPath] = itemInfo.AssetPath
                        end
                    end
                    Debug.LogFormat("【ShaderWarmup】添加预热队列%s-%s", svcPath, itemInfo.VariantCount)
                end
            end
        end
    end
end

---判断是否是vfx
---@param name string
---@return boolean
function WarmupAsyncHelper:IsVFX(name)
    return string.startswith(name, "HIDDEN_VFX") or string.endswith(name, "vfx.shadervariants")
end

---特殊情况放弃预热
function WarmupAsyncHelper:OnGiveupWarmup()
    if self.svcPathCache then
        for _, v in pairs(self.svcPathCache) do
            ShaderWarmupMgr.ChangeWarmupState(v, true)
        end
    end
    if self.loadQueue then
        for _, v in pairs(self.loadQueue) do
            ShaderWarmupMgr.ChangeWarmupState(v, true)
        end
    end
    self:WarmupCpl()
end

---
function WarmupAsyncHelper:OnStopWarmup()
    TimerMgr.Discard(self.timerId)
    self.timerId = 0
    StopBackgroundJob()
end

---卸载SVC接口
---@param shaderItem ShaderItemInfo
function WarmupAsyncHelper:UnloadShaderItem(shaderItem)
    --还是需要调用下Unload解掉引用
    Res.Unload(shaderItem.svc)
    Resources.UnloadAsset(shaderItem.svc)
    Debug.LogFormat("【ShaderWarmup】卸载SVC-%s", shaderItem.svcPath)
    if shaderItem.shader then
        --还是需要调用下Unload解掉引用
        Res.Unload(shaderItem.shader)
        Resources.UnloadAsset(shaderItem.shader)
        Debug.LogFormat("【ShaderWarmup】卸载Shader-%s", shaderItem.shaderPath)
    end
end

---根据SVC路径获得Shader路径
---@param svcPath string
---@return string
function WarmupAsyncHelper:GetShaderPath(svcPath)
    return self.shaderPathCache[svcPath]
end

---清理预热数据
function WarmupAsyncHelper:ClearWarmupData()
    table.clear(self.loadQueue)
    for i = #self.shaderItemCache, 1, -1 do
        if self.shaderItemCache[i] then
            self:UnloadShaderItem(self.shaderItemCache[i])
        end
    end
    table.clear(self.shaderItemCache)
    table.clear(self.svcPathCache)
    table.clear(self.asyncSvcTimeCache)
    table.clear(self.asyncWaitCache)
    self.onProgress = nil
    self.onCpl = nil
end

return WarmupAsyncHelper