---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by deling.
--- DateTime: 2023/9/14 11:26
---

---@class DatePlanCtrl
local DatePlanCtrl = class("DatePlanCtrl")
---@type DatePlanConst
local DatePlanConst = require("Runtime.System.X3Game.Modules.DatePlan.DatePlanConst")
---@type PurikuraConstNew
local PurikuraConstNew = require "Runtime.System.X3Game.Modules.PurikuraNew.PurikuraConstNew"

local CatCardConst = require("Runtime.System.X3Game.Modules.CatCard.Data.CatCardConst")

---@type PureLogic.ClientEntity
local _EntityCtrl = nil

local _LetterID = nil
local _ManType = nil
local _ContentID = nil
local _StageID = nil
---@type DialogueController
local _DialogCtrl = nil
local _Actor = nil

---玩法结束时传出的数据，临时放下，后面挪到核心逻辑中
local _PlayResult = nil

function DatePlanCtrl:Init()
    self.configList = {}

end

--不同玩法可能会透传出一些数据（目前仅喵喵牌结果，）断线后，需要使用服务器数据，正常游玩时，直接使用玩法内传递出来的数据
function DatePlanCtrl:FillGamePlayData(letterID)

end

function DatePlanCtrl:FillConfigList(letterID)
    local cfgList = LuaCfgMgr.GetListByCondition("DatePlanContent", {LetterID = letterID})
    table.sort(cfgList, function(a, b)
        return a.Order < b.Order
    end)
    self.configList = cfgList

end

function DatePlanCtrl:GetNextContentConfig(curContentId)
    Debug.LogWarning("GetNextContentConfig curContentId ", curContentId, " # ", #self.configList)
    if(not curContentId) then
        return self.configList[1]
    end
    local hit = false
    for i = 1, #self.configList do
        if(hit) then
            return self.configList[i]
        end
        if(self.configList[i].ID == curContentId) then
            hit = true
        end
    end
    Debug.LogWarning("GetNextContentConfig error ", curContentId)
end

function DatePlanCtrl:ChangeGameState()
    local result = GameStateMgr.Switch(GameState.DatePlan)
    Debug.LogWarning("ChangeGameState result ", result)
    return result
end

function DatePlanCtrl:Start(letterID, curContentId)
    local result = self:ChangeGameState()
    Debug.LogWarning("Start result ", result, "letterID ", letterID, "curContentId ", curContentId)
    _EntityCtrl = LogicEntityUtil.Open(ServerConst.GameType.GamePlayTypeDatePlan, letterID, nil, nil, function()
    end, nil, true)
    --_EntityCtrl:SetIsSaveCommand(false)
    self:FillConfigList(letterID)
    ---填充玩法数据
    local playData = BllMgr.GetDatePlanBLL():GetGamePlayData(letterID)
    _PlayResult = self:OnCacheGamePlayData(playData)

    --确认下这里，如果需要加载数据之类的，导致不是立即执行，这样使用流程代码而非回调中执行是不合适的
    self:InterStart(letterID, curContentId)
end

function DatePlanCtrl:OnAddListener()
    EventMgr.AddListener(DatePlanConst.LogicEventType.DatePlanOnStartLetter, self.OnLogicStartLetter, self)
    EventMgr.AddListener(DatePlanConst.LogicEventType.DatePlanOnStartContent, self.OnLogicStartContent, self)
    EventMgr.AddListener(DatePlanConst.LogicEventType.DatePlanOnEndContent, self.OnLogicEndContent, self)

end

function DatePlanCtrl:OnRemoveListener()
    EventMgr.RemoveListenerByTarget(self)
end

function DatePlanCtrl:InterStart(letterID, curContentId)
    Debug.LogWarning("InterStart ", letterID, " curContentId ", curContentId)
    local entryConfig = LuaCfgMgr.Get("DatePlanEntry", letterID)

    _LetterID = letterID
    _ManType = entryConfig.ManType
    _EntityCtrl:SendToServer(DatePlan.Command.StartLetterRequest,{LetterID = letterID, CurContentId = curContentId})
end

function DatePlanCtrl:StartContent(contentId)
    Debug.LogWarning("开启日程: StartContent ", contentId)
    local temp = LuaCfgMgr.Get("DatePlanContent", contentId)
    ---临时切下场景，需要再考虑
    self:ChangeScene(temp.Scene, function()
        _EntityCtrl:SendToServer(DatePlan.Command.StartDateContentRequest,{ContentID = contentId})
    end)
end

---开启拍照时
function DatePlanCtrl:OnStartPhoto(config)
    ---临时使用第一个关卡，后续可能需要传递
    _StageID = config.StageID[1]

    PurikuraMgrNew.Enter(_ManType, _StageID, PurikuraConstNew.EntryMode.DatePlan, handler(self, self.OnGamePlayComplete), config.PhotoProbation, config.Rule)
end

---开启喵喵牌时
function DatePlanCtrl:OnStartMiao(config)
    ---临时使用第一个关卡，后续可能需要传递
    _StageID = config.StageID[1]
    EventMgr.Dispatch("GamePlayCmd_EnterGame", Define.GamePlayEnterType.GamePlayEnterTypeDatePlan, Define.GamePlayType.GamePlayTypeMiao,
            _StageID, nil, config.DialogueID, config.Override, handler(self, self.OnGamePlayComplete))
end

---开启娃娃机时
function DatePlanCtrl:OnStartDolls(config)
    ---临时使用第一个关卡，后续可能需要传递
    _StageID = config.StageID[1]
    EventMgr.Dispatch("GamePlayCmd_EnterGame", Define.GamePlayEnterType.GamePlayEnterTypeDatePlan, Define.GamePlayType.GamePlayTypeUfoCatcher,
            _StageID, nil, config.DialogueID, config.Override, handler(self, self.OnGamePlayComplete))
end

---开启纯剧情时
function DatePlanCtrl:OnStartDialog(config)
    Debug.LogWarning("OnStartDialog ", config.ID)
    _DialogCtrl= DialogueManager.InitByName(config.StartConName)

    self:LoadRoleIns(config.Cloth, function()
        local assetID = LuaCfgMgr.Get("RoleInfo", _ManType).DefaultAssetID
        _DialogCtrl:InjectGameObject(assetID, _Actor)
        _DialogCtrl:InitDialogue(config.DialogueID, Mathf.Random(1, 10000), nil, nil, nil)
        _DialogCtrl:StartDialogueByName(config.DialogueID, config.StartConName, nil, nil, handler(self, self.OnDialogPlayComplete))
        if(_PlayResult) then
            for index, value in pairs(_PlayResult) do
                _DialogCtrl:ChangeVariableState(index, value)
            end
            _PlayResult = nil;
        end
    end)

end

---需要释放的
function DatePlanCtrl:LoadRoleIns(suitKey, callback)
    ---这里考虑下复用的，先无脑释放
    self:ReleaseRoleIns()
    CharacterMgr.GetInsWithSuitKey(suitKey, function(ins)
        _Actor = ins
        if(callback) then
            callback()
        end
    end)
end

function DatePlanCtrl:ReleaseRoleIns(partKey, callback)
    if(_Actor) then
        CharacterMgr.ReleaseIns(_Actor)
        _Actor = nil
    end
end

---开启不同玩法时(逻辑端转完了)
function DatePlanCtrl:OnLogicStartContent(reply)
    Debug.LogWarning("OnLogicStartContent ", reply.ContentID)
    local contentId = reply.ContentID
    _ContentID = contentId

    local contentConfig = LuaCfgMgr.Get("DatePlanContent", contentId)
    if(contentConfig.Type == DatePlan.DateContentType.Dialog) then
        self:OnStartDialog(contentConfig);
    elseif(contentConfig.Type == DatePlan.DateContentType.Dolls) then
        self:OnStartDolls(contentConfig);
    elseif(contentConfig.Type == DatePlan.DateContentType.Photo) then
        self:OnStartPhoto(contentConfig)
    elseif(contentConfig.Type == DatePlan.DateContentType.Miao) then
        self:OnStartMiao(contentConfig)
    else
        Debug.LogWarning("暂未支持")
    end
end

---纯剧情结束时
function DatePlanCtrl:OnDialogPlayComplete()
    Debug.LogWarning("OnDialogPlayComplete ", _ManType, " _LetterID ", _LetterID, " _ContentID ", _ContentID, " _StageID ", _StageID)
    local dialogCheck = nil
    if(_DialogCtrl) then
        dialogCheck = _DialogCtrl:PopProcessNodes()
        _DialogCtrl:EndDialogueAll()
        _DialogCtrl:ClearDialogueAll()
        _DialogCtrl = nil
        self:ReleaseRoleIns()
    end

    BllMgr.GetDatePlanBLL():SendProgressDateRequest(_ManType, _LetterID, _ContentID, _StageID, dialogCheck)
end

---解析玩法传出来的数据
function DatePlanCtrl:OnCacheGamePlayData(resultData)
    if(resultData) then
        local convertData = {}
        --local contentConfig = LuaCfgMgr.Get("DatePlanContent", _ContentID)
        --if(contentConfig.Type == DatePlan.DateContentType.Dialog) then
        --    Debug.LogError("非玩法不要凑热闹")
        --elseif(contentConfig.Type == DatePlan.DateContentType.Dolls) then
        --    Debug.LogError("没有支持的不要凑热闹")
        --elseif(contentConfig.Type == DatePlan.DateContentType.Photo) then
        --    Debug.LogError("没有支持的不要凑热闹")
        --elseif(contentConfig.Type == DatePlan.DateContentType.Miao) then
            if(resultData and resultData[1]) then
                local value = nil
                if(resultData[1] == CatCardConst.RoundRes.WIN) then
                    value = 1
                elseif (resultData[1] == CatCardConst.RoundRes.LOSS) then
                    value = 0
                elseif (resultData[1] == CatCardConst.RoundRes.DRAW) then
                    value = 2
                end
                ---约定值，后面看看丢到哪里
                convertData[8] = value
                return convertData;
            end
        --else
        --    Debug.LogWarning("暂未支持")
        --end
    end

end

---玩法中结束时
---@type table resultData 玩法结束时透传出的任务
---@type bool isHangUp 是否中途退出
function DatePlanCtrl:OnGamePlayComplete(resultData, isHangUp)
    _PlayResult = self:OnCacheGamePlayData(resultData)
    -----临时强关下
    UICommonUtil.SetLoadingEnable(GameConst.LoadingType.DEFAULT, false)

    if(not isHangUp) then
        ---玩法结束时，直接开下一个玩法
        local nextConfig = self:GetNextContentConfig(_ContentID)
        if(nextConfig) then
            Debug.LogWarning("OnGamePlayComplete ", _ManType, " _LetterID ", _LetterID, " _ContentID ", _ContentID, " _StageID ", _StageID, "nextConfig ", nextConfig and nextConfig.ID)
            self:ChangeGameState()
            _ContentID = nextConfig.ID
            _StageID = nextConfig.StageID and nextConfig.StageID[1]
            self:ReadyStart(_ContentID)
        else
            Debug.LogWarning("玩法结束后，没有下一个日程")
        end

    else
        Debug.LogWarning("约会计划中途退出")
    end

end

---服务器的返回
---每次更新一个日程时，纯剧情为结束，玩法为开始
function DatePlanCtrl:OnProgressDateUpdate(contentId)
    Debug.LogWarning("OnProgressDateUpdate 日程更新 ", contentId)
    if(contentId ~= _ContentID) then
        Debug.LogWarning("OnProgressDateUpdate error, ContentID:", contentId, " cur ", _ContentID)
    end
    local config = LuaCfgMgr.Get("DatePlanContent", contentId)
    if(config.Type == DatePlanConst.DatePlanContentType.DatePlanContentTypeDialogue) then
        _EntityCtrl:SendToServer(DatePlan.Command.CompleteDateContentRequest,{LetterID = _LetterID, ManType = _ManType, ContentID = _ContentID})
    else
        self:StartContent(contentId)
    end
end


function DatePlanCtrl:ReadyStart(contentId)
    Debug.LogWarning("ReadyStart ", contentId)
    local contentConfig = LuaCfgMgr.Get("DatePlanContent", contentId)
    ---纯剧情直接表演，表演结束直接发，玩法类的依赖服务器开启玩法，需要在日程开启前发
    if(contentConfig) then
        if(contentConfig.Type == DatePlanConst.DatePlanContentType.DatePlanContentTypeUfoCatcher or contentConfig.Type == DatePlanConst.DatePlanContentType.DatePlanContentTypeMiao
        or contentConfig.Type == DatePlanConst.DatePlanContentType.DatePlanContentTypePhoto) then
            local version = LogicEntityUtil.GetGameVersion(DatePlanConst.DatePlanContentGameType[contentConfig.Type])
            _ContentID = contentConfig.ID
            _StageID = contentConfig.StageID[1]
            BllMgr.GetDatePlanBLL():SendProgressDateRequest(_ManType, _LetterID, _ContentID, _StageID, nil, version)
        else
            self:StartContent(contentConfig.ID)
        end
    else
        ---直接发结算
        BllMgr.GetDatePlanBLL():SendFinishDateRequest(_ManType, _LetterID)
        Debug.LogWarning("没有下一个日程 ", reply.ContentID)
    end
end

---邀约开始时
function DatePlanCtrl:OnLogicStartLetter(reply)
    local curConfig  = LuaCfgMgr.Get("DatePlanContent", reply.CurContentId)
    Debug.LogWarning("OnLogicStartLetter ", reply.CurContentId, " curConfig.ID ", curConfig.ID)
    ---这里应该走数据判断，看要不要把数据内聚到玩法内考虑，从纯玩法逻辑的角度考虑可以不放进去
    --self:StartContent(curConfig.ID)
    self:ReadyStart(reply.CurContentId)
end

function DatePlanCtrl:OnLogicEndContent(reply)
    Debug.LogWarning("OnLogicEndContent ", reply.ContentID)
    local contentId = reply.ContentID
    local nextConfig = self:GetNextContentConfig(contentId)

    ---纯剧情直接表演，表演结束直接发，玩法类的依赖服务器开启玩法，需要在日程开启前发
    if(nextConfig) then
        self:ReadyStart(nextConfig.ID)
    else
        ---直接发结算
        BllMgr.GetDatePlanBLL():SendFinishDateRequest(_ManType, _LetterID)
        Debug.LogWarning("OnLogicEndContent 没有下一个日程 ", reply.ContentID)
    end
end

function DatePlanCtrl:GetCurContentCloth()
    local contentConfig = LuaCfgMgr.Get("DatePlanContent", _ContentID)
    Debug.LogWarning("GetCurContentCloth ", _ContentID, " -- ", contentConfig and contentConfig.Cloth or nil)
    return contentConfig and contentConfig.Cloth or nil
end

---约会日程结束(收到服务器回应)
function DatePlanCtrl:OnServerDateEnd(contentList)
    ---这里需要先去逻辑框架走一圈，成功后再展示奖励
    self:ShowReward(contentList)
end

---触发约会计划逻辑结束
function DatePlanCtrl:SendLogicClose()

end
function DatePlanCtrl:OnLogicClose()
    Debug.LogWarning("OnLogicClose")
    GameStateMgr.Switch(GameState.MainHome)
end


---全部日程结束后，展示奖励界面
function DatePlanCtrl:ShowReward(contentList)
    ---临时处理下，实际上UI处理去Bll层，先临时处理下
    UIMgr.Open(UIConf.DatePlanResult, contentList, handler(self, self.OnLogicClose))
end

function DatePlanCtrl:ChangeScene(sceneName, callback)
    SceneMgr.LoadSceneAsync(sceneName, nil, GameConst.LoadingType.Common, function(taskID)
        UICommonUtil.SetLoadingEnable(GameConst.LoadingType.Common, false)
        if(callback) then
            callback();
        end
    end, true)
end

function DatePlanCtrl:OnClear()
    self:Close()
end

function DatePlanCtrl:Close()
    _EntityCtrl = nil;
    _LetterID = nil
    self:OnRemoveListener()
end
-----事件继续
--function DatePlanCtrl.ResumeTime()
--
--end

return DatePlanCtrl