---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jianxin.
--- DateTime: 2021/7/16 14:23
---
---
---@class ResUpdateManager
local ResUpdateManager = class("ResUpdateManager")
local GameDataBridge = require("Runtime.System.X3Game.Modules.GameDataBridge.GameDataBridge")

local httpReq = require("Runtime.System.Framework.GameBase.Network.HttpRequest")
local ResourcesPacker = CS.ResourcesPacker.Runtime
local _stateMachine = nil
local downloadPackageIDKey = "SUBPACKAGE_ID"
local downloadPackageIDs = {}
local X3ResPatchHelper = CS.X3Game.X3ResPatchHelper
local Const = require("Runtime.System.X3Game.Modules.ResUpdate.ResUpdateConst")
---@type table<int, string[]>
local modifiedFile = {}

local X3DownloadRegisterThreadEvent = CS.X3Game.Download.X3DownloadRegisterThreadEvent

local m_ResCheckCpl = false
local m_WarmupCpl = false
local m_Warmingup = false
local m_WarmupProgress = 0
local downloadInMobile = false;

local KB = 1024
local MB = 1048576
local GB = 1073741824

local downloadSize = 0
local totalDownloadSize = 1
local m_opType = nil

local appVersionKey = "App_Version"
local appBuildNumKey = "App_BuildNum"

local DownloadErrorNum = 10

function ResUpdateManager:Init()
    self.needUpdate = false
    self.UseThreadedHandleTask = PlayerPrefs.GetBool("download_backstage", true)
    if SDKMgr.IsHaveSDK() and (not Application.IsIOSMobile()) then
        CS.X3Game.AppInfoMgr.Instance.AppInfo.ChannelId = SDKMgr.GetPlatID()
    end
    local parms = {
        key = downloadPackageIDKey
    }
    local url = ServerUrl:GetUrlWithType(ServerUrl.UrlType.CMS, ServerUrl.UrlOp.GameConfig, parms)
    local d = httpReq.GetDeferred(url, nil, nil):next(
            function(respTxt)
                return GameHttpRequest:ParseRespDataAndDeferred(respTxt, handler(self, self.OnGetPackageID))
            end
    )                :next(nil, function()
        PlayerPrefs.SetString(downloadPackageIDKey, "")
        self:InitResPatch()
    end)
end

function ResUpdateManager:SetResUpdateFinish(finishCallback)
    self.finishCallback = finishCallback
end

function ResUpdateManager:OnGetPackageID(data)
    self.downloadPackageIDStr = data.gameConfigParameter.value
    local splitStr = string.split(self.downloadPackageIDStr, "|")
    for i, v in ipairs(splitStr) do
        table.insert(downloadPackageIDs, tonumber(v))
    end
    PlayerPrefs.SetString(downloadPackageIDKey, self.downloadPackageIDStr)
    self:InitResPatch()
end

---热更流程启动 初始化
function ResUpdateManager:InitResPatch()
    ---是否是覆盖安装判断，覆盖安装要走特殊的资源校验方式
    local oldAppVersion = PlayerPrefs.GetString(appVersionKey, "")
    local oldBuildNum = PlayerPrefs.GetString(appBuildNumKey, "")
    self.oldVersion = PlayerPrefs.GetString("resVersion", "")
    local appUpdate = false
    if not string.isnilorempty(oldAppVersion) and not string.isnilorempty(oldBuildNum) then
        local newAppVersion, newAppBuildNum = AppInfoMgr.GetAppVersionAndBuildNum()
        appUpdate = newAppVersion ~= oldAppVersion or newAppBuildNum ~= tonumber(oldBuildNum)
        Debug.Log("ResUpdateManager,InitResPatch ", newAppVersion, newAppBuildNum, oldAppVersion, oldBuildNum)
    end
    Debug.Log("ResUpdateManager,appUpdate ", appUpdate)
    ResourcesPacker.Logger.Init()
    ---设置资源服url
    CS.X3ResPatchWebRequest.ClientID = ServerUrl.clientId
    CS.X3ResPatchWebRequest.ResPatchInfoUrl = ServerUrl.cmsUrl
    CS.X3ResPatchWebRequest.ClientKey = ServerUrl.clientKey
    CS.X3ResPatchWebRequest.RequestTimeOut = 30
    CS.X3ResPatchWebRequest.AppVersionUpdate = appUpdate

    if CS.ResourcesPacker.Runtime.ResPatchManager.CheckDiskSpaceEnabled ~= nil and Application.IsIOSMobile() then
        ---IOS 不判断储存空间
        CS.ResourcesPacker.Runtime.ResPatchManager.CheckDiskSpaceEnabled = false
    end

    ---开启多线程下载
    if self.UseThreadedHandleTask then
        CS.ResourcesPacker.Runtime.ResDownloadController.UseThreadedHandleTask = self.UseThreadedHandleTask
    end
    local webRequest = CS.X3ResPatchWebRequest()
    local context = ResourcesPacker.ResPatchContext(webRequest)
    ---获取必须下载A包 的语音语言包
    context.AttachedDownloadedPkgTags = CS.System.Collections.Generic.HashSet(typeof(CS.System.Int32))
    context.FailedCheckCountToStopAllDownload = DownloadErrorNum
    local packageIDs = SubPackageDownloadMgr.GetAPackageMultiLanguagePackage()
    for i, v in ipairs(downloadPackageIDs) do
        table.insert(packageIDs, v)
        table.insertto(packageIDs, SubPackageDownloadMgr.GetPackageMultiLanguagePackage_Fix(v))
    end
    for i, v in ipairs(packageIDs) do
        context.AttachedDownloadedPkgTags:Add(v)
    end
    _stateMachine = ResourcesPacker.ResPatchStateMachine()
    _stateMachine:InitContext(context)
    self.handler = handler(self, self.OnEventNotification)
    ResourcesPacker.ResPatchEventSystem.Instance:RegisterEvent(self.handler)
    if self.UseThreadedHandleTask then
        ---后台保活相关
        local BackgroundDownload = require("Runtime.System.X3Game.Modules.SubPackages.BackgroundDownload")
        BackgroundDownload:Open()
    end
    _stateMachine:GotoFirstState()
    self.tickID = TimerMgr.AddTimer(0, self.Update, self, true)
end

function ResUpdateManager:OnEventNotification(stateType, opType, arg1, arg2, arg3)
    self:OnResUpdateNotification(stateType, opType, arg1, arg2, arg3)
    EventMgr.Dispatch("ResUpdate_EventNotification", stateType, opType, arg1, arg2, arg3)
end

function ResUpdateManager:OnResUpdateNotification(stateType, opType, arg1, arg2, arg3)
    self.stateType = stateType
    self.opType = opType
    self.arg1 = arg1
    self.arg2 = arg2
    self.arg3 = arg3
    m_opType = opType
    if self.opType == Const.OperationType.EnterState then
        self:OnResUpdateEnterState(stateType)
    elseif self.opType == Const.OperationType.ExistState then
        self:OnResUpdateExistState(stateType)
    elseif self.opType == Const.OperationType.UpdateApp then
        EventTraceMgr:Trace(EventTraceEnum.EventType.ConnectCMS)
        EventTraceMgr:Trace(EventTraceEnum.EventType.CheckForceUpdate)
        EventTraceMgr:Trace(EventTraceEnum.EventType.CheckOptionalUpdate)
        self:OnUpdateApp(arg1.StringValue)
    elseif self.opType == Const.OperationType.SetResVersion then
        self:SetResVersion(arg1.StringValue)
        if stateType == Const.ResPatchStateType.ReadLocalResPatchCatalogState then
            self:SetOldVersion(arg1.StringValue)
        end
    elseif self.opType == Const.OperationType.ResModified then
        ---@type string 相对于Persistance的路径
        local resPath = arg1.StringValue
        local userData = arg2.StringValue
        Debug.Log("NotificationResModified_____________更新测试修改", resPath, userData)
        if userData == tostring(Const.NotificationResType.Lua) then
            X3ResPatchHelper.NotificationResModified(resPath, userData)
            self:AddModifiedFile(Const.NotificationResType.Lua, resPath)
        elseif userData == tostring(Const.NotificationResType.SRPResources) then
            self:AddModifiedFile(Const.NotificationResType.SRPResources, resPath)
        else
            --暂时只有Shader需求，如果有其他的可以根据路径分发
            if string.endswith(userData, ".shadervariants") then
                self:AddModifiedFile(Const.NotificationResType.SVC, userData)
            end
        end
    elseif self.opType == Const.OperationType.DownloadProgressChanged then
        downloadSize = arg1.LongValue
        totalDownloadSize = arg2.LongValue
    elseif self.opType == Const.OperationType.DownloadUpdateRes then
        self.needDownloadSize = arg1.LongValue
    elseif self.opType == Const.OperationType.DownloadPatchSingleFileError then
        self.downloadErrorCount = self.downloadErrorCount + 1
        if self.downloadErrorCount <= DownloadErrorNum then
            local filePath = arg1.StringValue
            local errorMsg = arg2.StringValue
            if not string.find(errorMsg, "timeout", 1, true) then
                Debug.LogFatal("ResUpdate  DownloadPatchSingleFileError  filePath --", filePath, "errorMsg:", errorMsg)
            end
        end
    elseif self.opType:GetHashCode() > Const.OperationType.ErrorBegin:GetHashCode() then
        local errorMsg = arg1.StringValue
        if not string.find(errorMsg, "some files download failed09", 1, true) then
            Debug.LogFatal("ResUpdate  opType Error errorMsg = ", errorMsg)
        end

    end
end

function ResUpdateManager:OnResUpdateEnterState(stateType)
    if stateType == Const.ResPatchStateType.StartGameState then
        m_ResCheckCpl = true
        if not self.needUpdate then
            SDKMgr.QosLoginJoin(-1, "4", "0", self.needDownloadSize)
            self:OnCheckEnterGame()
        else
            ---有资源更新，需要重新初始化RES
            self:StopWarmup()
            m_WarmupCpl = false
            
            ---等待资源加载完成再重启Res
            GameMgr.WaitAssetLoadFinished(function()
                Res.ForceInit()
                ---初始化一下分包的清单
                self:ResPatchReLoad()
                self:OnCheckEnterGame()
            end)
        end
        
    elseif stateType == Const.ResPatchStateType.DownloadPatchResState then
        ---下载失败上报log数量
        self.downloadErrorCount = 0
        self.needUpdate = true
        if _stateMachine.Context.RemoteResPatchCatalog ~= nil then
            self:SetNewVersion(_stateMachine.Context.RemoteResPatchCatalog.VersionString)
        else
            self:SetNewVersion(self.oldVersion)
        end
    elseif stateType == Const.ResPatchStateType.CheckResIntegrityState then
        EventTraceMgr:Trace(EventTraceEnum.EventType.StartResourceCheck)
        m_ResCheckCpl = false
    elseif stateType == Const.ResPatchStateType.MoveTempFilesState then
        EventTraceMgr:Trace(EventTraceEnum.EventType.ResourcePackageUnzip)
    elseif stateType == Const.ResPatchStateType.StartGameState then
        EventTraceMgr:Trace(EventTraceEnum.EventType.ResourceCheckResult)
    end
end

function ResUpdateManager:OnResUpdateExistState(stateType)
    if stateType == Const.ResPatchStateType.MoveTempFilesState then
        EventTraceMgr:Trace(EventTraceEnum.EventType.ResourcePackageUnzipResult)
    elseif stateType == Const.ResPatchStateType.CheckResIntegrityState then
        EventTraceMgr:Trace(EventTraceEnum.EventType.ResourceCheckResult)
    elseif stateType == Const.ResPatchStateType.ReadRemoteVersionState then
        EventTraceMgr:Trace(EventTraceEnum.EventType.ConnectCMS)
        EventTraceMgr:Trace(EventTraceEnum.EventType.CheckForceUpdate)
        EventTraceMgr:Trace(EventTraceEnum.EventType.CheckOptionalUpdate)
    elseif stateType == Const.ResPatchStateType.DownloadPatchResState then
        self:SendEndDownloadEvent(self.needDownloadSize or 0)
    end
end

function ResUpdateManager:SendStartDownloadEvent(size)
    Debug.Log("SendStartDownloadEvent  size", size)
    size = size or 0
    self.downloadStartTime = TimerMgr.GetRealTimeSeconds()
    local newAppVersion, newAppBuildNum = AppInfoMgr.GetAppVersionAndBuildNum()
    EventTraceMgr:Trace(EventTraceEnum.EventType.StartOptionalUpdate, {
        ResourceVersion = self.oldVersion,
        NewClientVersion = newAppVersion,
        NewResourceVersion = PlayerPrefs.GetString("resVersion", ""),
        UpdateSize = string.format("%.2f", (size / 1024 / 1024)),
        UpdateType = 1,
        Unit = "MB",
    }, true)
end

function ResUpdateManager:SendEndDownloadEvent(size)
    local downloadTime = 0
    if self.downloadStartTime then
        downloadTime = TimerMgr.GetRealTimeSeconds() - self.downloadStartTime
    end
    size = size or 0
    downloadSize = downloadSize or 0
    local newAppVersion, newAppBuildNum = AppInfoMgr.GetAppVersionAndBuildNum()
    EventTraceMgr:Trace(EventTraceEnum.EventType.FinishOptionalUpdate, {
        ResourceVersion = self.oldVersion,
        NewClientVersion = newAppVersion,
        NewResourceVersion = PlayerPrefs.GetString("resVersion", ""),
        UpdateSize = string.format("%.2f", (size / 1024 / 1024)),
        Unit = "MB",
        UpdatetimeCost = string.format("%.2f", downloadTime),
        UpdateType = 1,
        ComepleteSize = string.format("%.2f", (downloadSize / 1024 / 1024)),
    }, true)
end

function ResUpdateManager:OnUpdateApp(url)
    UICommonUtil.ShowMessageBox(UITextConst.UI_TEXT_5120, {
        { btn_type = GameConst.MessageBoxBtnType.CANCEL, btn_call = function()
            SDKMgr.ApplicationQuit()
        end, is_auto_close = false },
        { btn_type = GameConst.MessageBoxBtnType.CONFIRM, btn_call = function()
            if Application.IsIOSMobile() or not SDKMgr.IsHaveSDK() then
                CS.UnityEngine.Application.OpenURL(url)
                EventTraceMgr:Trace(EventTraceEnum.EventType.StartForceUpdate)
                SDKMgr.ApplicationQuit()
            else
                SDKMgr.AppUpdate(url)
            end
        end, is_auto_close = false }
    }, AutoCloseMode.None)
end

function ResUpdateManager:SetOldVersion(oldVersion)
    self.oldVersion = oldVersion
end

function ResUpdateManager:GetOldVersion()
    return self.oldVersion
end

function ResUpdateManager:SetNewVersion(newVersion)
    self.newVersion = newVersion
end

function ResUpdateManager:GetNewVersion()
    return self.newVersion
end

function ResUpdateManager:Update()
    if _stateMachine ~= nil then
        _stateMachine:OnUpdate(CS.UnityEngine.Time.deltaTime)
    end
end

function ResUpdateManager:Destory()
    self.stateType = nil
    self.opType = nil
    self.arg1 = nil
    self.arg2 = nil
    self.arg3 = nil
    TimerMgr.Discard(self.tickID)
    table.clear(modifiedFile)
    _stateMachine = nil
    ResourcesPacker.ResPatchEventSystem.Instance:UnregisterEvent(self.handler)
end

function ResUpdateManager:EnterGame(needUpdate)
    ---储存当前版本号，用于下次对比
    local newAppVersion, newAppBuildNum = AppInfoMgr.GetAppVersionAndBuildNum()
    PlayerPrefs.SetString(appVersionKey, newAppVersion)
    PlayerPrefs.SetString(appBuildNumKey, tostring(newAppBuildNum))
    if self.UseThreadedHandleTask then
        ---后台保活相关 下载阶段走完后关闭后台保活
        local BackgroundDownload = require("Runtime.System.X3Game.Modules.SubPackages.BackgroundDownload")
        BackgroundDownload:Close()
    end

    ---如果SRP资产热更，主动卸载一次
    local srpSources = modifiedFile[Const.NotificationResType.SRPResources]
    if srpSources and #srpSources > 0 then
        Debug.LogFormat("SRP资产热更, 资产数量: %s", srpSources and #srpSources or 0)
        if GameDataBridge.AddCacheData ~= nil then
            GameDataBridge.AddCacheData(GameDataBridge.CacheType.SrpResChanged, true)
        end
    end

    EventMgr.Dispatch("BeforeLuaEnvReboot")
    ---清理自身的数据
    self:Destory()
    if needUpdate then
        CS.InjectFixLoader:LoadFixPatch()
    end
    ---热更完成
    if self.finishCallback then
        self.finishCallback(true, needUpdate)
        self.finishCallback = nil
    end
end

---重新加载一下b包清单，热更阶段会下载b包
function ResUpdateManager:ResPatchReLoad()
    if ResourcesPacker.ResPatchManager.HasInstance then
        ResourcesPacker.ResPatchManager.Instance:ReLoad()
    end
end

function ResUpdateManager:GetDownloadSize()
    return downloadSize, totalDownloadSize
end

function ResUpdateManager:GetResUpdateOperationType()
    return m_opType
end

function ResUpdateManager:SetResVersion(resVersion)
    PlayerPrefs.SetString("resVersion", resVersion)
    Debug.LogFormat("resVersion %s", resVersion)
end

---添加文件修改
---@param typeString int
---@param value string
function ResUpdateManager:AddModifiedFile(typeEnum, value)
    if modifiedFile[typeEnum] == nil then
        modifiedFile[typeEnum] = {}
    end
    table.insert(modifiedFile[typeEnum], #modifiedFile[typeEnum] + 1, value)
end

---根据类型返回更改列表
---@param type int
function ResUpdateManager.GetModifiedFiles(type)
    return modifiedFile[type]
end

---@param type int
function ResUpdateManager.ClearModifiedFiles(type)
    modifiedFile[type] = nil
end

function ResUpdateManager:SetBackgroundDownload(value)
    self.UseThreadedHandleTask = value
end

function ResUpdateManager:OnCheckEnterGame()
    SDKMgr.QosLoginJoin(-1, "5", "0", self.needDownloadSize)
    if not m_WarmupCpl then
        self:StartWarmup()
    end
    self:CheckEnterGame()
end

---预热以及资源都下载完了就开始游戏
function ResUpdateManager:CheckEnterGame()
    if m_WarmupCpl and m_ResCheckCpl then
        m_WarmupCpl = false
        m_ResCheckCpl = false
        if self.playPV then
            LoginBgHelper.CheckStopResUpdateVideo()
            self.playPV = false
        end
        ---关闭界面前缓存字段, 避免被关闭后清理
        local needUpdate = self.needUpdate
        UIMgr.Close(UIConf.ResUpdate)
        UIMgr.Close(UIConf.Announcement)
        if BllMgr.GetLoginBLL():GetHadRepair() then
            UICommonUtil.ShowMessageBox(UITextConst.UI_TEXT_5088, {
                { btn_type = GameConst.MessageBoxBtnType.CONFIRM, btn_text = UITextConst.UI_TEXT_5089, btn_call = function()
                    SDKMgr.ApplicationQuit()
                end, is_auto_close = false }
            }, AutoCloseMode.None)
        else
            self:EnterGame(needUpdate)
        end
    end
end

--region ShaderWarmup
---开始预热
function ResUpdateManager:StartWarmup()
    m_WarmupCpl = not ShaderWarmupMgr.GetOpenWarmup()
    if not m_WarmupCpl then
        m_Warmingup = true
        m_WarmupProgress = 0
        ShaderWarmupMgr.StartWarmup(handler(self, self.OnProgressShaderWarmup), handler(self, self.OnShaderWarmupCpl))
    end
end

---停止预热
function ResUpdateManager:StopWarmup()
    if not m_WarmupCpl then
        ShaderWarmupMgr.StopWarmup()
    end
end

---预热进度
---@param progress float
function ResUpdateManager:OnProgressShaderWarmup(progress)
    m_WarmupProgress = progress
    if m_ResCheckCpl then
        EventMgr.Dispatch("OnProgressShaderWarmup", progress)
    end
end

---预热回调
function ResUpdateManager:OnShaderWarmupCpl()
    m_WarmupCpl = true
    m_Warmingup = false
    self:CheckEnterGame()
end

function ResUpdateManager:GetWarmupCpl()
    return m_WarmupCpl
end

function ResUpdateManager:GetWarmingUp()
    return m_Warmingup
end

--endregion


function ResUpdateManager:SetDownloadInMobile(_downloadInMobile)
    if self.UseThreadedHandleTask then
        downloadInMobile = _downloadInMobile
        X3DownloadRegisterThreadEvent.Instance.canDownloadInMobile = downloadInMobile
    end
end

function ResUpdateManager:GetDownloadInMobile()
    return downloadInMobile
end

function ResUpdateManager:IsHaveBackGroundDownload()
    return self.UseThreadedHandleTask
end


--region Tools

---获取下载量格式化
function ResUpdateManager.GetFormatSize(size)
    local number = 0
    local unit = "b"
    if size == 0 then
        number = 0
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30808)
    elseif size < MB * 0.1 then
        number = 0.1
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30808)
    elseif size > MB * 0.1 and size < GB then
        number = size / MB
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30808)
    else
        number = size / GB
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30813)
    end
    return string.format("%.1f%s", number, unit)
end

---获取下载速度格式化
function ResUpdateManager.GetSpeedFormatSize(size)
    local number = 0
    local unit = "b"
    if size == 0 then
        number = 0
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30809)
    elseif size < KB * 0.1 then
        number = 0.1
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30809)
    elseif size > KB * 0.1 and size < MB then
        number = size / KB
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30809)
    elseif size > MB and size < GB then
        number = size / MB
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30808)
    else
        number = size / GB
        unit = UITextHelper.GetUIText(UITextConst.UI_TEXT_30813)
    end
    return string.format("%.1f%s", number, unit)
end

---获取Url
function ResUpdateManager:GetUrl(url)
    local escapeUrl = CS.UnityEngine.Networking.UnityWebRequest.UnEscapeURL(url)
    local unicode1 = string.match(escapeUrl, "\\u[0-9]+0")
    if not string.isnilorempty(unicode1) then
        escapeUrl = string.urldecode(string.replace(escapeUrl, unicode1, "%"))
    end
    return escapeUrl
end
--endregion

return ResUpdateManager
