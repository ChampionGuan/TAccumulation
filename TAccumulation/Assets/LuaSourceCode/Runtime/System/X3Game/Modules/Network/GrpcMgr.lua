--- X3@PapeGames
--- GrpcMgr
--- Created by Tungway
--- Created Date: 2020/12/01
--- Maintained by Qige
--- Update Date: 2022/01/26

---@class GrpcMgr
local GrpcMgr = class("GrpcMgr")
local pbc = require "pb"
local ErrHandleList = require "Runtime.System.X3Game.Data.Network.ErrHandleList"
local crcMap = require "Runtime.System.X3Game.Data.Command.Register.AutoGenerated.CRCMap"
local MainHomeConst = require("Runtime.System.X3Game.Modules.MainHome.Data.MainHomeConst")
---连接状态
---@class GrpcMgr.ConnectionState
local ConnectionState = {
    ---初始状态，未连接
    Closed = 0,
    ---已断开连接
    Disconnected = 1,
    ---短暂断开连接
    DisconnectedTemporarily = 2,
    ---连接中
    Connecting = 3,
    ---重连中
    Reconnecting = 4,
    ---已连接
    Connected = 5,
    ---可以正常收发数据
    Ready = 6,
}

---打印日志类型
local LogType = {
    SendOrReceiveLoop = 1 << 1,
    Send = 1 << 2,
    Receive = 1 << 3,
    Connection = 1 << 4,
    Seq = 1 << 5,
    Update = 1 << 6,
    Delegate = 1 << 7,
}

local CS_MGR_CLS = CS.X3Game.Networking.GrpcMgr
local CSMGR = nil
---最后一次Ping的时间
local lastPingTime = os.time()
---断开连接的时间
local disconnectedTime = 0
---是否需要延迟显示连接中的菊花
local needDelayShowConnectingIndicator = true
---时区
local time_zone
---连接超时（秒）
local CONNECT_TIMEOUT = 15
---发送超时（秒）
local MSGACKNOWLEDGE_TIMEOUT = 20
---每个Ping包的间隔时间（秒）
local PING_INTERVAL = 3 * 60
---调试用代码
if UNITY_EDITOR then
    CONNECT_TIMEOUT = 10
    MSGACKNOWLEDGE_TIMEOUT = 20
end
---断线重连次数
local CONNECT_RETRY_COUNT = 3
---服务器是否有更新 在有更新时需要闪断
local serverIsUpdate = false
---服务器更新需拉全量数据
local isSendEnterGame = false
---Login是否成功
local isLoginSuccess = false

GrpcMgr.EVENT_SEND_MSG_BEGIN = "GRPC_EVENT_SEND_MSG_BEGIN"
GrpcMgr.Event_Connect_Failed = "Event_Connect_Failed"
GrpcMgr.Event_SendMsg_Error = "Event_SendMsg_Error"
GrpcMgr.Event_OnReceiveUpdateMsg = "Event_OnReceiveUpdateMsg"

---客户端断线完全重连时间
local CLIENT_RECONNECTION_TIME = 5 * 60
---自动重连间隔时间
local AUTO_CONNECT_INTERVAL = 3
---rpcLogin 是否是断线重连
local rpcLoginIsReconnect = false
---断线重连需要打开的会抢掉Focus的界面
local isOpenGrabFocus = false
---断线重连时是否需要UI表现
local displayReconnectTipsEnabled = true
---自动重连计时器
local autoConnectTimer = nil
---断线重连表现被关闭时是否有需要热更的tips
local isNeedShowResUpdateTips = false
---是否是因为BeKicked退出游戏断开网络 用于玩法中屏蔽断线重连表现
local isBeKickedLogout = false

local updateTimer = 0
---客户端收到服务器的回包数量
local receiveServerSeq = 0

local oldReceiveServerSeq = 0

local whiteRelyList = { "HelloReply", "LoginReply" }

---是否需要拉全量数据
local needSyncUserTotalData = false

local sendSyncUserTotalTimer = nil
---战斗中可以发送的消息白名单
local battleRequestWhiteList = { "DoStageRequest", "DungeonEndRequest", "ActiveVoicesRequest",
                                 "GuideFinishRequest", "SetCurrentGuideRequest", "SetGuideRequest",
                                 "PingRequest", "HelloRequest", "LoginRequest", "CancelStageRequest",
                                 "UsePowerSpItemRequest", "BuyPowerByJewelRequest", "GemCoreLockRequest",
                                 "EasterEggEffectRequest","EasterEggTriggerRequest" }
---战斗中发送的消息cache列表
local battleCacheRequestDataList = {}

local pbcByteIsInit = false

---syncUserTotalData是否执行完
local syncUserTotalDataIsEnd = false


local function CheckCanSendRequest(request, data, cacheRequest)
    if GameStateMgr.GetCurStateName() == GameState.Battle then
        local msgKey = request[1]
        if table.containsvalue(battleRequestWhiteList, msgKey) then
            return true
        else
            if UNITY_EDITOR then
                local msgKey = request[1]
                Debug.LogError("BattleState Send Request CheckFail msgKey:", msgKey)
            end
            local battleCacheRequest = PoolUtil.GetTable()
            battleCacheRequest.request = request
            battleCacheRequest.data = table.clone(data)
            battleCacheRequest.cacheRequest = cacheRequest
            table.insert(battleCacheRequestDataList, battleCacheRequest)
            return false
        end
    end
    return true
end

---@param msgKey string
local function SetReceiveServerSeqWithMsgKey(msgKey)
    if not table.containsvalue(whiteRelyList, msgKey) then
        receiveServerSeq = receiveServerSeq + 1
        --Debug.Log("ReceiveServerSeq++", "msgKey:", msgKey, "seq:", receiveServerSeq)
    end
end

local function GetReceiveServerSeq()
    return receiveServerSeq
end

local function ClearReceiveServerSeq()
    receiveServerSeq = 0
end

local function ClearOldReceiveServerSeq()
    oldReceiveServerSeq = 0
end

---清理战斗中发送的业务消息缓存
local function ClearBattleRequestDataList()
    for i = 1, #battleCacheRequestDataList do
        PoolUtil.ReleaseTable(battleCacheRequestDataList[i])
    end
    battleCacheRequestDataList = {}
end

---显示Server message
---@param errCode Int 错误码
local function ShowMessageTips(errCode)
    local cfg = LuaCfgMgr.Get("ServerError", errCode)
    if cfg then
        if DEBUG_GM then
            UICommonUtil.ShowMessage(UITextHelper.GetUIText(cfg.Msg) .. string.format("（%s）", errCode))
        else
            UICommonUtil.ShowMessage(UITextHelper.GetUIText(cfg.Msg))
        end
    else
        UICommonUtil.ShowMessage(string.format("ServerError:%s", errCode))
    end
end

---Send Ping
local function SendPing()
    GrpcMgr.SendRequestAsync(RpcDefines.PingRequest, {})
end

local function AutoConnect()
    if autoConnectTimer then
        return
    end
    autoConnectTimer = TimerMgr.AddTimer(AUTO_CONNECT_INTERVAL, function()
        GrpcMgr.Connect()
        autoConnectTimer = nil
    end)
end

function GrpcMgr.ProcBeKickedReply(errCode)
    ---角色注销踢下线客户端不统一处理
    if errCode == X3_CFG_CONST.SESSIONKICKCANCELUSERSELF then
        return
    end
    local cfg = LuaCfgMgr.Get("ServerError", errCode)
    local info
    if cfg then
        if DEBUG_GM then
            info = string.concat(UITextHelper.GetUIText(cfg.Msg), string.format("（%s）", errCode))
        else
            info = UITextHelper.GetUIText(cfg.Msg)
        end
    else
        info = tostring(errCode)
    end
    if errCode == X3_CFG_CONST.SERVERMESSAGEINBLACKLIST then
        UICommonUtil.ShowMessage(info)
        return
    end
    CSMGR.DisconnectByRemote = true
    GrpcMgr.Disconnect()
    ---if GameStateMgr.GetCurStateName() ~= GameState.Login then
    UICommonUtil.ShowMessageBoxWithOpenParam({ PanelOrder = GameConst.MessageBoxOrder.High }, info, {
        { btn_type = GameConst.MessageBoxBtnType.CONFIRM,
          btn_call = function()
              isBeKickedLogout = true
              if errCode == X3_CFG_CONST.USERBEKICKED or errCode == X3_CFG_CONST.SESSIONKICKLOGIN then
                  ---顶号需要注销sdk
                  GameStateMgr.Switch(GameState.Logout, true)
              else
                  GameStateMgr.Switch(GameState.Logout)
              end
          end,
          btn_text = UITextHelper.GetUIText(UITextConst.UI_TEXT_5173),
        }
    }, AutoCloseMode.None)
    ---end
end

local indicatorCount = 0
---显示或隐藏菊花（使用计数）
---@param enable boolean
---@param text string | number
---@param needDelay boolean
local function ExeShowIndicator(enable, text, needDelay)
    if enable and not displayReconnectTipsEnabled then
        return
    end
    needDelay = needDelay or false
    if enable == true then
        indicatorCount = indicatorCount + 1
        if needDelay then
            UICommonUtil.SetIndicatorEnableWithDelay(0.5, GameConst.IndicatorType.NETWORK_CONNECTING, true, text, GameConst.IndicatorShowType.NET_WORK, false, true)
        else
            UICommonUtil.SetIndicatorEnable(GameConst.IndicatorType.NETWORK_CONNECTING, true, text, GameConst.IndicatorShowType.NET_WORK, false, true)
        end
    else
        indicatorCount = math.max(0, indicatorCount - 1)
        if (indicatorCount == 0) then
            UICommonUtil.SetIndicatorEnable(GameConst.IndicatorType.NETWORK_CONNECTING, false)
        end
    end
end

---清除菊花（不做计数）
local function ClearIndicator()
    indicatorCount = 0
    UICommonUtil.SetIndicatorEnable(GameConst.IndicatorType.NETWORK_CONNECTING, false)
end

local function SetGrabFocusEnable(is_enable)
    UICommonUtil.SetGrabFocusEnable(GameConst.GrabFocusType.NETWORK_CONNECTING, is_enable)
end

---重连失败后显示确认框（包含“重试”按钮）
---@param txt string 对话框内容
---@param isReplace bool
local function DisplayConfirmAfterConnectFailed(txt, isReplace)
    UICommonUtil.ShowMessageBoxWithOpenParam({ PanelOrder = GameConst.MessageBoxOrder.High }, txt, {
        { btn_type = GameConst.MessageBoxBtnType.CONFIRM,
          btn_text = UITextHelper.GetUIText(UITextConst.UI_TEXT_5733),
          btn_call = function()
              ---连接中显示菊花不延迟
              needDelayShowConnectingIndicator = false
              GrpcMgr.Connect()
          end },
        { btn_type = GameConst.MessageBoxBtnType.CANCEL,
          btn_text = UITextHelper.GetUIText(UITextConst.UI_TEXT_5732),
          btn_call = function()
              GameStateMgr.Switch(GameState.Logout)
          end }
    }, AutoCloseMode.None, nil, isReplace)
end

---重连失败后显示确认框（只能去登录界面）
---@param txt string 对话框内容
local function DisplayConfirmAfterConnectFailedWithoutRetry(txt)
    UICommonUtil.ShowMessageBoxWithOpenParam({ PanelOrder = GameConst.MessageBoxOrder.High }, txt, {
        { btn_type = GameConst.MessageBoxBtnType.CONFIRM,
          btn_text = UITextHelper.GetUIText(UITextConst.UI_TEXT_5732),
          btn_call = function()
              GameStateMgr.Switch(GameState.Logout)
          end }
    }, AutoCloseMode.None)
end
---有资源更新弹窗 返回登陆界面
local function ShowResUpdateMessageBox()
    UICommonUtil.ShowMessageBoxWithOpenParam({ PanelOrder = GameConst.MessageBoxOrder.High }, UITextHelper.GetUIText(UITextConst.UI_TEXT_5727), {
        { btn_type = GameConst.MessageBoxBtnType.CONFIRM,
          btn_text = UITextHelper.GetUIText(UITextConst.UI_TEXT_5701),
          btn_call = function()
              GameStateMgr.Switch(GameState.Logout)
          end }
    }, AutoCloseMode.None)
end

---超时重连成功返回登陆界面
local function ShowBackMainHomeMessageBox()
    UICommonUtil.ShowMessageBoxWithOpenParam({ PanelOrder = GameConst.MessageBoxOrder.High }, UITextConst.UI_TEXT_5728, {
        { btn_type = GameConst.MessageBoxBtnType.CONFIRM,
          btn_text = UITextConst.UI_TEXT_5701,
          btn_call = function()
              CS.X3Game.GameHelper.ResUpdateUtility.ReqResUpdate(function(isUpdate)
                  if isUpdate then
                      ShowResUpdateMessageBox()
                  else
                      GameStateMgr.Switch(GameState.Disconnection)
                  end
              end)
          end }
    }, AutoCloseMode.None)
end

---初始化
function GrpcMgr.Init()
    CriticalLog.Log("Grpc.Init")
    local pbcAssetName = "Pbc"
    Debug.Log("LuaGrpcMgr.Init:", pbcAssetName)
    local buffer = Res.LoadBytes("Assets/Build/Res/GameObjectRes/BasicWidget/Pbc.bytes")
    CLIENT_RECONNECTION_TIME = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.CLIENTRECONNECTIONTIME)
    if buffer ~= nil then
        pbc.clear()
        pbc.load(buffer)
        pbc.option "enum_as_value"
        pbcByteIsInit = true
    else
        pbcByteIsInit = false
        Debug.LogFatal("Assets/Build/Res/GameObjectRes/BasicWidget/Pbc.bytes LoadBytes Fail")
    end
    CSMGR = CS.X3Game.Networking.GrpcMgr.Instance
    CSMGR.ConnectTimeout = CONNECT_TIMEOUT
    CSMGR.ConnectRetryMaxCount = CONNECT_RETRY_COUNT
    CSMGR.MsgAcknowledgeTimeout = MSGACKNOWLEDGE_TIMEOUT
    CSMGR:SetLoginMsgKeyList({ "HelloRequest", "LoginRequest" })
    CSMGR:AddDelegate(GrpcMgr)
    CSMGR.NetworkAvailableUrl = AppInfoMgr.GetCmsUrl()
    CS.X3Game.Networking.GrpcMgr.LogLevel = LogType.Send | LogType.Receive | LogType.Connection | LogType.Seq
    updateTimer = TimerMgr.AddTimer(0, GrpcMgr.OnUpdate, self, true)
    EventMgr.AddListener(MainHomeConst.Event.MAIN_HOME_CHECK_OTHER_SYSTEM, GrpcMgr.OnBackMainHome, self)
end

---Clear
function GrpcMgr.Clear()
    CriticalLog.Log("Grpc.Clear")
    if updateTimer and updateTimer ~= 0 then
        TimerMgr.Discard(updateTimer)
    end
    GrpcMgr.SetMetaData("Type", 0)
    isLoginSuccess = false
    GrpcMgr.SetSessionDataJson()
    GrpcMgr.Disconnect()
    ClearIndicator()
    isBeKickedLogout = false
    displayReconnectTipsEnabled = true
    needSyncUserTotalData = false
    syncUserTotalDataIsEnd = false
    ClearReceiveServerSeq()
    ClearOldReceiveServerSeq()
    ClearBattleRequestDataList()
end

---销毁GrpcMgr
function GrpcMgr.Destroy()
    CriticalLog.Log("Grpc.Destroy")
    if updateTimer and updateTimer ~= 0 then
        TimerMgr.Discard(updateTimer)
    end
    isLoginSuccess = false
    GrpcMgr.SetMetaData("Type", 0)
    GrpcMgr.SetSessionDataJson()
    CSMGR:RemoveDelegate(GrpcMgr)
    GrpcMgr.Disconnect()
    ClearIndicator()
    isBeKickedLogout = false
    displayReconnectTipsEnabled = true
    needSyncUserTotalData = false
    syncUserTotalDataIsEnd = false
    ClearReceiveServerSeq()
    ClearOldReceiveServerSeq()
    ClearBattleRequestDataList()
    CSMGR = nil
end

local SessionData = {}
---设置基本KV
---@param key string
---@param val string
function GrpcMgr.SetMetaData(key, val)
    if CSMGR == nil then
        print("Please GrpcMgr.Init() first")
        return
    end
    SessionData[key] = val
end

function GrpcMgr.GetMetaData(key)
    if SessionData == nil then
        GrpcMgr.GetSessionData()
    end
    return SessionData[key]
end

function GrpcMgr.GetSessionData()
    if table.nums(SessionData) <= 0 then
        SessionData = JsonUtil.Decode(CSMGR.SessionDataJson)
    end
    if CSMGR ~= nil then
        SessionData["LastRespondSeq"] = CSMGR.StartSeq
        SessionData["RecvServerSeq"] = oldReceiveServerSeq
    end
    return SessionData
end

function GrpcMgr.SetSessionDataJson()
    local jsonStr = JsonUtil.Encode(SessionData)
    CSMGR.SessionDataJson = jsonStr
end

---设置服务器时区
---@param tz int
function GrpcMgr.SetTimeZone(tz)
    if CSMGR == nil then
        print("Please GrpcMgr.Init() first")
        return
    end
    time_zone = tz
    CSMGR:SetTimeZone(tz)
end

---获取服务器时区
---@return int
function GrpcMgr.GetTimeZone()
    if CSMGR == nil then
        Debug.Log("Please GrpcMgr.Init() first")
        return
    end
    if not time_zone then
        time_zone = CSMGR:GetTimeZone()
    end
    return time_zone
end

---连接（完全连接）
---@param addr string 连接地址
function GrpcMgr.Connect(addr)
    if not pbcByteIsInit then
        UICommonUtil.ShowMessage(UITextConst.UI_TEXT_5114)
        return
    end
    CriticalLog.Log("Grpc.Connect")
    if CSMGR == nil then
        print("Please GrpcMgr.Init() first")
        return
    end
    if (CSMGR.IsConnecting == true) then
        print("正在连接中...，不要点")
        return
    end
    CSMGR:Connect(addr)
end

---断开与服务器的连接
function GrpcMgr.Disconnect()
    CriticalLog.Log("Grpc.Disconnect")
    if CSMGR == nil then
        print("Please GrpcMgr.Init() first")
        return
    end
    CSMGR:Disconnect()
    Debug.Log("GrpcMgr Disconnect")
end

function GrpcMgr.RpcLoginComplete(svrStartSeq, svrLastRespond, differenceReceiveSeq)
    if CSMGR == nil then
        print("Please GrpcMgr.Init() first")
        return
    end

    local canRpcLoginCompleteProceed = true
    local msgSentBackupQueue = CSMGR.MsgSentBackupQueue
    Debug.LogFormat("LuaGrpcMgr.RpcLoginComplete svrStartSeq=%s, differenceReceiveSeq=%s, msgSentBackupQueue=%s, svrLastRespond=%s", svrStartSeq, differenceReceiveSeq, msgSentBackupQueue.Count, svrLastRespond)
    if UNITY_EDITOR then
        if (CS_MGR_CLS.WriteExtraLog) then
            CS_MGR_CLS.WriteExtraLog(string.format("LuaGrpcMgr.RpcLoginComplete svrStartSeq=%s, differenceReceiveSeq=%s, msgSentBackupQueue=%s, svrLastRespond=%s", svrStartSeq, differenceReceiveSeq, msgSentBackupQueue.Count, svrLastRespond))
        end
    end

    if (not isSendEnterGame and rpcLoginIsReconnect and svrLastRespond == nil) or (msgSentBackupQueue.Count > 0 and svrLastRespond == nil) or (msgSentBackupQueue.Count > 1) then
        canRpcLoginCompleteProceed = false
    else
        if (msgSentBackupQueue.Count > 0) then
            local sentMsg = msgSentBackupQueue:Peek()
            ---客户端收到的包的数量和服务器发送的包的数量 只差1的情况下 如果客户端最后一个发送的包seq和服务器收到的最后一个包seq是相等的那么不需要拉取全量
            if needSyncUserTotalData and differenceReceiveSeq == 1 and sentMsg.Seq == svrLastRespond.Seq then
                needSyncUserTotalData = false
            end
            ---客户端已发Seq与服务器收到的Seq之差>1
            if math.abs(sentMsg.Seq - svrLastRespond.Seq) > 1 or svrLastRespond.Seq > sentMsg.Seq then
                Debug.LogWarning("LuaGrpcMgr.RpcLoginComplete: sentMsg.Seq(%s) - svrLastRespond.Seq(%s) > 1", sentMsg.Seq, svrLastRespond.Seq)
                canRpcLoginCompleteProceed = false
            end
        end
        if svrLastRespond ~= nil and (math.abs(CSMGR.StartSeq - svrLastRespond.Seq) > 1 or svrLastRespond.Seq > CSMGR.StartSeq) then
            canRpcLoginCompleteProceed = false
        end
    end

    if canRpcLoginCompleteProceed then
        local encodedBytes = nil
        if svrLastRespond ~= nil then
            encodedBytes = pbc.encode("pb.Respond", svrLastRespond)
        end
        CSMGR:RpcLoginComplete(svrStartSeq, encodedBytes, canRpcLoginCompleteProceed)
    else
        CSMGR:RpcLoginComplete(svrStartSeq, nil, canRpcLoginCompleteProceed)
    end
end

---获取服务器时间
---@return System.DateTimeOffset
function GrpcMgr.GetServerTime()
    if CSMGR == nil then
        Debug.LogError("Please GrpcMgr.Init() first")
        return
    end
    return CSMGR.ServerTime
end

---获取服务器时间 to UnixTimeSeconds
---@return Int
function GrpcMgr.GetServerTimeToUnixTimeSeconds()
    if CSMGR == nil then
        Debug.LogError("Please GrpcMgr.Init() first")
        return
    end

    return CSMGR.ServerTimeToUnixTimeSeconds
end

---同步发送Request协议（有菊花）
---@param request RpcDefines
---@param data table
---@param cacheRequest boolean
function GrpcMgr.SendRequest(request, data, cacheRequest)
    if request == nil then
        Debug.LogError("SendRequest: request is nil")
        return
    end

    if nil == data then
        Debug.LogError("SendRequest: data is nil")
        return
    end

    if not CheckCanSendRequest(request, data, cacheRequest) then
        return
    end

    local msgKey = request[1]

    local encodedBytes = pbc.encode(request[2], data)
    if nil == encodedBytes then
        Debug.LogErrorFormat("pbc.encode failed, msgKey=%s", msgKey)
        return
    end

    if CSMGR == nil then
        Debug.LogErrorFormat("Please GrpcMgr.Init() first")
        return
    end
    CSMGR:Send(msgKey, encodedBytes, true, cacheRequest and true or false)
end

---异步发送Request协议（没有菊花）
---@param request RpcDefines
---@param data table
function GrpcMgr.SendRequestAsync(request, data, cacheRequest)
    if request == nil then
        Debug.LogError("SendRequestAsync: request is nil")
        return
    end

    if nil == data then
        Debug.LogError("SendRequestAsync: data is nil")
        return
    end

    if not CheckCanSendRequest(request, data, cacheRequest) then
        return
    end

    local msgKey = request[1]

    local encodedBytes = pbc.encode(request[2], data)
    if nil == encodedBytes then
        Debug.LogErrorFormat("pbc.encode failed, msgKey=%s", msgKey)
        return
    end

    if CSMGR == nil then
        Debug.LogErrorFormat("Please GrpcMgr.Init() first")
        return
    end
    CSMGR:Send(msgKey, encodedBytes, false, cacheRequest and true or false)
end

---delegate of CS.PapeGames.X3.GrpcMgr------------------------------------------------------------------------

---与服务器连接开始
---@param reconnect bool 是否是断线重连
---@param withIndicator bool 是否有菊花
function GrpcMgr:OnConnectBegin(reconnect, withIndicator)
    CriticalLog.LogFormat("Grpc.OnConnectBegin: reconnect=%s, withIndicator=%s", reconnect, withIndicator)
    if withIndicator then
        ExeShowIndicator(true, UITextHelper.GetUIText(UITextConst.UI_TEXT_5199), needDelayShowConnectingIndicator)
    end
end

---RPC初始化开始
---@param reconnect bool 是否是断线重连
function GrpcMgr:OnRpcLoginBegin(reconnect)
    ExeShowIndicator(true, UITextHelper.GetUIText(UITextConst.UI_TEXT_5199), needDelayShowConnectingIndicator)
    rpcLoginIsReconnect = reconnect
    CS.X3Game.Networking.GrpcMgr.EncryptionEnable = false
    local aesKey = CS.X3Game.Cryptography.CryptoUtility.AesGenerateKey()
    local encryptedAesKey = CS.X3Game.Cryptography.CryptoUtility.RsaEncrypt(aesKey, nil)
    GrpcMgr.SendRequest(RpcDefines.HelloRequest, { AesKey = encryptedAesKey })
    CS.X3Game.Networking.GrpcMgr.EncryptionEnable = true
end

function GrpcMgr:OnRpcLoginEnd(success, isLoginError)
    ClearIndicator()
    if not isLoginSuccess then
        isLoginSuccess = success
    end

    Debug.LogFormat("LuaGrpcMgr.OnRpcLoginEnd success=%s", success)
    if UNITY_EDITOR then
        if (CS_MGR_CLS.WriteExtraLog) then
            CS_MGR_CLS.WriteExtraLog(string.format("LuaGrpcMgr.OnRpcLoginEnd success=%s", success))
        end
    end

    if success then
        if not rpcLoginIsReconnect or isSendEnterGame then
            GrpcMgr.EnterGame()
        else
            if needSyncUserTotalData and GameStateMgr.GetCurStateName() ~= GameState.Battle then
                GrpcMgr.SendSyncUserTotalDataAsync()
            end
        end
    else
        if displayReconnectTipsEnabled then
            if GrpcMgr.OnNeedCheckResUpdate() then
                GrpcMgr.Disconnect()
                CS.X3Game.GameHelper.ResUpdateUtility.ReqResUpdate(GrpcMgr.OnResIsUpdate)
            end
        else
            isNeedShowResUpdateTips = true
        end
    end
end

function GrpcMgr.OnHelloReply()
    if oldReceiveServerSeq == 0 then
        oldReceiveServerSeq = GetReceiveServerSeq()
    end
    ClearReceiveServerSeq()
    GrpcMgr.SendRequest(RpcDefines.LoginRequest, GrpcMgr.GetSessionData())
end

---@param data pbcmessage.LoginReply
function GrpcMgr.OnLoginReply(data)
    --Debug.Log("当前ReceiveServerSeq", data.SendServerSeq, "客戶端的ReceiveSeq", oldReceiveServerSeq)
    if data.SendServerSeq ~= oldReceiveServerSeq then
        needSyncUserTotalData = true
    end
    local differenceReceiveSeq = math.abs(data.SendServerSeq - oldReceiveServerSeq)
    ClearOldReceiveServerSeq()
    GrpcMgr.UpdateServerTime(data.ServerTime)
    --Debug.Log("当前Seq为" .. data.StartSeq .. " CachedSeq为" .. data.CachedSeq)
    GrpcMgr.RpcLoginComplete(data.StartSeq, data.LastRespond, differenceReceiveSeq)
end

function GrpcMgr.OnLoginReplyError()
    ClearIndicator()
end

function GrpcMgr.UpdateServerTime(timestamp)
    CSMGR:UpdateServerTime(timestamp)
    TimerMgr.ForceSync()
end

function GrpcMgr.EnterGame(isSendAsync)
    CriticalLog.Log("Grpc.SyncDataRequest")
    if isSendAsync == nil then
        isSendAsync = false
    end
    if isSendEnterGame then
        isSendEnterGame = false
    end
    if needSyncUserTotalData then
        needSyncUserTotalData = false
    end
    if isSendAsync then
        GrpcMgr.SendRequestAsync(RpcDefines.SyncUserTotalDataRequest, { })
    else
        GrpcMgr.SendRequest(RpcDefines.SyncUserTotalDataRequest, { })
    end
end

function GrpcMgr.__ConnectFailed()
    GrpcMgr.Disconnect()
    TimerMgr.AddTimer(0, function()
        DisplayConfirmAfterConnectFailedWithoutRetry(UITextConst.UI_TEXT_5729)
    end)
end

---与服务器连接完成
---@param reconnect bool 是否是重连
---@param success bool 是否成功
---@param errorCode int 错误码
---@param errorMsg string 错误
---@param isCanceled bool 是否为取消连接
---@param withIndicator bool 是否有菊花
function GrpcMgr:OnConnectEnd(reconnect, success, errorCode, errorMsg, isCanceled, withIndicator)
    CriticalLog.LogFormat("Grpc.OnConnectEnd: reconnect=%s, success=%s, errorCode=%s, errorMsg=%s, isCanceled=%s, withIndicator=%s", reconnect, success, errorCode, errorMsg, isCanceled, withIndicator)
    if (reconnect) then
        CriticalLog.LogFormat("Grpc.TotalReconnectCount: %s", CS_MGR_CLS.TotalReconnectCount)
    end
    if withIndicator then
        ExeShowIndicator(false)
    end

    if not isCanceled then
        if not needDelayShowConnectingIndicator then
            needDelayShowConnectingIndicator = true
        end
        if not success then
            if displayReconnectTipsEnabled then
                SetGrabFocusEnable(true)
                isOpenGrabFocus = true
                DisplayConfirmAfterConnectFailed(UITextConst.UI_TEXT_5734)
            else
                AutoConnect()
            end
            EventMgr.Dispatch(GrpcMgr.Event_Connect_Failed)
        else
            disconnectedTime = 0
        end
        if isOpenGrabFocus then
            SetGrabFocusEnable(false)
            isOpenGrabFocus = false
        end
    end
end

---与服务器闪断（接下来会走断线重连流程）
---@param reason int
function GrpcMgr:OnTempDisconnected(reason)
    CriticalLog.LogFormat("Grpc.OnTempDisconnected: reason=%s", reason)
    ---设置断线时间
    local nowTime = os.time()
    disconnectedTime = nowTime
    ---待发送数据数量
    local msgToSendCount = CSMGR:GetMsgToSendCount()
    ---待确认数据数量
    local msgSentCount = CSMGR:GetMsgSentCount()
    ---Type 登录为0  重连为1
    GrpcMgr.SetMetaData("Type", isLoginSuccess and 1 or 0)
    if (msgToSendCount + msgSentCount > 0) or not displayReconnectTipsEnabled or indicatorCount > 0 then
        CSMGR:Connect()
    end
end

---与服务器连接断开
function GrpcMgr:OnDisconnected()
    CriticalLog.Log("Grpc.OnDisconnected")
    ClearIndicator()
end

function GrpcMgr:OnClosed()
    if isSendEnterGame then
        GrpcMgr.Connect()
    end
end

function GrpcMgr:OnWillSendMsg(msgKey, withIndicator)
    if (withIndicator == true) then
        ExeShowIndicator(true, UITextHelper.GetUIText(UITextConst.UI_TEXT_5198), true)
    end
end

---开始发送某条消息
---@param msgKey string 协议名
---@param withIndicator boolean
function GrpcMgr:OnSendMsgBegin(msgKey, withIndicator)
    if (withIndicator == true) then
        ExeShowIndicator(true, UITextHelper.GetUIText(UITextConst.UI_TEXT_5198), true)
    end

    EventMgr.Dispatch(GrpcMgr.EVENT_SEND_MSG_BEGIN, msgKey)
end

---发送某条消息完成
---@param msgKey string 协议名
---@param success boolean 是否成功
---@param errorCode Int 失败时的状态码
---@param error string 错误
---@param withIndicator boolean 是否需要菊花
function GrpcMgr:OnSendMsgEnd(msgKey, success, errorCode, error, withIndicator)
    if withIndicator == true then
        ExeShowIndicator(false)
    end

    local totalSendMsgCount = CS_MGR_CLS.TotalSendMsgCount
    if ((totalSendMsgCount % 10) == 0) then
        CriticalLog.LogFormat("Grpc.statistics: sendMsgCost=%s, actualSendMsgCost=%s", CS_MGR_CLS.AvgSendMsgTimeCost, CS_MGR_CLS.AvgActualSendMsgTimeCost)
    end
end

---收到协议
---@param self table
---@param msgKeyHash int 协议号
---@param msgBody Byte[] 协议内容
function GrpcMgr:OnReceiveMsg(msgKeyHash, errorCode, msgBody, request, isUpdateMsg)
    local msgKey = crcMap[msgKeyHash]
    if not isUpdateMsg then
        SetReceiveServerSeqWithMsgKey(msgKey)
    end
    if msgKeyHash == 0 then
        return false
    end
    if msgKey == nil then
        Debug.LogErrorFormat("LuaGrpcMgr.OnReceiveMsg error=msgKeyHash(%s) not exist", msgKeyHash)
        return false
    end
    Debug.LogFormat("LuaGrpcMgr.OnReceiveMsg msgKey=%s", msgKey)
    if UNITY_EDITOR then
        if (CS_MGR_CLS.WriteExtraLog) then
            CS_MGR_CLS.WriteExtraLog(string.format("LuaGrpcMgr.OnReceiveMsg msgKey=%s", msgKey))
        end
    end
    if not syncUserTotalDataIsEnd then
        local requestMsgKey = string.replace(msgKey, "Reply", "Request")
        if RpcDefines[requestMsgKey] == nil then
            Debug.LogFatal("SyncUserTotalData is not end OnReceiveMsg msgKey=", msgKey)
        end
    end
    if errorCode ~= pbc.enum("pb.Errno", "Success") then
        local result, tbl = pcall(pbc.decode, RpcDefines[msgKey][2], msgBody)
        if msgKey ~= "" then
            local func_key = string.replace(msgKey, 'Reply', '')
            local reply_key = msgKey
            local msg_func = ErrHandleList[func_key]
            local msg_reply_func = ErrHandleList[reply_key]
            if nil ~= msg_func then
                msg_func(errorCode, tbl)
            elseif nil ~= msg_reply_func then
                msg_reply_func(errorCode, tbl)
            end
            EventMgr.Dispatch(GrpcMgr.Event_SendMsg_Error, func_key, errorCode)
        end
        EventMgr.Dispatch(string.format("%s_Error", msgKey), errorCode, tbl)

        ---是否需要飘Tips
        local needShowErrorTips = true

        if (errorCode < 0) then
            --TODO @教主 后台切换回来断线重连模糊相关问题
            TimerMgr.AddTimer(0, function()
                DisplayConfirmAfterConnectFailed(UITextConst.UI_TEXT_5731)
            end)
        else
            if errorCode == pbc.enum("pb.Errno", "NetworkCSeqDisorder")
                    or errorCode == pbc.enum("pb.Errno", "SessionNotFound")
                    or errorCode == pbc.enum("pb.Errno", "SessionKickLogin") then
                GrpcMgr.__ConnectFailed()
            elseif errorCode == X3_CFG_CONST.SERVERGAMENOTFOUND and GameStateMgr.GetCurStateName() ~= GameState.Login then
                needShowErrorTips = false
            end
        end

        if needShowErrorTips then
            GrpcMgr.ShowServerErrorCodeTips(errorCode)
        end

        return false
    end

    if RpcDefines[msgKey] == nil then
        Debug.LogError("RpcDefines not exist ", msgKey)
        return false
    end

    local result, tbl = pcall(pbc.decode, RpcDefines[msgKey][2], msgBody)
    if not result then
        UICommonUtil.ShowMessage(UITextConst.UI_TEXT_5109)
        local decodeError = tbl
        Debug.LogFatalFormat("[pbc.decode][error] msgKey:%s reason:%s", msgKey, decodeError)
        return false
    end

    ---todo:缓存Request的数据不应该从C#端传过来
    if request then
        local _, tbl2 = pcall(pbc.decode, string.replace(RpcDefines[msgKey][2], "Reply", "Request"), request)
        EventMgr.Dispatch(msgKey, tbl, tbl2)
    else
        EventMgr.Dispatch(msgKey, tbl)
    end

    ---todo:和GPRC解耦
    if RedPointMgr then
        RedPointMgr.CheckProto(msgKey)
    end
    ---todo:和GPRC解耦
    if BllMgr then
        BllMgr.GetConditionCheckBLL():CheckProto(msgKey)
    end

    return true
end

---本帧收到最后一个UpdateMsg
function GrpcMgr:OnReceiveUpdateMsg()
    EventMgr.Dispatch(GrpcMgr.Event_OnReceiveUpdateMsg)
end

---显示服务器errorCodeTips
---@param errorCode int
function GrpcMgr.ShowServerErrorCodeTips(errorCode)
    if errorCode == 0 then
        return
    end
    local bShowTips = true
    local CfgServerError = LuaCfgMgr.Get("ServerError", errorCode)
    if CfgServerError and CfgServerError.Tips <= 0 then
        bShowTips = false
    end
    if bShowTips == true then
        ShowMessageTips(errorCode)
    end
end

---是否需要检查热更
---@param self table
---@return boolean 是否需要完全连接
function GrpcMgr.OnNeedCheckResUpdate(self)
    return true
end

---是否需要热更
---@param self table
---@param isUpdate boolean
function GrpcMgr.OnResIsUpdate(isUpdate)
    if isUpdate then
        ShowResUpdateMessageBox()
    else
        ShowBackMainHomeMessageBox()
    end
end

---Update
function GrpcMgr.OnUpdate()
    ---处理心跳包
    if CSMGR.IsConnected then
        local nowTime = os.time()
        if nowTime - lastPingTime > PING_INTERVAL then
            lastPingTime = nowTime
            SendPing()
        end
    end
end

function GrpcMgr.OnReConnectSuccess()
    BllMgr.OnReconnect()
    UIMgr.OnReconnect()
end

---打开断线重连弹窗 网络编辑器工具使用
function GrpcMgr.ShowDisconnectMessageBox()
    ShowBackMainHomeMessageBox()
end

---服务器更新 需闪断连接
function GrpcMgr.OnServerUpdate()
    if GameStateMgr.GetCurStateName() == GameState.MainHome then
        GrpcMgr.ServerUpdateConnect()
    else
        serverIsUpdate = true
    end
end

function GrpcMgr.ServerUpdateConnect()
    serverIsUpdate = false
    CS.X3Game.GameHelper.ResUpdateUtility.ReqResUpdate(function(isUpdate)
        if not isUpdate then
            isSendEnterGame = true
            GrpcMgr.SetMetaData("Type", 0)
            GrpcMgr.Disconnect()
        end
    end)
end

function GrpcMgr.OnBackMainHome()
    if serverIsUpdate then
        GrpcMgr.ServerUpdateConnect()
    elseif needSyncUserTotalData then
        GrpcMgr.SendSyncUserTotalDataAsync()
    end
    if #battleCacheRequestDataList > 0 then
        for i = 1, #battleCacheRequestDataList do
            local tempRequest = battleCacheRequestDataList[i]
            GrpcMgr.SendRequestAsync(tempRequest.request, tempRequest.data, tempRequest.cacheRequest)
            PoolUtil.ReleaseTable(battleCacheRequestDataList[i])
        end
        battleCacheRequestDataList = {}
    end
end

---设置是否需要断线的表现（转菊花和二次确认重试弹窗） 此方法需成对出现 否则断线不会有正常表现
---@param enable boolean true 为默认正常表现 false为屏蔽断线重连所有表现
function GrpcMgr.SetReConnectIsShow(enable)
    displayReconnectTipsEnabled = enable
    ---被服务器踢掉之后退出玩法不再自动重连
    if isBeKickedLogout then
        return
    end
    if enable and isNeedShowResUpdateTips then
        CS.X3Game.GameHelper.ResUpdateUtility.ReqResUpdate(GrpcMgr.OnResIsUpdate)
        isNeedShowResUpdateTips = false
        return
    end
    if enable and not CSMGR.IsConnected then
        if autoConnectTimer then
            TimerMgr.Discard(autoConnectTimer)
            autoConnectTimer = nil
        end
        GrpcMgr.Connect()
    end
end

---网络是否已连接
---@return boolean true 为已连接 false 为未连接
function GrpcMgr.IsConnected()
    return CSMGR.IsConnected
end

---自动拉取全量工具使用
function GrpcMgr.GMAutoSendSyncUserTotalData()
    if DEBUG_GM and GrpcMgr.IsConnected() then
        if sendSyncUserTotalTimer == nil then
            GrpcMgr.SendRequestAsync(RpcDefines.SyncUserTotalDataRequest, { })
            sendSyncUserTotalTimer = TimerMgr.AddTimer(60 * 2, function()
                GrpcMgr.SendRequestAsync(RpcDefines.SyncUserTotalDataRequest, { })
            end, nil, true)
            Debug.Log("AutoSendSyncUserTotalData true")
        else
            TimerMgr.Discard(sendSyncUserTotalTimer)
            sendSyncUserTotalTimer = nil
            Debug.Log("AutoSendSyncUserTotalData false")
        end
    end
end

function GrpcMgr.GetIsAutoSendSyncUserTotalData()
    return sendSyncUserTotalTimer ~= nil
end

---Editor下读取proto版本 在login时候判断Proto文件是否和服务器匹配
function GrpcMgr.GetProtoVersion()
    local retVersionValue = 0
    if UNITY_EDITOR then
        local filePath = string.concat(CS.UnityEngine.Application.dataPath, "/../protocols/version.proto")
        if not CS.System.IO.File.Exists(filePath) then
            return retVersionValue
        end
        local text = CS.PapeGames.X3.FileUtility.ReadText(filePath)
        local protoVersionValue = text:match("ProtoVersionValue = (%d+);")
        if protoVersionValue then
            retVersionValue = tonumber(protoVersionValue)
        end
    end
    return retVersionValue
end

function GrpcMgr.SendSyncUserTotalDataAsync()
    GrpcMgr.EnterGame(true)
    ---此处好友数据不在全量数据中要单独拉取好友数据
    BllMgr.GetFriendBLL():SendFriendRequest_QueryTotal()
end

---设置SyncUserTotalDataIsEnd
function GrpcMgr.SetSyncUserTotalDataIsEnd(isEnd)
    syncUserTotalDataIsEnd = isEnd
end

return GrpcMgr
