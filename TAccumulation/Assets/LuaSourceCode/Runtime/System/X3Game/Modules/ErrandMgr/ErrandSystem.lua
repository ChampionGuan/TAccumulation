---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by doudou.
--- DateTime: 2023/3/21 21:09
---@class UIViewContext_LovePointMiniErrandErrandSystemNew
local ErrandSystem = class("ErrandSystemNew")

function ErrandSystem:ctor()

end

--region Debug
function ErrandSystem:_IsDebugEnable()
    if UNITY_EDITOR then
        return CS.X3GameEditor.ErrandSystemEditorHelper.isDebugOpen
    end
end

function ErrandSystem:_InitDebug()
    if not UNITY_EDITOR then
        return
    end

    CS.X3GameEditor.ErrandSystemEditorHelper.GetDebugInfo = handler(self, self._GetDebugInfo)
    CS.X3GameEditor.ErrandSystemEditorHelper.GetDebugMap = handler(self, self._GetDebugMap)
    CS.X3GameEditor.ErrandSystemEditorHelper.ClearDebugInfo = handler(self, self._ClearDebugInfo)
    self.debugInfoList = {}
end

function ErrandSystem:_GetDebugInfo()
    return self.debugInfoList
end

function ErrandSystem:_GetDebugMap()
    return self.debugMap
end

function ErrandSystem:_OnAddNewInfo()
    if not UNITY_EDITOR then
        return
    end

    CS.X3GameEditor.ErrandSystemEditorHelper.AddNewInfo()
end

function ErrandSystem:_AddDebugInfo(uid, type, operation, detail)
    if not self:_IsDebugEnable() then
        return
    end

    if self.debugInfoList == nil then
        self.debugInfoList = {}
    end

    if operation == ErrandConst.OperationType.OpenDelay then
        detail = debug.traceback()
    end

    table.insert(self.debugInfoList, {
        uid = uid,
        type = type,
        frameCount = TimerMgr.GetFrameCount(),
        operation = operation,
        detail = detail
    })

    if uid ~= 0 then
        if operation == ErrandConst.OperationType.Add or operation == ErrandConst.OperationType.TryExecute then
            self.debugMap[uid] = ErrandConst.ErrandState.Waiting
        elseif operation == ErrandConst.OperationType.Execute then
            self.debugMap[uid] = ErrandConst.ErrandState.Executing
        elseif operation == ErrandConst.OperationType.End or operation == ErrandConst.OperationType.Clear then
            self.debugMap[uid] = ErrandConst.ErrandState.End
        end
    end

    self:_OnAddNewInfo()
end

function ErrandSystem:_ClearDebugInfo()
    if not self:_IsDebugEnable() then
        return
    end

    self.debugInfoList = {}
    self.debugMap = {}
end
--endregion

function ErrandSystem:Init()
    ---@type ErrandDetail[] 等待队列
    self.errandQueue = {}
    ---@type table<int, ExecutingInfo[]>
    self.executingDict = {}
    ---@type boolean
    self.isMonopolizeOpen = false
    ---@type string
    self.monopolizeWndName = nil
    ---@type ErrandDebugInfo[]
    self.debugInfoList = {}
    ---@type DebugErrandMap
    self.debugMap = {}
    ---@type boolean
    self.isFreezeShow = false
    ---@type number[][] 记录已经打开事务队列(一维表示队列ID，二维表示事务Name)
    ---使用一维整形数组也是可以的，做累加，累减，控制。
    ---但是为了方便Debug，定位阻塞原因。使用了二维数组，最大占用空间，队列数*popupID数，目前应该是10*30=300，后续系统稳定后，可以优化
    self.blockQueueDict = {}

    ---@type int[]
    self.clearList = {}

    self.needCheckShow = false
    self.needCheckSceneClear = false

    self.nextUid = 1
    self.autoEnableTouchTimer = nil
    self.isInit = true

    self:_InitDebug()
    self:_RegisterEvent()
end

---@public
---检测是事务是否已打开或在等待触发的队列中
---@param typeId number 事务类型的ID或Key
function ErrandSystem:IsAdded(typeId)
    if not self.isInit then
        return false
    end
    for k, _ in pairs(self.executingDict) do
        if k == typeId then
            return true
        end
    end

    for i = 1, #self.errandQueue do
        if self.errandQueue[i].type == typeId then
            return true
        end
    end
    return false
end

---@public
---增加新待触发事务 直接打开配置中给的界面
---@param typeID number 事务类型的ID或Key
---@param data table 打开UI时的参数列表
function ErrandSystem:Add(typeID, data)
    if not self.isInit then
        return
    end

    local cfg = LuaCfgMgr.Get("Popup", typeID)

    if typeID == nil or cfg == nil then
        Debug.LogErrorWithTag(GameConst.LogTag.ErrandMgr, "事务类型不存在")
        return
    end

    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "开始添加事务==", cfg.InterfaceName)
    if not self.isFreezeShow then
        self:_DisableTouch()
    end

    ---@type ErrandDetail
    local detail = PoolUtil.GetTable()
    detail.uid = self.nextUid
    detail.type = typeID
    detail.params = data

    self.nextUid = self.nextUid + 1
    self:_AddErrand(detail)
end

---@public
---增加新待触发事务 界面可通过回调打开。按规则调用回调
---@param typeID number 事务类型的ID或Key
---@param startFunc function 开启用函数
---@param endFunc function 关闭用函数
function ErrandSystem:AddWithCallBack(typeID, startFunc, endFunc)
    if not self.isInit then
        return
    end

    local cfg = LuaCfgMgr.Get("Popup", typeID)

    if typeID == nil or cfg == nil then
        Debug.LogErrorWithTag(GameConst.LogTag.ErrandMgr, "事务类型不存在")
        return
    end
    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "开始添加事务回调==", cfg.InterfaceName)

    if not self.isFreezeShow then
        self:_DisableTouch()
    end

    ---@type ErrandDetail
    local detail = PoolUtil.GetTable()
    detail.uid = self.nextUid
    detail.type = typeID
    detail.startFunc = startFunc
    detail.endFunc = endFunc

    self.nextUid = self.nextUid + 1
    self:_AddErrand(detail)
end

---@param detail ErrandDetail
function ErrandSystem:_AddErrand(detail)
    local cfg = LuaCfgMgr.Get("Popup", detail.type)
    if cfg == nil or cfg.QueueBlackList ~= nil and self:_InList(cfg.QueueBlackList, cfg.QueueBlackListType) then
        PoolUtil.ReleaseTable(detail)
        return
    end

    local insertPos = 1
    for i = #self.errandQueue, 1, -1 do
        local curCfg = LuaCfgMgr.Get("Popup", self.errandQueue[i].type)
        if cfg.Priority <= curCfg.Priority then
            insertPos = i + 1
            break
        end
    end

    table.insert(self.errandQueue, insertPos, detail)
    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "添加事务成功==", cfg.InterfaceName)
    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByAddNew")

    self:_MarkForShowCheck()
    self:_AddDebugInfo(detail.uid, detail.type, ErrandConst.OperationType.Add)
end

---@public
---特殊事务结束时通知管理器
---@param typeID number 事务类型的ID或Key
---@param isCloseByMgr boolean 是否是由管理器关闭的
function ErrandSystem:End(typeID, isCloseByMgr)
    if not self.isInit then
        return
    end

    for k, v in pairs(self.executingDict) do
        if k == typeID then
            local cfg = LuaCfgMgr.Get("Popup", k)
            if cfg.Monopolize == 1 then
                self.isMonopolizeOpen = false
                self.monopolizeWndName = nil
                Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "调用ErrandEnd接口，关闭互斥==", cfg.InterfaceName)
            end

            local detail = table.remove(v, #v)
            self:_AddDebugInfo(detail.uid, detail.type, ErrandConst.OperationType.End, isCloseByMgr and "管理器关闭")
            if #v == 0 then
                self.executingDict[k] = nil
            end

            self:_RemoveBlockQueue(cfg)
            self:_MarkForShowCheck()
            break
        end
    end
end

---@public
---客户端延迟开启及关闭。暂停或者开启，事务队列
---condition默认不传值,是强锁定，必须配合相同condition的解锁，本模块锁定的须由本模块打开
---@param open boolean 是否打开客户端延迟
---@param detail string 提示信息
function ErrandSystem:SetDelay(open, detail)
    if not self.isInit then
        return
    end

    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "SetErrandDelay====", open)
    self.isFreezeShow = open

    self:_AddDebugInfo(0, 0, open and ErrandConst.OperationType.OpenDelay or ErrandConst.OperationType.CloseDelay, detail)
    if not open then
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByCloseDelay", open)
        self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "CloseDelay")
        self:_MarkForShowCheck()
    end
end

---@private
---客户端延迟开启
function ErrandSystem:_DelayOpen()
    self:SetDelay(true)
end

---@private
---客户端延迟关闭
function ErrandSystem:_DelayClose()
    self:SetDelay(false)
end

---@public 清理某一类型事务（仅清除等待触发的，已经触发的不关闭）
function ErrandSystem:ClearByType(typeID)
    if not self.isInit then
        return
    end

    table.insert(self.clearList, typeID)
end

--region check Function
---@private
---判断列表内窗口，是否以指定方式打开
--1 打开 open
--2 可见 visible
--3 焦点 focus
function ErrandSystem:_InList(wndList, checkType)
    for i = 1, #wndList do
        if self:_WndCheck(wndList[i], checkType) then
            return true
        end
    end

    return false
end

---@private
---根据类型判定窗口是否打开
function ErrandSystem:_WndCheck(name, checkType)
    local inputList = string.split(name, '_')

    if inputList[1] ~= "MainHomeWnd" or #inputList < 2 then
        if checkType == 1 then
            return UIMgr.IsOpened(name)
        elseif checkType == 2 then
            return UIMgr.IsVisible(name)
        else
            return UIMgr.IsFocused(name)
        end
    else
        if checkType == 1 then
            return UIMgr.IsOpened(UIConf.MainHomeWnd)
        elseif checkType == 2 then
            return UIMgr.IsVisible(UIConf.MainHomeWnd) and BllMgr.GetMainHomeBLL():GetCurViewType() == ErrandConst.MainHomeViewTag[inputList[2]]
        else
            return UIMgr.IsFocused(UIConf.MainHomeWnd) and BllMgr.GetMainHomeBLL():GetCurViewType() == ErrandConst.MainHomeViewTag[inputList[2]]
        end
    end
end

---检测事务是否在显示
---@param errand  ErrandDetail|ExecutingInfo
function ErrandSystem:_CheckIsVisible(errand)
    if errand.startFunc ~= nil then
        return self.executingDict[errand.type] ~= nil
    else
        local cfg = LuaCfgMgr.Get("Popup", errand.type)
        return UIMgr.IsVisible(cfg.InterfaceName)
    end
end

---@private
---添加阻塞队列
---@param popUpCfg cfg.Popup
function ErrandSystem:_InsertBlockQueue(popUpCfg)
    self.blockQueueDict[popUpCfg.CommonQueue] = self.blockQueueDict[popUpCfg.CommonQueue] or {} --策划要求默认阻塞本队列
    self.blockQueueDict[popUpCfg.CommonQueue][popUpCfg.InterfaceName] = true;
    if popUpCfg.ExtraBlockQueue then
        for i = 1, #popUpCfg.ExtraBlockQueue do
            self.blockQueueDict[popUpCfg.ExtraBlockQueue[i]] = self.blockQueueDict[popUpCfg.ExtraBlockQueue[i]] or {}
            self.blockQueueDict[popUpCfg.ExtraBlockQueue[i]][popUpCfg.InterfaceName] = true;
        end
    end
end
---@private
---移出阻塞队列
---@param popUpCfg cfg.Popup
function ErrandSystem:_RemoveBlockQueue(popUpCfg)
    if self.blockQueueDict[popUpCfg.CommonQueue] and self.blockQueueDict[popUpCfg.CommonQueue][popUpCfg.InterfaceName] then
        --策划要求默认阻塞本队列
        self.blockQueueDict[popUpCfg.CommonQueue][popUpCfg.InterfaceName] = nil;
    end
    if popUpCfg.ExtraBlockQueue then
        for i = 1, #popUpCfg.ExtraBlockQueue do
            if self.blockQueueDict[popUpCfg.ExtraBlockQueue[i]] and self.blockQueueDict[popUpCfg.ExtraBlockQueue[i]][popUpCfg.InterfaceName] then
                self.blockQueueDict[popUpCfg.ExtraBlockQueue[i]][popUpCfg.InterfaceName] = nil;
            end
        end
    end
end
---@private
---队列是否被阻塞
---@param queueID int 队列id
---@return boolean
function ErrandSystem:_IsQueueBlocked(queueID)
    if self.blockQueueDict[queueID] then
        for k, v in pairs(self.blockQueueDict[queueID]) do
            if v then
                Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("队列=%d, 被界面=%s=阻塞了", queueID, k))
                return true
            end
        end
    end
    return false
end

---@private
---是否能触发某类型事务
function ErrandSystem:_CanShow(typeCfg)
    local inBlackList = typeCfg.DelayBlackList ~= nil and self:_InList(typeCfg.DelayBlackList, typeCfg.DelayBlackListType)
    local inWhiteList = typeCfg.DelayWhiteList == nil or self:_InList(typeCfg.DelayWhiteList, typeCfg.DelayWhiteListType)

    if not inWhiteList then
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("窗口=%s,未在延迟白名单中，本次不触发", typeCfg.InterfaceName))
    end
    if inBlackList then
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("窗口=%s,在延迟黑名单中，本次不触发", typeCfg.InterfaceName))
    end
    return not inBlackList and inWhiteList
end
--endregion

--region touch
---@private
---屏蔽点击
function ErrandSystem:_DisableTouch(enableFrame)
    if GameStateMgr.GetCurStateName() ~= GameState.Battle then
        --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "ErrandMgr_Disable_Touch_Auto", TimerMgr.GetFrameCount())
        self:_AddDebugInfo(0, 0, ErrandConst.OperationType.DisableTouch)
        GameHelper.SetTouchBlockingForFrames(true)
        if self.autoEnableTouchTimer then
            TimerMgr.Discard(self.autoEnableTouchTimer)
        end
        enableFrame = enableFrame or 5
        self.autoEnableTouchTimer = TimerMgr.AddTimerByFrame(enableFrame, self._EnableTouch, self)
    end
end

---@private
---恢复点击
function ErrandSystem:_EnableTouch()
    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "ErrandMgr_Enable_Touch_Auto", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.EnableTouch)
    GameHelper.SetTouchBlockingForFrames(false)
    if self.autoEnableTouchTimer then
        TimerMgr.Discard(self.autoEnableTouchTimer)
        self.autoEnableTouchTimer = nil
    end
end
--endregion

--region simAdd
---@param simulationErrandQueue ErrandDetail[]
function ErrandSystem:_InitSimulateQueue(typeID, simulationErrandQueue)
    local cfg = LuaCfgMgr.Get("Popup", typeID)
    if typeID == nil or cfg == nil then
        Debug.LogErrorWithTag(GameConst.LogTag.ErrandMgr, "模拟加入的事务类型不存在")
        return false
    end

    if self.isFreezeShow then
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "模拟，=======队列现在是冻结状态=========")
    end

    for i = 1, #self.errandQueue do
        table.insert(simulationErrandQueue, i, self.errandQueue[i])
    end

    ---@type ErrandDetail
    local detail = PoolUtil.GetTable()
    detail.type = typeID
    detail.uid = self.nextUid

    if cfg.QueueBlackList ~= nil and self:_InList(cfg.QueueBlackList, cfg.QueueBlackListType) then
        Debug.LogErrorWithTag(GameConst.LogTag.ErrandMgr, "模拟加入队列，失败，因为队列黑名单")
        return false
    end

    local insertPos = 1

    for i = #simulationErrandQueue, 1, -1 do
        local curCfg = LuaCfgMgr.Get("Popup", simulationErrandQueue[i].type)
        if cfg.Priority <= curCfg.Priority then
            insertPos = i + 1
            break
        end
    end

    table.insert(simulationErrandQueue, insertPos, detail)
    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "模拟，添加事务成功==", cfg.InterfaceName)

    if Debug.IsEnabled() then
        local listString = "模拟，simulationErrandQueue"
        for i = 1, #simulationErrandQueue do
            local curCfg = LuaCfgMgr.Get("Popup", simulationErrandQueue[i].type)
            listString = string.concat(listString, "|", curCfg.InterfaceName)
        end
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, listString)
    end
    return true
end

---@public
---模拟加入事务，返回能否立即触发
---@param typeID number 事务类型的ID或Key
---@return bool 模拟加入后，本次是否触发
function ErrandSystem:SimulationAddCanPop(typeID)
    if not self.isInit then
        return
    end

    ---@type ErrandDetail[]
    local simulationErrandQueue = PoolUtil.GetTable()

    local simulationMonopolizeOpen = self.isMonopolizeOpen
    if self:_InitSimulateQueue(typeID, simulationErrandQueue) then
        local hasPop = false
        for i = 1, #simulationErrandQueue do
            local temp = simulationErrandQueue[i]
            local cfg = LuaCfgMgr.Get("Popup", temp.type)
            if self.executingDict[temp.type] == nil and not self:_IsQueueBlocked(cfg.CommonQueue) then
                if cfg.QueueBlackList ~= nil and self:_InList(cfg.QueueBlackList, cfg.QueueBlackListType) then
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("模拟，队列黑名单原因==%s==被移出队列", cfg.InterfaceName))
                elseif (cfg.Monopolize == 0 or simulationMonopolizeOpen == false) and self:_CanShow(cfg) then
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("模拟，出队列的事务name:%s", cfg.InterfaceName))
                    hasPop = true
                    simulationMonopolizeOpen = simulationMonopolizeOpen or cfg.Monopolize == 1
                    if temp.uid == self.nextUid then
                        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "模拟,目标界面可触发，中断模拟")
                        return true
                    end
                else
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("模拟，延迟黑白名单或独占原因==%s==无法触发", cfg.InterfaceName))
                end
            end
        end
        if not hasPop then
            Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "模拟，本次模拟没有触发")
        end
    end

    return false
end
--endregion

--region ui or scene change
function ErrandSystem:_OnWndFocus(data)
    --.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByWndFocus", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "WndFocus")
    self:_MarkForShowCheck()
end

function ErrandSystem:_OnWndOpen(data)
    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByWndOpen", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "WndOpen")
    self:_MarkForShowCheck()
end

---@private
---主界面分页切换时
function ErrandSystem:_OnMainHomeViewSwitch(viewTag)
    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByWndMainHomeSwitch", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "MainHomeSwitch")
    self:_MarkForShowCheck()
end

---@private
---UI关闭时
function ErrandSystem:_OnWndClose(data)
    for k, v in pairs(self.executingDict) do
        local cfg = LuaCfgMgr.Get("Popup", k)
        if #v > 0 and cfg and cfg.InterfaceName == data.ViewTag then
            if cfg.Monopolize == 1 then
                self.isMonopolizeOpen = false
                self.monopolizeWndName = nil
                Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "界面关闭，关闭互斥==", cfg.InterfaceName)
            end

            local detail = table.remove(v, #v)

            if #v == 0 then
                self.executingDict[k] = nil
            end

            self:_RemoveBlockQueue(cfg)

            self:_AddDebugInfo(detail.uid, detail.type, ErrandConst.OperationType.End, detail.isCloseByMgr and "管理器关闭")
            if detail.isCloseByMgr == true and cfg.InOrOutDelayWindowClose == 2 then
                self:Add(k, detail.params)
            end
            break
        end
    end

    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByWndClose", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "WndClose")
    self:_MarkForShowCheck()
end

---UI隐藏时
function ErrandSystem:_OnWndHide(data)
    for k, v in pairs(self.executingDict) do
        local cfg = LuaCfgMgr.Get("Popup", k)
        if cfg.InterfaceName == data.ViewTag then
            if cfg.Monopolize == 1 then
                self.isMonopolizeOpen = false
                self.monopolizeWndName = nil
                Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "界面隐藏，关闭互斥==", cfg.InterfaceName)
            end
            self:_RemoveBlockQueue(cfg)
            break
        end
    end

    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByWndHide", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "WndHide")
    self:_MarkForShowCheck()
end

---UI显示时
function ErrandSystem:_OnWndShow(data)
    for k, v in pairs(self.executingDict) do
        local cfg = LuaCfgMgr.Get("Popup", k)
        if cfg.InterfaceName == data.ViewTag then
            if cfg.Monopolize == 1 then
                self.isMonopolizeOpen = true
                self.monopolizeWndName = cfg.InterfaceName
                Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "界面显示，开启互斥==", cfg.InterfaceName)
            end
            self:_InsertBlockQueue(cfg)
            break
        end
    end

    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckByWndShow", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "WndShow")
    self:_MarkForShowCheck()
end

---@private
---场景切换时
function ErrandSystem:_OnSceneLoad()
    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "MarkNeedCheckSceneClear", TimerMgr.GetFrameCount())
    self:_AddDebugInfo(0, 0, ErrandConst.OperationType.MarkForCheck, "SceneClea")
    self.needCheckSceneClear = true
end
--endregion

--region msg
function ErrandSystem:_OnMsgSendBegin(msg)
    if ErrandConst.RequestDic[msg] then
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "msg lock Errand,key is==", msg)
        self:SetDelay(true, msg)
    end
end

function ErrandSystem:_OnMsgErr(msg)
    if ErrandConst.ErrDic[msg] then
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "err msg unlock Errand,key is==", msg)
        self:SetDelay(false, msg)
    end
end
--endregion

function ErrandSystem:_MarkForShowCheck()
    self.needCheckShow = true
    self:_DisableTouch()
end

function ErrandSystem:LateUpdate()
    if not self.isInit then
        return
    end

    if #self.clearList > 0 then
        self:_ClearByUser()
    end

    if self.needCheckSceneClear then
        self:_ClearByScene()
    end

    if self.needCheckShow then
        self:_CheckShow()
    end

    table.clear(self.clearList)
    self.needCheckSceneClear = false
    self.needCheckShow = false
end

function ErrandSystem:_ClearByUser()
    for i = 1, #self.clearList do
        local delList = PoolUtil.GetTable()
        local clearTypeId = self.clearList[i]
        local cfg = LuaCfgMgr.Get("Popup", clearTypeId)

        if cfg ~= nil then
            for i = 1, #self.errandQueue do
                if self.errandQueue[i].type == clearTypeId then
                    table.insert(delList, #delList + 1, i)
                end
            end

            for i = #delList, 1, -1 do
                local detail = table.remove(self.errandQueue, delList[i])
                self:_AddDebugInfo(detail.uid, detail.type, ErrandConst.OperationType.Clear, "外部调用")
                PoolUtil.ReleaseTable(detail)
            end
        end
        PoolUtil.ReleaseTable(delList)
    end
end

function ErrandSystem:_ClearByScene()
    for k, v in pairs(self.executingDict) do
        local cfg = LuaCfgMgr.Get("Popup", k)
        local lastErr = v[#v]
        if cfg.SceneClear == 1 and self:_CheckIsVisible(lastErr) then
            if not lastErr.isOpenByCallBack then
                if UIMgr.IsVisible(cfg.InterfaceName) then
                    lastErr.isCloseByMgr = true
                    UIMgr.Close(cfg.InterfaceName)
                end
            elseif lastErr.endFunc then
                lastErr.isCloseByMgr = true
                lastErr.endFunc()
                self:End(k, true)
            end
        end
    end

    local delList = PoolUtil.GetTable()

    for i = 1, #self.errandQueue do
        local cfg = LuaCfgMgr.Get("Popup", self.errandQueue[i].type)
        if cfg.SceneClearQueue == 1 then
            table.insert(delList, #delList + 1, i)
        end
    end

    for i = #delList, 1, -1 do
        local detail = table.remove(self.errandQueue, delList[i])
        self:_AddDebugInfo(detail.uid, detail.type, ErrandConst.OperationType.Clear, "场景切换")
        PoolUtil.ReleaseTable(detail)
    end

    PoolUtil.ReleaseTable(delList)
end

function ErrandSystem:_CheckShow()
    self:_CheckClose()

    if UIMgr.IsFocused(UIConf.MainHomeWnd) and BllMgr.GetMainHomeBLL():GetCurViewType() == ErrandConst.MainHomeViewTag.MainHome then
        self:SetDelay(false, "MainHomeFocus")
    end
    if not self.isFreezeShow then
        if self:_Show() then
            self:_DisableTouch(1)
        else
            self:_EnableTouch()
        end
    else
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "队列触发冻结中，无法触发")
        self:_AddDebugInfo(0, 0, ErrandConst.OperationType.TryExecute, "队列触发冻结中，无法触发")
    end
end

function ErrandSystem:_CheckClose()
    for k, v in pairs(self.executingDict) do
        local cfg = LuaCfgMgr.Get("Popup", k)
        if cfg.QueueBlackList ~= nil and ErrandSystem:_InList(cfg.QueueBlackList, cfg.QueueBlackListType) or
                cfg.InOrOutDelayWindowClose ~= 0 and not ErrandSystem:_CanShow(cfg) then
            local lastErr = v[#v]
            if not v.isOpenByCallBack then
                if not lastErr.isOpenByCallBack then
                    if UIMgr.IsVisible(cfg.InterfaceName) then
                        lastErr.isCloseByMgr = true
                        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "开启黑名单界面，关闭==", cfg.InterfaceName)
                        UIMgr.Close(cfg.InterfaceName)
                    end
                elseif lastErr.endFunc then
                    lastErr.isCloseByMgr = true
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "开启黑名单界面，关闭==", cfg.InterfaceName)
                    lastErr.endFunc()
                    self:End(k)
                end
            end
        end
    end
end

function ErrandSystem:_Show()
    if #self.errandQueue == 0 then
        --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "等待队列为空")
        return
    end

    if Debug.IsEnabled() then
        local listString = "Queue"
        for i = 1, #self.errandQueue do
            local cfg = LuaCfgMgr.Get("Popup", self.errandQueue[i].type)
            listString = string.concat(listString, "|", cfg.InterfaceName)
        end
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, listString)
    end

    local popWnd = false
    local delList = PoolUtil.GetTable()
    --Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "开始检查")
    for i = 1, #self.errandQueue do
        local temp = self.errandQueue[i]
        local cfg = LuaCfgMgr.Get("Popup", temp.type)
        if not self:_CheckIsVisible(temp) and not self:_IsQueueBlocked(cfg.CommonQueue) then
            ---界面没打开，且没被其他界面阻塞
            if cfg.QueueBlackList ~= nil and self:_InList(cfg.QueueBlackList, cfg.QueueBlackListType) then
                ---队列黑名单不为空，且有黑名单界面打开，需要清除自身（不触发）
                table.insert(delList, #delList + 1, i)
                self:_AddDebugInfo(temp.uid, temp.type, ErrandConst.OperationType.Clear, "因为黑名单界面已打开，事务清理出队列")
                Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("因为黑名单界面已打开，事务==%s==清理出队列，队列黑名单为==%s", cfg.InterfaceName, cfg.QueueBlackList))
            elseif (cfg.Monopolize == 0 or self.isMonopolizeOpen == false) and self:_CanShow(cfg) then
                Debug.LogWithTag(GameConst.LogTag.ErrandMgr, string.format("出队列的事务name:%s", cfg.InterfaceName))
                if self.executingDict[temp.type] == nil then
                    self.executingDict[temp.type] = {}
                end

                ---@type ExecutingInfo
                local info = {}
                info.uid = temp.uid
                info.type = temp.type
                info.isCloseByMgr = false
                info.params = temp.params
                info.startFunc = temp.startFunc
                info.endFunc = temp.endFunc

                table.insert(self.executingDict[temp.type], info)

                self:_InsertBlockQueue(cfg)

                self.isMonopolizeOpen = self.isMonopolizeOpen or cfg.Monopolize == 1
                if cfg.Monopolize == 1 then
                    self.monopolizeWndName = cfg.InterfaceName
                end

                self:_AddDebugInfo(temp.uid, temp.type, ErrandConst.OperationType.Execute)
                if temp.startFunc ~= nil then
                    temp.startFunc()
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "CallBack InterfaceName==", cfg.InterfaceName)
                else
                    UIMgr.Open(cfg.InterfaceName, temp.params)
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "openUI==", cfg.InterfaceName)
                end
                popWnd = true
                table.insert(delList, #delList + 1, i)
            else
                if self.isMonopolizeOpen and (cfg.Monopolize == 1 or cfg.Monopolize == 2) then
                    local info = string.format("界面%s独占打开,导致事务%s未触发==", self.monopolizeWndName, cfg.InterfaceName)
                    self:_AddDebugInfo(temp.uid, temp.type, ErrandConst.OperationType.TryExecute, info)
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, info)
                else
                    local info = string.format("事务==%s未满足白名单和黑名单条件==", cfg.InterfaceName)
                    self:_AddDebugInfo(temp.uid, temp.type, ErrandConst.OperationType.TryExecute, info)
                    Debug.LogWithTag(GameConst.LogTag.ErrandMgr, info)
                end
            end
        elseif self:_IsDebugEnable() then
            if self:_CheckIsVisible(temp) then
                self:_AddDebugInfo(temp.uid, temp.type, ErrandConst.OperationType.TryExecute, "当前类型正在执行中")
            elseif self:_IsQueueBlocked(cfg.CommonQueue) then
                self:_AddDebugInfo(temp.uid, temp.type, ErrandConst.OperationType.TryExecute, "队列阻塞")
            end
        end
    end

    for i = #delList, 1, -1 do
        local cfg = LuaCfgMgr.Get("Popup", self.errandQueue[i].type)
        Debug.LogWithTag(GameConst.LogTag.ErrandMgr, "需要移出队列的界面有==", cfg.InterfaceName)
        PoolUtil.ReleaseTable(table.remove(self.errandQueue, delList[i]))
    end
    PoolUtil.ReleaseTable(delList)
    return popWnd
end

function ErrandSystem:_RegisterEvent()
    EventMgr.AddListener(Const.Event.GLOBAL_UIVIEW_ON_FOCUS, self._CheckShow, self)
    EventMgr.AddListener(Const.Event.GLOBAL_UIVIEW_ON_OPEN, self._CheckShow, self)
    EventMgr.AddListener(Const.Event.GLOBAL_UIVIEW_ON_CLOSE, self._OnWndClose, self)
    EventMgr.AddListener(Const.Event.GLOBAL_UIVIEW_ON_HIDE, self._OnWndHide, self)
    EventMgr.AddListener(Const.Event.GLOBAL_UIVIEW_ON_SHOW, self._OnWndShow, self)
    EventMgr.AddListener(Const.Event.SCENE_LOADED, self._OnSceneLoad, self)
    EventMgr.AddListener(ErrandConst.ERRAND_DELAY_OPEN, self._DelayOpen, self)
    EventMgr.AddListener(ErrandConst.ERRAND_DELAY_CLOSE, self._DelayClose, self)
    EventMgr.AddListener(ErrandConst.ERRAND_MAIN_HOME_VIEW_SWITCH, self._OnMainHomeViewSwitch, self)

    EventMgr.AddListener(GrpcMgr.EVENT_SEND_MSG_BEGIN, self._OnMsgSendBegin, self)
    EventMgr.AddListener(GrpcMgr.Event_SendMsg_Error, self._OnMsgErr, self)
    for msg, _ in pairs(ErrandConst.ReplyDic) do
        EventMgr.AddListener(msg, self._DelayClose, self)
    end
end

function ErrandSystem:Clear()
    self.errandQueue = nil
    self.executingDict = nil
    self.isMonopolizeOpen = false
    self.monopolizeWndName = nil
    self.debugInfoList = nil
    self.debugMap = nil
    self.isFreezeShow = false
    self.blockQueueDict = nil
    self.clearList = nil

    self.needCheckShow = false
    self.needCheckSceneClear = false

    self.nextUid = 1
    self.autoEnableTouchTimer = nil
    self.isInit = false
    EventMgr.RemoveListenerByTarget(self)
end

function ErrandSystem:Destroy()
    self.debugInfoList = {}
    self.debugMap = {}
    if UNITY_EDITOR then
        CS.X3GameEditor.ErrandSystemEditorHelper.GetDebugInfo = nil
        CS.X3GameEditor.ErrandSystemEditorHelper.GetDebugMap = nil
        CS.X3GameEditor.ErrandSystemEditorHelper.ClearDebugInfo = nil
    end
end

return ErrandSystem