---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by fusu.
--- DateTime: 2023/4/4 19:58
---

local AccompanyConst = require("Runtime.System.X3Game.Modules.Accompany.Data.AccompanyConst")
local AccompanyBaseCtrl = require("Runtime.System.X3Game.Modules.Accompany.Controller.AccompanyBaseCtrl")
---@class AccompanyDialogueCtrl:AccompanyBaseCtrl 剧情控制
local AccompanyDialogueCtrl = class("AccompanyDialogueCtrl", AccompanyBaseCtrl)

function AccompanyDialogueCtrl:Init()
    ---Dialogue播放队列
    ---@type table
    self._dialogueQueue = {}
    
    ---@type int
    self.assetId = self.accMgr.accBll:GetCurAssetId()
    
    ---表演Actor
    ---@type GameObject
    self.actor = nil
    
    ---@type DialogueController
    self.dialogueCtrl = DialogueManager.InitByName(AccompanyConst.AccompanyDialogue)
    self.dialogueCtrl:GetSettingData():SetShowReviewButton(false)
    self.dialogueCtrl:GetSettingData():SetShowPauseButton(false)
    self.dialogueCtrl:GetSettingData():SetShowAutoButton(false)
    self.dialogueCtrl:SetDialogueUseDefaultSetting(true)

    local timeType = SelfProxyFactory.GetMainInteractProxy():GetSceneTimeType()
    self.dialogueCtrl:ChangeVariableState(2 , timeType)
end

function AccompanyDialogueCtrl:OnDestroy()
    AccompanyDialogueCtrl.super.OnDestroy(self)
    self.dialogueCtrl:EndDialogue()
    self.dialogueCtrl:ClearDialogueAll()
    CutSceneMgr.RemoveAssetInsPermanently(self.actor)
    self.assetId = nil
    self.actor = nil
    self.dialogueCtrl = nil
    self._dialogueQueue = nil
end

---设置剧情主角
---@param actor GameObject
function AccompanyDialogueCtrl:SetDialogueActor(actor)
    if self.actor ~= nil and self.actor ~= actor then
        self.dialogueCtrl:RemoveGameObject(self.assetId , actor)
    end
    self.actor = actor
    self.dialogueCtrl:InjectGameObject(self.assetId , actor)
    CutSceneMgr.InjectAssetInsPermanently(tostring(self.assetId), actor)
end


---@param conversationName string 剧情Name
---@param dialogueIdType int 剧情Id类型
---@param pipeLineKey string Pipeline指定Key
---@param stateKey string 剧情state名
---@param onPlayComplete function 回调函数
function AccompanyDialogueCtrl:StartDialogueByQueue(conversationName , dialogueIdType , pipeLineKey , stateKey, onPlayComplete)
    if not string.isnilorempty(stateKey) then
        local queueLength = #self._dialogueQueue

        local dialogueInfo = {}
        dialogueInfo.conversationName =conversationName
        dialogueInfo.dialogueIdType = dialogueIdType
        dialogueInfo.pipeLineKey = pipeLineKey
        dialogueInfo.stateKey = stateKey
        dialogueInfo.onPlayComplete = onPlayComplete
        dialogueInfo.isPlaying = false

        if queueLength <= 0 then
            self._dialogueQueue[#self._dialogueQueue + 1] = dialogueInfo
        else
            local lastDialogueInfo = self._dialogueQueue[#self._dialogueQueue]
            local lastStateConf = LuaCfgMgr.Get("AccompanyDialogueState", lastDialogueInfo.stateKey)
            if lastStateConf[stateKey]  == 1 then ---排队
                self._dialogueQueue[#self._dialogueQueue + 1] = dialogueInfo
            elseif lastStateConf[stateKey]  == 2 then ---丢弃
                dialogueInfo = nil
            elseif lastStateConf[stateKey]  == 3 then ---打断
                local firstDialogue = self._dialogueQueue[1]
                if firstDialogue.isPlaying == true then
                    self:StopDialogueByPipelineKey(firstDialogue.firstDialogue)
                end
                self._dialogueQueue[#self._dialogueQueue] = dialogueInfo
            end
        end
        local firstDialogue = self._dialogueQueue[1]
        if firstDialogue and firstDialogue.isPlaying == false then
            firstDialogue.isPlaying = true
            self:StartDialogueByName(firstDialogue.conversationName , firstDialogue.dialogueIdType , firstDialogue.pipeLineKey , function()
                table.remove(self._dialogueQueue , 1)
                if firstDialogue.onPlayComplete then
                    firstDialogue.onPlayComplete()
                end
            end)
        end
    end
end


---@param conversationName string 剧情Name
---@param dialogueIdType int 剧情Id类型
---@param pipeLineKey string Pipeline指定Key
---@param onPlayComplete function 回调函数
function AccompanyDialogueCtrl:StartDialogueByName(conversationName , dialogueIdType , pipeLineKey , onPlayComplete)
    local dialogueId = self.accMgr.accBll:GetDialogueId(dialogueIdType)

    if pipeLineKey == nil then
        pipeLineKey = AccompanyConst.AccompanyDialoguePipeLineKey
    end

    if self.dialogueCtrl:DialogueInited(dialogueId) == false then
        self.dialogueCtrl:InitDialogue(dialogueId)
    end
    
    self.dialogueCtrl:StartDialogueByName(dialogueId , conversationName , nil , pipeLineKey , function()
        if onPlayComplete then
            onPlayComplete()
        end
    end)
end

---停止剧情
---@param pipeLineKey string 
function AccompanyDialogueCtrl:StopDialogueByPipelineKey(pipeLineKey)
    if pipeLineKey == nil or self.dialogueCtrl == nil then
        return
    end
    self.dialogueCtrl:StopPipeline(pipeLineKey)
end

---设置剧情公共变量
---@param key int
---@param key int
function AccompanyDialogueCtrl:ChangeVariableState(key , value)
    self.dialogueCtrl:ChangeVariableState(key , value)
end

---获取剧情公共变量
---@return int
function AccompanyDialogueCtrl:GetVariableState(key)
    return self.dialogueCtrl:GetVariableState(key)
end

return AccompanyDialogueCtrl