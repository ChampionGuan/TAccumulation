---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by fusu.
--- DateTime: 2023/4/4 19:58
---

local AccompanyBaseCtrl = require("Runtime.System.X3Game.Modules.Accompany.Controller.AccompanyBaseCtrl")
local AccompanyConst = require("Runtime.System.X3Game.Modules.Accompany.Data.AccompanyConst")
---@class AccompanyActionCtrl:AccompanyBaseCtrl 所有的Action管理
local AccompanyActionCtrl = class("AccompanyActionCtrl", AccompanyBaseCtrl)

function AccompanyActionCtrl:Init()
    ---@type table<AccompanyConst.ActionType , Pool>
    self._actionPoolMap = PoolUtil.GetTable()
    ---@type table<AccompanyBaseAction>
    self._stateActionList = PoolUtil.GetTable()
    ---@type int
    self._curActionIndex = -1
    ---@type AccompanyConst.StateType
    self._curStateType = nil
    
    self:InitPool()
    
    EventMgr.AddListener(AccompanyConst.Event.ON_STATE_CHANGE , self._OnStateChanged , self)
    EventMgr.AddListener(AccompanyConst.Event.ON_ACTION_FINISH , self._OnActionFinished , self)
end

function AccompanyActionCtrl:OnDestroy()
    AccompanyActionCtrl.super.OnDestroy(self)
    for _, action in pairs(self._stateActionList) do
        self:ReleaseAction(action)
    end
    PoolUtil.ReleaseTable(self._stateActionList)
    self._stateActionList = nil
    
    for _, pool in pairs(self._actionPoolMap) do
        PoolUtil.Release(pool)
    end
    PoolUtil.ReleaseTable(self._actionPoolMap)
    self._actionPoolMap = nil
end

---初始化Action对象池
function AccompanyActionCtrl:InitPool()
    local createFunc = handler(self, self.OnCreateAction)
    local releaseFunc = handler(self, self.OnReleaseAction)
    for _, actionType in pairs(AccompanyConst.ActionType) do
        if not string.isnilorempty(actionType) then
            local pool = PoolUtil.Get(createFunc , releaseFunc)
            self._actionPoolMap[actionType] = pool
        end
    end
end

---根据类型创建Action
---@param actionType AccompanyConst.ActionType
function AccompanyActionCtrl:OnCreateAction(actionType)
    local actionPath = AccompanyConst.ActionPath[actionType]
    if string.isnilorempty(actionPath) then
        Debug.LogErrorFormat("AccompanyConst.ActionPath not has Path , actionType = %s" , actionType)
        return nil
    end
    local action = require(actionPath).new(actionType , self.accMgr)
    return action
end

---释放Action
---@param action AccompanyBaseAction
function AccompanyActionCtrl:OnReleaseAction(action)
    if action then
        action:OnDestroy()
    end
end

---获取Action
---@return AccompanyBaseAction action
function AccompanyActionCtrl:GetAction(actionType)
    local actionPool = self._actionPoolMap[actionType]
    if actionPool then
        local action = actionPool:Get(actionType)
        return action
    end
    return nil
end

---释放Action
---@param action AccompanyBaseAction
function AccompanyActionCtrl:ReleaseAction(action)
    local actionPool = self._actionPoolMap[action:GetActionType()]
    if actionPool then
        actionPool:Release(action)
    end
end

---状态改变事件处理
function AccompanyActionCtrl:_OnStateChanged(stateType)
    self._curStateType = stateType
    for _, action in ipairs(self._stateActionList) do
        self:ReleaseAction(action)
    end
    PoolUtil.ReleaseTable(self._stateActionList)
    self._stateActionList = PoolUtil.GetTable()
    local actionConfigList = AccompanyConst.ActionConfig[stateType]
    for index, config in ipairs(actionConfigList) do
        local actionType = config.ActionType
        local action = self:GetAction(actionType)
        action:Init(config.Param)
        action:SetActionCondition(config.ActionCondition)
        action:SetActionIndex(index)
        action:SetNextWaitFinish(config.NextWaitFinish)
        action:SetJumpCondition(config.JumpCondition)
        self._stateActionList[#self._stateActionList + 1] = action
    end
    self:_ExecuteStateAction(1)
end

---action完成回调
function AccompanyActionCtrl:_OnActionFinished(actionType, actionIndex)
    local curAction = self._stateActionList[actionIndex]
    if curAction and curAction:GetActionType() == actionType and curAction:GetNextWaitFinish() then
        local nextIndex = curAction:GetNextActionIndex()
        self:_ExecuteStateAction(nextIndex)
    end
end

---按序执行action
---@param actionIndex int
function AccompanyActionCtrl:_ExecuteStateAction(actionIndex)
    local curAction = self._stateActionList[actionIndex]
    if curAction then
        Debug.LogFormat("AccompanyAction Play CurActionIndex: %s , CurState: %s" , actionIndex , self._curStateType)
        curAction:Execute()
        if not curAction:GetNextWaitFinish() then
            local nextIndex = curAction:GetNextActionIndex()
            self:_ExecuteStateAction(nextIndex)
        end
    end
end

return AccompanyActionCtrl