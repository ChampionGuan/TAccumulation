---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by doudou.
--- DateTime: 2022/11/28 15:01
---@class PhoneMsgDetailSimulatorBase
local PhoneMsgDetailSimulatorBase = class("PhoneMsgDetailSimulatorBase")
local PhoneMsgHelper = require("Runtime.System.X3Game.Modules.PhoneMessage.PhoneMsgHelper")
local PhoneMsgConst = require("Runtime.System.X3Game.Modules.PhoneMessage.PhoneMsgConst")

function PhoneMsgDetailSimulatorBase:ctor()
    self.contactId = nil
    self.roleId = 0

    ---@type X3Data.PhoneMsgSimulatingData
    self.simData = nil
    ---@type X3Data.PhoneMsgConversationData
    self.curConvData = nil
    ---@type cfg.PhoneMsgConversation
    self.curCfg = nil

    self._startFunc = {
        [X3DataConst.PhoneMsgConversationStateType.Begin] = handler(self, self._StartBegin),
        [X3DataConst.PhoneMsgConversationStateType.Reading] = handler(self, self._StartReading),
        [X3DataConst.PhoneMsgConversationStateType.Input] = handler(self, self._StartInput),
        [X3DataConst.PhoneMsgConversationStateType.Execute] = handler(self, self._StartExecute),
        [X3DataConst.PhoneMsgConversationStateType.Finish] = handler(self, self._StartFinish),
    }

    self._onFunc = {
        [X3DataConst.PhoneMsgConversationStateType.Execute] = handler(self, self._OnExecute),
    }

    self._endFunc = {
        [X3DataConst.PhoneMsgConversationStateType.Execute] = handler(self, self._EndExecute),
    }

    self._specialExecuteFunc = {
        [X3_CFG_CONST.CONVERSATION_TYPE_CHOICE] = handler(self, self._WaitForInput),
        [X3_CFG_CONST.CONVERSATION_TYPE_CHOICE_AUTO] = handler(self, self._WaitForInput),
    }
    self._specialOnExecuteFunc = {}
    self._specialEndExecuteFunc = {}

    self.conversationCfgName = "PhoneMsgConversation"
    self.msgCfgName = "PhoneMsg"
    self.simUidOffset = 100
end

function PhoneMsgDetailSimulatorBase:SetContactId(contactId)
    self.contactId = contactId
    local cfg = LuaCfgMgr.Get("PhoneContact", contactId)
    self.roleId = cfg.Mantype
end

function PhoneMsgDetailSimulatorBase:GetCurrentMsgId()
    return self.simData and self.simData:GetGUID() or 0
end

function PhoneMsgDetailSimulatorBase:IsWaitingForFinish()
    return self.simData and self.simData:GetIsWaitingForFinish()
end

function PhoneMsgDetailSimulatorBase:FinishMsg()
    EventMgr.Dispatch(PhoneMsgConst.MessageUpdateEvent, self.contactId, self.simData:GetGUID(), nil, Define.PhoneMsgSimulationState.End)
    self:ReadAll(PhoneMsgConst.PlayerTellerId)
    self:_Clear()
end

function PhoneMsgDetailSimulatorBase:Update(curTime)
    if self.curConvData then
         if self.curConvData:GetFireTime() ~= 0 and self.curConvData:GetFireTime() < curTime then
            self:_MoveToNextState()
        end

        local onFunc = self._onFunc[self.curConvData:GetState()]
        if onFunc then
            onFunc()
        end
    end

    local recallMap = self.simData and self.simData:GetRecallMap()
    if recallMap then
        local removeTab = PoolUtil.GetTable()
        for k, v in pairs(recallMap) do
            if v < curTime then
                table.insert(removeTab, k)
                EventMgr.Dispatch(PhoneMsgConst.DrawMsgEvent, self.contactId, k)
            end
        end
        for i = 1, #removeTab do
            self.simData:RemoveRecallMapValue(removeTab[i])
        end

        PoolUtil.ReleaseTable(removeTab)
    end
end

---@return X3Data.PhoneMsgConversationData[]
function PhoneMsgDetailSimulatorBase:GetConversationList()
    local result = {}
    local history = self.simData and self.simData:GetHistory()
    local msgId = self.simData and self.simData:GetGUID()

    if history and #history > 0 then
        for i = 1, #history - 1 do
            table.insert(result, PhoneMsgHelper.GetConverId(msgId, history[i]))
        end
        local lastUid = history[#history]
        local lastDetail = X3DataMgr.Get(X3DataConst.X3Data.PhoneMsgConversationData, lastUid)
        if lastDetail ~= nil then
            if lastDetail and lastDetail:GetState() == X3DataConst.PhoneMsgConversationStateType.Execute
                    or lastDetail:GetState() == X3DataConst.PhoneMsgConversationStateType.Finish
                    or lastDetail:GetState() == X3DataConst.PhoneMsgConversationStateType.FakeFinish then
                table.insert(result, PhoneMsgHelper.GetConverId(msgId, lastUid))
            end
        else
            Debug.LogErrorFormatWithTag(GameConst.LogTag.PhoneMsg, "Invalid ConverId = %d, in msg = %d - %d", lastUid, self.simData:GetGUID(), self.simData:GetCfgId())
        end
    end
    return result
end

function PhoneMsgDetailSimulatorBase:UpdateMsg(convId)
    if self.curConvData and self.curConvData:GetState() == X3DataConst.PhoneMsgConversationStateType.Execute then
        self.curConvData:SetNextCfgId(convId)
        self:_MoveToNextState()
    end
end

function PhoneMsgDetailSimulatorBase:ReadAll(teller)

end

function PhoneMsgDetailSimulatorBase:ReadConversation(uid, teller)
end


function PhoneMsgDetailSimulatorBase:_InitSimData(msgId, cfgId)
    if self.simData == nil then
        self.simData = X3DataMgr.Add(X3DataConst.X3Data.PhoneMsgSimulatingData)
        self.simData:SetPrimaryValue(self.contactId * self.simUidOffset)
    end
    self.simData:SetGUID(msgId)
    self.simData:SetCfgId(cfgId)
end

function PhoneMsgDetailSimulatorBase:_StartMsg()
    if self.simData ~= nil then
        EventMgr.Dispatch(PhoneMsgConst.MessageUpdateEvent, self.contactId, self.simData:GetGUID(), nil, Define.PhoneMsgSimulationState.Start)
        self:_BeginConversation()
    end
end

function PhoneMsgDetailSimulatorBase:_MoveToNextState()
    local state = self.curConvData:GetState()

    if self._endFunc[state] then
        self._endFunc[state]()
    end

    if PhoneMsgConst.MsgLoop[state] then
        self._startFunc[PhoneMsgConst.MsgLoop[state]]()
    end
end

--region 状态机
function PhoneMsgDetailSimulatorBase:_StartBegin()
    self.curConvData:SetState(X3DataConst.PhoneMsgConversationStateType.Begin)

    self.simData:AddHistoryValue(self.curConvData:GetPrimaryValue())
    if self.curCfg.NextID then
        self.curConvData:SetNextCfgId(self:_GetNextCfgIdByHistory() or 0)
    end

    if self.curCfg.DelayTime > 0 then
        self.curConvData:SetFireTime(TimerMgr.RealtimeSinceStartup() + self.curCfg.DelayTime / 1000)
        EventMgr.Dispatch(PhoneMsgConst.MessageUpdateEvent, self.contactId, self.simData:GetGUID(), self.curConvData:GetCfgId(), Define.PhoneMsgSimulationState.Wating)
    else
        self:_MoveToNextState()
    end
end

function PhoneMsgDetailSimulatorBase:_StartReading()
    self.curConvData:SetState(X3DataConst.PhoneMsgConversationStateType.Reading)
    if self.curCfg.Teller ~= PhoneMsgConst.PlayerTellerId then
        self:ReadAll(self.curCfg.Teller)
    end

    EventMgr.Dispatch(PhoneMsgConst.MessageUpdateEvent, self.contactId, self.simData:GetGUID(), self.curConvData:GetCfgId(), Define.PhoneMsgSimulationState.Read)
    if self.curCfg.DelayTime > 0 then
        self.curConvData:SetFireTime(TimerMgr.RealtimeSinceStartup() + PhoneMsgConst.PhoneMsgReadDelayTime)
    else
        self:_MoveToNextState()
    end
end

function PhoneMsgDetailSimulatorBase:_StartInput()
    self.curConvData:SetState(X3DataConst.PhoneMsgConversationStateType.Input)
    if self.curCfg.Time > 0 then
        EventMgr.Dispatch(PhoneMsgConst.MessageUpdateEvent, self.contactId, self.simData:GetGUID(), self.curConvData:GetCfgId(), Define.PhoneMsgSimulationState.BeginInputing)
        self.curConvData:SetFireTime(TimerMgr.RealtimeSinceStartup() + self.curCfg.Time / 1000)
    else
        self:_MoveToNextState()
    end
end

function PhoneMsgDetailSimulatorBase:_StartExecute()
    self.curConvData:SetState(X3DataConst.PhoneMsgConversationStateType.Execute)
    local moveToNext = true
    if self._specialExecuteFunc[self.curCfg.Type] then
        self.curConvData:SetFireTime(0)
        moveToNext = self._specialExecuteFunc[self.curCfg.Type]()
    end

    EventMgr.Dispatch(PhoneMsgConst.MessageUpdateEvent, self.contactId, self.simData:GetGUID(), self.curConvData:GetCfgId(), Define.PhoneMsgSimulationState.Executing)
    if moveToNext then
        self:_MoveToNextState()
    end
end

function PhoneMsgDetailSimulatorBase:_OnExecute()
    if self._specialOnExecuteFunc[self.curCfg.Type] then
        self._specialOnExecuteFunc[self.curCfg.Type]()
    end
end

function PhoneMsgDetailSimulatorBase:_EndExecute()
    if self._specialEndExecuteFunc[self.curCfg.Type] then
        self._specialEndExecuteFunc[self.curCfg.Type]()
    end
end

function PhoneMsgDetailSimulatorBase:_StartFinish()
    self.curConvData:SetState(X3DataConst.PhoneMsgConversationStateType.Finish)
    self.curConvData:SetFireTime(0)
    local isFinish = self:_CheckIsFinish(self.curConvData:GetNextCfgId())

    self:_OnConvFinish()
    EventMgr.Dispatch(PhoneMsgConst.MessageUpdateEvent, self.contactId, self.simData:GetGUID(), self.curConvData:GetCfgId(), Define.PhoneMsgSimulationState.Finish)

    if not isFinish then
        self:_EnterNextConversation(self.curConvData:GetNextCfgId())
    end
end

function PhoneMsgDetailSimulatorBase:_OnConvFinish()

end
--endregion

--region execute
function PhoneMsgDetailSimulatorBase:_WaitForInput()

end

function PhoneMsgDetailSimulatorBase:_Recall()
    self.simData:AddOrUpdateRecallMapValue(self.curCfg.ID, TimerMgr.RealtimeSinceStartup() + self.curCfg.RecallTime / 1000)
    return true
end
--endregion

function PhoneMsgDetailSimulatorBase:_Clear()
    if self.simData then
        PhoneMsgHelper.ReleaseHistoryByUidList(self.contactId, self.simData:GetHistory())
        ---撤回不清空
        self.simData:SetGUID(0)
        self.simData:SetCfgId(0)
        self.simData:ClearHistoryValue()
        self.simData:ClearRewardMapValue()
        self.simData:ClearRedPacketMapValue()
        self.simData:ClearUnreadListValue()
        self.simData:SetIsWaitingForFinish(false)
        self.simData:SetLastReadId(0)

        self.severData = nil
        self.curConvData = nil
        self.curCfg = nil
    end
end

function PhoneMsgDetailSimulatorBase:_GetNextCfgIdByHistory()
    local history = self.simData:GetHistory()

    if history ~= nil then
        for i = #history, 1, -1 do
            ---@type X3Data.PhoneMsgConversationData
            local historyInfo = X3DataMgr.Get(X3DataConst.X3Data.PhoneMsgConversationData, history[i])

            if historyInfo then
                ---@type cfg.PhoneMsgConversation
                local lastCfg = LuaCfgMgr.Get(self.conversationCfgName, historyInfo:GetCfgId())
                if lastCfg.NextID == nil then
                    return 0
                end

                if i == #history then
                    if PhoneMsgConst.ChoiceType[lastCfg.Type] then
                        local saveNext = PhoneMsgHelper.GetChoiceResult(lastCfg.ID, self.severData:GetChoiceList())
                        if saveNext then
                            return saveNext
                        end
                    end
                    if lastCfg.NextID[1] ~= -1 then
                        return lastCfg.NextID[1]
                    end
                end

                if lastCfg.NextID[1] ~= -1 and PhoneMsgConst.ChoiceType[lastCfg.Type] then
                    return lastCfg.NextID[1]
                end
            else
                break
            end
        end
        return 0
    end
end

function PhoneMsgDetailSimulatorBase:_BeginConversation()
    local nextId = self:_GetNextCfgIdByHistory() or PhoneMsgHelper.GetFirstConversationId(self.simData:GetCfgId(), self.contactId, self.msgCfgName)

    if not self:_CheckIsFinish(nextId) then
        self:_EnterNextConversation(nextId)
    end
end

function PhoneMsgDetailSimulatorBase:_CheckIsFinish(nextId)
    if nextId == 0 then
        self.simData:SetIsWaitingForFinish(true)
        return true
    end

    return false
end

function PhoneMsgDetailSimulatorBase:_EnterNextConversation(converId)
    ---@type cfg.PhoneMsgConversation
    local cfg = LuaCfgMgr.Get(self.conversationCfgName, converId)
    if cfg == nil then
        Debug.LogErrorFormatWithTag(GameConst.LogTag.PhoneMsg, "Invalid ConverId = %d in msgId = %d", converId, self.simData:GetGUID())
        return
    end

    local uid = PhoneMsgHelper.GetConverUid(self.simData:GetGUID(), converId)
    ---@type X3Data.PhoneMsgConversationData
    local convData =  X3DataMgr.Get(X3DataConst.X3Data.PhoneMsgConversationData, uid)
    if convData == nil then
        convData = X3DataMgr.Add(X3DataConst.X3Data.PhoneMsgConversationData)
        convData:SetPrimaryValue(uid)
        convData:SetCfgId(converId)
        convData:SetType(cfg.Type)
        if PhoneMsgConst.ContentConversationType[cfg.Type] then
            convData:SetReadState(X3DataConst.PhoneMsgConversationReadType.Unread)
        else
            convData:SetReadState(X3DataConst.PhoneMsgConversationReadType.Read)
        end
    end

    local rwdType = PhoneMsgHelper.GetRewardState(cfg)
    convData:SetRewardState(rwdType)

    self.curConvData = convData
    self.curCfg = cfg

    self:_StartBegin()
end

function PhoneMsgDetailSimulatorBase:OnClear()
    self.contactId = nil
    self.roleId = 0

    X3DataMgr.Release(self.simData)
    X3DataMgr.Release(self.curConvData)

    ---@type X3Data.PhoneMsgSimulatingData
    self.simData = nil
    ---@type X3Data.PhoneMsgConversationData
    self.curConvData = nil
    ---@type cfg.PhoneMsgConversation
    self.curCfg = nil
end

return PhoneMsgDetailSimulatorBase