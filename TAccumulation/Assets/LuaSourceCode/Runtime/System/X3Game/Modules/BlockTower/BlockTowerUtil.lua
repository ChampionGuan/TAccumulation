---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2022/6/20 17:30
---

---@class BlockTowerUtil
local BlockTowerUtil = class("BlockTowerUtil")
local CS_PhysicsUtil = CS.X3Game.BlockTowerPhysicsUtil

---复写块的物理参数
---@param go GameObject
---@param friction float 摩擦力
---@param bounciness float 弹力
function BlockTowerUtil.RewritePpMaterial(go, friction, bounciness)
    CS_PhysicsUtil.RewritePpMaterial(go, friction, bounciness)
end

---清除选中块的速度
---@parap go GameObject
function BlockTowerUtil.ClearVelocity(go)
    CS_PhysicsUtil.ClearVelocity(go)
end

---@return CS.UnityEngine.RaycastHit[]
function BlockTowerUtil.CheckColliderCastDistance(go, direction, distance)
    return CS_PhysicsUtil.CheckColliderCastDistance(go, direction, distance)
end

---@return CS.UnityEngine.Collider[]
function BlockTowerUtil.CheckColliderOverlap(go, offset)
    return CS_PhysicsUtil.CheckColliderOverlap(go, offset)
end

---@param ppScene CS.Framework.RigidBodyDynamics.PpPhysicsScene
---@param type BlockTowerConst.PpShapeType
---@param points Vector3[]
---@return CS.Framework.RigidBodyDynamics.PpIndex
function BlockTowerUtil.ConvertPointToGeometry(ppScene, type, points)
    return CS_PhysicsUtil.ConvertPointToGeometry(ppScene, type, points)
end

---@param ppScene CS.Framework.RigidBodyDynamics.PpPhysicsScene
---@param type BlockTowerConst.PpShapeType
---@param mesh CS.UnityEngine.Mesh
---@return CS.Framework.RigidBodyDynamics.PpIndex
function BlockTowerUtil.ConvertMeshToGeometry(ppScene, type, mesh)
    return CS_PhysicsUtil.ConvertMeshToGeometry(ppScene, type, mesh)
end

---@return CS.Framework.RigidBodyDynamics.PpRigidBody[]
function BlockTowerUtil.CreateBodyCollision()
    return CS_PhysicsUtil.CreateBodyCollision()
end

---@param transform Transform
---@param x float
---@param y float
---@param z float
---@return Vector3
function BlockTowerUtil.WorldToLocal(transform, x, y, z)
    return GameUtil.GetVector(CS_PhysicsUtil.WorldToLocal(transform, x, y, z))
end

---@param transform Transform
---@param x float
---@param y float
---@param z float
---@return Vector3
function BlockTowerUtil.LocalToWorld(transform, x, y, z)
    return GameUtil.GetVector(CS_PhysicsUtil.LocalToWorld(transform, x or 0, y or 0, z or 0))
end

---判断某一个块的中心店投影是否落在块范围内
---@param topBlock GameObject
---@param bottomBlock GameObject
---@param blockSize Vector3
---@return boolean
function BlockTowerUtil.IsBlockCenterOnTop(topBlock, bottomBlock, blockSize)
    local topPosition = GameObjectUtil.GetPosition(topBlock)
    local bottomPosition = GameObjectUtil.GetPosition(bottomBlock)
    local bottomRotation = GameObjectUtil.GetRotation(bottomBlock)

    local leftTopPos = Vector3.Temp(-blockSize.x / 2, 0, blockSize.z / 2)
    local leftBottomPos = Vector3.Temp(-blockSize.x / 2, 0, -blockSize.z / 2)
    local rightTopPos = Vector3.Temp(blockSize.x / 2, 0, blockSize.z / 2)
    local rightBottomPos = Vector3.Temp(blockSize.x / 2, 0, -blockSize.z / 2)

    leftTopPos = leftTopPos * bottomRotation + bottomPosition
    leftBottomPos = leftBottomPos * bottomRotation + bottomPosition
    rightTopPos = rightTopPos * bottomRotation + bottomPosition
    rightBottomPos = rightBottomPos * bottomRotation + bottomPosition

    local topCenter = Vector2.Temp(topPosition.x, topPosition.z)
    local p1 = Vector2.Temp(leftTopPos.x, leftTopPos.z)
    local p2 = Vector2.Temp(leftBottomPos.x, leftBottomPos.z)
    local p3 = Vector2.Temp(rightBottomPos.x, rightBottomPos.z)
    local p4 = Vector2.Temp(rightTopPos.x, rightTopPos.z)
    return BlockTowerUtil.IsPointInRectangle(topCenter, p1, p2, p3, p4)
end

---判断一个点的投影是否在矩形区域内
---@param point Vector2
---@param leftTop Vector2
---@param leftBottom Vector2
---@param rightBottom Vector2
---@param rightTop Vector2
---@return boolean
function BlockTowerUtil.IsPointInRectangle(point, leftTop, leftBottom, rightBottom, rightTop)
    return (BlockTowerUtil.GetCross(leftTop, leftBottom, point) * BlockTowerUtil.GetCross(rightBottom, rightTop, point) >= 0) and
            (BlockTowerUtil.GetCross(leftBottom, rightBottom, point) * BlockTowerUtil.GetCross(rightTop, leftTop, point) >= 0)
end

---
---@param p1 Vector2
---@param p2 Vector2
---@param p Vector2
function BlockTowerUtil.GetCross(p1, p2, p)
    return (p2.x - p1.x) * (p.y - p1.y) - (p.x - p1.x) * (p2.y - p1.y);
end

return BlockTowerUtil