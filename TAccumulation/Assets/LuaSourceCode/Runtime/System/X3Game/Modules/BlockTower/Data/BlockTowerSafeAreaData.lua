---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2022/6/22 20:30
---
---叠叠乐安全区数据
---@class BlockTowerSafeAreaData
local BlockTowerSafeAreaData = class("BlockTowerSafeAreaData")

---@param blockWidth float
---@param blockLength float
function BlockTowerSafeAreaData:ctor(blockWidth, blockLength)
    ---@type float
    self.blockWidth = blockWidth
    ---@type float
    self.blockLength = blockLength
    ---@type Vector3
    self.centerPos = Vector3.zero
    ---@type Vector3
    self.leftTopPos = Vector3.zero
    ---@type Vector3
    self.leftBottomPos = Vector3.zero
    ---@type Vector3
    self.rightTopPos = Vector3.zero
    ---@type Vector3
    self.rightBottomPos = Vector3.zero
    ---@type float
    self.areaWidth = 0
    ---@type float
    self.areaLength = 0
    ---@type Quaternion
    self.rotation = nil
end

---
---@param blockList BlockTowerBlockData[]
function BlockTowerSafeAreaData:Update(blockList)
    local deltaAngle = 0
    self.centerPos = Vector3.zero
    for _, blockData in ipairs(blockList) do
        local position = GameObjectUtil.GetPosition(blockData.blockGO)
        self.centerPos = self.centerPos + position
        local _, blockDeltaAngle, _ = GameObjectUtil.GetEulerAnglesXYZ(blockData.blockGO)
        deltaAngle = deltaAngle + self:StandardRotationY(blockDeltaAngle)
    end
    local blockCount = #blockList
    self.centerPos = self.centerPos / blockCount
    deltaAngle = deltaAngle / blockCount
    self.areaWidth = self.blockWidth * blockCount
    self.areaLength = self.blockLength

    self.leftTopPos = Vector3(-self.areaLength / 2, 0, self.areaWidth / 2);
    self.leftBottomPos = Vector3(-self.areaLength / 2, 0, -self.areaWidth / 2);
    self.rightTopPos = Vector3(self.areaLength / 2, 0, self.areaWidth / 2);
    self.rightBottomPos = Vector3(self.areaLength / 2, 0, -self.areaWidth / 2);

    self.rotation = Quaternion.Euler(0, deltaAngle, 0);
    self.leftTopPos = self.leftTopPos * self.rotation + self.centerPos;
    self.leftBottomPos = self.leftBottomPos * self.rotation + self.centerPos;
    self.rightTopPos = self.rightTopPos * self.rotation + self.centerPos;
    self.rightBottomPos = self.rightBottomPos * self.rotation + self.centerPos;
end

---@param rotationY float
function BlockTowerSafeAreaData:StandardRotationY(rotationY)
    while rotationY > 180 do
        rotationY = rotationY - 180
    end
    while rotationY < 0 do
        rotationY = rotationY + 180
    end
    if rotationY > 135 then
        return rotationY - 180
    else
        return rotationY
    end
end

---@param localPosition Vector3
---@return float
function BlockTowerSafeAreaData:DistanceToLeft(localPosition)
    return self:DistanceOfPointToVector(self.leftBottomPos, self.leftTopPos, localPosition)
end

---@param localPosition Vector3
---@return float
function BlockTowerSafeAreaData:DistanceToRight(localPosition)
    return self:DistanceOfPointToVector(self.rightBottomPos, self.rightTopPos, localPosition)
end

---@param lerp float
---@return Vector3
function BlockTowerSafeAreaData:GetRandomLocalPosFromLeftSide(lerp)
    return Vector3.Lerp(self.leftBottomPos, self.leftTopPos, lerp)
end

---@param lerp float
---@return Vector3
function BlockTowerSafeAreaData:GetRandomLocalPosFromRightSide(lerp)
    return Vector3.Lerp(self.rightBottomPos, self.rightTopPos, lerp)
end

---@param position Vector3
---@return Vector3
function BlockTowerSafeAreaData:GetNearestPutPosition(position)
    local distancetoLeft = self:DistanceToLeft(position)
    local distanceToRight = self:DistanceToRight(position)
    if distancetoLeft > distanceToRight then
        return position - self.rotation * Vector3(self.blockWidth * 1.1, 0, 0)
    else
        return position + self.rotation * Vector3(self.blockWidth * 1.1, 0, 0)
    end
end

---求点到直线的距离，采用数学公式Ax+By+C = 0; d = A*p.x + B * p.y + C / sqrt(A^2 + B ^ 2)
---A: y2 - y1
---B: x1 - x2
---C: x2 * y1 - x1 * y2
---此算法忽略掉三维向量的Y轴，只在XZ平面进行计算，适用于一般3D游戏。
---@param startPoint Vector3
---@param endPoint Vector3
---@param point Vector3
---@return float
function BlockTowerSafeAreaData:DistanceOfPointToVector(startPoint, endPoint, point)
    local A = endPoint.z - startPoint.z
    local B = startPoint.x - endPoint.x
    local C = endPoint.x * startPoint.z - startPoint.x * endPoint.z
    local denominator = math.sqrt((math.pow(A, 2) + math.pow(B, 2)))
    return math.abs(((A * point.x) + (B * point.z) + C) / denominator)
end

return BlockTowerSafeAreaData