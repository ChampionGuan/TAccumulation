---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2022/6/17 14:30
---
---@class BlockTowerGameController
local BlockTowerGameController = class("BlockTowerGameController")

---@type BlockTowerConst
local Const = require("Runtime.System.X3Game.Modules.BlockTower.BlockTowerConst")
---@type BlockTowerUtil
local BlockTowerUtil = require("Runtime.System.X3Game.Modules.BlockTower.BlockTowerUtil")

local CtrlType = GameObjClickUtil.CtrlType
local TouchType = GameObjClickUtil.TouchType

---@class BlockTowerRaycastData
---@field dragging int
---@field gameObject GameObject
---@field pointOnBody Vector3
---@field oriPosition Vector3
---@field oriArrowEndPos Vector3

---@class BlockTowerCfg
---@field cameraMoveSpeed Vector2 摄像机移动的速度
---@field cameraCancelSelectedDistance float 超过一定距离取消选择的摄像机高度
---@field z1Toz2ModeDistance float 超过一定距离取消选择的摄像机高度
---@field absorbSpeed float 摄像机吸附速度
---@field endTurnModeTime float 结束阶段平衡所需时间
---@field distanceMin float 摄像机最近距离
---@field distanceMax float 摄像机最远距离
---@field offsetY float 摄像机Y偏移
---@field endCameraRotateTime float 结束阶段摄像机转一圈的时间
---@field pushRange float 戳的粒度，对应MousePoint的位置
---@field pushTime float 戳的时间
---@field needBalanceTime float 需要平衡的时间

---@class BlockRoundResult
---@field fromLayerIndex int
---@field fromBlockIndex int
---@field isFailed boolean

---@class BlockCheckEventData
---@field result boolean
---@field canPutTop boolean
---@field isIn boolean

function BlockTowerGameController:ctor()
    ---@type BlockTowerGameData
    self.gameData = require("Runtime.System.X3Game.Modules.BlockTower.Data.BlockTowerGameData").new()
    ---@type BlockTowerRaycastData
    self.raycastData = {}
    ---@type BlockTowerCfg
    self.gameCfg = {
        cameraMoveSpeed = Vector2(1 / 10, 1 / 2000),
        cameraCancelSelectedDistance = 0.5,
        z1Toz2ModeDistance = 0.2,
        absorbSpeed = 0.3,
        endTurnModeTime = 2,
        distanceMin = 0.2,
        distanceMax = 1,
        offsetY = 0.08,
        endCameraRotateTime = 10,
        pushRange = 0.3,
        pushTime = 0.01,
        needBalanceTime = 1
    }
    ---@type cfg.BlockTowerDifficulty
    self.staticCfg = nil
    ---@type BlockRoundResult
    self.roundResult = {}
    ---@type BlockCheckEventData
    self.putCheckResult = {}

    ---@type BlockTowerArrowHelper
    self.arrowHelper = require("Runtime.System.X3Game.Modules.BlockTower.BlockTowerArrowHelper")
    ---@type BlockTowerPhysicsHelper
    self.physicsHelper = require("Runtime.System.X3Game.Modules.BlockTower.BlockTowerPhysicsHelper")
    ---@type BlockTowerCameraHelper
    self.cameraHelper = require("Runtime.System.X3Game.Modules.BlockTower.BlockTowerCameraHelper")
    ---@type InputComponent
    self.gestureCtrl = nil

    ---@type AITree
    self.aiBehaviorTree = nil
    ---@type GameObject
    self.blockTowerTable = nil
    ---@type GameObject
    self.plOutlineBlock = nil
    ---@type GameObject
    self.manOutlineBlock = nil
    ---@type GameObject
    self.putEnableBlock = nil
    ---@type GameObject
    self.putDisableBlock = nil
    ---@type Transform
    self.blockRoot = nil
    ---@type boolean
    self.isRunning = true
    ---@type GameObject[]
    self.autoDestroyPool = {}
    ---@type float
    self.curBalancedTime = 0
    ---@type float
    self.touchDownTime = 0
    ---@type Vector3
    self.pressedDownPos = Vector3.zero
    ---@type boolean
    self.fingerMoved = false
    ---@type float 上一次更新安全区的时间戳
    self.lastSafeAreaUpdatedTimestamp = 0
end

--region Get/Set
---@return BlockTowerGameData
function BlockTowerGameController:GetGameData()
    return self.gameData
end

---@return BlockTowerRaycastData
function BlockTowerGameController:GetRaycastData()
    return self.raycastData
end

---@return BlockTowerCfg
function BlockTowerGameController:GetGameCfg()
    return self.gameCfg
end

---获取游戏的基准坐标
---@return Vector3
function BlockTowerGameController:GetRootPosition()
    return GameObjectUtil.GetPosition(self.blockTowerTable)
end

---获取游戏的基准旋转
---@return Vector3
function BlockTowerGameController:GetRootEulerAngles()
    return GameObjectUtil.GetEulerAngles(self.blockTowerTable)
end

---@return Vector3
function BlockTowerGameController:GetBlockRootPosition()
    return GameObjectUtil.GetPosition(self.blockRoot)
end

---@return GameObject
function BlockTowerGameController:GetPlOutlineBlock()
    return self.plOutlineBlock
end

---@return GameObject
function BlockTowerGameController:GetManOutlineBlock()
    return self.manOutlineBlock
end
--endregion

---初始化逻辑
---@param cfg cfg.BlockTowerDifficulty
function BlockTowerGameController:InitGame(cfg)
    self.staticCfg = cfg
    self.gameData.manType = cfg.ManType
    self.gameData.layerForbidden = cfg.TopLayerForbid

    self.blockTowerTable = Res.LoadGameObject(cfg.Model, ResType.T_DatingItem)
    self.plOutlineBlock = Res.LoadGameObject(LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.BLOCKTOWERPLSELECTHINTPATH))
    self.manOutlineBlock = Res.LoadGameObject(LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.BLOCKTOWERMANSELECTHINTPATH))
    GameObjectUtil.SetParent(self.plOutlineBlock.transform, self.blockTowerTable.transform, false)
    GameObjectUtil.SetParent(self.manOutlineBlock.transform, self.blockTowerTable.transform, false)
    GameObjectUtil.SetActive(self.blockTowerTable, true)
    GameObjectUtil.SetPosition(self.blockTowerTable, cfg.Pos.X / 1000, cfg.Pos.Y / 1000, cfg.Pos.Z / 1000)
    GameObjectUtil.SetEulerAngles(self.blockTowerTable, cfg.Rot.X / 1000, cfg.Rot.Y / 1000, cfg.Rot.Z / 1000)

    local aiList = string.split(cfg.MaleAI, '|')
    local aiName = "ST_BlockTower_Stage1" --TODO 临时，目前3000条件检查过不去
    for i = 1, #aiList do
        local condition = string.split(aiList[i], '=')
        if ConditionCheckUtil.CheckConditionByCommonConditionGroupId(tonumber(condition[1])) then
            aiName = condition[2]
            break
        end
    end
    self:CreateAI(string.concat("Date.", aiName))

    self.arrowHelper:Init(self)
    self.physicsHelper:Init(self, self.blockTowerTable)
    self.cameraHelper:Init(self, self.blockTowerTable)
    self.blockRoot = GameObjectUtil.GetComponent(self.blockTowerTable, "CubeRoot", "Transform")
    self.putEnableBlock = GameObjectUtil.GetComponent(self.blockTowerTable, "PutEnableBlock", "GameObject")
    self.putDisableBlock = GameObjectUtil.GetComponent(self.blockTowerTable, "PutDisableBlock", "GameObject")

    self.gestureCtrl = GameObjClickUtil.Get(self.blockTowerTable)
    self.gestureCtrl:SetTouchBlockEnableByUI(TouchType.ON_TOUCH_CLICK | TouchType.ON_TOUCH_DOWN | TouchType.ON_DRAG | TouchType.ON_TOUCH_UP, true)
    self.gestureCtrl:SetDelegate(self)
    self.gestureCtrl:SetCtrlType(CtrlType.DRAG | CtrlType.CLICK | CtrlType.MOUSE_SCROLL)

    EventMgr.AddListener("ClickBlockTowerPut", self.PutBlock, self)

    GameHelper.SetMultiTouchEnable(true, GameConst.MultiTouchLockType.BlockTowerCamera)
end

---@param blockList pbcmessage.BlockTowerLayer[]
function BlockTowerGameController:CreateGame(blockList)
    self:ClearBlocks()
    local height = 0
    local width = 0
    for i = 0, #blockList - 1 do
        local layer = blockList[i + 1]
        for j = 0, #layer.BlockList - 1 do
            local blockTowerPool = LuaCfgMgr.Get("BlockTowerPool", layer.BlockList[j + 1].Id)
            local cube = Res.LoadGameObject(blockTowerPool.BlockPrefab, ResType.T_DatingItem)
            cube:SetActive(true)
            self.physicsHelper:AddRigidBody(cube)
            table.insert(self.autoDestroyPool, cube)
            local blockData = GameObjectCtrl.GetOrAddCtrl(cube, "Runtime.System.X3Game.Modules.BlockTower.Data.BlockTowerBlockData", self)
            blockData.blockId = layer.BlockList[j + 1].Id
            blockData.initLayer = i
            blockData.physicsLayer = i
            blockData.blockIndex = (i * 100 + j)
            blockData.blockGO = cube
            blockData.rigidBody = GameObjectUtil.GetComponent(cube, "", "PpRigidBody")
            if i == 0 then
                blockData.ignoreDrop = true
            end
            self.physicsHelper:RewritePpMaterial(cube, math.random(blockTowerPool.MinFriction, blockTowerPool.MaxFriction) / 100,
                    Mathf.RandomFloat(blockTowerPool.MaxBounciness, blockTowerPool.MinBounciness))

            if width == 0 and height == 0 then
                ---meshRender size 会随旋转 x,y,z改变
                local boxCollider = cube:GetComponentInChildren(typeof(CS.UnityEngine.BoxCollider))
                self.gameData.blockSize = boxCollider.size
                width = boxCollider.size.z
                height = boxCollider.size.y
            end
            GameObjectUtil.SetParent(cube.transform, self.blockRoot.transform, false)
            local cubeOffset = width / 50
            GameObjectUtil.SetLocalPosition(cube, (width + cubeOffset) * (j - 1) * (i % 2), (i + 1 / 2) * height, (width + cubeOffset) * (j - 1) * ((i + 1) % 2))
            GameObjectUtil.SetEulerAngles(cube, 0, 90 * (i % 2), 0)
            table.insert(self.gameData:GetLayer(i), blockData)
        end
    end
    self.gameData.curLayer = #blockList
    self.gameData.timeLimitFailed = false
    self.gameData.dropCount = 0

    self.curBalancedTime = 0

    self:RefreshPhysicsLayer()
    self.cameraHelper:CreateGame()
    GameObjectUtil.SetActive(self.putEnableBlock, false)
    GameObjectUtil.SetActive(self.putDisableBlock, false)
end

---
function BlockTowerGameController:ClearBlocks()
    for _, layer in pairs(self.gameData.logicLayerDict) do
        for _, block in pairs(layer) do
            self.physicsHelper:RemoveRigidBody(block.blockGO)
            Res.DiscardGameObject(block.blockGO)
        end
    end
    self.gameData:ClearBlocks()
end

---回合开始
function BlockTowerGameController:TurnStart()
    self.gameData.blockIsolated = false
    self.gestureCtrl:SetTouchEnable(true)
    self:SwitchToChooseMode()
end

---@param value GamePlayConst.GameMode
function BlockTowerGameController:SwitchPlayer(value)
    if value == GamePlayConst.GameMode.Player then
        self.gameData.layerAddForce = self.staticCfg.LayerAddForceToPL
        self:EndedAI()
    else
        self.gameData.layerAddForce = self.staticCfg.LayerAddForceToAI
        self:RestartAI()
    end
end

--region Update
function BlockTowerGameController:Update()
    if self.isRunning and self.gameData.blockTowerControlMode ~= Const.ControlMode.None then
        self:InternalUpdate()
        self.arrowHelper:Update()
        self.cameraHelper:Update()
        self:UpdateData()

        ---如果不行放在FixedUpdate里
        self.physicsHelper:Update()
        if self.gameData.selectedBlock ~= nil then
            local position = GameObjectUtil.GetPosition(self.gameData.selectedBlock)
            local rotation = GameObjectUtil.GetRotation(self.gameData.selectedBlock)
            if self.gameData.blockTowerControlMode == Const.ControlMode.Put then
                local position = GameObjectUtil.GetPosition(self.gameData.selectedBlock)
                position.y = position.y - self.gameData.blockSize.y * 2
                GameObjectUtil.SetPosition(self.putEnableBlock, position)
                GameObjectUtil.SetRotation(self.putEnableBlock, rotation)
                GameObjectUtil.SetPosition(self.putDisableBlock, position)
                GameObjectUtil.SetRotation(self.putDisableBlock, rotation)
            end
            GameObjectUtil.SetPosition(self.gameData.outlineBlock, position)
            GameObjectUtil.SetRotation(self.gameData.outlineBlock, rotation)
        end

        self:BlockMoveCheck()
        self:GameResultCheck()
    end
end

function BlockTowerGameController:FixedUpdate()
    if self.isRunning and self.gameData.blockTowerControlMode ~= Const.ControlMode.None then
        self.physicsHelper:FixedUpdate()
    end
end

---内部Update
function BlockTowerGameController:InternalUpdate()
    if self.gameData.blockTowerControlMode == Const.ControlMode.Choose then
        self:ChooseUpdate()
    elseif self.gameData.blockTowerControlMode == Const.ControlMode.SelectedSide then
        self:SelectedSideUpdate()
    elseif self.gameData.blockTowerControlMode == Const.ControlMode.Put then
        self:PutUpdate()
    elseif self.gameData.blockTowerControlMode == Const.ControlMode.PutEnd then
        self:PutEndUpdate()
    elseif self.gameData.blockTowerControlMode == Const.ControlMode.End then
        self:EndUpdate()
    end
end

---
function BlockTowerGameController:ChooseUpdate()
    if self.gameData:IsPlayerMode() == false then
        return
    end
    if self.gameData.clickedBlock ~= nil then
        if self:BlockCanSelect(self.gameData.clickedBlock) then
            self:SelectBlock(self.gameData.clickedBlock)
            if self.gameData:IsPlayerMode() then
                self.cameraHelper:TweenCameraTarget(GameObjectUtil.GetPositionXYZ(self.gameData.clickedBlock))
            end
            self:SelectBlockCpl()
        else
            UICommonUtil.ShowMessage(UITextHelper.GetUIText(UITextConst.UI_TEXT_6210, self.gameData.layerForbidden))
        end
        self.gameData.clickedBlock = nil
    end
end

---
function BlockTowerGameController:SelectedSideUpdate()
    if self.gameData:IsPlayerMode() == false then
        return
    end
    if self.gameData.clickedBlock ~= nil then
        if self:BlockCanSelect(self.gameData.clickedBlock) then
            self:UnselectBlock()
            self:SelectBlock(self.gameData.clickedBlock)
            if self.gameData:IsPlayerMode() then
                self.cameraHelper:TweenCameraTarget(GameObjectUtil.GetPositionXYZ(self.gameData.clickedBlock))
            end
            self:SelectBlockCpl()
        else
            UICommonUtil.ShowMessage(UITextHelper.GetUIText(UITextConst.UI_TEXT_6210, self.gameData.layerForbidden))
        end
        self.gameData.clickedBlock = nil
    end
end

---
function BlockTowerGameController:PutUpdate()
    local isIn = true
    local canPutTop = self.physicsHelper:CanPutTop()
    if self.gameData:IsPlayerMode() then
        local position = GameObjectUtil.GetPosition(self.gameData.selectedBlock)
        local tops = self.gameData:GetTopBlocks()
        local safeArea = nil
        if #tops == 1 then
            safeArea = self.gameData:GetSafeArea(self.gameData.curPhysicsLayer - 1)
        else
            safeArea = self.gameData:GetSafeArea(self.gameData.curPhysicsLayer)
        end

        local topCenter = Vector2(position.x, position.z)
        local p1 = Vector2(safeArea.leftTopPos.x, safeArea.leftTopPos.z)
        local p2 = Vector2(safeArea.leftBottomPos.x, safeArea.leftBottomPos.z)
        local p3 = Vector2(safeArea.rightBottomPos.x, safeArea.rightBottomPos.z)
        local p4 = Vector2(safeArea.rightTopPos.x, safeArea.rightTopPos.z)
        isIn = BlockTowerUtil.IsPointInRectangle(topCenter, p1, p2, p3, p4)
        local distance = Vector3.Distance(position, self.gameData.putPosition)
        if distance > safeArea.areaWidth * 2 and distance > safeArea.areaLength * 2 then
            GameObjectUtil.SetPosition(self.gameData.selectedBlock, self.gameData.putPosition)
            self.physicsHelper:ClearSelectedBlockVelocity()
            self:OnTouchUp(nil)
            UICommonUtil.ShowMessage(UITextHelper.GetUIText(UITextConst.UI_TEXT_6209))
        end
    end
    self.putCheckResult.canPutTop = canPutTop
    self.putCheckResult.isIn = isIn
    local topBlock = self.physicsHelper:GetTopCheckBlock()
    if topBlock ~= nil then
        if canPutTop and isIn then
            self.putCheckResult.result = true
            GameObjectUtil.SetActive(self.putEnableBlock, true)
            GameObjectUtil.SetActive(self.putDisableBlock, false)
        else
            self.putCheckResult.result = false
            GameObjectUtil.SetActive(self.putEnableBlock, false)
            GameObjectUtil.SetActive(self.putDisableBlock, true)
        end
    else
        if isIn then
            self.putCheckResult.result = true
            GameObjectUtil.SetActive(self.putEnableBlock, true)
            GameObjectUtil.SetActive(self.putDisableBlock, false)
        else
            self.putCheckResult.result = false
            GameObjectUtil.SetActive(self.putEnableBlock, false)
            GameObjectUtil.SetActive(self.putDisableBlock, true)
        end
    end
    self.gameData.showingAlert = not canPutTop
    EventMgr.Dispatch("BlockTowerPutCheckEvent", self.putCheckResult)
end

---
function BlockTowerGameController:PutEndUpdate()
    if self:IsAllBalanced() then
        self.curBalancedTime = self.curBalancedTime + TimerMgr.GetCurTickDelta()
        if self.curBalancedTime > self.gameCfg.needBalanceTime then
            self.curBalancedTime = 0
            self:SwitchMode(Const.ControlMode.None)
            EventMgr.Dispatch("BlockTowerPut", self.roundResult)
        end
    end
end

---
function BlockTowerGameController:EndUpdate()
    if self:IsAllBalanced() or TimerMgr.RealtimeSinceStartup() - self.endTimestamp >= self.gameCfg.endTurnModeTime then
        self:SwitchMode(Const.ControlMode.None)
        table.clear(self.roundResult)
        self.roundResult.isFailed = true
        EventMgr.Dispatch("BlockTowerPut", self.roundResult)
    end
end

---@return boolean
function BlockTowerGameController:IsAllBalanced()
    for _, layer in pairs(self.gameData.logicLayerDict) do
        for _, blockData in pairs(layer) do
            if blockData:IsBalanced() == false then
                return false
            end
        end
    end
    return true
end

---
function BlockTowerGameController:BlockMoveCheck()
    if self.gameData.blockTowerControlMode ~= Const.ControlMode.Put and self.gameData.selectedBlock ~= nil then
        local selectedBlockData = self.gameData:GetCurSelectBlockData()
        if selectedBlockData:IsBalanced() == false then
            self:SetBlockTowerMoved()
        end

        if self.gameData.blockIsolated then
            local topBlockData = self.gameData:GetTopBlocks()[1]
            if topBlockData:IsBalanced() then
                self.curBalancedTime = self.curBalancedTime + TimerMgr.GetCurTickDelta()
                if self.curBalancedTime >= self.gameCfg.needBalanceTime then
                    self.curBalancedTime = 0
                    self:SwitchToPutMode()
                    self.gameData.blockIsolated = false
                end
            end
        else
            local isIsolated = true
            local distanceHits = BlockTowerUtil.CheckColliderOverlap(self.gameData.selectedBlock,
                    Vector3(self.gameData.blockSize.z / 20, self.gameData.blockSize.z / 20, self.gameData.blockSize.z / 20))
            for i = 0, distanceHits.Length - 1 do
                local distanceHit = distanceHits[i]
                local blockData = self.gameData:GetBlockData(distanceHit.gameObject)
                if blockData ~= nil and distanceHit.gameObject ~= self.gameData.selectedBlock then
                    isIsolated = false
                end
            end

            if isIsolated then
                self.gameData.blockIsolated = true
                self:ClearPickEntity()
                self.gestureCtrl:SetTouchEnable(false)
                self.physicsHelper:DisableBlockPhysics()
            end
        end
    end
end

---游戏结束Check
function BlockTowerGameController:GameResultCheck()
    if self.gameData.dropCount > 0 or self.gameData.isTimeLimit then
        if self.gameData.blockTowerControlMode ~= Const.ControlMode.End and self.gameData.blockTowerControlMode ~= Const.ControlMode.None then
            self.gameData.clickedBlock = nil
            self:ClearPickEntity()
            if self.gameData.selectedBlock then
                self.physicsHelper:DropBlock()
            end
            GameObjectUtil.SetActive(self.putEnableBlock, false)
            GameObjectUtil.SetActive(self.putDisableBlock, false)
            self:UnselectBlock()
            self.endTimestamp = TimerMgr.RealtimeSinceStartup()
            self:SwitchMode(Const.ControlMode.End)
            self.gestureCtrl:SetTouchEnable(false)
            self.gameData.isTimeLimit = false
        end
    end
end

---@param blockGO GameObject
function BlockTowerGameController:SelectBlock(blockGO)
    self.physicsHelper:SelectBlock(blockGO)
end

---
function BlockTowerGameController:SelectBlockCpl()
    if self.gameData:IsPlayerMode() then
        self:SwitchMode(Const.ControlMode.SelectedSide)
    else
        if self:IsSideBlock(self.gameData.selectedBlock) then
            self:SwitchMode(Const.ControlMode.SelectedSide)
        else
            self:SwitchMode(Const.ControlMode.SelectedMid)
        end
    end
end

---@param blockGO GameObject
---@return boolean
function BlockTowerGameController:IsSideBlock(blockGO)
    return blockGO.blockType == Const.BlockType.Side
end

---
function BlockTowerGameController:UnselectBlock()
    if self.gameData.selectedBlock ~= nil then
        GameObjectUtil.SetActive(self.gameData.outlineBlock, false)
        self.gameData.outlineBlock = nil
        self.physicsHelper:UnselectBlock()
        local blockData = self.gameData:GetBlockData(self.gameData.selectedBlock)
        if blockData.initLayer ~= 0 then
            blockData.ignoreDrop = false
        end

        self.gameData.selectedBlock = nil
        if self.gameData:IsPlayerMode() then
            self.cameraHelper:SwitchCamera()
        end
    end
end

---
function BlockTowerGameController:ClickedBlock()
    if self.raycastData.dragging ~= 0 then
        self.gameData.clickedBlock = self.raycastData.gameObject
        self.physicsHelper:ClearRaycastData()
    end
end

---
function BlockTowerGameController:UpdateData()
    self:UpdateCubeData()
    self:UpdateLayerSafeArea()
end

---
function BlockTowerGameController:UpdateCubeData()
    for _, layer in pairs(self.gameData.logicLayerDict) do
        for _, blockData in pairs(layer) do
            local curPos = GameObjectUtil.GetPosition(blockData.blockGO)
            blockData.deltaPos = curPos - blockData.lastPos
            blockData.lastPos = curPos
        end
    end
end
--endregion

---
---@param mode BlockTowerConst.ControlMode
function BlockTowerGameController:SwitchMode(mode)
    if self.gameData.blockTowerControlMode == mode then
        return
    end
    self.gameData.blockTowerControlMode = mode
    self.cameraHelper:SwitchCamera()
    if mode == Const.ControlMode.Put then
        self:ClearPickEntity()
    end
    EventMgr.Dispatch("BlockTowerModeSwitched", mode)
    if mode ~= Const.ControlMode.End then
        self:UpdateLayerSafeArea()
    end
end

---
function BlockTowerGameController:SwitchToChooseMode()
    self:RefreshPhysicsLayer()
    self:SwitchMode(Const.ControlMode.Choose)
    self.cameraHelper:SetCameraCanControl(true)
end

---
function BlockTowerGameController:SwitchToPutMode()
    local topBlocks = self.gameData:GetTopBlocks()
    local nextLayer = self.gameData.curPhysicsLayer
    if #topBlocks > 1 then
        nextLayer = nextLayer + 1
    end
    local safeArea = self.gameData:GetSafeArea(nextLayer - 1)
    local rotation = Quaternion.AngleAxis(90, Vector3.up) * safeArea.rotation
    self.gameData.putRotation = rotation

    local defaultPutPosition = self:GetNearestEffectivePutPosition()
    defaultPutPosition.y = defaultPutPosition.y + self.gameData.blockSize.y * 3
    self.physicsHelper:ClearSelectedBlockVelocity()
    GameObjectUtil.SetPosition(self.gameData.selectedBlock, defaultPutPosition)
    GameObjectUtil.SetRotation(self.gameData.selectedBlock, rotation)
    self.gestureCtrl:SetTouchEnable(true)
    self.cameraHelper:SetCameraCanControl(true)
    self.gameData.putPosition = defaultPutPosition
    self:SwitchMode(Const.ControlMode.Put)
    if self.gameData:IsPlayerMode() then
        self.cameraHelper:TweenCameraTarget(defaultPutPosition.x, defaultPutPosition.y, defaultPutPosition.z)
    end
end

---是否是支撑块
---@param blockData BlockTowerBlockData
---@return boolean
function BlockTowerGameController:IsSupportBlock(blockData)
    local upBlocks = self.gameData:GetPhysicsLayer(blockData.physicsLayer + 1)
    if #upBlocks <= 0 then
        return false
    else
        for _, upBlock in ipairs(upBlocks) do
            if BlockTowerUtil.IsBlockCenterOnTop(upBlock.blockGO, blockData.blockGO, self.gameData:GetBlockSize()) == false then
                return false
            end
        end
        return true
    end
end

---获得一个随机有效放置位置
---@param sideLerp float
---@param lerp float
---@return Vector3
function BlockTowerGameController:GetRandomEffectivePutPosition(sideLerp, lerp)
    local putPosition = Vector3.zero
    local topBlocks = self.gameData:GetTopBlocks()
    local safeArea = nil
    if #topBlocks == 1 then
        safeArea = self.gameData:GetSafeArea(self.gameData.curPhysicsLayer - 1)
        local topPosition = GameObjectUtil.GetPosition(topBlocks[1].blockGO)
        local distanceToLeft = safeArea:DistanceToLeft(topPosition)
        local distanceToRight = safeArea:DistanceToRight(topPosition)
        if distanceToLeft > distanceToRight then
            putPosition = Vector3.Lerp(topPosition, safeArea:GetRandomLocalPosFromLeftSide(sideLerp), lerp)
        else
            putPosition = Vector3.Lerp(topPosition, safeArea:GetRandomLocalPosFromRightSide(sideLerp), lerp)
        end
    else
        safeArea = self.gameData:GetSafeArea(self.gameData.curPhysicsLayer)
        putPosition = safeArea.centerPos
    end
    return putPosition
end

---@return Vector3
function BlockTowerGameController:GetNearestEffectivePutPosition()
    local putPosition = Vector3.zero
    local topBlocks = self.gameData:GetTopBlocks()
    local safeArea = nil
    local topPosition = GameObjectUtil.GetPosition(topBlocks[1].blockGO)
    if #topBlocks == 1 then
        safeArea = self.gameData:GetSafeArea(self.gameData.curPhysicsLayer - 1)
        putPosition = safeArea:GetNearestPutPosition(topPosition)
    else
        safeArea = self.gameData:GetSafeArea(self.gameData.curPhysicsLayer)
        putPosition = safeArea.centerPos
    end
    return putPosition
end

---
function BlockTowerGameController:ClearPickEntity()
    self.physicsHelper:ClearRaycastData()
    table.clear(self.gameData.safeBlockList)
    self.gameData.aiChoosedLayer = -1
    self.physicsHelper:DisableSoftJoint()
end

---更新安全区域
function BlockTowerGameController:UpdateLayerSafeArea()
    if TimerMgr.GetCurTimeSeconds() - self.lastSafeAreaUpdatedTimestamp > 1 then
        self.lastSafeAreaUpdatedTimestamp = TimerMgr.GetCurTimeSeconds()
        local blocks = self.gameData:GetPhysicsLayer(self.gameData.curPhysicsLayer)
        local safeArea = self.gameData:GetSafeArea(self.gameData.curPhysicsLayer)
        safeArea:Update(blocks)
    end
end

---是否能放置
---@return boolean
function BlockTowerGameController:CanPutTop()
    return self.physicsHelper:CanPutTop()
end

---防止块
function BlockTowerGameController:PutBlock()
    if self.physicsHelper:CanPutTop() == false then
        return
    end
    if GameObjectUtil.IsNull(self.gameData.selectedBlock) then
        return
    end
    self.physicsHelper:ClearSelectedBlockVelocity()
    self.physicsHelper:DropBlock()
    local tops = self.gameData:GetTopBlocks()
    if #tops > 1 then
        self.gameData.curLayer = self.gameData.curLayer + 1
    end
    local curBlockData = self.gameData:GetCurSelectBlockData()
    table.clear(self.roundResult)
    self.roundResult.fromBlockIndex = curBlockData:GetBlockIndex()
    self.roundResult.fromLayerIndex = curBlockData:GetLayerIndex()
    self.roundResult.isFailed = false
    curBlockData.ignoreDrop = false
    self.gameData:ChangeLayer(self.gameData.curLayer, curBlockData)
    self.curBalancedTime = 0
    self:SwitchMode(Const.ControlMode.PutEnd)
    self.gameData.clickedBlock = nil
    self:UnselectBlock()
    self.gestureCtrl:SetTouchEnable(false)
    GameObjectUtil.SetActive(self.putEnableBlock, false)
    GameObjectUtil.SetActive(self.putDisableBlock, false)
end

---暂停
function BlockTowerGameController:Pause()
    self.isRunning = false
end

---继续
function BlockTowerGameController:Resume()
    self.isRunning = true
end

---刷新物理块分层
function BlockTowerGameController:RefreshPhysicsLayer()
    table.clear(self.gameData.physicsLayerDict)
    self.gameData.curPhysicsLayer = -1
    for _, layer in pairs(self.gameData.logicLayerDict) do
        for _, blockData in pairs(layer) do
            local blockPos = GameObjectUtil.GetPosition(blockData.blockGO)
            local physicsLayerIndex = math.floor((blockPos.y - self:GetBlockRootPosition().y + self.gameData.blockSize.y / 2) / self.gameData.blockSize.y)
            table.insert(self.gameData:GetPhysicsLayer(physicsLayerIndex), blockData)
            blockData.physicsLayer = physicsLayerIndex
            self.gameData.curPhysicsLayer = math.max(self.gameData.curPhysicsLayer, physicsLayerIndex)
        end
    end
end

---判断块的类型
---@param block GameObject
---@param isSeparateChoose boolean
---@return BlockTowerConst.BlockType
function BlockTowerGameController:BlockTowerTypeTest(block, isSeparateChoose)
    return self.physicsHelper:BlockTowerTypeTest(block, isSeparateChoose)
end

---AI使用的保底碰撞检测
---@param block GameObject
---@return BlockTowerConst.BlockType
function BlockTowerGameController:ColliderHitTestLastPlan(block)
    return self.physicsHelper:ColliderHitTestLastPlan(block)
end

---模拟拖拽
---@param position Vector3
function BlockTowerGameController:DragByWorldPosition(position)
    self.physicsHelper:DragByWorldPosition(position)
end

---戳块
---@param pointOnBody Vector3 戳在块上的哪个位置(LocalPosition)
---@param pushRange float 戳的幅度=离开戳的点多少距离拽块
---@param pushTime float 戳的时间
function BlockTowerGameController:PushBlock(pointOnBody, pushRange, pushTime)
    self.physicsHelper:PushBlock(pointOnBody, pushRange, pushTime)
end

---碰撞检测
---@param block GameObject 被检测的块
---@param direction Vector3 检测方向
---@param distance int 检测距离
---@param layerDetection boolean 是否检测同层碰撞
---@return boolean
function BlockTowerGameController:ColliderCastTest(block, direction, distance, layerDetection)
    return self.physicsHelper:ColliderCastTest(block, direction, distance, layerDetection)
end

--region AI
---
function BlockTowerGameController:CreateAI(path)
    self.aiBehaviorTree = AIMgr.CreateTree(path)
    self.aiBehaviorTree:AddVariable("GameController", AIVarType.Object, self)
    self:PauseAI()
end

---
function BlockTowerGameController:PauseAI()
    if self.aiBehaviorTree then
        self.aiBehaviorTree:Pause(true)
    end
end

---
function BlockTowerGameController:ResumeAI()
    if self.aiBehaviorTree then
        self.aiBehaviorTree:Pause(false)
    end
end

---
function BlockTowerGameController:RestartAI()
    if self.aiBehaviorTree then
        self.aiBehaviorTree:Restart()
    end
end

---
function BlockTowerGameController:EndedAI()
    if self.aiBehaviorTree then
        self.aiBehaviorTree:Ended()
    end
end
--endregion

---
function BlockTowerGameController:SetBlockTowerMoved()
    if self.gameData.blockTowerMoved == false then
        self.gameData.blockTowerMoved = true
    end
    if self.gameData.showingAlert == true then
        EventMgr.Dispatch("BlockTowerHidePlayerAlert")
        self.gameData.showingAlert = false
    end
    EventMgr.Dispatch("BlockTowerOperated", nil)
end

---
function BlockTowerGameController:SetBlockTowerChoosed()
    if self.gameData.blockTowerChoosed == false then
        self.gameData.blockTowerChoosed = true
    end
    if self.gameData.showingAlert == true then
        EventMgr.Dispatch("BlockTowerHidePlayerAlert")
    end
    EventMgr.Dispatch("BlockTowerOperated", nil)
end

---
function BlockTowerGameController:CancelSelect()
    self:UnselectBlock()
    self:SwitchToChooseMode()
end

---
---@param blockGO GameObject
---@return boolean
function BlockTowerGameController:BlockCanSelect(blockGO)
    local hitObjLayer = self.gameData:GetBlockData(blockGO).physicsLayer
    return self.gameData.curPhysicsLayer - hitObjLayer >= self.gameData.layerForbidden
end

---初始化相机
function BlockTowerGameController:InitCamera()
    self.cameraHelper:InitCamera()
end

--region InputComponent
---@param pos Vector3
---@param deltaPos Vector3
---@param gesture X3Game.InputComponent.GestrueType
function BlockTowerGameController:OnDrag(pos, deltaPos, gesture)
    self.cameraHelper:OnDrag(pos, deltaPos, gesture)
end

---@param pos Vector2
function BlockTowerGameController:OnTouchUp(pos)
    --self.physicsHelper:ClearRaycastData()
    self.physicsHelper:DisableSoftJoint()
    if self.gameData:IsPlayerMode() == false then
        return
    end
    local distance = Vector2.Distance(CS.UnityEngine.Input.mousePosition, self.pressedDownPos)
    if distance > 1 then
        self.fingerMoved = true
    end
    if self.gameData.blockTowerControlMode == Const.ControlMode.Choose then
        if self.fingerMoved == false then
            self.physicsHelper:GetBlockPick()
            self:ClickedBlock()
        end
    elseif self.gameData.blockTowerControlMode == Const.ControlMode.SelectedSide then
        if self.fingerMoved == false then
            self.physicsHelper:GetBlockPick()
            if self.raycastData.dragging == 0 then
                self:CancelSelect()
            else
                if self.raycastData.gameObject == self.gameData.selectedBlock and TimerMgr.RealtimeSinceStartup() - self.touchDownTime < 0.5 then
                    self:PushBlock(self.raycastData.pointOnBody, self.gameCfg.pushRange, self.gameCfg.pushTime)
                else
                    self:ClickedBlock()
                end
            end
        else
            self.physicsHelper:ClearRaycastData()
        end
    elseif self.gameData.blockTowerControlMode == Const.ControlMode.Put then
        self.physicsHelper:ClearRaycastData()
    end
    self.cameraHelper:OnTouchUp(pos)
end

---@param pos Vector2
function BlockTowerGameController:OnTouchDown(pos)
    if self.gameData:IsPlayerMode() == false then
        return
    end
    if GameObjClickUtil.TouchCount() > 1 then
        self.physicsHelper:ClearRaycastData()
        return
    end

    self.fingerMoved = false
    self.pressedDownPos = CS.UnityEngine.Input.mousePosition
    self.touchDownTime = TimerMgr.RealtimeSinceStartup()
    if self.gameData.blockTowerControlMode == Const.ControlMode.SelectedSide or
            self.gameData.blockTowerControlMode == Const.ControlMode.Put then
        self.physicsHelper:GetBlockPick()
        if self.raycastData.dragging ~= 0 and self.raycastData.gameObject == self.gameData.selectedBlock then
            self.cameraHelper:SetCameraCanControl(false)
        else
            self.cameraHelper:SetCameraCanControl(true)
        end
    end
end

---@param scrollWheel number
---@param delta number
function BlockTowerGameController:OnScrollWheel(scrollWheel, delta)
    self.cameraHelper:OnScrollWheel(scrollWheel, delta)
end

---@param delta number 相对于上一次缩放变化量（放大（>0）:者缩小(<0)）
---@param scale number 双指缩放[0,无穷]
function BlockTowerGameController:OnDoubleTouchScale(delta, scale)
    self.cameraHelper:OnDoubleTouchScale(delta, scale)
end
--endregion

---销毁逻辑
function BlockTowerGameController:Destroy()
    if self.aiBehaviorTree then
        AIMgr.RemoveTree(self.aiBehaviorTree)
        self.aiBehaviorTree = nil
    end
    for _, go in pairs(self.autoDestroyPool) do
        if GameObjectUtil.IsNull(go) == false then
            GameObjectUtil.SetActive(go, false)
            Res.DiscardGameObject(go)
        end
    end
    Res.DiscardGameObject(self.blockTowerTable)
    Res.DiscardGameObject(self.plOutlineBlock)
    Res.DiscardGameObject(self.manOutlineBlock)
    self.arrowHelper:Destroy()
    self.arrowHelper = nil
    self.physicsHelper:Destroy()
    self.physicsHelper = nil
    self.cameraHelper:Destroy()
    self.cameraHelper = nil
    GameUtil.ClearTarget(self)
    GameHelper.SetMultiTouchEnable(false, GameConst.MultiTouchLockType.BlockTowerCamera)
end

return BlockTowerGameController
