---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2022/6/21 17:55
---

---叠叠乐物理控制器
---@class BlockTowerPhysicsHelper
local BlockTowerPhysicsHelper = class("BlockTowerPhysicsHelper")
---@type BlockTowerConst
local Const = require("Runtime.System.X3Game.Modules.BlockTower.BlockTowerConst")
---@type BlockTowerUtil
local BlockTowerUtil = require("Runtime.System.X3Game.Modules.BlockTower.BlockTowerUtil")

---掉落检查间隔
local DROP_CHECK_GAP = 0.5

---@param gameController BlockTowerGameController
---@param blockTowerTable GameObject
function BlockTowerPhysicsHelper:Init(gameController, blockTowerTable)
    ---@type BlockTowerGameController
    self.gameController = gameController
    ---@type GameObject
    self.blockTowerTable = blockTowerTable
    ---@type CS.Framework.RigidBodyDynamics.PpPhysicsScene
    self.ppScene = self.blockTowerTable:GetComponent("PpPhysicsScene")
    ---@type CS.Framework.RigidBodyDynamics.PpSoftJoint
    self.softJoint = GameObjectUtil.GetComponent(blockTowerTable, "SoftJoint", "PpSoftJoint")
    ---@type GameObject
    self.mousePointRigidBody = GameObjectUtil.GetComponent(blockTowerTable, "MousePoint", "PpRigidBody")
    ---@type float 上次掉落检查的时间戳
    self.dropCheckTimestamp = 0
    ---@type CS.Framework.RigidBodyDynamics.PpIndex
    self.cubeGeo = nil
    ---@type CS.Framework.RigidBodyDynamics.PpRigidBody[]
    self.collisions = BlockTowerUtil.CreateBodyCollision()
    ---@type CS.Framework.RigidBodyDynamics.PpRigidBody
    self.tableRigidBody = nil
    ---@type CS.Framework.RigidBodyDynamics.PpRigidBody
    self.groundRigidBody = nil
    ---@type int 戳的timer
    self.pushTimer = 0
    self:InitPhysics()
end

---@return BlockTowerGameData
function BlockTowerPhysicsHelper:GetGameData()
    return self.gameController:GetGameData()
end

---@return BlockTowerCfg
function BlockTowerPhysicsHelper:GetGameCfg()
    return self.gameController:GetGameCfg()
end

---@return BlockTowerRaycastData
function BlockTowerPhysicsHelper:GetRaycastData()
    return self.gameController:GetRaycastData()
end

---获得顶层需要物理碰撞检测的块
---@return BlockTowerBlockData
function BlockTowerPhysicsHelper:GetTopCheckBlock()
    local topBlocks = self:GetGameData():GetTopBlocks()
    if #topBlocks == 1 then
        return topBlocks[1]
    else
        return nil
    end
end

---
function BlockTowerPhysicsHelper:InitPhysics()
    self.ppScene:Initialization()
    local groundMesh = GameObjectUtil.GetComponent(self.blockTowerTable, "Ground", "MeshFilter")
    local groundGeo = BlockTowerUtil.ConvertMeshToGeometry(self.ppScene, Const.PpShapeType.Box, groundMesh.sharedMesh)
    self.groundRigidBody = GameObjectUtil.GetComponent(groundMesh.gameObject, "", "PpRigidBody")
    self.groundRigidBody.Layer = 1
    self.ppScene:AddRigidBody(self.groundRigidBody, groundGeo)

    self.tableMesh = GameObjectUtil.GetComponent(self.blockTowerTable, "Table", "MeshFilter")
    local tableGeo = BlockTowerUtil.ConvertMeshToGeometry(self.ppScene, Const.PpShapeType.Box, self.tableMesh.sharedMesh)
    self.tableRigidBody = GameObjectUtil.GetComponent(self.tableMesh.gameObject, "", "PpRigidBody")
    self.tableRigidBody.Layer = 1
    self.ppScene:AddRigidBody(self.tableRigidBody, tableGeo)

    local pointVtx = { Vector3.zero, Vector3.zero, Vector3.zero, Vector3.zero }
    local pointGeo = BlockTowerUtil.ConvertPointToGeometry(self.ppScene, Const.PpShapeType.Point, pointVtx)
    self.mousePointRigidBody.Layer = 1
    self.ppScene:AddRigidBody(self.mousePointRigidBody, pointGeo)
    self.ppScene:AddSoftJoint(self.softJoint)
end

---如果不行放在FixedUpdate里
function BlockTowerPhysicsHelper:Update()
    self:HandleDrag()
    self.dropCheckTimestamp = self.dropCheckTimestamp + TimerMgr.GetCurTickDelta()
    if self.dropCheckTimestamp > DROP_CHECK_GAP then
        local count, collisions = self.ppScene:GetBodyCollisionMessage(self.groundRigidBody, self.collisions)
        self.collisions = collisions
        for i = 1, count do
            if collisions[i] then
                self:CheckDrop(collisions[i].gameObject)
            end
        end

        count, collisions = self.ppScene:GetBodyCollisionMessage(self.tableRigidBody, self.collisions)
        self.collisions = collisions
        for i = 1, count do
            if collisions[i] then
                self:CheckDrop(collisions[i].gameObject)
            end
        end
        self.dropCheckTimestamp = 0
    end
end

function BlockTowerPhysicsHelper:FixedUpdate()
    self.ppScene:Run(2)
end

---检查掉落
---@param blockGO GameObject
function BlockTowerPhysicsHelper:CheckDrop(blockGO)
    local blockData = self:GetGameData():GetBlockData(blockGO)
    if blockData and blockData.ignoreDrop == false and blockData.isDropped == false then
        blockData.isDropped = true
        self:GetGameData().dropCount = self:GetGameData().dropCount + 1
    end
end

---
function BlockTowerPhysicsHelper:HandleDrag()
    if self:GetRaycastData().dragging == 1 and self:GetRaycastData().gameObject == self:GetGameData().selectedBlock then
        local ray = GlobalCameraMgr.ScreenPointToRay(CS.UnityEngine.Input.mousePosition)
        local dir = ray.direction
        local springWs = BlockTowerUtil.LocalToWorld(self:GetGameData().selectedBlock.transform, self:GetRaycastData().pointOnBody.x, self:GetRaycastData().pointOnBody.y, self:GetRaycastData().pointOnBody.z)
        if dir.y == 0 then
            self:GetGameData().arrowEndPos = Vector3.zero
        else
            local times = (springWs.y - ray.origin.y) / dir.y
            self:GetGameData().arrowEndPos = ray.origin + ray.direction * times
        end
        self:GetGameData().arrowStartPos = springWs
        self:GetGameData().showArrow = true
        if self:GetGameData().blockTowerControlMode ~= Const.ControlMode.Put then
            self.softJoint.localPos0 = self:GetRaycastData().pointOnBody
            GameObjectUtil.SetPosition(self.softJoint.body1, self:GetGameData().arrowEndPos)
            self:EnableSoftJoint()
        else
            GameObjectUtil.SetPosition(self:GetGameData().selectedBlock, self:GetRaycastData().oriPosition + self:GetGameData().arrowEndPos - self:GetRaycastData().oriArrowEndPos)
        end
    else
        self:GetGameData().showArrow = false
    end
end

---
function BlockTowerPhysicsHelper:EnableSoftJoint()
    self.softJoint.enable = true
end

---
function BlockTowerPhysicsHelper:DisableSoftJoint()
    self.softJoint.enable = false
end

---@param go GameObject
function BlockTowerPhysicsHelper:AddRigidBody(go)
    local rigidBody = GameObjectUtil.GetComponent(go, "", "PpRigidBody")
    if self.cubeGeo == nil then
        local cubeMesh = GameObjectUtil.GetComponent(go, "", "MeshFilter")
        self.cubeGeo = BlockTowerUtil.ConvertMeshToGeometry(self.ppScene, Const.PpShapeType.Box, cubeMesh.sharedMesh)
    end
    rigidBody.Layer = 1
    self.ppScene:AddRigidBody(rigidBody, self.cubeGeo)
end

---移除RigidBody
---@param go GameObject
function BlockTowerPhysicsHelper:RemoveRigidBody(go)
    local rigidBody = GameObjectUtil.GetComponent(go, "", "PpRigidBody")
    self.ppScene:RemoveRigidBody(rigidBody)
end

---
function BlockTowerPhysicsHelper:GetBlockPick()
    local ray = GlobalCameraMgr.ScreenPointToRay(CS.UnityEngine.Input.mousePosition)
    local hitPos = CS.Unity.Mathematics.float3.zero
    local rigidBody = nil
    rigidBody, hitPos = self.ppScene:RayIntersect(ray, hitPos)
    if rigidBody ~= nil and rigidBody.isStatic == false then
        local blockData = self:GetGameData():GetBlockData(rigidBody.gameObject)
        --这里可能点到MousePoint，就保持原样
        if blockData ~= nil then
            self:GetRaycastData().gameObject = rigidBody.gameObject
            self:GetRaycastData().pointOnBody = BlockTowerUtil.WorldToLocal(rigidBody.transform, hitPos.x, hitPos.y, hitPos.z)
            self:GetRaycastData().oriPosition = GameObjectUtil.GetPosition(rigidBody.gameObject)
            local dir = ray.direction
            if dir.y == 0 then
                self:GetRaycastData().oriArrowEndPos = Vector3.zero
            else
                local times = (hitPos.y - ray.origin.y) / dir.y
                self:GetRaycastData().oriArrowEndPos = ray.origin + ray.direction * times
            end
            self:GetRaycastData().dragging = 1
        end
    else
        self:ClearRaycastData()
    end
end

---
function BlockTowerPhysicsHelper:ClearRaycastData()
    self:GetRaycastData().gameObject = nil
    self:GetRaycastData().oriPosition = Vector3.zero
    self:GetRaycastData().oriArrowEndPos = Vector3.zero
    self:GetRaycastData().dragging = 0
    self:GetRaycastData().pointOnBody = Vector3.zero
end

---@param blockGO GameObject
function BlockTowerPhysicsHelper:SelectBlock(blockGO)
    self:GetGameData().selectedBlock = blockGO
    local blockData = self:GetGameData():GetBlockData(blockGO)
    self.softJoint.body0 = blockData.rigidBody
    self.softJoint.distance = 0
    --[[    self.softJoint.localPos0 = self:GetRaycastData().pointOnBody
        self.softJoint.localPos1 = Vector3.zero
        GameObjectUtil.SetPosition(self.softJoint.body1,
                BlockTowerUtil.LocalToWorld(blockGO.transform,
                        self:GetRaycastData().pointOnBody.x,
                        self:GetRaycastData().pointOnBody.y,
                        self:GetRaycastData().pointOnBody.z))]]
    if self:GetGameData():IsPlayerMode() then
        self:GetGameData().outlineBlock = self.gameController:GetPlOutlineBlock()
    else
        self:GetGameData().outlineBlock = self.gameController:GetManOutlineBlock()
    end
    GameObjectUtil.SetActive(self:GetGameData().outlineBlock, true)
    blockData.ignoreDrop = true
    self.gameController:SetBlockTowerChoosed()
end

---
function BlockTowerPhysicsHelper:UnselectBlock()
    self.softJoint.body0 = nil
end

---模拟拖拽
---@param position Vector3
function BlockTowerPhysicsHelper:DragByWorldPosition(position)
    GameObjectUtil.SetPosition(self.softJoint.body1, position)
    self:EnableSoftJoint()
end

---
function BlockTowerPhysicsHelper:DropBlock()
    self:GetGameData():GetCurSelectBlockData().rigidBody.gravityFactor = 1
end

---戳块
---@param pointOnBody Vector3 戳在块上的哪个位置(LocalPosition)
---@param pushRange float 戳的幅度=离开戳的点多少距离拽块
---@param pushTime float 戳的时间
function BlockTowerPhysicsHelper:PushBlock(pointOnBody, pushRange, pushTime)
    self.softJoint.localPos0 = -pointOnBody
    local worldPos = BlockTowerUtil.LocalToWorld(self:GetGameData().selectedBlock.transform, self.softJoint.localPos0.x,
            self.softJoint.localPos0.y, self.softJoint.localPos0.z)
    local pos = GameObjectUtil.GetPosition(self:GetGameData().selectedBlock)
    local simulatePushPos = (worldPos - pos).normalized * pushRange + worldPos
    GameObjectUtil.SetPosition(self.softJoint.body1, simulatePushPos)
    self:EnableSoftJoint()
    self:ClearRaycastData()
    if self.pushTimer ~= 0 then
        TimerMgr.Discard(self.pushTimer)
        self.pushTimer = 0
    end
    self.pushTimer = TimerMgr.AddTimer(pushTime, self.DisableSoftJoint, self)
end

function BlockTowerPhysicsHelper:DisableBlockPhysics()
    self:GetGameData():GetCurSelectBlockData().rigidBody.gravityFactor = 0
    self:ClearSelectedBlockVelocity()
end

---
function BlockTowerPhysicsHelper:ClearSelectedBlockVelocity()
    local curBlockData = self:GetGameData():GetCurSelectBlockData()
    BlockTowerUtil.ClearVelocity(curBlockData.blockGO)
end

---复写块的物理参数
---@param go GameObject
---@param friction float 摩擦力
---@param bounciness float 弹力
function BlockTowerPhysicsHelper:RewritePpMaterial(go, friction, bounciness)
    BlockTowerUtil.RewritePpMaterial(go, friction, bounciness)
end

---@return boolean
function BlockTowerPhysicsHelper:CanPutTop()
    local canPut = true
    local topCheckBlock = self:GetTopCheckBlock()
    if topCheckBlock ~= nil then
        local raycastHits = BlockTowerUtil.CheckColliderCastDistance(self:GetGameData().selectedBlock, Vector3.down, self:GetGameData().blockSize.y * 2)
        for i = 0, raycastHits.Length - 1 do
            local hit = raycastHits[i]
            if hit.collider.gameObject == topCheckBlock.blockGO then
                canPut = false
            end
        end
    end
    return canPut
end

---@param block GameObject
---@param isSeparateChoose boolean
---@return BlockTowerConst.BlockType
function BlockTowerPhysicsHelper:BlockTowerTypeTest(block, isSeparateChoose)
    local faceC1 = self:ColliderCastTest(block, Vector3.left, self:GetGameData().blockSize.z * 2, true)
    local faceC2 = self:ColliderCastTest(block, Vector3.right, self:GetGameData().blockSize.z * 2, true)
    local faceB1 = self:ColliderCastTest(block, Vector3.back, self:GetGameData().blockSize.z * 2, true)
    local faceB2 = self:ColliderCastTest(block, Vector3.forward, self:GetGameData().blockSize.z * 2, true)
    local blockType = Const.BlockType.None
    if (faceC1 and faceC2) or (faceB1 and faceB2) then
        blockType = Const.BlockType.Middle
        if (faceC1 and faceC2 and (faceB1 or faceB2)) then
            blockType = Const.BlockType.Side
        end
        if (faceB1 and faceB2 and (faceC1 or faceC2)) then
            blockType = Const.BlockType.Side
        end
    else
        if isSeparateChoose then
            if faceB1 or faceB2 then
                blockType = Const.BlockType.Side
            elseif faceC1 or faceC2 then
                blockType = Const.BlockType.Middle
            end
        end
    end
    return blockType
end

---@param block GameObject
---@return BlockTowerConst.BlockType
function BlockTowerPhysicsHelper:ColliderHitTestLastPlan(block)
    local faceC1 = self:ColliderCastTest(block, Vector3.left, self:GetGameData().blockSize.z * 2, true)
    if faceC1 then
        return Const.BlockType.Middle
    end

    local faceC2 = self:ColliderCastTest(block, Vector3.right, self:GetGameData().blockSize.z * 2, true)
    if faceC2 then
        return Const.BlockType.Middle
    end

    local faceB1 = self:ColliderCastTest(block, Vector3.back, self:GetGameData().blockSize.z * 2, true)
    if faceB1 then
        return Const.BlockType.Middle
    end

    local faceB2 = self:ColliderCastTest(block, Vector3.forward, self:GetGameData().blockSize.z * 2, true)
    if faceB2 then
        return Const.BlockType.Middle
    end
    return Const.BlockType.None
end

---碰撞检测
---@param block GameObject 被检测的块
---@param direction Vector3 检测方向
---@param distance int 检测距离
---@param layerDetection boolean 是否检测同层碰撞
---@return boolean
function BlockTowerPhysicsHelper:ColliderCastTest(block, direction, distance, layerDetection)
    if GameObjectUtil.IsNull(block) then
        return true
    end
    local raycastHits = BlockTowerUtil.CheckColliderCastDistance(block, direction, distance)
    for i = 0, raycastHits.Length - 1 do
        local hit = raycastHits[i]
        if GameObjectUtil.IsNull(hit.collider.gameObject) == false then
            if hit.collider.gameObject ~= block then
                if layerDetection == false or (self:GetGameData():GetPhysicsLayerIndex(hit.collider.gameObject) == self:GetGameData():GetPhysicsLayerIndex(block)) then
                    return false
                end
            end
        end
    end
    return true
end

---销毁函数
function BlockTowerPhysicsHelper:Destroy()

end

return BlockTowerPhysicsHelper