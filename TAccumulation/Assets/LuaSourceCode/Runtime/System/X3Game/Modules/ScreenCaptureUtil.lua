---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiaozhu.
--- DateTime: 2022/4/15 22:40
--- 屏幕截图通用接口
---@class ScreenCaptureUtil
local ScreenCaptureUtil = {}

local CS_TEXTURE_HELPER = CS.X3Game.TextureUtility
local CS_CAMERA_HELPER = CS.X3Game.CameraUtility
local CS_RECT_HELPER = CS.UnityEngine.Rect
local CS_RenderTexture = CS.UnityEngine.RenderTexture

---@param targetObj GameObject 要截图的gameObject
---@param finishCall fun(Texture2D):void 截屏完成时的回调
---@param captureRect UnityEngine.Rect 需要裁剪的区域，默认全屏
---@param objHandler fun(GameObject):void 截图前做节点属性处理（隐藏，放大等）
---@param noSafeUI bool 是否需要无视异性屏的屏幕适配，用于异形屏下截取全屏
---@param needUIBlur bool 是否需要模糊背景
function ScreenCaptureUtil.CaptureUI(targetObj, finishCall, captureRect, objHandler, noSafeUI, needUIBlur)
    if not targetObj then
        if finishCall then
            finishCall()
        end
        Debug.LogError("ScreenCaptureUtil.CaptureUI failed targetObj is nil")
        return
    end
    local capture_rect = captureRect
    if not capture_rect then
        --local screen_size = CS.X3Game.CameraUtility.GetScreenSize()
        ---需要处理异形屏的情况，所以不能使用屏幕大小
        local safeSize = RectTransformUtil.GetScreenRect(targetObj.transform)
        capture_rect = CS.UnityEngine.Rect(0, 0, math.ceil(safeSize.width), math.ceil(safeSize.height))
    end
    local ui_camera = UIMgr.GetUICamera()
    local capture_camera = GameObjectUtil.GetComponent(GameObjectUtil.InstantiateGameObject(ui_camera, ui_camera.gameObject.transform.parent), "", "Camera")
    capture_camera.depth = ui_camera.depth - 1
    capture_camera.cullingMask = (1 << Const.LayerMask.ClearUI)
    GameObjectUtil.SetPosition(capture_camera, 1000, 1000, 1000) -- 将复制出来的 Camera 和 UI 移动到很远的地方，避免与现有 UI 冲突
    local screenCaptureRoot = UIMgr.LoadDynamicUIPrefab(PrefabConst.ScreenCaptureRoot)
    local cameraDataComp = GameObjectUtil.GetComponent(capture_camera.gameObject,"","UIAdditionalCameraData")
    local needCloseAutoRelease = false
    if needUIBlur and cameraDataComp ~= nil and cameraDataComp._UIBlurTexture ~= nil then
        cameraDataComp._UIBlurEnable = false

        local UIBlurController = UIMgr.GetBlurController()
        local rawImg = GameObjectUtil.GetComponent(screenCaptureRoot, "OCX_ShadowRoot", "RawImage")
        rawImg.enabled = true
        rawImg.texture = UIBlurController:GetBlurRT2()
        ---避免被释放
        UIMgr.SetBlurRtAutoReleaseState(false)
        needCloseAutoRelease = true
    end

    ---加载节点树
    --obj:SetActive(false)
    GameObjectUtil.SetParent(screenCaptureRoot.transform, capture_camera.transform.parent)

    ---@type UnityEngine.Canvas
    local canvas = GameObjectUtil.GetComponent(screenCaptureRoot, "", "Canvas")
    canvas.worldCamera = capture_camera
    canvas.renderMode = CS.UnityEngine.RenderMode.ScreenSpaceCamera
    canvas.additionalShaderChannels = UIMgr.GetRootCanvas().additionalShaderChannels

    local canvas_scaler = GameObjectUtil.GetComponent(UIMgr.GetRootCanvas(), nil, "CanvasScaler")
    local scaler = GameObjectUtil.GetComponent(screenCaptureRoot, "", "CanvasScaler")--
    if scaler then
        scaler.referenceResolution = canvas_scaler.referenceResolution
        scaler.screenMatchMode = canvas_scaler.screenMatchMode
        scaler.scaleFactor = canvas_scaler.scaleFactor
        scaler.uiScaleMode = canvas_scaler.uiScaleMode
    end

    local copyRoot = GameObjectUtil.GetComponent(screenCaptureRoot, "OCX_CopyRoot")
    ---异形屏的实现依赖于UIRoot层级的RECTTRANS，特此复制属性
    local uiRoot = UIMgr.GetUIRoot():GetComponent(typeof(CS.UnityEngine.RectTransform))
    local contentRectTransform = GameObjectUtil.GetComponent(screenCaptureRoot, "OCX_CopyRoot", "RectTransform")
    --GameObjectUtil.SetLocalPosition(contentRectTransform, Vector3.zero_readonly)
    --GameObjectUtil.SetLocalScale(contentRectTransform, Vector3.one_readonly)
    contentRectTransform.anchorMax = uiRoot.anchorMax
    contentRectTransform.anchorMin = uiRoot.anchorMin
    GameObjectUtil.SetAnchoredPosition(contentRectTransform, Vector2.zero_readonly)
    if(noSafeUI) then
        contentRectTransform.offsetMin = Vector2.new(0, 0)
        contentRectTransform.offsetMax = Vector2.new(0, 0)
    end

    --local bgNode = GameObjectUtil.InstantiateGameObject(UIMgr.GetBasePlateRoot(), copyRoot.transform)
    --for i = 0, bgNode.transform.childCount - 1 do
    --    local child = bgNode.transform:GetChild(i)
    --    GameObjectUtil.RemoveCSComponent(child.gameObject, typeof(CS.UnityEngine.Canvas))
    --end

    local capture_obj = GameObjectUtil.InstantiateGameObject(targetObj, copyRoot.transform)
    if objHandler then
        objHandler(capture_obj)
    end

    GameObjectUtil.SetLayer(screenCaptureRoot, Const.LayerMask.ClearUI, true)
    ScreenCaptureUtil.CaptureTextureWithNewCamera(capture_camera, capture_rect, function(texture_2d)
        GameObjectUtil.Destroy(screenCaptureRoot)
        GameObjectUtil.Destroy(capture_camera.gameObject)

        ---恢复自动释放相关设置
        if(needCloseAutoRelease) then
            UIMgr.SetBlurRtAutoReleaseState(true)
        end

        if finishCall then
            finishCall(texture_2d)
        end
    end,false)

end

---使用复制相机或新建相机截图，与CaptureUI配合使用
---@param camera UnityEngine.Camera 非主相机
---@param cropRect Rect 裁剪区域
---@param onComplete fun(Texture2D):void 截屏完成时的回调
---@param waitTime float 等待时间
function ScreenCaptureUtil.CaptureTextureWithNewCamera(camera, cropRect, onComplete, waitTime)
    if camera then
        local screenSize = CS_CAMERA_HELPER.GetScreenSize()
        cropRect = cropRect or CS_RECT_HELPER(0, 0, screenSize.x, screenSize.y)
        cropRect = RectTransformUtil.GetCaptureRect(cropRect)
        waitTime = waitTime or 0
        CS_CAMERA_HELPER.CaptureTextureWithNewCamera(camera, cropRect, onComplete, waitTime)
    end
end

---裁剪纹理
---@param srcTex Texture2D 需要被裁剪的纹理
---@param cropRect RectInt or {x=0, y=0, width=100, height=100} 裁剪区域
---@return Texture2D
function ScreenCaptureUtil.CropTexture(srcTex, cropRect)
    if (cropRect.width * cropRect.height == 0) then
        return srcTex
    end

    return CS_TEXTURE_HELPER.Crop(srcTex, cropRect)
end

---传入 UI 摄像机截图
---@param camera UnityEngine.Camera
---@param cropRect Rect 裁剪区域
---@param onComplete fun(Texture2D):void 完成后的回调
---@param isTransparent bool 是否是透明 默认是True
---@param waitTime float 等待时间 默认是0，即下一帧
function ScreenCaptureUtil.CaptureTextureWithCamera(camera, cropRect, onComplete, isTransparent, waitTime)
    if camera then
        local screenSize = CS_CAMERA_HELPER.GetScreenSize()

        cropRect = cropRect or CS_RECT_HELPER(0, 0, screenSize.x, screenSize.y)
        cropRect = RectTransformUtil.GetCaptureRect(cropRect)
        if isTransparent == nil then
            isTransparent = true
        end
        if waitTime == nil then
            waitTime = 0
        end
        CS_CAMERA_HELPER.CaptureAlphaTexture(camera, cropRect, onComplete, isTransparent, waitTime)
    end
end

---用默认 3D 主相机截高画质图
---@param cropRect Rect 裁剪区域
---@param onComplete fun(Texture2D):void 完成后的回调
---@param isTransparent bool 是否是透明 默认是True
---@param waitTime float 等待时间 默认是0，即下一帧
---@param withUI bool 是否将 UI 也截下来
---@param highQuality bool 高品质
function ScreenCaptureUtil.CaptureTextureByMainCamera(cropRect, onComplete, isTransparent, waitTime, withUI, highQuality)
    if highQuality == nil then highQuality = true end
    if withUI then
        if highQuality then
            BllMgr.GetSystemSettingBLL():BeginScreenCapture()
        end
        ScreenCaptureUtil.CaptureTexture(function(texture)
            if highQuality then
                BllMgr.GetSystemSettingBLL():EndScreenCapture()
            end
            if onComplete then
                onComplete(texture)
            end
        end, cropRect)
    else
        local camera = GlobalCameraMgr.GetUnityMainCamera()
        if camera then
            if highQuality then
                BllMgr.GetSystemSettingBLL():BeginScreenCapture()
            end
            ScreenCaptureUtil.CaptureTextureWithCamera(camera, cropRect, function(texture)
                if highQuality then
                    BllMgr.GetSystemSettingBLL():EndScreenCapture()
                end
                if onComplete then
                    onComplete(texture)
                end
            end, isTransparent, waitTime)
        end
    end
end

---调用系统截屏接口截取当前屏幕
---@param onComplete fun(type:Texture2D)
---@param cropRect Rect 裁剪区域
function ScreenCaptureUtil.CaptureTexture(onComplete, cropRect)
    if cropRect then
        CS_CAMERA_HELPER.CaptureScreenWithCropRect(cropRect, onComplete)
    else
        CS_CAMERA_HELPER.CaptureScreen(onComplete)
    end
end

function ScreenCaptureUtil.Clear()
    CS_CAMERA_HELPER.Clear()
end

function ScreenCaptureUtil.Destroy()
    ScreenCaptureUtil.Clear()
end

---allRect并集区域
function ScreenCaptureUtil.GetCropRectIntByMultipleRect(allRect)
    local minX = allRect[1].x
    local minY = allRect[1].y

    local maxEndX = allRect[1].x + allRect[1].width
    local maxEndY = allRect[1].y + allRect[1].height
    for i = 1, #allRect do
        minX = math.min(minX, allRect[i].x)
        minY = math.min(minY, allRect[i].y)

        maxEndX = math.max(maxEndX, allRect[i].x + allRect[i].width)
        maxEndY = math.max(maxEndY, allRect[i].y + allRect[i].height)
    end

    minX = math.ceil(minX) minY =  math.ceil(minY) maxEndX = math.floor(maxEndX) maxEndY = math.floor(maxEndY)
    return CS.UnityEngine.RectInt(minX, minY, maxEndX - minX, maxEndY - minY)
end

---allRect交集区域
function  ScreenCaptureUtil.GetCropRectIntByIntersectionRect(allRect)
    local minX = allRect[1].x
    local minY = allRect[1].y

    local maxEndX = allRect[1].x + allRect[1].width
    local maxEndY = allRect[1].y + allRect[1].height
    for i = 1, #allRect do
        minX = math.max(minX, allRect[i].x)
        minY = math.max(minY, allRect[i].y)

        maxEndX = math.min(maxEndX, allRect[i].x + allRect[i].width)
        maxEndY = math.min(maxEndY, allRect[i].y + allRect[i].height)
    end

    minX = math.ceil(minX) minY =  math.ceil(minY) maxEndX = math.floor(maxEndX) maxEndY = math.floor(maxEndY)
    return CS.UnityEngine.RectInt(minX, minY, maxEndX - minX, maxEndY - minY)
end


function ScreenCaptureUtil.GetCropRectInt(cropArea)
    local screenRect = RectTransformUtil.GetScreenRect(cropArea)
    return CS.UnityEngine.RectInt(math.floor(screenRect.x), math.floor(screenRect.y), math.floor(screenRect.width), math.floor(screenRect.height))
end

---根据摄像机截图 ---捏脸使用
---@param camera UnityEngine.Camera
---@param screenShotSize Vector2 截图大小
---@param iconWidth int 输出Icon大小
---@param iconHeight int 输出Icon大小
---@param offset S2Int 输出Icon大小
---@param captureHeight int 输出Icon大小
---@param onComplete fun(Texture2D):void 完成后的回调
---@param isTransparent bool 是否是透明 默认是True
---@param waitTime float 等待时间 默认是0，即是下一帧
function ScreenCaptureUtil.CaptureIconWithCamera(camera, screenShotSize, iconWidth, iconHeight, offset, captureHeight, onComplete, isTransparent, waitTime)
    if camera then
        if isTransparent == nil then
            isTransparent = true
        end
        if waitTime == nil then
            waitTime = 0
        end
        local iconSize = Vector2(iconWidth, iconHeight)
        local screenRect = RectTransformUtil.GetScreenRectByScreen(screenShotSize, offset, captureHeight, iconWidth / iconHeight)

        local v = Vector4()
        v.x = screenRect.x / screenShotSize.x
        v.y = screenRect.y / screenShotSize.y
        v.z = screenRect.width / screenShotSize.x
        v.w = screenRect.height / screenShotSize.y

        CS_CAMERA_HELPER.CaptureAlphaIcon(camera, screenShotSize, iconSize, v, onComplete, isTransparent, waitTime)
    end
end

function ScreenCaptureUtil.StopCaptureIconWithCamera()
    CS_CAMERA_HELPER.StopCaptureAlphaIcon()
end


---根据摄像机截图 for Debug ---证件照DEBUG使用
---@param camera UnityEngine.Camera
---@param cropRect Rect 裁剪区域
---@param onComplete fun(Texture2D):void 完成后的回调
---@param isTransparent bool 是否是透明 默认是True
function ScreenCaptureUtil.CaptureTextureWithCameraDebug(camera, cropRect, onComplete, isTransparent, goDebug)
    if camera then
        local screenSize = CS_CAMERA_HELPER.GetScreenSize()
        cropRect = cropRect and cropRect or CS_RECT_HELPER(0, 0, screenSize.x, screenSize.y)
        cropRect = RectTransformUtil.GetCaptureRect(cropRect)
        if isTransparent == nil then
            isTransparent = true
        end

        TimerMgr.AddTimerByFrame(2, function()
            local prevFlag = camera.clearFlags
            local prevColor = camera.backgroundColor
            local prevRT = camera.targetTexture
            local prev = CS_RenderTexture.active

            if isTransparent then
                camera.clearFlags = CS.UnityEngine.CameraClearFlags.SolidColor
                local clr = camera.backgroundColor
                clr.a = 0
                camera.backgroundColor = clr
                CS.UnityEngine.Shader.SetGlobalFloat("_TransBGFlag", 0)
            end

            local rt = RenderTextureUtil.GetRt(nil, nil, 0, CS.UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm)
            rt.antiAliasing = 1
            rt.name = "RT_DebugIDPhoto"
            rt:Create()

            camera.targetTexture = rt
            camera:Render()
            CS_RenderTexture.active = rt

            local rawImg = nil
            if goDebug and not GameObjectUtil.IsNull(goDebug) then
                rawImg = goDebug:GetOrAddComponent(typeof(CS.UnityEngine.UI.RawImage))
                GameObjectUtil.SetSizeDeltaXY(goDebug, cropRect.width, cropRect.height)
            end
            if rawImg then
                rawImg.texture = rt

                local rectX = cropRect.x / (screenSize.x + Mathf.Epsilon)
                local tmpY = cropRect.y
                if UNITY_EDITOR then
                    tmpY = screenSize.y - cropRect.height - cropRect.y
                end
                local rectY = tmpY / (screenSize.y + Mathf.Epsilon)
                local rectW = cropRect.width / (screenSize.x + Mathf.Epsilon)
                local rectH = cropRect.height / (screenSize.y + Mathf.Epsilon)
                rawImg.uvRect = CS.UnityEngine.Rect(rectX, rectY, rectW, rectH)
                --Debug.LogFormat("<color=#f6ad00>screenSize = (%s, %s)</color>", screenSize.x, screenSize.y)
                Debug.LogFormat("<color=#f6ad00>cropRect(%.3f,%.3f, %.3f,%.3f) -> uvRect(%.3f,%.3f, %.3f,%.3f)</color>",
                        cropRect.x, cropRect.y, cropRect.width, cropRect.height, rectX, rectY, rectW, rectH)
            end

            local texture = CS_TEXTURE_HELPER.GetScreenTexture(cropRect, isTransparent)
            texture.wrapMode = CS.UnityEngine.TextureWrapMode.Clamp

            -- 等待时间方便暂停查看
            TimerMgr.AddTimer(3, function()
                -- 恢复设置
                if not GameObjectUtil.IsNull(rawImg) then
                    rawImg.texture = nil
                end
                RenderTextureUtil.ReleaseRt(rt)
                CS_RenderTexture.active = prev
                if not GameObjectUtil.IsNull(camera) then
                    camera.targetTexture = prevRT
                end
                if isTransparent then
                    if not GameObjectUtil.IsNull(camera) then
                        camera.clearFlags = prevFlag
                        camera.backgroundColor = prevColor
                    end
                    CS.UnityEngine.Shader.SetGlobalFloat("_TransBGFlag", 1)
                end

                -- 回调
                if onComplete and type(onComplete) == "function" then
                    onComplete(texture)
                end
            end)

        end)
    end
end


return ScreenCaptureUtil