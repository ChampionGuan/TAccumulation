---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by pc.
--- DateTime: 2020/8/27 14:51
---
local CatCardConst = require("Runtime.System.X3Game.Modules.CatCard.Data.CatCardConst")
local CatCardBaseCtrl = require(CatCardConst.BASE_CTRL_PATH)
---@class CatCard.CatCardLogicCtrl
local CatCardLogicCtrl = class("CatCardLogicCtrl", CatCardBaseCtrl)
function CatCardLogicCtrl:Init()
    if self.is_init then
        return
    end
    ---@type CatCardBLL
    self.bll = self.bll
    self.is_init = true
    self.models = {}
    self.root_model_loaded = false
    self.root_model = nil
    self.card_models = {}
    self.slot_models = {}
    self.load_model_func = handler(self, self.LoadModel)
    self.pool_map = {}
    self.card_stack_model = nil
    self.rob_stack_nodes = {}
    self.rob_stack_pos_map = {}
    self.rob_origin_pos = {}
    self.effect_pool = {}
    self.effect_template = {}
    self.last_select = nil
    self.zero_pos = GameUtil.GetVector(0, 0, 0)
    self.one_pos = GameUtil.GetVector(1, 1, 1)
    self.is_empty_touch_enable = true
    self.is_touch_can_execute_action = true
    self.round_res_cat_map = {}
    self.funccard_stack_nodes = {}
    self.temp_logic_map = {}
    self.show_logic_map = {}
    self.pos_name_map = {}
    self.model_name_map = {}
    self.discard_stack_node = nil
    self.discard_show_center = nil
    self.show_center_screen_pos = nil
    self.func_card_model_names = {}
    self.changed_models_layer = {}
    self.func_screen_pos_map = {}
    self.play_card_pos_map = {}
    self.slot_pos_map = {}
    self.slot_node_map = {}
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_ADD_MODEL_TO_POOL, self.AddModelToPool, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_ADD_EFFECT_TO_POOL, self.AddEffectToPool, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_RESET_MODEL, self.ResetModel, self)
    --EventMgr.AddListener(CatCardConst.Event.CAT_CARD_ON_SELECT_MODEL,self.OnEventSelectModel,self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_MODEL_SELECT, self.OnEventSetModelSelect, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_MODEL_CAN_SELECT, self.OnEventSetModelCanSelect, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_CAT_SELECT, self.OnEventSetCatSelect, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_ALL_SELECT_CATS_IS_PICK, self.OnEventSetAllSelectCatsPick, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_REFRESH_MODEL, self.OnEventRefreshModel, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_REFRESH_MODELS, self.RefreshModels, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_REFRESH_STACK_EVENT, self.RefreshStack, self)
    --EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_TOUCH_EMPTY_ENABLE,self.OnEventSetTouchEmptyEnable,self)
    --EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_TOUCH_CAN_EXECUTE_ACTION,self.OnEventSetTouchCanExecuteAction,self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_ROB_NODE_SELECT, self.SetRobNodeSelect, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_MODEL_LAYER, self.OnEventSetModelLayer, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_ADD_MODEL_TO_TEMP, self.OnEventAddModelToTemp, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_ADD_MODEL_TO_SHOW, self.OnEventAddModelToShow, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_RELEASE_TEMP_MODEL, self.OnEventReleaseTempModel, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_RELEASE_SHOW_MODEL, self.OnEventReleaseShowModel, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_REMOVE_MODEL, self.OnEventRemoveModel, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_ROTATION_MODEL, self.OnEventRotationModel, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_SET_ALL_RUNNING_MODELS_LAYER, self.OnEventSetAllRunningModelsLayer, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_REFRESH_MARK_STATE, self.RefreshMarkState, self)
    EventMgr.AddListener(CatCardConst.Event.CAT_CARD_REFRESH_POS_MASK_STATE, self.RefreshPosMarkState, self)
end

---选中模型SLOt/Card
---@param card_type CatCardConst.CardType
---@param index int
---@param player_type CatCardConst.PlayerType
function CatCardLogicCtrl:OnEventSelectModel(card_type, index, player_type)
    local model

    if not card_type then
        if not self.is_empty_touch_enable then
            return
        end
        self.bll:SetCurSelectIndex(card_type)
        if self.last_select then
            self.last_select:SetSelect(false)
            self.last_select = nil
        end
    else
        model = self:GetModel(card_type, index, player_type)
    end
    if self.bll:IsCurRoundOver() then
        return
    end
    if model and model:IsTouchEnable() then
        self.bll:SetCurSelectIndex(card_type)
        self.bll:SetCurSelectIndex(card_type, index)

        --点击音效
        if card_type == CatCardConst.CardType.CARD then
            self.bll:CheckSound(CatCardConst.SoundType.DEFAULT, CatCardConst.Sound.SYSTEM_MIAO_CARDSELECT)
        elseif card_type == CatCardConst.CardType.SLOT then
            self.bll:CheckSound(CatCardConst.SoundType.DEFAULT, CatCardConst.Sound.SYSTEM_MIAO_CLICKBLOCK)
        end

        if self.last_select == model then
            return
        end
        if self.last_select then
            self.last_select:SetSelect(false)
            self.last_select = nil
        end
        if self.bll:IsDebugMode() then
            self.bll:Log("模型位置:", index, "  模型名称:", model:GetNodeName())
        end
        model:SetSelect(true)

        self.last_select = model
    end
end

function CatCardLogicCtrl:RefreshStack()
    self.card_stack_model:CheckFuncCardStack()
end

function CatCardLogicCtrl:OnEventAddModelToTemp(model_name, model)
    local res = self.temp_logic_map[model_name]
    if not res then
        res = PoolUtil.GetTable()
        self.temp_logic_map[model_name] = res
    end
    table.insert(res, model)
end

function CatCardLogicCtrl:OnEventAddModelToShow(model_name, model)
    local res = self.show_logic_map[model_name]
    if not res then
        res = PoolUtil.GetTable()
        self.show_logic_map[model_name] = res
    end
    table.insert(res, model)
end

function CatCardLogicCtrl:OnEventReleaseTempModel()
    if table.isnilorempty(self.temp_logic_map) then
        return
    end
    for model_name, model_list in pairs(self.temp_logic_map) do
        for _, model in pairs(model_list) do
            self:AddModelToPool(model_name, model)
        end
        PoolUtil.ReleaseTable(model_list)
    end
    table.clear(self.temp_logic_map)
end

function CatCardLogicCtrl:OnEventReleaseShowModel()
    if table.isnilorempty(self.show_logic_map) then
        return
    end
    for model_name, model_list in pairs(self.show_logic_map) do
        for _, model in pairs(model_list) do
            self:AddModelToPool(model_name, model)
        end
        PoolUtil.ReleaseTable(model_list)
    end
    table.clear(self.show_logic_map)
end

function CatCardLogicCtrl:OnEventSetModelLayer(layer, card_type, index, player_type)
    local model = self:GetModel(card_type, index, player_type)
    if model then
        model:SetLayer(layer)
    end
end

--function CatCardLogicCtrl:OnEventSetTouchEmptyEnable(is_empty_touch_enable)
--    self.is_empty_touch_enable = is_empty_touch_enable
--end
--
--function CatCardLogicCtrl:OnEventSetTouchCanExecuteAction(is_touch_can_execute_action)
--    self.is_touch_can_execute_action = is_touch_can_execute_action
--end

---设置模型是否选中
function CatCardLogicCtrl:OnEventSetModelSelect(is_select, card_type, index, player_type)
    self:SetModelsActive(is_select, card_type, index, player_type)
end

---设置模型是否选中
function CatCardLogicCtrl:OnEventSetModelCanSelect(is_select, card_type, index, player_type)
    self:SetModelsActive(is_select, card_type, index, player_type, true)
end

---设置猫是否被选中
function CatCardLogicCtrl:OnEventSetCatSelect(slot_index, is_select, callback)
    local model = self:GetModel(CatCardConst.CardType.SLOT, slot_index)
    if model then
        model:SetCatSelect(is_select, callback)
    else
        if callback then
            callback()
        end
    end
end

---设置选中的猫是否被pick
function CatCardLogicCtrl:OnEventSetAllSelectCatsPick(is_pick, call_back)
    local select_indexs = self.bll:GetSelectIndexs(CatCardConst.CardType.SLOT)
    if select_indexs and #select_indexs > 0 then
        local call
        for k, v in pairs(select_indexs) do
            call = k == #select_indexs and call_back or nil
            EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SET_CAT_SELECT, v, is_pick, call)
        end
    else
        if call_back then
            call_back()
        end
    end
end

---刷新model
function CatCardLogicCtrl:OnEventRefreshModel(...)
    self:RefreshModel(...)
end

function CatCardLogicCtrl:OnEventRemoveModel(...)
    self:RemoveModel(...)
end

function CatCardLogicCtrl:OnEventRotationModel(card_type, pos_index, player_type, finish_call)
    local model = self:GetModel(card_type, pos_index, player_type)
    if model then
        self.bll:CheckSound(CatCardConst.SoundType.DEFAULT, CatCardConst.Sound.SYSTEM_MIAO_CARDTURN)
        self.bll:CheckAnimation(CatCardConst.AnimationType.MOVE_MODEL, CatCardConst.AnimationState.ROTATION, model:GetMoveTarget(), model:GetComponent("", "Transform"), CatCardConst.CARD_SPEED, finish_call)
    end
end

---@param is_reset boolean
---@param card_type CatCardConst.CardType
---@param player_type CatCardConst.PlayerType
function CatCardLogicCtrl:OnEventSetAllRunningModelsLayer(is_reset, card_type, player_type)
    local layer = is_reset and Const.LayerMask.DEFAULT or Const.LayerMask.RT
    if is_reset then

        table.clear(self.changed_models_layer)
        local models = self:GetModels(card_type, player_type)
        if models then
            for k, v in pairs(models) do
                if layer ~= v:GetLayer() then
                    table.insert(self.changed_models_layer, v)
                    v:SetLayer(layer)
                end
            end
            PoolUtil.ReleaseTable(models)
        end
    else
        for k, v in pairs(self.changed_models_layer) do
            v:SetLayer(layer)
        end
        table.clear(self.changed_models_layer)
    end
    for k, v in pairs(self.show_logic_map) do
        for m, n in pairs(v) do
            GameObjectUtil.SetLayer(n, layer, true)
        end
    end

end

---@param card_type CatCardConst.CardType
---@param index int
---@param player_type CatCardConst.PlayerType
function CatCardLogicCtrl:RemoveModel(card_type, index, player_type, ...)
    local model = self:GetModel(card_type, index, player_type)
    if model then
        ---@type CatCard.TargetStateActionData
        local action = self.bll:GetActionData(CatCardConst.ActionType.TargetState, player_type)
        action:Set(card_type, index, CatCardConst.TargetShowState.Unselect | CatCardConst.TargetShowState.DisableCanSelect | CatCardConst.TargetShowState.DisablePreview)
        action:Begin()
        if card_type == CatCardConst.CardType.SLOT then
            ---@type SlotData
            local data = self.bll:GetData(card_type, index, player_type)
            if data then
                data:SetCardId(0)
                data:Refresh()
            end
            model:Refresh(index)
        end
        model:Refresh()
    end
end

---刷新模型
---@param card_type CatCardConst.CardType
---@param index int
---@param player_type CatCardConst.PlayerType
---@varg any
function CatCardLogicCtrl:RefreshModel(card_type, index, player_type, ...)
    local model = self:GetModel(card_type, index, player_type)
    if model then
        model:Refresh(index, ...)
    else
        if index > 0 then
            self:CreateModel(card_type, index, player_type, ...)
        end
    end
end

---创建model
---@param card_type CatCardConst.CardType
---@param index int
---@param player_type CatCardConst.PlayerType
function CatCardLogicCtrl:CreateModel(card_type, index, player_type)
    local model = self:GetModel(card_type, index, player_type)
    if model then
        model:Refresh(index)
        return model
    end
    local type_conf = CatCardConst.TypeConf[card_type]
    local map = self[type_conf.MODEL_MAP]
    local node_name = self:GetModelName(card_type, index, player_type)
    local obj = self:GetModelParent(card_type, index, player_type)
    if not obj then
        return
    end
    ---@type CatCardBaseLogic
    local model = GameObjectCtrl.GetOrAddCtrl(obj, type_conf.MODEL_LUA_PATH, self)
    model:SetLoadModelFunc(self.load_model_func)
    model:SetNodeName(node_name)
    model:SetType(card_type, player_type)
    model:SetBll(self.bll)
    model:SetLogicCtrl(self)
    if player_type then
        if not map[player_type] then
            map[player_type] = {}
        end
        map[player_type][index] = model
    else
        map[index] = model
    end
    model:Refresh(index)
    return model
end

---显示可上的牌
function CatCardLogicCtrl:SetModelsActive(is_active, card_type, index, player_type, is_can_select)
    if index then
        local model = self:GetModel(card_type, index, player_type)
        if model and model:IsValid() then
            if is_can_select then
                model:SetCanSelect(is_active)
            else
                model:SetSelect(is_active)
                if is_active then
                    model:SetCanSelect(false)
                end
            end

        end
    else
        local type_conf = CatCardConst.TypeConf[card_type]
        local map = self[type_conf.MODEL_MAP]
        if player_type then
            map = map[player_type]
        end
        if map then
            for k, v in pairs(map) do
                if is_can_select then
                    v:SetCanSelect(is_active)
                else
                    v:SetSelect(is_active)
                    if is_active then
                        v:SetCanSelect(false)
                    end
                end
            end
        end
    end

end

---添加到缓存
function CatCardLogicCtrl:AddModelToPool(model_name, model)
    if not model_name or not model then
        return
    end
    if not self.pool_map[model_name] then
        self.pool_map[model_name] = {}
    end
    GameObjectUtil.SetActive(model, false)
    self:ResetModel(model)
    local map = self.pool_map[model_name]
    if not table.containsvalue(map, model) then
        table.insert(map, model)
    end
end

---重置model
function CatCardLogicCtrl:ResetModel(model, rotationZ)
    local eulerAngle = rotationZ and GameUtil.GetVector(self.zero_pos.x, self.zero_pos.y, rotationZ) or self.zero_pos
    GameObjectUtil.SetLocalPosition(model, self.zero_pos)
    GameObjectUtil.SetScale(model, self.one_pos)
    GameObjectUtil.SetLocalEulerAngles(GameObjectUtil.GetComponent(model, nil, "Transform"), eulerAngle)
    GameObjectUtil.SetLayer(model, Const.LayerMask.DEFAULT, true)
end

---从缓存中获取
function CatCardLogicCtrl:GetModelFromPool(model_name)
    local model
    local map = self.pool_map[model_name]
    if map and #map > 0 then
        model = table.remove(map)
    end
    return model
end

function CatCardLogicCtrl:RefreshModels(...)
    self:OnEventReleaseTempModel()
    self:OnEventReleaseShowModel()
    local card_type, is_force_replace, player_type = select(1, ...)
    ---加载root_model
    self:LoadRootModel()
    ---加载格子model
    if card_type == nil or card_type == CatCardConst.CardType.SLOT then
        self:LoadModels(CatCardConst.CardType.SLOT, nil, is_force_replace)
    end
    ---加载卡片model
    if card_type == nil or card_type == CatCardConst.CardType.CARD then
        for k, v in pairs(CatCardConst.PlayerType) do
            if player_type == nil or player_type == v then
                self:LoadModels(CatCardConst.CardType.CARD, v, is_force_replace)
            end
        end
        if self.bll:GetMode() ~= CatCardConst.ModeType.Func then
            EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_CARD_CAN_SELECT)
        end
    end
    self:RefreshStack()
end

---获取模型所属父节点
---@param card_type CatCardConst.CardType
---@param pos_index int
---@param player_type CatCardConst.PlayerType
---@return GameObject
function CatCardLogicCtrl:GetModelParent(card_type, pos_index, player_type)
    local model = self:GetModel(card_type, pos_index, player_type)
    if model then
        return model.gameObject
    else
        return GameObjectUtil.GetComponent(self.root_model, self:GetModelParentName(card_type, pos_index, player_type))
    end

end

---加载特效
function CatCardLogicCtrl:LoadEffect(effect_name, parent)
    local pool = self.effect_pool[effect_name]
    local effect = nil
    if table.isnilorempty(pool) then
        effect = GameObjectUtil.InstantiateGameObject(self.effect_template[effect_name], parent)
    else
        effect = table.remove(pool)
    end
    if not effect then
        Debug.LogErrorFormat("[喵喵牌]LoadEffect[%s]--failed ", effect_name)
        return nil
    end
    if parent then
        GameObjectUtil.SetParent(effect.transform, parent)
    end
    self:ResetModel(effect)
    GameObjectUtil.SetActive(effect, true)
    return effect
end

---把特效添加到缓存池
function CatCardLogicCtrl:AddEffectToPool(effect_name, effect)
    local pool = self.effect_pool[effect_name]
    if not pool then
        pool = {}
        self.effect_template[effect_name] = effect
        self.effect_pool[effect_name] = pool
    end
    table.insert(pool, effect)
    GameObjectUtil.SetActive(effect, false)
end

---GetPosByIndex
---根据类型获取坐标
function CatCardLogicCtrl:GetPos(card_type, pos_index, player_type)
    local model = self:GetModel(card_type, pos_index, player_type)
    if model then
        return model:GetPosition()
    else
        local obj = GameObjectUtil.GetComponent(self.root_model, self:GetModelParentName(card_type, pos_index, player_type))
        return GameObjectUtil.GetPosition(obj)
    end
end

---获取原始坐标
function CatCardLogicCtrl:GetOriginPos(card_type, pos_index, player_type)
    local model = self:GetModel(card_type, pos_index, player_type)
    if model then
        return model:GetOriginPos()
    else
        return self:GetPos(card_type, pos_index, player_type)
    end
end

---获取飞行坐标
function CatCardLogicCtrl:GetMovePos(card_type, pos_index, player_type)
    local model = self:GetModel(card_type, pos_index, player_type)
    if model then
        return model:GetMoveTargetPos(player_type)
    else
        return self:GetPos(card_type, pos_index, player_type)
    end
end

---获取slot牌堆位置
---@param card_type CatCardConst.CardType
---@param pos_index int
---@param player_type CatCardConst.PlayerType
---@return GameObject
function CatCardLogicCtrl:GetSlotStackNode(card_type, pos_index, player_type)
    local model = self:GetModel(card_type, pos_index, player_type)
    return model:GetSlotStack(player_type)
end

---@param sub_type CatCardConst.SubType
---@param card_type CatCardConst.CardType
---@param pos_index int
---@param player_type CatCardConst.PlayerType
---@return GameObject
function CatCardLogicCtrl:GetSlotStackNodeByType(sub_type, card_type, pos_index, player_type)
    if sub_type == CatCardConst.SubType.FUNCCARD then
        local conf = CatCardConst.PlayerTypeConf[player_type]
        return GameObjectUtil.GetComponent(self.root_model, conf.func_card_stack)
    else
        return self:GetSlotStackNode(card_type, pos_index, player_type)
    end
end

---获取抢牌卡坐标位置
function CatCardLogicCtrl:GetRobPos(pos_index)
    return pos_index and self.rob_origin_pos[pos_index] or nil
end

---设置robnode 选中状态
function CatCardLogicCtrl:SetRobNodeSelect(is_select, pos_index, no_check_effect)
    self:SetRobNodeCanSelect(false)
    if not pos_index then
        for k, v in pairs(self.rob_origin_pos) do
            self:SetRobNodeSelect(is_select, k)
        end
        return
    end
    local rob_node = self:GetRobNode(pos_index)
    local origin_pos = self.rob_origin_pos[pos_index]
    if not origin_pos then
        origin_pos = rob_node.transform.position
        self.rob_origin_pos[pos_index] = origin_pos
    end
    local pos
    if is_select then
        pos = origin_pos - rob_node.transform.up * CatCardConst.MODEL_SELECT_OFFSET
    else
        pos = origin_pos
    end
    GameObjectUtil.SetPosition(rob_node, pos)
    if no_check_effect then
        return
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_UI_EFFECT, is_select and CatCardConst.EffectState.SHOW or CatCardConst.EffectState.HIDE, pos_index, CatCardConst.Effect.CARD_SELECTED_UI, self.rob_stack_pos_map[pos_index], true)
end

---设置可选中状态
---@param is_select boolean
---@param pos_index int
function CatCardLogicCtrl:SetRobNodeCanSelect(is_select, pos_index)
    --todo 临时屏蔽,等等策划后面讨论具体实现方案
    --if not pos_index then
    --    local datas = self.bll:GetDataList(CatCardConst.CardType.CARD,CatCardConst.PlayerType.ENEMY)
    --    for k,v in pairs(datas) do
    --        self:SetRobNodeCanSelect(is_select,v:GetIndex())
    --    end
    --    return
    --end
    --local pos = self.rob_stack_pos_map[pos_index]
    --EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_CHECK_UI_EFFECT,is_select and CatCardConst.EffectState.SHOW or CatCardConst.EffectState.HIDE,pos_index,CatCardConst.Effect.CARD_CAN_SELECT_UI,pos,true)
end

---获取抢牌node
function CatCardLogicCtrl:GetRobNode(pos_index)
    local obj = self.rob_stack_nodes[pos_index]
    if not obj then
        local type_conf = CatCardConst.TypeConf[CatCardConst.CardType.CARD]
        local player_type = CatCardConst.PlayerType.ENEMY
        obj = GameObjectUtil.GetComponent(self.rob_card_show_root_model, string.concat(CatCardConst.ROB_POS_NAME, pos_index - type_conf.POS_INDEX))
        obj.name = string.concat(player_type == nil and type_conf.NODE_PREFIX or type_conf.NODE_PREFIX[player_type], pos_index)
        self.rob_stack_nodes[pos_index] = obj
    end
    return obj
end

---获取slot槽位node
function CatCardLogicCtrl:GetSlotNode(pos_index)
    if pos_index > CatCardConst.SLOT_COUNT then
        return
    end
    local obj = self.slot_node_map[pos_index]
    if not obj then
        local type_conf = CatCardConst.TypeConf[CatCardConst.CardType.SLOT]
        local pos_name = string.concat(type_conf.POS, pos_index - 1)
        obj = GameObjectUtil.GetComponent(self.root_model, pos_name, "Transform")
        self.slot_node_map[pos_index] = obj
    end
    return obj
end

---获取功能牌面node
function CatCardLogicCtrl:GetFuncNode(pos_index)
    if pos_index > CatCardConst.MAX_FUNCCARD_COUNT then
        return
    end
    local obj = self.funccard_stack_nodes[pos_index]
    if not obj then
        obj = GameObjectUtil.GetComponent(self.func_card_show_root_model, string.concat(CatCardConst.ROB_POS_NAME, pos_index))
        obj.name = string.concat("Discard_", pos_index)
        self.funccard_stack_nodes[pos_index] = obj
    end
    return obj
end

---@param player_type CatCardConst.PlayerType
---@return GameObject
function CatCardLogicCtrl:GetDiscardStackNode(player_type)
    if not self.discard_stack_node then
        self.discard_stack_node = GameObjectUtil.GetComponent(self.root_model, CatCardConst.DISCARD_CARD_NODE)
    end
    return self.discard_stack_node
end

---获得立牌面展示中心节点
---@return GameObject
function CatCardLogicCtrl:GetDiscardShowCenter()
    if not self.discard_show_center then
        self.discard_show_center = GameObjectUtil.GetComponent(self.root_model, CatCardConst.DISCARD_SHOW_CENTER)
        self.show_center_screen_pos = self:WorldPosToScreen(GameObjectUtil.GetPosition(self.discard_show_center))
    end
    return self.discard_show_center, self.show_center_screen_pos
end

---获取牌堆位置节点
---@param sub_type CatCardConst.SubType
function CatCardLogicCtrl:GetStackPosNode(sub_type)
    return self.card_stack_model:GetStackPosNode(sub_type)
end

---获取robmodel
function CatCardLogicCtrl:SetModelMaskActive(is_active)
    GameObjectUtil.SetActive(self.model_mask, is_active)
end

---获取结算猫
function CatCardLogicCtrl:GetReslutCatModel(res_type)
    local round_conf = CatCardConst.RoundConf[res_type]
    local cat = self.round_res_cat_map[round_conf.cat_root]
    if not cat then
        cat = GameObjectUtil.GetComponent(self.round_res_root, string.concat(round_conf.cat_root, "/", round_conf.cat_name), "Transform")
        if cat then
            GameObjectUtil.SetActive(cat.parent.gameObject, true)
            cat = cat:GetChild(0)
        end
        if cat then
            self.round_res_cat_map[round_conf.cat_root] = cat.gameObject
        end
    end
    return self.round_res_cat_map[round_conf.cat_root]
end

---设置显示猫
function CatCardLogicCtrl:SetResultCatActive(res_type, is_active)
    local cat = self:GetReslutCatModel(res_type)
    GameObjectUtil.SetActive(cat, is_active)
end

function CatCardLogicCtrl:SetResultCatModelsActive(is_active)
    for k, v in pairs(self.round_res_cat_map) do
        GameObjectUtil.SetActive(v, is_active)
    end
end

---根据类型加载
function CatCardLogicCtrl:LoadModels(card_type, player_type, is_force_replace)
    local datas = self.bll:GetDataList(card_type, player_type)
    local type_conf = CatCardConst.TypeConf[card_type]
    local map = self[type_conf.MODEL_MAP]
    local data_models = PoolUtil.GetTable()
    for k, v in pairs(datas) do
        local model = self:GetModel(card_type, v:GetIndex(), player_type)
        if not model then
            model = self:CreateModel(card_type, v:GetIndex(), player_type)
        else
            if is_force_replace then
                model:Refresh()
            end
            model:Refresh(v:GetIndex())
        end
        data_models[v:GetIndex()] = true
    end
    map = player_type and map[player_type] or map
    for k, v in pairs(map) do
        if not data_models[k] then
            self:RemoveModel(card_type, k, player_type)
        end
    end
    PoolUtil.ReleaseTable(data_models)
    PoolUtil.ReleaseTable(datas)
end

---设置model的层级
function CatCardLogicCtrl:SetModelsLayer(models, layer)
    layer = layer and layer or Const.LayerMask.DEFAULT
    for k, v in pairs(models) do
        GameObjectUtil.SetLayer(v, layer, true)
    end
end

---@param card_type CatCardConst.CardType
---@param player_type CatCardConst.PlayerType
---@return int
function CatCardLogicCtrl:GetModelsCount(card_type, player_type)
    local models = self:GetModels(card_type, player_type)
    local count = #models
    PoolUtil.ReleaseTable(models)
    return count
end

---根据类型获取当前所有models
---@param card_type CatCardConst.CardType
---@param player_type CatCardConst.PlayerType
---@return CatCardBaseLogic[]
function CatCardLogicCtrl:GetModels(card_type, player_type)
    local type_conf = CatCardConst.TypeConf[card_type]
    ---@type CatCardBaseLogic[]
    local map = self[type_conf.MODEL_MAP]
    if map and player_type ~= nil then
        map = map[player_type]
    end
    local models = {}
    if map then
        for k, v in pairs(map) do
            if v:IsValid() then
                table.insert(models, v)
            end
        end
    end
    return models
end

---获取model
---@param card_type CatCardConst.CardType
---@param index int
---@param player_type CatCardConst.PlayerType
---@return CatCardBaseLogic
function CatCardLogicCtrl:GetModel(card_type, index, player_type)
    local type_conf = CatCardConst.TypeConf[card_type]
    local get_model_func = self[type_conf.GET_MODEL]
    local model = get_model_func(self, index, player_type)
    return model
end

---刷新卡牌遮罩状态
function CatCardLogicCtrl:RefreshMarkState()
    local card_models = self.card_models[CatCardConst.PlayerType.PLAYER]
    for _, cardLogic in pairs(card_models) do
        cardLogic:SetMaskState()
    end
end

---@param card_type CatCardConst.CardType
---@param index int
---@param player_type CatCardConst.PlayerType
---@param effect_state CatCardConst.EffectState
function CatCardLogicCtrl:RefreshPosMarkState(card_type, index, player_type, effect_state)
    local model = self:GetModel(card_type, index, player_type)
    if model then
        model:SetMaskState(effect_state)
    end
end

function CatCardLogicCtrl:GetSlot(id)
    return id and self.slot_models[id] or nil
end

function CatCardLogicCtrl:GetCard(id, player_type)
    return (id and player_type and self.card_models[player_type]) and self.card_models[player_type][id] or nil
end

---加载UI显示预设
function CatCardLogicCtrl:LoadUIModel(model, card_id)
    if not model or not card_id then
        return
    end
    local tr_up = GameObjectUtil.GetComponent(model, "NumPosUp", "Transform")
    local cardData = LuaCfgMgr.Get("MiaoCardInfo", card_id)
    if cardData then
        local prefab = UIMgr.LoadDynamicUIPrefab(CatCardConst.CAT_CARD_UI_PREFAB_PATH)
        local cardInfo = LuaCfgMgr.Get("MiaoCardFuncEffect", cardData.Num)
        if prefab and cardInfo then
            prefab.transform:SetParent(tr_up, false)
            local txt_top = GameObjectUtil.GetComponent(prefab, "OCX_txt_TitleTop")
            UIUtil.SetText(txt_top, cardInfo.HandCardTag)
            local txt_title = GameObjectUtil.GetComponent(prefab, "OCX_txt_Title")
            UIUtil.SetText(txt_title, cardInfo.HandCardName)
            local txt_content = GameObjectUtil.GetComponent(prefab, "OCX_txt_Content")
            UIUtil.SetText(txt_content, cardInfo.HandCardDes)
        end
    end
end

---加载所有model统一接口
---@param model_name string
---@param load_type int
function CatCardLogicCtrl:LoadModel(model_name, load_type)
    if not model_name or model_name == "" then
        return nil
    end
    local model = self:GetModelFromPool(model_name)
    if not model then
        model = Res.LoadGameObject(model_name, load_type and load_type or ResType.T_DatingItem)
        if self.func_card_model_names[model_name] then
            --todo
            self:LoadUIModel(model, self.func_card_model_names[model_name])
        end
        table.insert(self.models, model)
    end
    GameObjectUtil.SetActive(model, true)
    return model
end

---加载root_model
function CatCardLogicCtrl:LoadRootModel()
    if self.root_model_loaded then
        return
    end
    self.root_model_loaded = true
    local cat_card_bll = BllMgr.GetCatCardBLL()
    local card_difficluity = cat_card_bll:GetStateData():GetMiaoCardDiff()
    local position = GameUtil.GetVector(card_difficluity.Pos.X, card_difficluity.Pos.Y, card_difficluity.Pos.Z)
    local rotation = GameUtil.GetVector(card_difficluity.Rot.X, card_difficluity.Rot.Y, card_difficluity.Rot.Z)
    local root_model = cat_card_bll:GetRootModel()
    self.root_model = self:LoadModel(root_model)
    self.card_stack_model = GameObjectCtrl.GetOrAddCtrl(self.root_model, CatCardConst.CARD_STACK_LUA_PATH, self)
    self.card_stack_model:SetBll(self.bll)
    self.rob_card_show_root_model = GameObjectUtil.GetComponent(self.root_model, CatCardConst.ROB_SHOW_MODEL_NAME)
    GameObjectUtil.SetActive(self.rob_card_show_root_model, true)
    self.func_card_show_root_model = GameObjectUtil.GetComponent(self.root_model, CatCardConst.FUNCTION_CARD_SHOW)
    GameObjectUtil.SetActive(self.func_card_show_root_model, true)
    local empty_click = GameObjectUtil.GetComponent(self.root_model, CatCardConst.CARD_EMPTY_CLICK, "GameObject")
    if empty_click then
        empty_click.name = string.concat(CatCardConst.CARD_EMPTY_CLICK, "_0")
    end
    self:InitResultModel()
    self:InitEffect()
    GameObjectUtil.SetPosition(self.root_model.transform, position)
    GameObjectUtil.SetEulerAngles(self.root_model.transform, rotation)
    self:InitFunCardNameMap()
    self:InitFuncNodePos()
    self:InitPlayNodePos()
    self:InitSlotPosMap()
end

---@param card_type CatCardConst.CardType
---@param pos_idx int
---@param player_type CatCardConst.PlayerType
---@return string
function CatCardLogicCtrl:GetModelName(card_type, pos_idx, player_type)
    local map = self.model_name_map[card_type]
    if not map then
        map = {}
        self.model_name_map[card_type] = map
    end
    if player_type then
        if not map[player_type] then
            map[player_type] = {}
        end
        map = map[player_type]
    end
    local name = ""
    if pos_idx then
        name = map[pos_idx]
        if not name then
            local type_conf = CatCardConst.TypeConf[card_type]
            name = string.concat(player_type == nil and type_conf.NODE_PREFIX or type_conf.NODE_PREFIX[player_type], pos_idx)
            map[pos_idx] = name
        end
    else
        Debug.LogError("pos_idx is nil")
    end

    return name
end

---@param card_type CatCardConst.CardType
---@param pos_idx int
---@param player_type CatCardConst.PlayerType
---@return string
function CatCardLogicCtrl:GetModelParentName(card_type, pos_idx, player_type)
    local nameMap = self.pos_name_map[card_type]
    if not nameMap then
        nameMap = {}
        self.pos_name_map[card_type] = nameMap
    end
    if player_type then
        if not nameMap[player_type] then
            nameMap[player_type] = {}
        end
        nameMap = nameMap[player_type]
    end
    local name = nameMap[pos_idx]
    if not name then
        local type_conf = CatCardConst.TypeConf[card_type]
        name = string.concat(player_type == nil and type_conf.POS or type_conf.POS[player_type], pos_idx - type_conf.POS_INDEX)
        nameMap[pos_idx] = name
    end
    return name
end

function CatCardLogicCtrl:InitResultModel()
    self.round_res_root = GameObjectUtil.GetComponent(self.root_model, CatCardConst.MODEL_ROUND_RES_NAME)
    for k, v in pairs(CatCardConst.RoundConf) do
        self:SetResultCatActive(k, false)
    end
    GameObjectUtil.SetActive(self.round_res_root, true)
end

function CatCardLogicCtrl:InitEffect()
    local root_trans = GameObjectUtil.GetComponent(self.root_model, CatCardConst.MODEL_EFFECT_NAME, "Transform")
    local child_count = root_trans.childCount
    for k = 0, child_count - 1 do
        local trans = root_trans:GetChild(k)
        local name = trans.name
        self:AddEffectToPool(name, trans.gameObject)
    end
    GameObjectUtil.SetActive(root_trans, true)
end

function CatCardLogicCtrl:WorldPosToScreen(world_pos, camera)
    camera = camera and camera or CameraUtil.GetSceneCamera()
    return CS.UnityEngine.RectTransformUtility.WorldToScreenPoint(camera, world_pos)
end

function CatCardLogicCtrl:InitRobNodePos()
    if #self.rob_stack_pos_map > 0 then
        return
    end
    for k = 1, CatCardConst.MAX_CARD_COUNT do
        local rob_node = self:GetRobNode(k)
        if rob_node then
            self:SetRobNodeSelect(true, k, true)
            table.insert(self.rob_stack_pos_map, self:WorldPosToScreen(rob_node.transform.position))
            self:SetRobNodeSelect(false, k, true)
        end
    end
end

function CatCardLogicCtrl:InitFunCardNameMap()
    local condition = PoolUtil.GetTable()
    condition.Class = CatCardConst.CardType.CARD
    condition.SubClass = CatCardConst.SubType.FUNCCARD
    ---@type cfg.MiaoCardInfo[]
    local list = LuaCfgMgr.GetListByCondition("MiaoCardInfo", condition)
    local res = self.func_card_model_names

    for k, v in pairs(list) do
        local card_data = self.bll:GenData(CatCardConst.CardType.CARD, v.Index, 0)
        res[card_data:GetCardModel()] = card_data:GetId()
        self.bll:ReleaseData(card_data)
    end
    PoolUtil.ReleaseTable(list)
    PoolUtil.ReleaseTable(condition)
end

function CatCardLogicCtrl:InitFuncNodePos()
    self.func_screen_pos_map = {}
    local func_node_list = {}
    for k = 1, CatCardConst.MAX_FUNCCARD_COUNT do
        local func_node = self:GetFuncNode(k)
        if func_node then
            table.insert(self.func_screen_pos_map, self:WorldPosToScreen(GameObjectUtil.GetPosition(func_node)))
            table.insert(func_node_list, func_node)
        end
    end
    self.bll:SetFuncNodeList(func_node_list)
end

function CatCardLogicCtrl:InitSlotPosMap()
    self.slot_pos_map = {}
    for i = 1, CatCardConst.SLOT_COUNT do
        local slotObj = self:GetSlotNode(i)
        local cardPos = GameObjectUtil.GetComponent(slotObj, CatCardConst.SLOT_CARD_MOVE_POS, "Transform")
        self.slot_pos_map[i] = self:WorldPosToScreen(GameObjectUtil.GetPosition(cardPos))
    end
    self.bll:SetSlotPosMap(self.slot_pos_map)
end

function CatCardLogicCtrl:InitPlayNodePos()
    self.play_card_pos_map = {}
    for k, v in pairs(CatCardConst.PlayerType) do
        local node = self:GetSlotStackNodeByType(CatCardConst.SubType.FUNCCARD, nil, nil, v)
        self.play_card_pos_map[v] = self:WorldPosToScreen(GameObjectUtil.GetPosition(node))
    end
    EventMgr.Dispatch(CatCardConst.Event.CAT_CARD_SET_PLAYCARD_POS, self.play_card_pos_map)
end

function CatCardLogicCtrl:GetPlayCardPos(playerType)
    return self.play_card_pos_map[playerType]
end

function CatCardLogicCtrl:GetFuncRootNodePosInfo()
    local pos = GameObjectUtil.GetPosition(self.func_card_show_root_model)
    return pos, self.func_card_show_root_model
end

function CatCardLogicCtrl:GetFuncScreenPosByIndex(index)
    return self.func_screen_pos_map[index]
end

---获取子节点
---@param nodeName string
---@return GameObject
function CatCardLogicCtrl:GetChildNode(nodeName)
    local node = GameObjectUtil.GetComponent(self.root_model, nodeName)
    return node
end

function CatCardLogicCtrl:Enter()
    self.super.Enter(self)
end

function CatCardLogicCtrl:Exit()
    if self.root_model then
        Res.DiscardGameObject(self.root_model)
    end
    self.super.Exit(self)
end

return CatCardLogicCtrl