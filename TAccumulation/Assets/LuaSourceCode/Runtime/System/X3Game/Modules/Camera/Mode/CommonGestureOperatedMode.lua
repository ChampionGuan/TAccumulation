---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canghai.
--- DateTime: 2023/11/14 11:27
---

---@class CommonGestureOperatedMode:CameraModeBase
local CommonGestureOperatedMode = class("CommonGestureOperatedMode", require("Runtime.System.X3Game.Modules.Camera.Base.CameraModeBase"))
CommonGestureOperatedMode.CameraClassType = CameraClassType.CommonGestureOperated --绑定CameraMode以及CameraClassType
local DOTween = CS.DG.Tweening.DOTween
local Ease = CS.DG.Tweening.Ease
local Flag = X3DataConst.CommonGestureOperatedModeFunctionFlag

---@param virtualCamera VirtualCameraBase
function CommonGestureOperatedMode:ctor(virtualCamera)
    ---@type boolean 是否已经进入该模式
    self.isEnter = false
    ---@type CommonGestureOperatedCamera
    self.virtualCamera = virtualCamera
    ---- 常量 ----
    ---@type Vector2
    self.screenSize = CS.X3Game.CameraUtility.GetScreenSize()
    ---@type float 屏幕宽度
    self.screenWidth = self.screenSize.x
    ---@type float 屏幕高度
    self.screenHeight = self.screenSize.y
    ---@type float
    self.rad2Deg = 180 / math.pi
    ---@type float
    self.deg2Rad = math.pi / 180
    ---@type float
    self.threshold = 0.05

    ---- 功能控制参数 ----
    ---@type boolean 是否允许水平旋转
    self.isUseHorizontalRotate = false
    ---@type boolean 是否允许水平回弹
    self.isUseHorizontalRebound = false
    ---@type boolean 是否允许垂直旋转
    self.isUseVerticalRotate = false
    ---@type boolean 是否允许垂直回弹
    self.isUseVerticalRebound = false
    ---@type boolean 是否允许垂直移动
    self.isUseVerticalMove = false
    ---@type boolean 是否允许缩放
    self.isUseZoom = false

    ---- 旋转模式参数 ----
    ---@type X3DataConst.CommonGestureOperatedModeRotateModel 旋转模式（默认是球面）
    self.rotateModel = X3DataConst.CommonGestureOperatedModeRotateModel.Sphere
    ---@type float[]
    self.rotateModelParam = nil

    ---- 水平旋转参数 ----
    ---@type float[] 水平旋转角度区间配置
    self.horizontalRotateRangeConfig = nil
    ---@type float[] 水平旋转角度区间根据初始Yaw算出
    self.horizontalRotateRange = nil
    ---@type float[] 水平旋转角度最大区间根据"旋转角度区间"以及"回弹区间"算出
    self.horizontalRotateMaxRange = nil
    ---@type float 水平旋转速度，表示从屏幕最左侧滑动到最右侧能转动的角度（默认是 horizontalRotateMaxRange 的范围）
    self.horizontalRotateSpeed = 0
    ---@type float 水平回弹速度 (10 表示每秒 10°)
    self.horizontalReboundSpeed = 10
    ---@type float[] 水平旋转回弹区间 {-5, 5} 表示上限和下限都能突破5°，当超过突破前的上限和下限时会触发回弹
    self.horizontalReboundRange = nil

    ---- 垂直旋转参数 ----
    ---@type float[] 垂直旋转角度区间配置
    self.verticalRotateRangeConfig = nil
    ---@type float[] 垂直旋转角度区间根据初始Yaw算出
    self.verticalRotateRange = nil
    ---@type float[] 垂直旋转角度最大区间根据"旋转角度区间"以及"回弹区间"算出
    self.verticalRotateMaxRange = nil
    ---@type float 垂直旋转速度，表示从屏幕最上侧滑动到最下侧能转动的角度（默认是 verticalRotateMaxRange 的范围）
    self.verticalRotateSpeed = 0
    ---@type float 垂直回弹速度 (10 表示每秒 10°)
    self.verticalReboundSpeed = 10
    ---@type float[] 垂直旋转回弹区间 {-5, 5} 表示上限和下限都能突破5°，当超过突破前的上限和下限时会触发回弹
    self.verticalReboundRange = nil

    ---- 垂直移动参数 ----
    ---@type float[] 垂直移动区间配置
    self.verticalMoveRangeConfig = nil
    ---@type float[] 垂直移动区间范围，根据初值Target位置算出
    self.verticalMoveRange = nil
    ---@type float 垂直移动速度，表示从屏幕顶端滑动到底部能目标点能移动的距离（默认是 verticalMoveRangeConfig 的范围）
    self.verticalMoveSpeed = 0

    ---- 缩放参数 ---
    ---@type float[] 缩放区间范围，根据初值Distance算出
    self.zoomRange = nil
    ---@type float[] 缩放区间配置
    self.zoomRangeConfig = nil
    ---@type float 缩放速度，默认是 缩放范围/2 代表100%
    self.zoomSpeed = 0

    ---- 初始参数（可以用于重置视角） ----
    ---@type Vector3 初始目标点位置
    self.originTargetPos = Vector3.zero_readonly
    ---@type Vector3 初始相机的位置 
    self.originCameraPos = Vector3.zero_readonly
    ---@type Vector3 初始相机的旋转值
    self.originCameraRot = Vector3.zero_readonly
    ---@type float 初始的距离
    self.originDistance = 0

    ---- 运行时参数 ----
    ---@type float 俯仰角
    self.pitchAngle = 0
    ---@type float 航角
    self.yawAngle = 0
    ---@type float 相机距离真实目标点的距离
    self.distance = 0
    ---@type Vector3 真实目标点相对初始目标点的偏移量
    self.originTargetOffSet = Vector3.zero_readonly
    ---@type boolean 是否已经初始化过目标
    self.isInitTarget = false

    ---- 手势相关参数 ----
    ---@type InputComponent
    self.gestureCtrl = nil
    ---@type DG.Tweening.Tweener
    self.horizontalReboundTweener = nil
    ---@type DG.Tweening.Tweener
    self.verticalReboundTweener = nil

    ---- X3Data ----
    ---@type X3Data.CommonGestureOperatedModeData
    self.data = X3DataMgr.GetOrAdd(X3DataConst.X3Data.CommonGestureOperatedModeData)
end

--相机被激活时调用
function CommonGestureOperatedMode:OnEnter(...)
    self.isEnter = true
end

function CommonGestureOperatedMode:OnDestroy()
    self:Clear()
end

---清理数据
function CommonGestureOperatedMode:Clear()
    self.isEnter = false
    ---- 功能控制参数 ----
    self.isUseHorizontalRotate = false
    self.isUseHorizontalRebound = false
    self.isUseVerticalRotate = false
    self.isUseVerticalRebound = false
    self.isUseVerticalMove = false
    self.isUseZoom = false
    ---- 水平旋转参数 ----
    self.horizontalRotateRangeConfig = nil
    PoolUtil.ReleaseTable(self.horizontalRotateRange)
    self.horizontalRotateRange = nil
    PoolUtil.ReleaseTable(self.horizontalRotateMaxRange)
    self.horizontalRotateMaxRange = nil
    self.horizontalRotateSpeed = 0
    self.horizontalReboundSpeed = 10
    self.horizontalReboundRange = nil
    if self.horizontalReboundTweener then
        self.horizontalReboundTweener:Kill()
        self.horizontalReboundTweener = nil
    end
    ---- 垂直旋转参数 ----
    self.verticalRotateRangeConfig = nil
    PoolUtil.ReleaseTable(self.verticalRotateRange)
    self.verticalRotateRange = nil
    PoolUtil.ReleaseTable(self.verticalRotateMaxRange)
    self.verticalRotateMaxRange = nil
    self.verticalRotateSpeed = 0
    self.verticalReboundSpeed = 10
    self.verticalReboundRange = nil
    if self.verticalReboundTweener then
        self.verticalReboundTweener:Kill()
        self.verticalReboundTweener = nil
    end
    ---- 垂直移动参数 ----
    self.verticalMoveRangeConfig = nil
    PoolUtil.ReleaseTable(self.verticalMoveRange)
    self.verticalMoveRange = nil
    self.verticalMoveSpeed = 0
    ---- 缩放参数 ----
    PoolUtil.ReleaseTable(self.zoomRange)
    self.zoomRange = nil
    self.zoomRangeConfig = nil
    self.zoomSpeed = 0
    ---- 其它参数 ----
    self.originTargetPos = Vector3.zero_readonly
    self.originCameraPos = Vector3.zero_readonly
    self.originCameraRot = Vector3.zero_readonly
    self.originDistance = 0
    self.pitchAngle = 0
    self.yawAngle = 0
    self.distance = 0
    self.originTargetOffSet = Vector3.zero_readonly
    GameObjClickUtil.Remove(self.virtualCamera._rootG)
    self.gestureCtrl = nil
    self.isInitTarget = false
    ---- X3Data ----
    self.data = nil
    X3DataMgr.RemoveAll(X3DataConst.X3Data.CommonGestureOperatedModeData)
    EventMgr.RemoveListenerByTarget(self)
end

--region Init Func
---@param refCamera Cinemachine.CinemachineVirtualCameraBase 参考相机
---@param originTargetPos Vector3 初始目标点位置
function CommonGestureOperatedMode:Init(refCamera, originTargetPos)
    refCamera = refCamera or GlobalCameraMgr.GetCurrCineMachineCamera()
    if refCamera == nil then
        Debug.LogError("CommonGestureOperatedMode 没有参考相机，请检查场景中是否存在激活的 CinamchineVirtualCamera")
        return
    end

    --继承FOV（目前不提供配置）
    self.virtualCamera:SetFov(refCamera.m_Lens.FieldOfView)
    self.originTargetPos = originTargetPos or Vector3.zero_readonly
    self.originCameraPos = refCamera.transform.position
    self.originCameraRot = refCamera.transform.rotation.eulerAngles
    GameObjectUtil.SetPosition(self.virtualCamera._rootG, self.originCameraPos.x, self.originCameraPos.y, self.originCameraPos.z)

    ---- 计算参数 ----
    local realTargetPos = Vector3.Get()
    self:_GetRealTargetPos(self.originCameraPos, self.originCameraRot, self.originTargetPos, realTargetPos)
    self.virtualCamera:LookAt(realTargetPos)
    --TODO GC
    self.originTargetOffSet = realTargetPos - self.originTargetPos
    local direction = Vector3.Get()
    Vector3Helper.Add(direction, self.originCameraPos)
    Vector3Helper.Sub(direction, realTargetPos)
    self.pitchAngle, self.yawAngle = self:_CalPitchAndYawAngle(direction)
    self.data:SetInitYawAngle(self.yawAngle)
    self.data:SetInitPitchAngle(self.pitchAngle)
    self.distance = Vector3.Distance(self.originCameraPos, realTargetPos)
    self.originDistance = self.distance
    self.isInitTarget = true
    self.data:SetYawAngle(self.yawAngle)
    EventMgr.AddListener(Const.Event.DEVICE_ORATION_CHANGED, self._OnOrationChanged, self)
    ---释放临时Vector
    Vector3.Release(realTargetPos)
    Vector3.Release(direction)

    --设置虚拟相机以及手势
    self.virtualCamera:SetLookAt(nil)
    self.virtualCamera:SetFollow(nil)
    if not self.gestureCtrl then
        self.gestureCtrl = GameObjClickUtil.Get(self.virtualCamera._rootG)
        self.gestureCtrl:SetCtrlType(GameObjClickUtil.CtrlType.DRAG | GameObjClickUtil.CtrlType.MULTI_TOUCH)
        --不设置点击就会触发拖拽（单位是像素）
        self.gestureCtrl:SetMoveThresholdDis(10)
        self.gestureCtrl:SetDelegate(self)
    end
end

---初始化水平旋转数据
---@param horizontalRotateRange float[] 水平旋转角度区间
---@param horizontalRotateSpeed float 水平旋转速度（从屏幕左侧滑动到右侧能转动的角度）
---@param horizontalReboundRange float[] 水平旋转回弹区间
---@param horizontalReboundSpeed float 水平回弹速度
function CommonGestureOperatedMode:InitHorizontalRotateData(horizontalRotateRange, horizontalRotateSpeed, horizontalReboundRange, horizontalReboundSpeed)
    if not self:_InitCheck() then
        return
    end

    if horizontalRotateRange == nil or #horizontalRotateRange ~= 2 or horizontalRotateRange[2] <= horizontalRotateRange[1] then
        Debug.LogError("CommonGestureOperatedMode 水平旋转限制区间配置错误")
        return
    end

    self.horizontalRotateRangeConfig = horizontalRotateRange
    self.horizontalReboundRange = horizontalReboundRange or { 0, 0 }
    self.horizontalRotateRange = PoolUtil.GetTable()
    self.horizontalRotateRange[1] = self.horizontalRotateRangeConfig[1] + self.yawAngle
    self.horizontalRotateRange[2] = self.horizontalRotateRangeConfig[2] + self.yawAngle
    self.horizontalRotateMaxRange = PoolUtil.GetTable()
    self.horizontalRotateMaxRange[1] = self.horizontalRotateRange[1] + self.horizontalReboundRange[1]
    self.horizontalRotateMaxRange[2] = self.horizontalRotateRange[2] + self.horizontalReboundRange[2]
    self.horizontalReboundSpeed = horizontalReboundSpeed or 10 --默认是10
    self.horizontalRotateSpeed = horizontalRotateSpeed or self.horizontalRotateMaxRange[2] - self.horizontalRotateMaxRange[1]
    self:_InitYawLimits()
end

---初始化垂直旋转数据
---@param verticalRotateRange float[] 垂直旋转角度区间
---@param verticalRotateSpeed float 垂直旋转速度（从屏幕顶部滑动到底部能转动的角度）
---@param verticalReboundRange float[] 垂直旋转回弹区间
---@param verticalReboundSpeed float 垂直回弹速度
function CommonGestureOperatedMode:InitVerticalRotateData(verticalRotateRange, verticalRotateSpeed, verticalReboundRange, verticalReboundSpeed)
    if not self:_InitCheck() then
        return
    end

    if verticalRotateRange == nil or #verticalRotateRange ~= 2 or verticalRotateRange[2] <= verticalRotateRange[1] then
        Debug.LogError("CommonGestureOperatedMode 垂直旋转限制区间配置错误")
        return
    end

    self.verticalRotateRangeConfig = verticalRotateRange
    self.verticalReboundRange = verticalReboundRange or { 0, 0 }
    self.verticalRotateRange = PoolUtil.GetTable()
    self.verticalRotateRange[1] = self.verticalRotateRangeConfig[1] + self.pitchAngle
    self.verticalRotateRange[2] = self.verticalRotateRangeConfig[2] + self.pitchAngle
    self.verticalRotateMaxRange = PoolUtil.GetTable()
    self.verticalRotateMaxRange[1] = self.verticalRotateRange[1] + self.verticalReboundRange[1]
    self.verticalRotateMaxRange[2] = self.verticalRotateRange[2] + self.verticalReboundRange[2]
    self.verticalReboundSpeed = verticalReboundSpeed or 10 --默认是10
    self.verticalRotateSpeed = verticalRotateSpeed or self.verticalRotateMaxRange[2] - self.verticalRotateMaxRange[1]
    self:_InitYawLimits()
end

---初始化垂直移动数据
---@param verticalMoveRange float[] 垂直移动区间
---@param verticalMoveSpeed float 垂直移动速度（从屏幕顶部滑动到底部目标点能移动的距离）
function CommonGestureOperatedMode:InitVerticalMoveData(verticalMoveRange, verticalMoveSpeed)
    if not self:_InitCheck() then
        return
    end

    if verticalMoveRange == nil or #verticalMoveRange ~= 2 or verticalMoveRange[2] <= verticalMoveRange[1] then
        Debug.LogError("CommonGestureOperatedMode 垂直移动区间配置错误")
        return
    end

    self.verticalMoveRangeConfig = verticalMoveRange
    self.verticalMoveRange = PoolUtil.GetTable()
    self.verticalMoveRange[1] = self.verticalMoveRangeConfig[1] + self.originTargetOffSet.y
    self.verticalMoveRange[2] = self.verticalMoveRangeConfig[2] + self.originTargetOffSet.y
    self.verticalMoveSpeed = verticalMoveSpeed or self.verticalMoveRange[2] - self.verticalMoveRange[1]
end

---初始化缩放数据
---@param zoomRange float[] 垂直移动区间
---@param zoomSpeed float 缩放速度（默认是缩放区间）
function CommonGestureOperatedMode:InitZoomData(zoomRange, zoomSpeed)
    if not self:_InitCheck() then
        return
    end

    if zoomRange == nil or #zoomRange ~= 2 or zoomRange[2] <= zoomRange[1] then
        Debug.LogError("CommonGestureOperatedMode 缩放区间配置错误")
        return
    end

    self.zoomRangeConfig = zoomRange
    self.zoomRange = PoolUtil.GetTable()
    self.zoomRange[1] = self.zoomRangeConfig[1] + self.distance
    self.zoomRange[2] = self.zoomRangeConfig[2] + self.distance
    self.zoomSpeed = zoomSpeed or self.zoomRangeConfig[2] - self.zoomRangeConfig[1]
end

---初始化旋转模式
---@param rotateModel X3DataConst.CommonGestureOperatedModeRotateModel 旋转模式
---@vararg any
function CommonGestureOperatedMode:InitRotateModel(rotateModel, ...)
    if not self:_InitCheck() then
        return
    end

    self.rotateModel = rotateModel or self.rotateModel
    local params = { ... }
    if table.isnilorempty(params) then
        if self.rotateModel == X3DataConst.CommonGestureOperatedModeRotateModel.Ellipsoid then
            Debug.LogError("CommonGestureOperatedMode 旋转模式为椭球时，需要传入椭球参数")
            return
        end
    else
        if self.rotateModel == X3DataConst.CommonGestureOperatedModeRotateModel.Ellipsoid then
            if #params ~= 3 then
                if #params == 1 then
                    self.rotateModelParam = { self.distance, params[1], self.distance }
                else
                    Debug.LogError("CommonGestureOperatedMode 旋转模式为椭球时，需要传入x,y,z三个半轴的长度，或者只传入y半轴的长度，x,z用distance替代")
                    return
                end
            else
                self.rotateModelParam = params
            end
        end
    end
end

---设置相机开启的功能(不需要的可以传 nil 或者 false)
---@param flag X3DataConst.CommonGestureOperatedModeFunctionFlag
function CommonGestureOperatedMode:SetEnable(flag)
    self.isUseHorizontalRotate = (flag & Flag.HorizontalRotate ~= 0) or false
    self.isUseHorizontalRebound = (flag & Flag.HorizontalRebound ~= 0) or false
    self.isUseVerticalRotate = (flag & Flag.VerticalRotate ~= 0) or false
    self.isUseVerticalRebound = (flag & Flag.VerticalRebound ~= 0) or false
    self.isUseVerticalMove = (flag & Flag.VerticalMove ~= 0) or false
    self.isUseZoom = (flag & Flag.Zoom ~= 0) or false
end

---@private 初始化水平旋转角度限制范围
function CommonGestureOperatedMode:_InitYawLimits()
    self.data:ClearYawLimitsValue()
    self.data:AddYawLimitsValue(self.horizontalRotateMaxRange[1])
    self.data:AddYawLimitsValue(self.horizontalRotateRange[1])
    self.data:AddYawLimitsValue(self.horizontalRotateRange[2])
    self.data:AddYawLimitsValue(self.horizontalRotateMaxRange[2])
end
--endregion

--region Util Func
---根据参数刷新相机的状态
function CommonGestureOperatedMode:UpdateCameraState()
    if not self.isEnter then
        return
    end
    
    local realTargetPos = Vector3.Get()
    Vector3Helper.Add(realTargetPos, self.originTargetPos)
    Vector3Helper.Add(realTargetPos, self.originTargetOffSet)
    local direction = Vector3.Get()
    self:_GetDirection(self.pitchAngle, self.yawAngle, direction)
    local pos = Vector3.Get()
    if self.rotateModel == X3DataConst.CommonGestureOperatedModeRotateModel.Sphere then
        self:_GetSphereIntersectionPoint(realTargetPos, self.distance, direction, pos)
    elseif self.rotateModel == X3DataConst.CommonGestureOperatedModeRotateModel.Ellipsoid then
        local par1 = direction.x ^ 2 / self.rotateModelParam[1] ^ 2
        local par2 = direction.y ^ 2 / self.rotateModelParam[2] ^ 2
        local par3 = direction.z ^ 2 / self.rotateModelParam[3] ^ 2
        local lambda = math.sqrt(1 / (par1 + par2 + par3)) * (self.distance / self.originDistance)
        Vector3Helper.Add(pos, realTargetPos)
        Vector3Helper.Mul(direction, lambda)
        Vector3Helper.Add(pos, direction)
    end
    GameObjectUtil.SetPosition(self.virtualCamera._rootG, pos.x, pos.y, pos.z)
    self.virtualCamera:LookAt(realTargetPos)
    self.data:SetYawAngle(self.yawAngle)
    --释放临时Vector
    Vector3.Release(realTargetPos)
    Vector3.Release(direction)
    Vector3.Release(pos)
end

---重置镜头到Init的时候的状态
function CommonGestureOperatedMode:ResetCameraState()
    if not self.isEnter then
        return
    end
    
    local realTargetPos = Vector3.Get()
    self:_GetRealTargetPos(self.originCameraPos, self.originCameraRot, self.originTargetPos, realTargetPos)
    --TODO GC
    self.originTargetOffSet = realTargetPos - self.originTargetPos
    local direction = Vector3.Get()
    Vector3Helper.Add(direction, self.originCameraPos)
    Vector3Helper.Sub(direction, realTargetPos)
    self.pitchAngle, self.yawAngle = self:_CalPitchAndYawAngle(direction)
    self.distance = self.originDistance
    self:UpdateCameraState()
    Vector3.Release(realTargetPos)
    Vector3.Release(direction)
end

---给定一个resultVec，pitch和yaw计算相机的位置（会受到旋转模型以及缩放的影响）
---@param resultVec Vector3 必须传入一个Vector3，用于接收计算出来的方向
---@param pitch float 默认值是初始俯仰角
---@param yaw float 默认值是初始航角
function CommonGestureOperatedMode:CalCameraPos(resultVec, pitch, yaw)
    if not resultVec then
        Debug.LogError("ResultVec 为空请检查!!!")
        return
    end

    if pitch == nil then
        pitch = self.data:GetInitPitchAngle()
    end

    if yaw == nil then
        yaw = self.data:GetInitYawAngle()
    end

    local realTargetPos = Vector3.Get()
    Vector3Helper.Add(realTargetPos, self.originTargetPos)
    Vector3Helper.Add(realTargetPos, self.originTargetOffSet)
    local direction = Vector3.Get()
    self:_GetDirection(pitch, yaw, direction)
    if self.rotateModel == X3DataConst.CommonGestureOperatedModeRotateModel.Sphere then
        self:_GetSphereIntersectionPoint(realTargetPos, self.distance, direction, resultVec)
    elseif self.rotateModel == X3DataConst.CommonGestureOperatedModeRotateModel.Ellipsoid then
        local par1 = direction.x ^ 2 / self.rotateModelParam[1] ^ 2
        local par2 = direction.y ^ 2 / self.rotateModelParam[2] ^ 2
        local par3 = direction.z ^ 2 / self.rotateModelParam[3] ^ 2
        local lambda = math.sqrt(1 / (par1 + par2 + par3)) * (self.distance / self.originDistance)
        Vector3Helper.Add(resultVec, realTargetPos)
        Vector3Helper.Mul(direction, lambda)
        Vector3Helper.Add(resultVec, direction)
    end
    Vector3.Release(realTargetPos)
    Vector3.Release(direction)
end

---@private
---根据相机的位置和旋转以及参考目标计算真实目标点的位置
---@param cameraPos Vector3
---@param cameraRot Vector3
---@param originTargetPos Vector3
---@param resultVec Vector3
function CommonGestureOperatedMode:_GetRealTargetPos(cameraPos, cameraRot, originTargetPos, resultVec)
    if not resultVec then
        return
    end

    local cameraXOZ = Vector3.Get(cameraPos.x, 0, cameraPos.z)
    local charXOZ = Vector3.Get(originTargetPos.x, 0, originTargetPos.z)
    local dis = Vector3.Distance(cameraXOZ, charXOZ)
    local rot = Quaternion.Get()
    Quaternion.Euler(cameraRot.x, cameraRot.y, cameraRot.z, rot)
    ---@type Vector3
    local forward = Vector3.Get()
    QuaternionHelper.MulVec3(rot, Vector3.forward_readonly, forward)
    forward:Normalize()
    local x, y, z = forward.x, forward.y, forward.z
    if math.abs(y) <= self.threshold then
        local angle = math.atan(y, math.sqrt(x * x + z * z))
        dis = dis / math.cos(angle)
    end

    Vector3Helper.Add(resultVec, cameraPos)
    Vector3Helper.Add(resultVec, Vector3Helper.Mul(forward, dis))

    --释放临时Vector
    Vector3.Release(cameraXOZ)
    Vector3.Release(charXOZ)
    Quaternion.Release(rot)
    Vector3.Release(forward)
end

---@private
---@param dir Vector3
---@return float,float pitch yaw
function CommonGestureOperatedMode:_CalPitchAndYawAngle(dir)
    dir:Normalize()
    local pitch = math.asin(dir.y) * self.rad2Deg
    local yaw = math.atan(dir.x, dir.z) * self.rad2Deg
    return pitch, yaw
end

---@private
---@param pitch Vector3
---@param yaw Vector3
---@param resultVec Vector3
function CommonGestureOperatedMode:_GetDirection(pitch, yaw, resultVec)
    if not resultVec then
        return
    end

    local pitchRad = pitch * self.deg2Rad
    local yawRad = yaw * self.deg2Rad
    resultVec.x = math.cos(pitchRad) * math.sin(yawRad)
    resultVec.y = math.sin(pitchRad)
    resultVec.z = math.cos(pitchRad) * math.cos(yawRad)
    resultVec:Normalize()
end

---@private
---获得球面与射线的交点
---@param center Vector3
---@param radius float
---@param direction Vector3
---@param resultVec Vector3
function CommonGestureOperatedMode:_GetSphereIntersectionPoint(center, radius, direction, resultVec)
    direction:Normalize()
    Vector3Helper.Add(resultVec, center)
    --创建临时 dir 缓存 direction 的值
    local dir = Vector3.Get(direction.x, direction.y, direction.z)
    Vector3Helper.Mul(dir, radius)
    Vector3Helper.Add(resultVec, dir)
    Vector3.Release(dir)
end
--endregion

--region Gesture Callback
---@private
---@param delta number 相对于上一次缩放变化量（放大（>0）:者缩小(<0)）
---@param scale number 相对于双手按下的时候为【标准1】开始计算双指缩放[0,无穷]
function CommonGestureOperatedMode:OnBeginDoubleTouchScale(delta, scale)
    if not self.isUseZoom or not self.isEnter then
        return
    end
end

---@private
---@param delta number 相对于上一次缩放变化量（放大（>0）:者缩小(<0)）
---@param scale number 双指缩放[0,无穷]
function CommonGestureOperatedMode:OnDoubleTouchScale(delta, scale)
    if not self.isUseZoom or not self.isEnter then
        return
    end

    local distance = self.distance - delta * self.zoomSpeed
    self.distance = math.clamp(distance, self.zoomRange[1], self.zoomRange[2])
    self:UpdateCameraState()
end

---@private
---@param delta number 相对于上一次缩放变化量（放大（>0）:者缩小(<0)）
---@param scale number 双指缩放[0,无穷]
function CommonGestureOperatedMode:OnEndDoubleTouchScale(delta, scale)
    if not self.isUseZoom or not self.isEnter then
        return
    end
end

---@private
---@param pos Vector2
function CommonGestureOperatedMode:OnBeginDrag(pos)
    if not self.isEnter then
        return
    end
    
    self.data:SetDragState(X3DataConst.CommonGestureOperatedModeDragState.DragStart)
    if self.horizontalReboundTweener then
        self.horizontalReboundTweener:Kill()
        self.horizontalReboundTweener = nil
        self.data:SetDragState(X3DataConst.CommonGestureOperatedModeDragState.HorizontalReboundEnd)
    end
end

---@private
---@param pos Vector2
---@param deltaPos Vector2
---@param gesture _Gesture
function CommonGestureOperatedMode:OnDrag(pos, deltaPos, gesture)
    if not self.isEnter then
        return
    end
    
    self.data:SetDragState(X3DataConst.CommonGestureOperatedModeDragState.Dragging)
    if self.isUseHorizontalRotate then
        --左滑yaw变小 右滑yaw增大
        if gesture == GameObjClickUtil.Gesture.LEFT or gesture == GameObjClickUtil.Gesture.RIGHT then
            self.yawAngle = self.yawAngle + deltaPos.x / self.screenWidth * self.horizontalRotateSpeed
            self.yawAngle = math.clamp(self.yawAngle,
                    self.horizontalRotateMaxRange[1], self.horizontalRotateMaxRange[2])
        end
    end

    --TODO 解决手势冲突
    if self.isUseVerticalRotate then
        if self.isUseVerticalMove then
            Debug.LogError("CommonGestureOperatedMode 垂直旋转和垂直移动不能同时开启")
            return
        end

        if gesture == GameObjClickUtil.Gesture.UP or gesture == GameObjClickUtil.Gesture.DOWN then
            --调整了方向
            self.pitchAngle = self.pitchAngle - deltaPos.y / self.screenHeight * self.verticalRotateSpeed
            self.pitchAngle = math.clamp(self.pitchAngle,
                    self.verticalRotateMaxRange[1], self.verticalRotateMaxRange[2])
        end
    end

    if self.isUseVerticalMove then
        if self.isUseVerticalRebound then
            Debug.LogError("CommonGestureOperatedMode 垂直旋转和垂直移动不能同时开启")
            return
        end

        if gesture == GameObjClickUtil.Gesture.UP or gesture == GameObjClickUtil.Gesture.DOWN then
            self.originTargetOffSet.y = self.originTargetOffSet.y + deltaPos.y / self.screenHeight * self.verticalMoveSpeed
            self.originTargetOffSet.y = math.clamp(self.originTargetOffSet.y, self.verticalMoveRange[1], self.verticalMoveRange[2])
        end
    end

    self:UpdateCameraState()
end

---@private
---@param pos Vector2
function CommonGestureOperatedMode:OnEndDrag(pos)
    if not self.isEnter then
        return
    end
    
    self.data:SetDragState(X3DataConst.CommonGestureOperatedModeDragState.DragEnd)
    if self.isUseHorizontalRotate and self.isUseHorizontalRebound then
        if self.yawAngle < self.horizontalRotateRange[1] then
            --处于最小值回弹区间
            local duration = (self.horizontalRotateRange[1] - self.yawAngle) / self.horizontalReboundSpeed
            self.horizontalReboundTweener = DOTween.To(handler(self, self._OnHorizontalReboundTick),
                    self.yawAngle, self.horizontalRotateRange[1], duration)
            self.horizontalReboundTweener:SetEase(Ease.OutCubic)
            self.horizontalReboundTweener:OnComplete(handler(self, self._OnTweenComplete))
        elseif self.yawAngle > self.horizontalRotateRange[2] then
            --处于最大值回弹区间
            local duration = (self.yawAngle - self.horizontalRotateRange[2]) / self.horizontalReboundSpeed
            self.horizontalReboundTweener = DOTween.To(handler(self, self._OnHorizontalReboundTick),
                    self.yawAngle, self.horizontalRotateRange[2], duration)
            self.horizontalReboundTweener:SetEase(Ease.OutCubic)
            self.horizontalReboundTweener:OnComplete(handler(self, self._OnTweenComplete))
        end
    end

    --TODO 垂直回弹存在冲突，想想怎么实现（应该是有先后）
end
--endregion

--region Tweener Callback
---@private
---@param value float
function CommonGestureOperatedMode:_OnHorizontalReboundTick(value)
    if not self.isEnter then
        return
    end
    
    self.yawAngle = value
    self:UpdateCameraState()
end

---@private
function CommonGestureOperatedMode:_OnTweenComplete()
    if not self.isEnter then
        return
    end
    
    self.horizontalReboundTweener = nil
    self.data:SetDragState(X3DataConst.CommonGestureOperatedModeDragState.HorizontalReboundEnd)
end
--endregion

--region Event
---@private
---横竖屏切换
function CommonGestureOperatedMode:_OnOrationChanged()
    if not self.isEnter then
        return
    end
    
    self.screenSize = CS.X3Game.CameraUtility.GetScreenSize()
    self.screenWidth = self.screenSize.x
    self.screenHeight = self.screenSize.y
end
--endregion

--region SafetyCheck
---@private
---@return boolean
function CommonGestureOperatedMode:_InitCheck()
    if not self.isInitTarget then
        Debug.LogError("CommonGestureOperatedMode 目标位置尚未设置，无法正确的初始化")
    end

    return self.isInitTarget
end
--endregion

function CommonGestureOperatedMode:BindImpulse()
    ---@type GameObject
    self.virtualCamera:AddCineMachineExtension(CameraExtensionType.ImpulseListener)
end

return CommonGestureOperatedMode