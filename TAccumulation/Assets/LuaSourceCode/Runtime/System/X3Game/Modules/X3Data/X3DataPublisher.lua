---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canghai.
--- DateTime: 2022/10/31 13:56
---

---负责X3DataPublisher的数据分发部分---
---@class X3DataPublisher
local X3DataPublisher = {}

---@type X3DataSafety
local X3DataSafety

---@type X3DataPool
local X3DataPool

---X3DataSys的数据变更回调
---@alias X3DataChangeDelegate fun(data:X3Data.X3DataBase, flag:X3DataConst.X3DataChangeFlag):void | fun(data:X3Data.X3DataBase):void

---用于索引 X3DataSubscribeRecord 的两个 key
---@class X3DataSubscribeRecordIndex
---@field firstKey string X3Data的类型
---@field secondKey string | X3DataConst.X3DataChangeFlag X3DataConst.X3DataChangeFlag 或 X3Data的FieldName

---回调方法与X3Data绑定的键值对类型
---@class X3DataSubscribeRecord
---@field callback X3DataChangeDelegate 回调不能为空
---@field target table --回调的发起者，nil表示回调是非对象方法

---数据增、删、变更的记录
---@class X3DataChangeRecord
---@field fieldName number Modify下才会关注
---@field flag X3DataConst.X3DataChangeFlag

--region Local Field
---@type table<string, table<X3DataConst.X3DataChangeFlag | string, X3DataSubscribeRecord[]>>
--- 一级Key是 X3Data的类型
--- 二级Key是 X3DataConst.X3DataChangeFlag 或 X3Data的FieldName
--- 三级是 X3DataSubscribeRecord 的数组(根据 callback 以及 target 进行去重)
local RecordMap = {}

---通过callback加索引反向查找
---@type table<X3DataChangeDelegate, X3DataSubscribeRecordIndex[]>
local CallbackIndexArrayDic = {}

---通过target加callback反向查找
---@type table<table, X3DataChangeDelegate[]>
local TargetCallbackArrayDic = {}

--- 存储变更的X3Data的队列，会直接用于推送给所有的针对X3Data类型注册监听的模块
---@type table<X3Data.X3DataBase, X3DataChangeRecord[]>
local X3DataChangeRecordArrayDic = {}

--- 当前是否需要推送
local IsDirty = false

--- 当前是否已经在Invoking
local IsInvoking = false

--- 当前是否禁用
local IsDisabled = false

--- 复合状态的集合，减少 if else
local CompositeFlagArrayDic = {
    [X3DataConst.X3DataChangeFlag.Modify] = { X3DataConst.X3DataChangeFlag.Modify, X3DataConst.X3DataChangeFlag.AddOrModify, X3DataConst.X3DataChangeFlag.RemoveOrModify, X3DataConst.X3DataChangeFlag.ALL },
    [X3DataConst.X3DataChangeFlag.Add] = { X3DataConst.X3DataChangeFlag.Add, X3DataConst.X3DataChangeFlag.AddOrModify, X3DataConst.X3DataChangeFlag.AddOrRemove, X3DataConst.X3DataChangeFlag.ALL },
    [X3DataConst.X3DataChangeFlag.Remove] = { X3DataConst.X3DataChangeFlag.Remove, X3DataConst.X3DataChangeFlag.RemoveOrModify, X3DataConst.X3DataChangeFlag.AddOrRemove, X3DataConst.X3DataChangeFlag.ALL }
}

--endregion Local Field 结束

---@param x3DataSafety X3DataSafety
function X3DataPublisher.InjectX3DataSafetyModule(x3DataSafety)
    X3DataSafety = x3DataSafety
end

---@param x3DataPool X3DataPool
function X3DataPublisher.InjectX3DataPoolModule(x3DataPool)
    X3DataPool = x3DataPool
end

---@param value boolean
function X3DataPublisher.SetIsDisabled(value)
    IsDisabled = value
end

---@return boolean
function X3DataPublisher.GetIsDisabled()
    return IsDisabled
end

--region 订阅和取消订阅
--- 订阅变更，如果可变参数为空，就是关于类型的变更，且为ALL
---@param x3DataType string X3Data的类型
---@param callback X3DataChangeDelegate
---@param target table 回调的发起者，nil表示回调是非对象方法
---@vararg number 关注的变更字段
---@return boolean
function X3DataPublisher.Subscribe(x3DataType, callback, target, ...)
    local fieldNameArray = { ... }
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if type(callback) ~= "function" then
            Debug.LogErrorWithTag(GameConst.LogTag.X3DataSys, "X3DataPublisher.Subscribe 失败，请检查 callback！！！")
            return false
        end

        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Subscribe") then
            return false
        end

        --允许 target 是 nil
        if target ~= nil and type(target) ~= "table" then
            Debug.LogErrorWithTag(GameConst.LogTag.X3DataSys, "X3DataPublisher.Subscribe 失败，请检查 target！！！")
            return false
        end

        for _, fieldName in pairs(fieldNameArray) do
            -- 这里的fieldName是value没法快速索引
            local result = false
            for _, v in pairs(X3DataConst.X3DataField[x3DataType]) do
                if v == fieldName then
                    result = true
                end
            end
            if result == false then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3DataPublisher.Subscribe 失败，%s 不是X3Data.%s的字段！！！", fieldName, x3DataType)
                return false
            end
        end
    end
    ---- 安全检查结束 ----

    ---- 针对字段进行回调 ----
    if not table.isnilorempty(fieldNameArray) then
        for _, fieldName in ipairs(fieldNameArray) do
            X3DataPublisher.AddRecord(callback, target, x3DataType, fieldName)
        end
    else
        local flag = X3DataConst.X3DataChangeFlag.ALL
        X3DataPublisher.AddRecord(callback, target, x3DataType, flag)
    end
    return true
end

---@param x3DataType string X3Data的类型
---@param callback X3DataChangeDelegate
---@param target table 回调的发起者，nil表示回调是非对象方法
---@param flag X3DataConst.X3DataChangeFlag 关注的变更类型默认是ALL
---@return boolean
function X3DataPublisher.SubscribeWithChangeFlag(x3DataType, callback, target, flag)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if type(callback) ~= "function" then
            Debug.LogErrorWithTag(GameConst.LogTag.X3DataSys, "X3DataPublisher.SubscribeWithChangeFlag 失败，请检查 callback！！！")
            return false
        end

        if not X3DataSafety.X3DataTypeCheck(x3DataType, "SubscribeWithChangeFlag") then
            return false
        end

        --允许 target 是 nil
        if target ~= nil and type(target) ~= "table" then
            Debug.LogErrorWithTag(GameConst.LogTag.X3DataSys, "X3DataPublisher.SubscribeWithChangeFlag 失败，请检查 target！！！")
            return false
        end

        if flag ~= nil and table.containsvalue(X3DataConst.X3DataChangeFlag[flag], flag) then
            Debug.LogErrorWithTag(GameConst.LogTag.X3DataSys, "X3DataPublisher.SubscribeWithChangeFlag 失败，请检查 flag！！！")
            return false
        end
    end
    ---- 安全检查结束 ----

    flag = flag or X3DataConst.X3DataChangeFlag.ALL
    X3DataPublisher.AddRecord(callback, target, x3DataType, flag)
    return true
end

---@param callback X3DataChangeDelegate
---@return boolean
function X3DataPublisher.Unsubscribe(callback)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if type(callback) ~= "function" then
            Debug.LogErrorWithTag(GameConst.LogTag.X3DataSys, "X3DataPublisher.Unsubscribe 失败，请检查 callback！！！")
            return false
        end
    end
    ---- 安全检查结束 ----

    X3DataPublisher.RemoveRecordByCallback(callback)
    return true
end

---@param target table
---@return boolean
function X3DataPublisher.UnsubscribeWithTarget(target)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if type(target) ~= "table" then
            Debug.LogErrorWithTag(GameConst.LogTag.X3DataSys, "X3DataPublisher.UnsubscribeWithTarget 失败，请检查 target！！！")
            return false
        end
    end
    ---- 安全检查结束 ----

    X3DataPublisher.RemoveRecordByTarget(target)
    return true
end
--endregion 订阅和取消订阅结束

--region 增加ChangeRecord 以及 Invoke
---将X3Data的变更记录加入 X3DataChangeRecordDic
---@param x3Data X3Data.X3DataBase
---@param flag X3DataConst.X3DataChangeFlag
---@param fieldName number
function X3DataPublisher.AddX3DataChangeRecord(x3Data, flag, fieldName)
    if IsDisabled then
        return
    end
    
    --基于X3Data回调做的X3Data的变动必须要在这一帧中做完，因此需要立即触发
    if IsInvoking then
        X3DataPublisher.InvokeImmediately(x3Data, flag, fieldName)  
        return
    end

    local recordArray = X3DataChangeRecordArrayDic[x3Data]
    if recordArray == nil then
        recordArray = PoolUtil.GetTable()
        X3DataChangeRecordArrayDic[x3Data] = recordArray
    end

    --去重
    for _, record in ipairs(recordArray) do
        if record.flag == flag and record.fieldName == fieldName then
            return
        end
    end

    ---@type X3DataChangeRecord
    local record = PoolUtil.GetTable()
    record.flag = flag
    record.fieldName = fieldName
    table.insert(recordArray, record)
    IsDirty = true
end

---发布变更信息，调用各模块注册的回调
function X3DataPublisher.InvokeX3DataChangeCallback()
    if not IsDirty or IsDisabled then
        return
    end

    IsInvoking = true
    for x3Data, recordArray in pairs(X3DataChangeRecordArrayDic) do
        --除了Remove的情况, 修改通知模式为只Invoke在数据库中的数据
        -- 检查该类型是否有回调注册进来
        local isRemoved = false
        if RecordMap[x3Data.__cname] ~= nil then
            for _, record in ipairs(recordArray) do
                --被 Remove 以后后续的回调都不触发了
                if not isRemoved then
                    if record.fieldName ~= nil then
                        if x3Data.__isInX3DataSet then
                            ---- 针对字段的回调 ----
                            -- flag 是 nil
                            X3DataPublisher.InvokeCallbackByField(x3Data, record.fieldName)
                        end
                    elseif record.flag ~= nil then
                        ---- 针对类型的回调 ----
                        -- 基础类型的 flag 会影响复合类型的 flag
                        if record.flag == X3DataConst.X3DataChangeFlag.Remove then
                            --remove 后续就不再通知了因为要 Release 数据
                            X3DataPublisher.InvokeCallbackByFlag(x3Data, record.flag)
                            X3DataPool.Release(x3Data)
                            isRemoved = true
                        elseif x3Data.__isInX3DataSet then
                            X3DataPublisher.InvokeCallbackByFlag(x3Data, record.flag)
                        end
                    end
                end

                PoolUtil.ReleaseTable(record)
            end
            PoolUtil.ReleaseTable(recordArray)
        end
        -- 回调触发完毕，可以重置X3Data的isDirty
        if not isRemoved then
            rawset(x3Data, "__isDirty", false)
        end
    end
    table.clear(X3DataChangeRecordArrayDic)
    IsDirty = false
    IsInvoking = false
end

---立即触发回调
---@private
---@param x3Data X3Data.X3DataBase
---@param flag X3DataConst.X3DataChangeFlag
---@param fieldName number
function X3DataPublisher.InvokeImmediately(x3Data, flag, fieldName)
    if IsDisabled then
        return
    end
    
    --除了Remove的情况, 修改通知模式为只Invoke在数据库中的数据
    if RecordMap[x3Data.__cname] == nil then
        rawset(x3Data, "__isDirty", false)
        return
    end

    if fieldName ~= nil then
        ---- 针对字段的回调 ----
        -- flag 是 nil
        if x3Data.__isInX3DataSet then
            X3DataPublisher.InvokeCallbackByField(x3Data, fieldName)
        end
        return
    end

    if flag ~= nil then
        ---- 针对类型的回调 ----
        -- Remove Flag 的数据在执行完成回调后会直接 Release 掉
        if flag == X3DataConst.X3DataChangeFlag.Remove then
            X3DataPublisher.InvokeCallbackByFlag(x3Data, flag)
            X3DataPool.Release(x3Data)
            return
        elseif x3Data.__isInX3DataSet then
            X3DataPublisher.InvokeCallbackByFlag(x3Data, flag)
        end
    end

    rawset(x3Data, "__isDirty", false)
end

---@private
---通过field触发回调
---@param x3Data X3Data.X3DataBase
---@param fieldName number
function X3DataPublisher.InvokeCallbackByField(x3Data, fieldName)
    local recordArray = RecordMap[x3Data.__cname][fieldName]
    if recordArray ~= nil then
        ---@type X3DataSubscribeRecord
        for _, subscribeRecord in ipairs(recordArray) do
            local callback = subscribeRecord.callback
            if subscribeRecord.target == nil then
                callback(x3Data)
            else
                callback(subscribeRecord.target, x3Data)
            end
        end
    end
end

---@private
---通过flag触发回调
---@param x3Data X3Data.X3DataBase
---@param flag X3DataConst.X3DataChangeFlag
function X3DataPublisher.InvokeCallbackByFlag(x3Data, flag)
    -- 基础类型的 flag 会影响复合类型的 flag
    local compositeFlagArray = CompositeFlagArrayDic[flag]
    for _, f in ipairs(compositeFlagArray) do
        local recordArray = RecordMap[x3Data.__cname][f]
        if recordArray ~= nil then
            ---@type X3DataSubscribeRecord
            for _, subscribeRecord in ipairs(recordArray) do
                local callback = subscribeRecord.callback
                if subscribeRecord.target == nil then
                    callback(x3Data, f)
                else
                    callback(subscribeRecord.target, x3Data, f)
                end
            end
        end
    end
end
--endregion

--region 增加Record
---@private
---向 recordArray 中增加 record 会自动去重
---@param callback X3DataChangeDelegate
---@param target table
---@param firstKey X3DataConst.X3Data X3Data类型
---@param secondKey X3DataConst.X3DataField | X3DataConst.X3DataChangeFlag X3DataConst.X3DataField 或 X3DataConst.X3DataChangeFlag
function X3DataPublisher.AddRecord(callback, target, firstKey, secondKey)
    if RecordMap[firstKey] == nil then
        RecordMap[firstKey] = PoolUtil.GetTable()
    end

    ---@type X3DataSubscribeRecord[]
    local recordArray = RecordMap[firstKey][secondKey]
    if recordArray == nil then
        RecordMap[firstKey][secondKey] = PoolUtil.GetTable()
        recordArray = RecordMap[firstKey][secondKey]
    end

    local isExist = false
    for _, record in ipairs(recordArray) do
        if record.callback == callback and record.target == target then
            isExist = true
            break
        end
    end

    if not isExist then
        ---@type X3DataSubscribeRecord
        local temp = PoolUtil.GetTable()
        temp.callback = callback
        temp.target = target
        table.insert(recordArray, temp)
        X3DataPublisher.AddCallbackIndexArray(callback, firstKey, secondKey, target)
        if target then
            X3DataPublisher.AddTargetIndexArray(target, callback)
        end
    end
end

---@private
---便于通过 callback 反订阅
---@param callback X3DataChangeDelegate
---@param firstKey X3DataConst.X3Data
---@param secondKey X3DataConst.X3DataField | X3DataConst.X3DataChangeFlag
---@param target table
function X3DataPublisher.AddCallbackIndexArray(callback, firstKey, secondKey, target)
    local indexArray = CallbackIndexArrayDic[callback]
    if indexArray == nil then
        indexArray = PoolUtil.GetTable()
        CallbackIndexArrayDic[callback] = indexArray
    end

    local isExist = false
    for _,recordIndex in ipairs(indexArray) do
        if recordIndex.firstKey == firstKey and recordIndex.secondKey == secondKey then
            isExist = true
            break
        end
    end

    if not isExist then
        ---@type X3DataSubscribeRecordIndex
        local temp = PoolUtil.GetTable()
        temp.firstKey = firstKey
        temp.secondKey = secondKey
        table.insert(indexArray, temp)
    end
end

---@private
---便于通过 target 反订阅(target 必须依赖 callback 才有意义)
---@param target table
---@param callback X3DataChangeDelegate
function X3DataPublisher.AddTargetIndexArray(target, callback)
    local callbackArray = TargetCallbackArrayDic[target]
    if callbackArray == nil then
        callbackArray = PoolUtil.GetTable()
        TargetCallbackArrayDic[target] = callbackArray
    end

    local isExist = false
    for _, value in ipairs(callbackArray) do
        if value == callback then
            isExist = true
            break
        end
    end

    if not isExist then
        table.insert(callbackArray, callback)
    end
end
--endregion

--region 删除Record
---@private
---通过 callback 删除 Record
---@param callback X3DataChangeDelegate
function X3DataPublisher.RemoveRecordByCallback(callback)
    local indexArray = CallbackIndexArrayDic[callback]
    if indexArray == nil then
        return
    end
    
    for i = #indexArray, 1, -1 do
        local recordIndex = indexArray[i]
        local recordArray = RecordMap[recordIndex.firstKey][recordIndex.secondKey]
        for j = #recordArray, 1, -1 do
            local record = recordArray[j]
            if record.callback == callback then
                --删除 TargetCallbackArrayDic 中关于 callback 的记录
                if record.target ~= nil then
                    local callbackArray = TargetCallbackArrayDic[record.target]
                    if callbackArray ~= nil then
                        for k = #callbackArray, 1, -1 do
                            if callbackArray[k] == callback then
                                table.remove(callbackArray, k)
                                break
                            end
                        end
                    end

                    --释放已经空了的target Array
                    if table.isnilorempty(callbackArray) then
                        TargetCallbackArrayDic[record.target] = nil
                        PoolUtil.ReleaseTable(callbackArray)
                    end
                end
                
                table.remove(recordArray, j)
                PoolUtil.ReleaseTable(record)
            end
        end

        --释放已经空了的recordArray
        if table.isnilorempty(recordArray) then
            PoolUtil.ReleaseTable(recordArray)
            RecordMap[recordIndex.firstKey][recordIndex.secondKey] = nil
        end
        
        PoolUtil.ReleaseTable(recordIndex)
    end
    
    --解除引用
    CallbackIndexArrayDic[callback] = nil
    PoolUtil.ReleaseTable(indexArray)
end

---@private
---通过 target 删除 Record
---@param target table
function X3DataPublisher.RemoveRecordByTarget(target)
    local callbackArray = TargetCallbackArrayDic[target]
    if callbackArray == nil then
        return
    end

    for idx = #callbackArray, 1, -1 do
        local callback = callbackArray[idx]
        local indexArray = CallbackIndexArrayDic[callback]
        if indexArray ~= nil then
            for i = #indexArray, 1, -1 do
                local recordIndex = indexArray[i]
                local recordArray = RecordMap[recordIndex.firstKey][recordIndex.secondKey]
                for j = #recordArray, 1, -1 do
                    local record = recordArray[j]
                    --这里不会有重复的，因为前面已经去重过
                    if record.callback == callback and record.target == target then
                        table.remove(recordArray, j)
                        break
                    end
                end

                --判断是否还有 callback 的引用(callback Index)
                local isNeedRemove = true
                --释放已经空了的recordArray
                if table.isnilorempty(recordArray) then
                    PoolUtil.ReleaseTable(recordArray)
                    RecordMap[recordIndex.firstKey][recordIndex.secondKey] = nil
                    --释放最外层
                    if table.isnilorempty(RecordMap[recordIndex.firstKey]) then
                        PoolUtil.ReleaseTable(RecordMap[recordIndex.firstKey])
                        RecordMap[recordIndex.firstKey] = nil
                    end
                else
                    for j = #recordArray, 1, -1 do
                        local record = recordArray[j]
                        if record.callback == callback then
                            isNeedRemove = false
                            break
                        end
                    end
                end
                
                if isNeedRemove then
                    table.remove(indexArray, i)
                    PoolUtil.ReleaseTable(recordIndex)
                end
            end
        end

        if table.isnilorempty(indexArray) then
            CallbackIndexArrayDic[callback] = nil
            PoolUtil.ReleaseTable(indexArray)
        end
    end

    TargetCallbackArrayDic[target] = nil
    PoolUtil.ReleaseTable(callbackArray)
end
--endregion

function X3DataPublisher.Clear()
    RecordMap = {}
    CallbackIndexArrayDic = {}
    TargetCallbackArrayDic = {}
    X3DataChangeRecordArrayDic = {}
    IsDirty = false
    IsInvoking = false
    IsDisabled = false
end

return X3DataPublisher
