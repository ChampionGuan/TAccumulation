---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canghai.
--- DateTime: 2022/11/8 11:46
---

---历史堆栈的操作记录
---@class X3DataHistoryOperate 被做成了数组
---@field operateType X3DataConst.X3DataOperateType 1 
---@field fieldName string 2
---@field newValue any 3
---@field key any 4 对于部分操作没有这个值

---历史堆栈树形结构的节点
---@class X3DataHistoryTreeNode
---@field index number 操作的序号
---@field parent X3DataHistoryTreeNode 用于还原数据的父节点
---@field children X3DataHistoryTreeNode[]
---@field operateFromParent X3DataHistoryOperate 相对于父节点做的操作
---@field isResetNode boolean 是否是重置节点

---历史树
---@class X3DataHistoryTree
---@field x3DataClone X3Data.X3DataBase 开启历史记录的时候的拷贝，随着版本的切换也会发生变更
---@field root X3DataHistoryTreeNode 根节点
---@field rollbackNodeStack X3DataHistoryTreeNode[] 回退历史，与树的裁剪相关
---@field markArray X3DataHistoryTreeNode[] 记录当前被标记的节点，与树的裁剪相关
---@field curNode X3DataHistoryTreeNode 当前正在访问的节点，新增节点、跳转(重置、回退、恢复)都会变化
---@field curMaxIndex number 当前最大的序号，不断递增
---@field markVisitIndex number 当前访问到mark的下标
---- 版本控制相关数据 ----
---@field serializedX3DataArray table<any, X3Data.X3DataBase> 存储序列化的全量数据
---@field curVersion number 当前的序列化版本
---@field maxVersion number 已经存储的最大版本
---@field versionStack number[] 记录回退栈
local X3DataHistoryTree = class("X3DataHistoryTree", nil)

--TODO 如果未来有性能问题可能的改进方向 
--1. 现在所有的变化都是从头开始，速度方面存在优化空间
--2. 增加逻辑复杂度，判断能否用这次的结果做Undo或者是Redo(需要开辟额外的空间存储旧的数据)
--3. 增加空间复杂度，当树的深度大于一定值的时候创建新的树降低深度，或者要求外界超出一定范围后坍缩

--- Redo的时候用到的方法
local X3DataOperateRedoFuncDic = {
    ---@param operate X3DataHistoryOperate
    ---@param x3Data X3Data.X3DataBase
    [X3DataConst.X3DataOperateType.BasicSet] = function(operate, x3Data)
        x3Data:_SetBasicField(operate[2], operate[3])
    end,
    ---@param operate X3DataHistoryOperate
    ---@param x3Data X3Data.X3DataBase
    [X3DataConst.X3DataOperateType.ArrayCopy] = function(operate, x3Data)
        --array 先清理再添加
        x3Data:_ClearArrayValue(operate[2], nil)
        local source = operate[3]
        for _, v in ipairs(source) do
            x3Data:_AddTableValue(operate[2], v)
        end
    end,
    ---@param operate X3DataHistoryOperate
    ---@param x3Data X3Data.X3DataBase
    [X3DataConst.X3DataOperateType.MapUpdate] = function(operate, x3Data)
        x3Data:_UpdateTableValue(operate[2], operate[4], operate[3])
    end,
    ---@param operate X3DataHistoryOperate
    ---@param x3Data X3Data.X3DataBase
    [X3DataConst.X3DataOperateType.MapClear] = function(operate, x3Data)
        x3Data:_ClearMapValue(operate[2], nil)
    end
}

function X3DataHistoryTree:Clear()
    ---- 释放所有的节点 ----
    local result = PoolUtil.GetTable()
    self:_TreeToArray(self.root, result)
    for _, node in pairs(result) do
        if node.operateFromParent ~= nil then
            if type(node.operateFromParent[3]) == "table" then
                PoolUtil.ReleaseTable(node.operateFromParent[3])
            end
            PoolUtil.ReleaseTable(node.operateFromParent)
        end
        
        PoolUtil.ReleaseTable(node.children)
        PoolUtil.ReleaseTable(node)
    end

    PoolUtil.ReleaseTable(result)
    
    self.root = nil
    PoolUtil.ReleaseTable(self.rollbackNodeStack)
    self.rollbackNodeStack = nil
    PoolUtil.ReleaseTable(self.markArray)
    self.markArray = nil
    self.curNode = nil
    self.curMaxIndex = 0
    self.markVisitIndex = 0

    X3DataMgr.Release(self.x3DataClone)
    self.x3DataClone = nil
    
    for _, dataClone in pairs(self.serializedX3DataArray) do
        X3DataMgr.Release(dataClone)
    end

    PoolUtil.ReleaseTable(self.serializedX3DataArray)
    self.serializedX3DataArray = nil
    self.curVersion = 0
    self.maxVersion = 0
    
    PoolUtil.ReleaseTable(self.versionStack)
    self.versionStack = nil
end

---树的初始化在X3Data开启历史记录的时候发生
---@param x3Data X3Data.X3DataBase
function X3DataHistoryTree:Init(x3Data)
    ---开启记录的时候初始化
    self.x3DataClone = x3Data:Clone()
    self.rollbackNodeStack = PoolUtil.GetTable()

    self.curMaxIndex = 0
    self.root = self:CreateTreeNode(nil, nil, false)
    self.curNode = self.root

    self.markVisitIndex = 0
    self.markArray = PoolUtil.GetTable()
    self:AddMark()

    self.serializedX3DataArray = PoolUtil.GetTable()
    --放入原始版本
    table.insert(self.serializedX3DataArray, self.x3DataClone)
    self.curVersion = 1
    self.maxVersion = 1
    self.versionStack = PoolUtil.GetTable()
end

---创建节点
---@param parent X3DataHistoryTreeNode
---@param operate X3DataHistoryOperate
---@param isReset boolean 是否是重置节点
---@return X3DataHistoryTreeNode
function X3DataHistoryTree:CreateTreeNode(parent, operate, isReset)
    self.curMaxIndex = self.curMaxIndex + 1
    ---@type X3DataHistoryTreeNode
    local node = PoolUtil.GetTable()
    node.index = self.curMaxIndex
    node.operateFromParent = operate
    node.isResetNode = isReset
    node.parent = parent
    if parent ~= nil then
        if parent.children == nil then
            parent.children = PoolUtil.GetTable()
        end

        table.insert(parent.children, node)
    end

    self.curNode = node

    --markArray中在stack中出现的节点都需要被移除
    if #self.rollbackNodeStack >= 1 then
        self:_RemoveMark()
    end
    
    return node
end

---标记当前位置是需要回退的节点
---@return boolean
function X3DataHistoryTree:AddMark()
    local markedNode = self.curNode
    if markedNode == nil then
        return false
    end

    for _, node in pairs(self.markArray) do
        if node.index == markedNode.index then
            --不允许重复mark
            return false
        end
    end

    table.insert(self.markArray, markedNode)
    self.markVisitIndex = self.markVisitIndex + 1
end

---由创建节点触发的对于mark记录的移除
---@private
function X3DataHistoryTree:_RemoveMark()
    for _, node in pairs(self.rollbackNodeStack) do
        table.removebyvalue(self.markArray, node)
        --TODO 如果节点很多可能会耗费较多时间，为了降低CPU占用这里可以考虑分帧做
        self:_CutTree(node)
    end
    table.clear(self.rollbackNodeStack)
end

---重置
---@param x3Data X3Data.X3DataBase
function X3DataHistoryTree:Reset(x3Data)
    --没有mark过就直接回退到初始
    if #self.markArray < 1 then
        x3Data:Parse(self.x3DataClone)
        rawset(x3Data, '__isEnableHistory', true)
        return
    end

    local lastNode = self.markArray[#self.markArray]
    if lastNode.isResetNode then
        x3Data:Parse(self.x3DataClone)
        rawset(x3Data, '__isEnableHistory', true)
        return
    end

    --1. 创建重置节点，并mark
    --2. 将curNode指向root
    --3. 重置x3Data
    self:CreateTreeNode(self.curNode, nil, true)
    -- 此时curNode是重置节点了
    self:AddMark()

    self.curNode = self.root
    x3Data:Parse(self.x3DataClone)
    rawset(x3Data, '__isEnableHistory', true)
end

---重置并清理当前版本的历史记录
---@param x3Data X3Data.X3DataBase
function X3DataHistoryTree:ResetWithHistoryCleared(x3Data)
    self:_ClearByVersionSwitch()
    self:_Deserialize(x3Data, self.curVersion)
end

---回退
---@param x3Data X3Data.X3DataBase
---@return boolean
function X3DataHistoryTree:Undo(x3Data)
    if not self:CheckCanUndo() then
        return false
    end

    table.insert(self.rollbackNodeStack, self.markArray[self.markVisitIndex])
    self.markVisitIndex = self.markVisitIndex - 1
    local markNode = self.markArray[self.markVisitIndex]
    if markNode.isResetNode then
        -- mark回到重置节点， cur要回到root
        self.curNode = self.root
        x3Data:Parse(self.x3DataClone)
        rawset(x3Data, '__isEnableHistory', true)
    else
        self.curNode = markNode
        local result = PoolUtil.GetTable()
        self:_SearchPath(self.root, result, self.curNode.index)
        table.remove(result, 1)
        self:_InitDataWithHistory(x3Data, result)
        PoolUtil.ReleaseTable(result)
    end
    return true
end

---重做
---@param x3Data X3Data.X3DataBase
---@return boolean
function X3DataHistoryTree:Redo(x3Data)
    if not self:CheckCanRedo() then
        return false
    end

    table.remove(self.rollbackNodeStack)

    self.markVisitIndex = self.markVisitIndex + 1
    local markNode = self.markArray[self.markVisitIndex]
    if markNode.isResetNode then
        -- mark回到重置节点， cur要回到root
        self.curNode = self.root
        x3Data:Parse(self.x3DataClone)
        rawset(x3Data, '__isEnableHistory', true)
    else
        self.curNode = markNode
        local result = PoolUtil.GetTable()
        self:_SearchPath(self.root, result, self.curNode.index)
        -- 需要移除根节点
        table.remove(result, 1)
        self:_InitDataWithHistory(x3Data, result)
        PoolUtil.ReleaseTable(result)
    end
    return true
end

---检查是否能回退，true表示能
---@return boolean
function X3DataHistoryTree:CheckCanUndo()
    return self.markVisitIndex >= 2
end

---检查是否能重做，true表示能
---@return boolean
function X3DataHistoryTree:CheckCanRedo()
    return self.markVisitIndex > 0 and self.markVisitIndex < #self.markArray
end

---用于切换版本的时候的清理
---@private
function X3DataHistoryTree:_ClearByVersionSwitch()
    if self.root == nil then
        return
    end

    if not table.isnilorempty(self.root.children) then
        for _, node in ipairs(self.root.children) do
            self:_CutTree(node)
        end
    end

    --回到只有根节点的情况
    table.clear(self.rollbackNodeStack)
    table.clear(self.markArray)
    self.curNode = self.root
    self.curMaxIndex = 1
    self.markVisitIndex = 0
end

---Editor下使用的接口，用于跳转版本
---@param x3Data X3Data.X3DataBase
---@param index number
function X3DataHistoryTree:_RevertByIndex(x3Data, index)
    local result = PoolUtil.GetTable()
    self:_SearchPath(self.root, result, index)
    table.remove(result, 1)
    --最后一个节点是目标节点
    local count = #result
    if count > 0 then
        self.curNode = result[count]
    else
        self.curNode = self.root
    end
    
    self:_InitDataWithHistory(x3Data, result)
    PoolUtil.ReleaseTable(result)
end

--region Version Control
---@param x3Data X3Data.X3DataBase
function X3DataHistoryTree:_Serialize(x3Data)
    self.maxVersion = self.maxVersion + 1
    self.serializedX3DataArray[self.maxVersion] = x3Data:Clone()
end

---@param x3Data X3Data.X3DataBase
---@param version number
---@return boolean
function X3DataHistoryTree:_Deserialize(x3Data, version)
    if self.serializedX3DataArray[version] == nil then
        return false
    end

    local source = self.serializedX3DataArray[version]
    x3Data:Parse(source)
    rawset(x3Data, '__isEnableHistory', true)
    self.x3DataClone = source
    return true
end

---还原到旧的版本
---@return boolean
function X3DataHistoryTree:RevertToPreVersion(x3Data)
    if self.curVersion < 2 then
        return false
    end
    
    self:_ClearByVersionSwitch()
    --记录当前版本
    table.insert(self.versionStack, self.curVersion)
    self.curVersion = self.curVersion - 1
    self:_Deserialize(x3Data, self.curVersion)
    return true
end

---回到新的版本
---@return boolean
function X3DataHistoryTree:RevertToNextVersion(x3Data)
    if self.curVersion >= self.maxVersion then
        return false
    end
    
    self:_ClearByVersionSwitch()
    --清理最后记录的版本
    table.remove(self.versionStack)
    self.curVersion = self.curVersion + 1
    self:_Deserialize(x3Data, self.curVersion)
    return true
end

---@return boolean
function X3DataHistoryTree:CheckCanRevertToPreVersion()
    return self.curVersion >= 2
end

---@return boolean
function X3DataHistoryTree:CheckCanRevertToNextVersion()
    return self.curVersion < self.maxVersion
end

---清理版本记录，回到最原始的版本
function X3DataHistoryTree:ClearSerializedVersion(x3Data)
    self:_ClearByVersionSwitch()
    x3Data:Parse(self.x3DataClone)
    rawset(x3Data, '__isEnableHistory', true)
    --清理非原始版本的所有版本
    if self.maxVersion > 1 then
        for i = self.maxVersion, 2, -1 do
            X3DataMgr.Release(self.serializedX3DataArray[i])
            table.remove(self.serializedX3DataArray)
        end
    end
    
    self.curVersion = 1
    self.maxVersion = 1
    table.clear(self.versionStack)
end

---清理VersionStack中记录的曾经回退过的版本
function X3DataHistoryTree:ClearVersionStack()
    if #self.versionStack == 0 then
        return
    end
    
    local begin = self.versionStack[1]
    for i = self.maxVersion, begin, -1 do
        X3DataMgr.Release(self.serializedX3DataArray[i])
        table.remove(self.serializedX3DataArray)
    end
    self.maxVersion = #self.serializedX3DataArray
    table.clear(self.versionStack)
end

--region Version Control End

---将一棵树 DFS 变成一个节点数组
---@private
---@param node X3DataHistoryTreeNode 起始节点
---@param result X3DataHistoryTreeNode[]
function X3DataHistoryTree:_TreeToArray(node, result)
    local stack = PoolUtil.GetTable()
    table.insert(stack, node)
    local stackCount = 1
    while (stackCount > 0) do
        local curNode = table.remove(stack)
        stackCount = stackCount - 1
        table.insert(result, curNode)
        if curNode.children ~= nil then
            for _, child in ipairs(curNode.children) do
                stackCount = stackCount + 1
                table.insert(stack, child)
            end
        end
    end
    PoolUtil.ReleaseTable(stack)
end

---DFS查询节点到某个子节点的路径
---@private
---@param node X3DataHistoryTreeNode
---@param result X3DataHistoryTreeNode[]
---@param targetIndex number
---@return boolean
function X3DataHistoryTree:_SearchPath(node, result, targetIndex)
    if node == nil then
        return false
    end

    --将当前节点压入栈中
    table.insert(result, node)
    
    if node.index == targetIndex then
        return true
    end

    if node.children ~= nil then
        for _, child in ipairs(node.children) do
            if self:_SearchPath(child, result, targetIndex) then
                return true
            end
        end
    end
    
    --弹栈
    table.remove(result)
    return false
end

---@private
---@param x3Data X3Data.X3DataBase
---@param nodeArray X3DataHistoryTreeNode[] 存储历史操作的节点
function X3DataHistoryTree:_InitDataWithHistory(x3Data, nodeArray)
    --需要先将X3Data重置，然后再根据路径上的节点重新初始化
    x3Data:Parse(self.x3DataClone)
    rawset(x3Data, '__isEnableHistory', true)
    if #nodeArray < 1 then
        return
    end

    for _, node in ipairs(nodeArray) do
        local operate = node.operateFromParent
        X3DataOperateRedoFuncDic[operate[1]](operate, x3Data)
    end
end

---当发生RemoveMark时裁剪永远也到不了的节点
---@private
---@param node X3DataHistoryTreeNode
function X3DataHistoryTree:_CutTree(node)
    --从主树上断开
    table.removebyvalue(node.parent.children, node)
    local result = PoolUtil.GetTable()
    self:_TreeToArray(node, result)
    for _, v in pairs(result) do
        if v.operateFromParent ~= nil then
            if type(v.operateFromParent[3]) == "table" then
                PoolUtil.ReleaseTable(v.operateFromParent[3])
            end
            PoolUtil.ReleaseTable(v.operateFromParent)
        end
        
        PoolUtil.ReleaseTable(v.children)
        PoolUtil.ReleaseTable(v)
    end

    PoolUtil.ReleaseTable(result)
end

return X3DataHistoryTree