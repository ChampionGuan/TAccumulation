---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canghai.
--- DateTime: 2022/9/16 15:03
---

---@class X3Data.X3DataBase 提供X3Data类的基本操纵数据方法
---由X3DataMgr赋予的属性不受X3DataBase管理
---@field __uniqueId number 当前数据的唯一id
---@field __isInX3DataSet boolean 当前数据是否被数据库记录
---@field __isPrimarySet boolean 当前主键是否已经设置过
---本身非proto定义的属性
---@field protected __isDirty boolean 当前数据是否已经变更
---@field protected __isEnableHistory boolean 是否允许记录
---@field protected __isDisableFieldRecord boolean 是否禁止X3DataMgr记录字段变更
---@field protected __isDisableModifyRecord boolean 是否禁止X3DataMgr记录Modify变更
---@field protected __isDisablePrimary boolean 是否禁用主键
---@field protected __isReleased boolean 是否已经被回收
local X3DataBase = class("X3DataBase", nil, true)

---@type X3DataHistory
local X3DataHistory
---@type X3DataSafety
local X3DataSafety
---@type X3DataPublisher
local X3DataPublisher
---@type X3DataPool
local X3DataPool
---@type X3DataAssociation
local X3DataAssociation
---@type X3DataExternalBridge
local X3DataExternalBridge
---@type X3DataPersistence
local X3DataPersistence

local GetFieldNameByValue

--region Module Init
---用于注入X3DataHistory
---@private
---@param value X3DataHistory
function X3DataBase.InjectX3DataHistoryModule(value)
    X3DataHistory = value
end

---用于注入X3DataHistory
---@private
---@param value X3DataSafety
function X3DataBase.InjectX3DataSafetyModule(value)
    X3DataSafety = value
end

---用于注入X3DataHistory
---@private
---@param value X3DataPublisher
function X3DataBase.InjectX3DataPublisherModule(value)
    X3DataPublisher = value
end

---用于注入X3DataHistory
---@private
---@param value X3DataPool
function X3DataBase.InjectX3DataPoolModule(value)
    X3DataPool = value
end

---@private
---@param value X3DataAssociation
function X3DataBase.InjectX3DataAssociationModule(value)
    X3DataAssociation = value
end

---@param x3DataExternalBridge X3DataExternalBridge
function X3DataBase.InjectX3DataExternalBridgeModule(x3DataExternalBridge)
    X3DataExternalBridge = x3DataExternalBridge
end

---@param x3DataPersistence X3DataPersistence
function X3DataBase.InjectX3DataPersistenceModule(x3DataPersistence)
    X3DataPersistence = x3DataPersistence
end
--endregion

--region Common
---清空所有的引用关系，并将值类型置为初始值
---number 0
---string ''
---boolean false
---@protected
function X3DataBase:Clear()
end

---解析数据，只清理source中有的Field，会对X3Data类型的字段或者是X3Data的array或map进行递归
---@protected
---@param source table
---@return boolean
function X3DataBase:ParseByField(source)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if type(source) ~= "table" then
            return false
        end
    end
    ---- 安全检查结束 ----

    -- Parse的时候不记录，引用全部丢失了
    local isEnableHistory = self.__isEnableHistory
    rawset(self, '__isEnableHistory', false)
    for fieldName, fieldValue in pairs(source) do
        local fieldType = self:_GetFieldType(fieldName)
        if fieldType ~= nil then
            if X3DataConst.BasicFieldType[fieldType] then
                -- 基础类型
                if self:GetPrimaryKey() == fieldName then
                    self:SetPrimaryValue(fieldValue)
                elseif self:_GetEnumValueType(fieldName) then
                    local enumType = self:_GetEnumValueType(fieldName)
                    self:_SetEnumField(fieldName, fieldValue, enumType)
                else
                    self:_SetBasicField(fieldName, fieldValue)
                end
            elseif X3DataConst.MapOrArrayFieldType[fieldType] then
                local tableValueType = self:_GetTableValueType(fieldName)
                if not X3DataConst.BasicFieldType[tableValueType] then
                    --X3Data array/map
                    if fieldType == "array" then
                        self:_ClearArrayValue(fieldName)
                        for _, v in ipairs(fieldValue) do
                            local data = X3DataMgr.Create(tableValueType)
                            data:Parse(v)
                            self:_AddArrayValue(fieldName, data)
                        end
                    else
                        self:_ClearMapValue(fieldName)
                        for k, v in pairs(fieldValue) do
                            local data = X3DataMgr.Create(tableValueType)
                            data:Parse(v)
                            self:_AddOrUpdateMapValue(fieldName, k, data)
                        end
                    end
                else
                    --普通array/map
                    if fieldType == "array" then
                        self:_ClearArrayValue(fieldName)
                        for _, v in ipairs(fieldValue) do
                            self:_AddArrayValue(fieldName, v)
                        end
                    else
                        self:_ClearMapValue(fieldName)
                        for k, v in pairs(fieldValue) do
                            self:_AddOrUpdateMapValue(fieldName, k, v)
                        end
                    end

                end
            else
                --X3Data
                ---@type X3Data.X3DataBase
                local x3Data = self[fieldName]
                if x3Data ~= nil then
                    x3Data:Parse(fieldValue)
                else
                    x3Data = X3DataMgr.Create(fieldType)
                    x3Data:Parse(fieldValue)
                    self:_SetX3DataField(fieldName, x3Data)
                end
            end
        end
    end

    rawset(self, '__isEnableHistory', isEnableHistory)
    return true
end

---解析数据，只增加和替换，会对X3Data类型的字段或者是X3Data的array或map进行递归
---@protected
---@param source table
---@return boolean
function X3DataBase:ParseByIncrement(source)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if type(source) ~= "table" then
            return false
        end
    end
    ---- 安全检查结束 ----

    for fieldName, fieldValue in pairs(source) do
        local fieldType = self:_GetFieldType(fieldName)
        if fieldType ~= nil then
            if X3DataConst.BasicFieldType[fieldType] then
                -- 基础类型
                if self:GetPrimaryKey() == fieldName then
                    self:SetPrimaryValue(fieldValue)
                elseif self:_GetEnumValueType(fieldName) then
                    local enumType = self:_GetEnumValueType(fieldName)
                    self:_SetEnumField(fieldName, fieldValue, enumType)
                else
                    self:_SetBasicField(fieldName, fieldValue)
                end
            elseif X3DataConst.MapOrArrayFieldType[fieldType] then
                local tableValueType = self:_GetTableValueType(fieldName)
                if not X3DataConst.BasicFieldType[tableValueType] then
                    --X3Data array/map
                    if fieldType == "array" then
                        for k, v in ipairs(fieldValue) do
                            local data = X3DataMgr.Create(tableValueType)
                            data:Parse(v)
                            self:_AddOrUpdateArrayValue(fieldName, k, data)
                        end
                    else
                        for k, v in pairs(fieldValue) do
                            local data = X3DataMgr.Create(tableValueType)
                            data:Parse(v)
                            self:_AddOrUpdateMapValue(fieldName, k, data)
                        end
                    end
                else
                    --普通array/map
                    if fieldType == "array" then
                        for k, v in ipairs(fieldValue) do
                            self:_AddOrUpdateArrayValue(fieldName, k, v)
                        end
                    else
                        for k, v in pairs(fieldValue) do
                            self:_AddOrUpdateMapValue(fieldName, k, v)
                        end
                    end

                end
            else
                --X3Data
                ---@type X3Data.X3DataBase
                local x3Data = self[fieldName]
                if x3Data ~= nil then
                    x3Data:ParseByIncrement(fieldValue)
                else
                    x3Data = X3DataMgr.Create(fieldType)
                    x3Data:Parse(fieldValue)
                    self:_SetX3DataField(fieldName, x3Data)
                end
            end
        end
    end
    return true
end

---解析数据，先调用Clear再增加，会对X3Data类型的字段或者是X3Data的array或map进行递归
---Parse的时候关于字段的变更不会被记录
---@protected
---@param source table
---@return boolean
function X3DataBase:Parse(source)
end

---以自身为source克隆一个新的数据
---@protected
---@return X3Data.X3DataBase
function X3DataBase:Clone()
    --克隆的时候禁止所有的ModifyRecord
    local clone = X3DataPool.Create(self.__cname)
    rawset(clone, '__isDisableFieldRecord', true)
    rawset(clone, '__isDisableModifyRecord', true)
    clone:Parse(self)
    rawset(clone, '__isDisableFieldRecord', false)
    rawset(clone, '__isDisableModifyRecord', false)
    return clone
end

---获取当前X3Data主键的值
---如果主键没有设置过默认值是 0 或 ''
---@protected
---@return any
function X3DataBase:GetPrimaryValue()
end

---设置主键的值
---@protected
---@param value number|string
---@return boolean
function X3DataBase:SetPrimaryValue(value)
end

---获取当前X3Data主键字段枚举的值
---@protected
---@return number
function X3DataBase:GetPrimaryKey()
end

---检查 array/map 的 key 是否存在
---@protected
---@param fieldName number
---@param key any
---@return boolean
function X3DataBase:IsTableKeyExist(fieldName, key)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldStr = GetFieldNameByValue(self.__cname, fieldName)
        if key == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:IsTableKeyExist %s 失败，请检查 value!!!", self.__cname, fieldStr)
            return false
        end

        -- fieldName检查
        if not self:_FieldNameCheck(fieldName) then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:IsTableKeyExist %s 失败，请检查 fieldName!!!", self.__cname, fieldStr)
            return false
        end

        -- 排除基础类型和X3Data类型
        local fieldType = self:_GetFieldType(fieldName)
        if X3DataConst.BasicFieldType[fieldType] ~= nil or X3DataConst.X3Data[fieldType] ~= nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:IsTableKeyExist %s 失败，接口只允许 array 或 map 类型的字段使用!!!", self.__cname, fieldStr)
            return
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    if tab == nil then
        return false
    end

    return table.containskey(tab, key)
end

---检查 array/map 的 value 是否存在
---@protected
---@param fieldName number
---@param value any
---@return boolean
function X3DataBase:IsTableValueExist(fieldName, value)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldStr = GetFieldNameByValue(self.__cname, fieldName)
        if value == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:IsTableValueExist %s 失败，请检查 value!!!", self.__cname, fieldStr)
            return false
        end

        -- fieldName检查
        if not self:_FieldNameCheck(fieldName) then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:IsTableValueExist %s 失败，请检查 fieldName!!!", self.__cname, fieldStr)
            return false
        end

        -- 排除基础类型和X3Data类型
        local fieldType = self:_GetFieldType(fieldName)
        if X3DataConst.BasicFieldType[fieldType] ~= nil or X3DataConst.X3Data[fieldType] ~= nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:IsTableValueExist %s 失败，接口只允许 array 或 map 类型的字段使用!!!", self.__cname, fieldStr)
            return
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    if tab == nil then
        return false
    end

    for _, v in pairs(tab) do
        if v == value then
            return true
        end
    end
    return false
end

---针对array/map类型的排序方法
---@protected
---@param fieldName number
---@param comp fun(a:X3Data.X3DataBase, b:X3Data.X3DataBase):boolean
function X3DataBase:SortTable(fieldName, comp)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldStr = GetFieldNameByValue(self.__cname, fieldName)
        if comp == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Sort%sTable 失败，请检查 comp!!!", self.__cname, fieldStr)
            return
        end

        -- fieldName检查
        if not self:_FieldNameCheck(fieldName) then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Sort%sTable 失败，请检查 fieldName!!!", self.__cname, fieldStr)
            return
        end

        -- 排除基础类型和X3Data类型
        local fieldType = self:_GetFieldType(fieldName)
        if X3DataConst.BasicFieldType[fieldType] ~= nil or X3DataConst.X3Data[fieldType] ~= nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Sort%sTable 失败，接口只允许 array 或 map 类型的字段使用!!!", self.__cname, fieldStr)
            return
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    if tab == nil then
        Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                "X3Data.%s:Sort%sTable 失败，请使用 AddTableValue 先添加数据数据!!!", self.__cname, fieldName)
        return
    end

    table.sort(tab, comp)
    -- 排序只能都当成变化了进行处理
    self:_MarkDirty()
end

---先Clear再解析X3Data或者是普通table中的字段(key的名称和类型需要和proto中定义的一致)
---@protected
---@param source table
function X3DataBase:Decode(source)
end

---解析X3Data或者是普通table中的字段（只Clear source中有的部分不会删除原来有的其他字段）
---@protected
---@param source table
function X3DataBase:DecodeByField(source)
end

---在DecodeByField的基础上只会增加、修改数据，不会删除数据 
---@protected
---@param source table
function X3DataBase:DecodeByIncrement(source)
end

---将X3Data从number索引转成string索引（用于pbc序列化）
---@protected
---@param result table
function X3DataBase:Encode(result)
end

---是否彻底禁用在数据库中的X3Data的主键设置后，可以通过主键查找到该Data的功能
---@param value boolean
function X3DataBase:SetIsDisablePrimary(value)
    rawset(self, "__isDisablePrimary", value)
end
--endregion Common Method Over

--region History
---清理历史操作记录以及缓存的版本
function X3DataBase:ClearHistory()
    X3DataHistory.ClearHistory(self)
end

---设置是否需要该数据记录历史操作，默认是关闭状态
---@param value boolean
function X3DataBase:SetIsEnableHistory(value)
    X3DataHistory.SetIsEnableHistory(self, value)
end

---设置redo和undo的标记
---请在对X3Data进行非Reset/Undo/Redo的数据操作后AddMark，否则无法正确的回到上一次mark的位置
---@return boolean
function X3DataBase:AddMark()
    return X3DataHistory.AddMark(self)
end

---向记录中插入重置操作并重置X3Data到历史记录开启的时刻
---@return boolean
function X3DataBase:Reset()
    return X3DataHistory.Reset(self)
end

---重置并清理当前版本的历史记录
---@return boolean
function X3DataBase:ResetWithHistoryCleared()
    return X3DataHistory.ResetWithHistoryCleared(self)
end

---恢复X3Data到上一个Mark
---@return boolean
function X3DataBase:Undo()
    return X3DataHistory.Undo(self)
end

---恢复X3Data到下一个Mark
---@return boolean
function X3DataBase:Redo()
    return X3DataHistory.Redo(self)
end

---检查是否可以Undo
---@return boolean
function X3DataBase:CheckCanUndo()
    return X3DataHistory.CheckCanUndo(self)
end

---检查是否可以Redo
---@return boolean
function X3DataBase:CheckCanRedo()
    return X3DataHistory.CheckCanRedo(self)
end

---将当前的X3Data进行一个完整的备份
---@return boolean
function X3DataBase:SerializeVersion()
    return X3DataHistory.SerializeVersion(self)
end

---将X3Data恢复到上一个备份的版本
---@return boolean
function X3DataBase:RevertToPreVersion()
    return X3DataHistory.RevertToPreVersion(self)
end

---将X3Data恢复到下一个备份的版本
---@return boolean
function X3DataBase:RevertToNextVersion()
    return X3DataHistory.RevertToNextVersion(self)
end

---检查是否可以回到上一个版本
---@return boolean
function X3DataBase:CheckCanRevertToPreVersion()
    return X3DataHistory.CheckCanRevertToPreVersion(self)
end

---检查是否可以回到下一个版本
---@return boolean
function X3DataBase:CheckCanRevertToNextVersion()
    return X3DataHistory.CheckCanRevertToNextVersion(self)
end

---清理X3Data的备份
function X3DataBase:ClearSerializedVersion()
    X3DataHistory.ClearSerializedVersion(self)
end

---获取X3Data的最大历史操作数序号
---@return number
function X3DataBase:GetHistoryRecordMaxIndex()
    return X3DataHistory.GetHistoryRecordMaxIndex(self)
end

---获取X3Data的当前历史操作数序号
---@return number
function X3DataBase:GetCurHistoryRecordIndex()
    return X3DataHistory.GetCurHistoryRecordIndex(self)
end

---将X3Data恢复到指定的历史操作序号对应的版本
---@param index number
---@return boolean
function X3DataBase:RevertByRecordIndex(index)
    return X3DataHistory.RevertByRecordIndex(self, index)
end
--endregion History Over

--region Protected
---@protected
---@param fieldName number 字段名称
---@return string
function X3DataBase:_GetFieldType(fieldName)
    return ""
end

---@protected
---@param fieldName number 字段名称
---@return string
function X3DataBase:_GetMapKeyType(fieldName)
end

---@protected
---@param fieldName number 字段名称
---@return string
function X3DataBase:_GetTableValueType(fieldName)
end

---@protected
---@param fieldName number 字段名称
---@return string
function X3DataBase:_GetEnumValueType(fieldName)
end

---@protected
---@param fieldName number X3DataConst.X3DataField.XXX 的字段
---@return any
function X3DataBase:_Get(fieldName)
    return self[fieldName]
end

---@protected
---@param fieldName number
---@param value any
---@return boolean
function X3DataBase:_Set(fieldName, value)
    if self:GetPrimaryKey() == fieldName then
        return self:SetPrimaryValue(value)
    end

    local fieldType = self:_GetFieldType(fieldName)
    if X3DataConst.BasicFieldType[fieldType] then
        if self:_GetEnumValueType(fieldName) then
            return self:_SetEnumField(fieldName, value, self:_GetEnumValueType(fieldName))
        else
            return self:_SetBasicField(fieldName, value)
        end
    else
        return self:_SetX3DataField(fieldName, value)
    end
end

---@protected
---@param fieldName number
---@param value any
---@return boolean
function X3DataBase:_SetBasicField(fieldName, value)
    local fieldType = self:_GetFieldType(fieldName)

    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        local valueType = type(value)

        if not X3DataConst.BasicFieldType[valueType] then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Set%s 失败，FieldType: %s 与 ValueType: %s 不匹配!!!",
                    self.__cname, fieldNameStr, fieldType, valueType)
            return false
        end
    end
    ---- 安全检查结束 ----

    -- 防止单帧重复设置
    if self[fieldName] == value then
        return true
    end

    rawset(self, fieldName, value)
    if X3DataConst.BasicFieldType[fieldType] then
        X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.BasicSet, self, fieldName, value)
    end
    self:_AddFieldChangeRecord(fieldName)
    self:_MarkDirty()
    return true
end

---@protected
---@param fieldName number
---@param value any
---@param enumType string
---@return boolean
function X3DataBase:_SetEnumField(fieldName, value, enumType)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        local valueType = type(value)

        if not X3DataConst.NumberFieldType[valueType] then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Set%s 失败，FieldType: integer 与 ValueType: %s 不匹配!!!",
                    self.__cname, fieldNameStr, valueType)
            return false
        else
            valueType = math.type(value)
            if valueType ~= "integer" then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:Set%s 失败，FieldType: integer 与 ValueType: %s 不匹配!!!",
                        self.__cname, fieldNameStr, valueType)
                return false
            end
        end
    end
    ---- 安全检查结束 ----

    -- 防止单帧重复设置
    if self[fieldName] == value then
        return true
    end

    local enumMap = X3DataConst[enumType]
    for _, v in pairs(enumMap) do
        if value == v then
            rawset(self, fieldName, value)
            X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.BasicSet, self, fieldName, value)
            self:_AddFieldChangeRecord(fieldName)
            self:_MarkDirty()
            return true
        end
    end

    Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3Data.%s:Set%s 失败，Value的值[%s] 超出了X3DataConst.%s的范围!!!", self.__cname, GetFieldNameByValue(self.__cname, fieldName), value, enumType)
    return false
end

---@protected
---@param fieldName number
---@param value any
---@return boolean
function X3DataBase:_SetX3DataField(fieldName, value)
    local fieldType = self:_GetFieldType(fieldName)

    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        if value ~= nil then
            local valueType = type(value)

            if valueType ~= "table" then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:Set%s 失败，FieldType: %s 与 ValueType: %s 不匹配!!!",
                        self.__cname, fieldNameStr, fieldType, valueType)
                return false
            end

            if value.__X3DataBase == nil or value.__cname ~= fieldType then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:Set%s 失败，FieldType: %s 与 ValueType: %s 不匹配!!!",
                        self.__cname, fieldNameStr, fieldType, valueType)
                return false
            end
        end
    end
    ---- 安全检查结束 ----

    -- 防止单帧重复设置
    local oldData = self[fieldName]
    if oldData == value then
        return true
    end

    rawset(self, fieldName, value)
    self:_AddFieldChangeRecord(fieldName)
    self:_MarkDirty()
    if oldData ~= nil then
        if value ~= nil then
            self:_UpdateAssociation(fieldName, oldData, value)
        else
            self:_BreakAssociation(fieldName, oldData)
        end
    else
        --这里value一定是非空的
        self:_MakeAssociation(fieldName, value)
    end

    return true
end

---array 只能插入数据，没有key就插入到最后，无法修改已经有的数据
---map 需要提供 value 和 key，无法修改已经有的数据
---@protected
---@param fieldName number
---@param value any 非空
---@param key any
---@return boolean
function X3DataBase:_AddTableValue(fieldName, value, key)
    local fieldType = self:_GetFieldType(fieldName)
    if fieldType == "array" then
        return self:_AddArrayValue(fieldName, value, key)
    end

    --map Add 就是 AddOrUpdate
    return self:_AddOrUpdateMapValue(fieldName, key, value)
end

---array 只能插入数据，没有key就插入到最后，无法修改已经有的数据
---@protected
---@param fieldName number
---@param value any 非空
---@param key any
---@return boolean
function X3DataBase:_AddArrayValue(fieldName, value, key)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        --value 非空检查
        if value == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Add%sValue 失败，value 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        --key 类型检查
        if not self:_ArrayKeyTypeCheck(fieldName, key, "Add") then
            return false
        end

        -- value 类型检查
        if not self:_TableValueTypeCheck(fieldName, value, "Add") then
            return false
        end
    end
    ---- 安全检查结束 ----

    -- 初始化尚未初始化的table
    if self[fieldName] == nil then
        rawset(self, fieldName, PoolUtil.GetTable())
    end

    local tab = self[fieldName]
    if key == nil then
        table.insert(tab, value)
        if type(value) ~= "table" then
            X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
        end
    else
        if key < X3DataConst.First or key > #tab + 1 then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Add%sValue 失败，本次插入的位置 %s 已经超出了array的范围 %s !!!", self.__cname, fieldName, key, #tab)
            return false
        end
        table.insert(tab, key, value)
        if type(value) ~= "table" then
            X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
        end
    end
    self:_AddFieldChangeRecord(fieldName)
    self:_MarkDirty()
    --建立联系
    self:_MakeAssociation(fieldName, value)

    return true
end

---更新数据
---@protected
---@param fieldName number
---@param key any
---@param value any
---@return boolean
function X3DataBase:_UpdateTableValue(fieldName, key, value)
    local fieldType = self:_GetFieldType(fieldName)
    if fieldType == "array" then
        return self:_UpdateArrayValue(fieldName, key, value)
    end

    return self:_UpdateMapValue(fieldName, key, value)
end

---Update Array 只能修改已经有的值
---@protected
---@param fieldName number
---@param key any
---@param value any
---@return boolean
function X3DataBase:_UpdateArrayValue(fieldName, key, value)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        -- 非空检查
        if key == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Update%sValue 失败，key 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        if value == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Update%sValue 失败，value 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        --key 类型检查
        if not self:_ArrayKeyTypeCheck(fieldName, key, "Update") then
            return false
        end

        -- value 类型检查
        if not self:_TableValueTypeCheck(fieldName, value, "Update") then
            return false
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    if tab == nil or tab[key] == nil then
        Debug.LogFormatWithTag(GameConst.LogTag.X3DataSys,
                "X3Data.%s:Update%sValue 使用存在错误，请先给Array[%s]添加数据数据!!!", self.__cname, GetFieldNameByValue(self.__cname, fieldName), key)
        return false
    end

    if tab[key] ~= value then
        local oldData = tab[key]
        tab[key] = value
        if type(value) ~= "table" then
            X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
        end

        self:_AddFieldChangeRecord(fieldName)
        self:_MarkDirty()
        self:_UpdateAssociation(fieldName, oldData, value)
    end

    return true
end

---Update map 只能修改已经有的值
---@protected
---@param fieldName number
---@param key any
---@param value any
---@return boolean
function X3DataBase:_UpdateMapValue(fieldName, key, value)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        --非空检查
        if value == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Update%sValue 失败，value 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        if key == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:Update%sValue 失败，key 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        --key 类型检查
        if not self:_MapKeyTypeCheck(fieldName, key, "Update") then
            return false
        end

        -- value 类型检查
        if not self:_TableValueTypeCheck(fieldName, value, "Update") then
            return false
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    if tab == nil or tab[key] == nil then
        Debug.LogFormatWithTag(GameConst.LogTag.X3DataSys,
                "X3Data.%s:Update%sValue 使用存在错误，请先给 Map[%s] 添加数据数据!!!", self.__cname, GetFieldNameByValue(self.__cname, fieldName), key)
        return false
    end

    if tab[key] ~= value then
        local oldData = tab[key]
        tab[key] = value
        if type(value) ~= "table" then
            X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.MapUpdate, self, fieldName, value, key)
        end

        self:_AddFieldChangeRecord(fieldName)
        self:_MarkDirty()
        self:_UpdateAssociation(fieldName, oldData, value)
    end
    return true
end

---插入或更新数据
---@protected
---@param fieldName number
---@param key any
---@param value any
---@return boolean
function X3DataBase:_AddOrUpdateTableValue(fieldName, key, value)
    local fieldType = self:_GetFieldType(fieldName)
    if fieldType == "array" then
        return self:_AddOrUpdateArrayValue(fieldName, key, value)
    end

    return self:_AddOrUpdateMapValue(fieldName, key, value)
end

---插入或更新数据
---array如果对应位置有元素就Update，没有就做合法的插入（会创建array）
---@protected
---@param fieldName number
---@param key any
---@param value any
---@return boolean
function X3DataBase:_AddOrUpdateArrayValue(fieldName, key, value)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        -- 非空检查
        if key == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:AddOrUpdate%sValue 失败，key 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        if value == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:AddOrUpdate%sValue 失败，value 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        --key 类型检查
        if not self:_ArrayKeyTypeCheck(fieldName, key, "AddOrUpdate") then
            return false
        end

        -- value 类型检查
        if not self:_TableValueTypeCheck(fieldName, value, "AddOrUpdate") then
            return false
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    local isUpdate = false

    -- 初始化尚未初始化的table
    if tab == nil then
        if key == X3DataConst.First or key == X3DataConst.Last then
            rawset(self, fieldName, PoolUtil.GetTable())
            tab = self[fieldName]
            table.insert(tab, value)
            if type(value) ~= "table" then
                X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
            end

            self:_AddFieldChangeRecord(fieldName)
            self:_MarkDirty()
            self:_MakeAssociation(fieldName, value)
        else
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:AddOrUpdate%sValue 失败，array为空无法插入Index:[%s]!!!", self.__cname, GetFieldNameByValue(self.__cname, fieldName), key)
            return false
        end
    else
        local oldData = tab[key]
        if oldData ~= nil then
            isUpdate = true
            if oldData ~= value then
                tab[key] = value
                if type(value) ~= "table" then
                    X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
                end

                self:_AddFieldChangeRecord(fieldName)
                self:_MarkDirty()
                self:_UpdateAssociation(fieldName, oldData, value)
            end
        else
            local insertPos = #tab + 1
            if key == X3DataConst.Last then
                key = insertPos
            end

            if key == insertPos then
                table.insert(tab, key, value)
                if type(value) ~= "table" then
                    X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
                end

                self:_AddFieldChangeRecord(fieldName)
                self:_MarkDirty()
                self:_MakeAssociation(fieldName, value)
            else
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:AddOrUpdate%sValue 失败，插入的位置[%s]超出了array的最大index[%s]!!!", self.__cname, GetFieldNameByValue(self.__cname, fieldName), key, #tab)
                return false
            end
        end
    end

    return true
end

---插入或更新数据
---map如果有数据就修改，没有就创建
---@protected
---@param fieldName number
---@param key any
---@param value any
---@return boolean
function X3DataBase:_AddOrUpdateMapValue(fieldName, key, value)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
        -- 非空检查
        if key == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:AddOrUpdate%sValue 失败，key 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        if value == nil then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:AddOrUpdate%sValue 失败，value 不允许为空!!!", self.__cname, fieldNameStr)
            return false
        end

        --key 类型检查
        if not self:_MapKeyTypeCheck(fieldName, key, "AddOrUpdate") then
            return false
        end

        -- value 类型检查
        if not self:_TableValueTypeCheck(fieldName, value, "AddOrUpdate") then
            return false
        end
    end
    ---- 安全检查结束 ----

    -- 初始化尚未初始化的table
    if self[fieldName] == nil then
        rawset(self, fieldName, PoolUtil.GetTable())
    end

    local tab = self[fieldName]
    local isUpdate = false
    if tab[key] == nil then
        tab[key] = value
        if type(value) ~= "table" then
            X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.MapUpdate, self, fieldName, value, key)
        end

        self:_AddFieldChangeRecord(fieldName)
        self:_MarkDirty()
        self:_MakeAssociation(fieldName, value)
    else
        -- 避免重复修改
        local oldData = tab[key]
        if oldData ~= value then
            isUpdate = true
            tab[key] = value
            if type(value) ~= "table" then
                X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.MapUpdate, self, fieldName, value, key)
            end

            self:_AddFieldChangeRecord(fieldName)
            self:_MarkDirty()
            self:_UpdateAssociation(fieldName, oldData, value)
        end
    end

    return true
end

---array删除数据，后面的会前移
---map将指定key的位置置空
---@protected
---@param fieldName number
---@param key string|number
---@return boolean
function X3DataBase:_RemoveTableValue(fieldName, key)
    local fieldType = self:_GetFieldType(fieldName)
    if fieldType == "array" then
        return self:_RemoveArrayValue(fieldName, key)
    end

    return self:_RemoveMapValue(fieldName, key)
end

---key为nil/array尚未添加数据/array[key]为nil都return true
---@protected
---@param fieldName number
---@param key string|number
---@return boolean
function X3DataBase:_RemoveArrayValue(fieldName, key)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if key == nil then
            return true
        end

        --key 类型检查
        if not self:_ArrayKeyTypeCheck(fieldName, key, "Remove") then
            return false
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    if tab == nil or key ~= nil and tab[key] == nil then
        return true
    end

    local removedData
    if key == nil then
        removedData = table.remove(tab)
    else
        removedData = table.remove(tab, key)
    end

    X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
    self:_AddFieldChangeRecord(fieldName)
    self:_MarkDirty()
    self:_BreakAssociation(fieldName, removedData)

    if table.isnilorempty(tab) then
        PoolUtil.ReleaseTable(tab)
        rawset(self, fieldName, nil)
    end

    return true
end

---key为nil/map尚未添加数据/map[key]为nil都return true
---@protected
---@param fieldName number
---@param key string|number
---@return boolean
function X3DataBase:_RemoveMapValue(fieldName, key)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if key == nil then
            return true
        end

        --key 类型检查
        if not self:_MapKeyTypeCheck(fieldName, key, "Remove") then
            return false
        end
    end
    ---- 安全检查结束 ----

    local tab = self[fieldName]
    if tab == nil or key ~= nil and tab[key] == nil then
        return true
    end

    local removedData = tab[key]
    tab[key] = nil
    X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.MapUpdate, self, fieldName, nil, key)
    self:_AddFieldChangeRecord(fieldName)
    self:_MarkDirty()
    self:_BreakAssociation(fieldName, removedData)
    if table.isnilorempty(tab) then
        PoolUtil.ReleaseTable(tab)
        rawset(self, fieldName, nil)
    end

    return true
end

---@protected
---@param fieldName number
---@return boolean
function X3DataBase:_ClearTableValue(fieldName)
    local fieldType = self:_GetFieldType(fieldName)
    if fieldType == "array" then
        return self:_ClearArrayValue(fieldName)
    end

    return self:_ClearMapValue(fieldName)
end

---@protected
---@param fieldName number
---@return boolean
function X3DataBase:_ClearArrayValue(fieldName)
    local tab = self[fieldName]
    if tab == nil then
        return true
    end

    self:_BreakAssociationByField(fieldName)
    table.clear(tab)
    X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.ArrayCopy, self, fieldName, tab)
    self:_AddFieldChangeRecord(fieldName)
    self:_MarkDirty()

    if table.isnilorempty(tab) then
        PoolUtil.ReleaseTable(tab)
        rawset(self, fieldName, nil)
    end

    return true
end

---@protected
---@param fieldName number
---@return boolean
function X3DataBase:_ClearMapValue(fieldName)
    local tab = self[fieldName]
    if tab == nil then
        return true
    end

    self:_BreakAssociationByField(fieldName)
    table.clear(tab)
    X3DataHistory.AddOrModifyOperateCache(X3DataConst.X3DataOperateType.MapClear, self, fieldName)
    self:_AddFieldChangeRecord(fieldName)
    self:_MarkDirty()
    if table.isnilorempty(tab) then
        PoolUtil.ReleaseTable(tab)
        rawset(self, fieldName, nil)
    end

    return true
end

---将自己标记为 Dirty 并且加入 X3DataMgr 的 Invoke 队列中
---@protected
---@param isBubble boolean 是否传递Dirty
function X3DataBase:_MarkDirty(isBubble)
    if X3DataPublisher.GetIsDisabled() then
        --初始化流程中应该禁用一切写入和回调
        return
    end
    
    isBubble = isBubble or true
    if not self.__isDirty then
        rawset(self, "__isDirty", true)
        if not self.__isDisableModifyRecord then
            --当APP处于后台的时候不触发回调，但是会触发持久化
            if X3DataExternalBridge.GetIsLoseFocus() then
                X3DataPersistence.SavePersistenceDataByDBMgr(self.__cname)
            else
                X3DataPublisher.AddX3DataChangeRecord(self, X3DataConst.X3DataChangeFlag.Modify)
            end
        end

        if isBubble then
            self:_BubbleDirty()
        end
    end
end

---将fieldName的变更加入到X3DataMgr中
---@param fieldName number
---@protected
function X3DataBase:_AddFieldChangeRecord(fieldName)
    if X3DataPublisher.GetIsDisabled() then
        --初始化流程中应该禁用一切写入和回调
        return
    end
    
    if not self.__isDisableFieldRecord then
        --当APP处于后台的时候不触发回调，但是会触发持久化
        if X3DataExternalBridge.GetIsLoseFocus() then
            X3DataPersistence.SavePersistenceDataByDBMgr(self.__cname)
        else
            X3DataPublisher.AddX3DataChangeRecord(self, nil, fieldName)
        end
    end
end
--endregion Protected Over

--region Association
---在保证安全的情况下建立关联
---@private
---@param fieldName number
---@param value X3Data.X3DataBase
function X3DataBase:_MakeAssociation(fieldName, value)
    local valueType = self:_GetFieldType(fieldName)
    if X3DataConst.MapOrArrayFieldType[valueType] ~= nil then
        valueType = self:_GetTableValueType(fieldName)
    end

    if X3DataConst.X3Data[valueType] ~= nil then
        X3DataAssociation.MakeAssociation(self, value, fieldName)
    end
end

---在保证安全的情况下解除关联
---@private
---@param fieldName number
---@param value X3Data.X3DataBase
function X3DataBase:_BreakAssociation(fieldName, value)
    local valueType = self:_GetFieldType(fieldName)
    if X3DataConst.MapOrArrayFieldType[valueType] ~= nil then
        valueType = self:_GetTableValueType(fieldName)
    end

    if X3DataConst.X3Data[valueType] ~= nil then
        X3DataAssociation.BreakAssociation(self, value, fieldName)
    end
end

---在保证安全的情况下解除map/array里所有的关联
function X3DataBase:_BreakAssociationByField(fieldName)
    local valueType = self:_GetFieldType(fieldName)
    if X3DataConst.MapOrArrayFieldType[valueType] ~= nil then
        valueType = self:_GetTableValueType(fieldName)
    end

    if X3DataConst.X3Data[valueType] ~= nil then
        local tab = self[fieldName]
        for _, removedData in ipairs(tab) do
            X3DataAssociation.BreakAssociation(self, removedData, fieldName)
        end
    end
end
---在保证安全的情况下更新关联
---@private
---@param fieldName number
---@param oldValue X3Data.X3DataBase
---@param value X3Data.X3DataBase
function X3DataBase:_UpdateAssociation(fieldName, oldValue, value)
    local valueType = self:_GetFieldType(fieldName)
    if X3DataConst.MapOrArrayFieldType[valueType] ~= nil then
        valueType = self:_GetTableValueType(fieldName)
    end

    if X3DataConst.X3Data[valueType] ~= nil then
        X3DataAssociation.BreakAssociation(self, oldValue, fieldName)
        X3DataAssociation.MakeAssociation(self, value, fieldName)
    end
end

---向最终节点传导Dirty信息
---@private
function X3DataBase:_BubbleDirty()
    ---@type X3DataAssociationGraph.Edge[]
    local parentEdges = PoolUtil.GetTable()
    X3DataAssociation.GetUniqueParentNodeEdges(self, parentEdges)
    if not table.isnilorempty(parentEdges) then
        for _, edge in ipairs(parentEdges) do
            local parentData = edge.parentNode.data
            parentData:_MarkDirty(false)
            parentData:_AddFieldChangeRecord(edge.associateField)
        end
    end
    PoolUtil.ReleaseTable(parentEdges)
end
--endregion 

--region Safety Check
---检查 fieldName 是否在当前 X3Data的类型中定义
---@param fieldName number
---@return boolean
function X3DataBase:_FieldNameCheck(fieldName)
    if fieldName == nil or type(fieldName) ~= "number" then
        return false
    end

    local fieldType = X3DataConst.X3DataField[self.__cname]
    for _, v in pairs(fieldType) do
        if v == fieldName then
            return true
        end
    end

    return false
end

---检查array的key的定义类型integer与传入的key是否匹配
---@param fieldName number
---@param key any
---@param operate string
---@return boolean
function X3DataBase:_ArrayKeyTypeCheck(fieldName, key, operate)
    local keyType = type(key)
    local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
    if key ~= nil then
        if keyType ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:%s%sValue 失败，key 类型 %s 为非integer!!!", self.__cname, operate, fieldNameStr, keyType)
            return false
        else
            keyType = math.type(key)
            if keyType ~= "integer" then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:%s%sValue 失败，key 类型 %s 为非integer!!!", self.__cname, operate, fieldNameStr, keyType)
                return false
            end
        end
    end

    return true
end

---检查map的key的定义类型与传入的key是否匹配
---@param fieldName number
---@param key any
---@param operate string
---@return boolean
function X3DataBase:_MapKeyTypeCheck(fieldName, key, operate)
    local fieldKeyType = self:_GetMapKeyType(fieldName)
    local keyType = type(key)
    local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
    if key == nil then
        Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                "X3Data.%s:%s%sValue 失败，key 不允许为空!!!", self.__cname, operate, fieldNameStr)
        return false
    end

    if X3DataConst.NumberFieldType[fieldKeyType] then
        if keyType ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:%s%sValue 失败，key 类型 %s 为非integer!!!", self.__cname, operate, fieldNameStr, keyType)
            return false
        else
            keyType = math.type(key)
            if keyType ~= fieldKeyType then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:%s%sValue 失败，key %s 与定义类型 %s 不匹配!!!", self.__cname, operate, fieldNameStr, keyType, fieldKeyType)
                return false
            end
        end
    end

    if fieldKeyType ~= keyType then
        Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                "X3Data.%s:%s%sValue 失败，key %s 与定义类型 %s 不匹配!!!", self.__cname, operate, fieldNameStr, keyType, fieldKeyType)
        return false
    end

    return true
end

---检查array/map的value的定义类型与传入的类型是否匹配
---@param fieldName number
---@param value any
---@param operate string
---@return boolean
function X3DataBase:_TableValueTypeCheck(fieldName, value, operate)
    local fieldValueType = self:_GetTableValueType(fieldName)
    local valueType = type(value)
    local fieldNameStr = GetFieldNameByValue(self.__cname, fieldName)
    if X3DataConst.BasicFieldType[fieldValueType] then
        if X3DataConst.NumberFieldType[fieldValueType] then
            if valueType ~= "number" then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:%s%sValue 失败，value 类型 %s 与定义类型 %s 不匹配!!!", self.__cname, operate, fieldNameStr, valueType, fieldValueType)
                return false
            else
                valueType = math.type(value)
                if value ~= 0 and (fieldValueType == "integer" and valueType ~= fieldValueType) then
                    Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                            "X3Data.%s:%s%sValue 失败，value 类型 %s 与定义类型 %s 不匹配!!!", self.__cname, operate, fieldNameStr, valueType, fieldValueType)
                    return false
                end
            end

        end
    else
        if valueType ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                    "X3Data.%s:%s%sValue 失败，value 类型 %s 与定义类型 %s 不匹配!!!", self.__cname, operate, fieldNameStr, valueType, fieldValueType)
            return false
        else
            if value.__cname ~= fieldValueType then
                Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys,
                        "X3Data.%s:%s%sValue 失败，value 类型 %s 与定义类型 %s 不匹配!!!", self.__cname, operate, fieldNameStr, value.__cname or valueType, fieldValueType)
                return false
            end
        end
    end

    return true
end
--endregion Safety Check Over

-- metatable的设置必须放在方法已经初始化完成以后
local meta = {
    __newindex = function(tab, newField, value)
        Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "请使用Getter/Setter修改X3Data.[%s]中定义的[%s]字段的值!!!", tab.__cname, newField)
    end
}
setmetatable(X3DataBase, meta)

---通过value反向查找fieldName
---@return string
GetFieldNameByValue = function(x3DataType, fieldValue)
    local fieldTypeDic = X3DataConst.X3DataField[x3DataType]
    for fieldName, v in pairs(fieldTypeDic) do
        if v == fieldValue then
            return fieldName
        end
    end
    return ""
end

return X3DataBase