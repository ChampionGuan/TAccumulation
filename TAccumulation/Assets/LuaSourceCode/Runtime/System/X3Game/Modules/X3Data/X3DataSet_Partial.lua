---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canghai.
--- DateTime: 2022/11/29 20:01
---

---@type X3DataSet
local X3DataSet = class('X3DataSet', nil, true)

---@type X3DataPool
local X3DataPool

---@param x3DataPool X3DataPool
function X3DataSet.InjectX3DataPoolModule(x3DataPool)
    X3DataPool = x3DataPool
end

---在X3DataMgr中初始化时会调用该方法
---@param result table 需要被回收的数据的array
---@return number 返回result的元素数量
function X3DataSet:Clear(result)
    -- 第一次初始化
    if self.__X3DataSetMap == nil then
        self.__X3DataSetMap = PoolUtil.GetTable()
        self.__X3DataSetMap.__isMap = PoolUtil.GetTable()
        return 0
    end

    -- 清理
    for x3DataType, map in pairs(self.__X3DataSetMap) do
        PoolUtil.ReleaseTable(map)
        self.__X3DataSetMap[x3DataType] = nil
    end

    for x3DataType, array in pairs(self)do
        for _, x3Data in ipairs(array) do
            -- 将需要被回收的数据插入 result
            table.insert(result, x3Data)
        end
        PoolUtil.ReleaseTable(array)
        -- 这里也会把X3DataSetMap解引用
        self[x3DataType] = nil
    end

    self.__X3DataSetMap = PoolUtil.GetTable()
    self.__X3DataSetMap.__isMap = PoolUtil.GetTable()
    return #result
end

---更新数据库，采用ParseByField的方式
---@param source table
function X3DataSet:UpdateWithParseByField(source)
    ---@param array X3Data.X3DataBase[]
    for x3DataType, array in pairs(source) do
        if not table.isnilorempty(array) then
            local dataTable = self[x3DataType]
            if dataTable == nil then
                -- 尚未添加过数据
                for _, x3Data in pairs(array) do
                    ---@type X3Data.X3DataBase
                    local data = X3DataPool.Create(x3DataType)
                    self:AddData(data, X3DataConst.Last)
                    data:ParseByField(x3Data)
                end
            else
                -- 更新有的数据
                for _, x3Data in pairs(array) do
                    local oldData = self:GetDataByPrimary(x3DataType, x3Data:GetPrimaryValue())
                    if oldData ~= nil then
                        oldData:ParseByField(x3Data)
                    else
                        -- 尚未添加过的数据
                        ---@type X3Data.X3DataBase
                        local data = X3DataPool.Create(x3DataType)
                        self:AddData(data, X3DataConst.Last)
                        data:ParseByField(x3Data)
                    end
                end
            end
        end
    end
end

---更新数据库，采用DecodeByField的方式
---@param source table
function X3DataSet:UpdateWithDecodeByField(source)
    for x3DataType, array in pairs(source) do
        if not table.isnilorempty(array) then
            local dataTable = self[x3DataType]
            if dataTable == nil then
                -- 尚未添加过数据
                for _, sourceTab in pairs(array) do
                    ---@type X3Data.X3DataBase
                    local data = X3DataPool.Create(x3DataType)
                    self:AddData(data, X3DataConst.Last)
                    data:DecodeByField(sourceTab)
                end
            else
                -- 更新有的数据
                for _, sourceTab in pairs(array) do
                    ---@type X3Data.X3DataBase
                    local tempX3Data = X3DataPool.Create(x3DataType)
                    tempX3Data:DecodeByField(sourceTab)
                    local oldData = self:GetDataByPrimary(x3DataType, tempX3Data:GetPrimaryValue())
                    if oldData ~= nil then
                        oldData:ParseByField(tempX3Data)
                        X3DataPool.Release(tempX3Data)
                    else
                        -- 先释放用于索引Primary的临时数据
                        X3DataPool.Release(tempX3Data)
                        -- 尚未添加过的数据
                        tempX3Data = X3DataPool.Create(x3DataType)
                        self:AddData(tempX3Data, X3DataConst.Last)
                        tempX3Data:DecodeByField(sourceTab)
                    end
                end
            end
        end
    end
end

---只会清空与source中相同类型的数据，然后信任source
---@param source table
---@param releaseArray table 需要被回收的数据array
function X3DataSet:Parse(source, releaseArray)
    for x3DataType, array in pairs(source) do
        -- 清空已经有的数据
        if self[x3DataType] ~= nil then
            -- 清空记录
            for _, x3Data in pairs(self[x3DataType]) do
                -- 将数据加入需要Release的array
                table.insert(releaseArray, x3Data)
            end
            PoolUtil.ReleaseTable(self[x3DataType])
            PoolUtil.ReleaseTable(self.__X3DataSetMap[x3DataType])
            self[x3DataType] = nil
            self.__X3DataSetMap[x3DataType] = nil
        end

        -- 插入新数据
        for _, x3Data in pairs(array) do
            ---@type X3Data.X3DataBase
            local data = X3DataPool.Create(x3DataType)
            self:AddData(data, X3DataConst.Last)
            -- 这里需要先加入到数据库中再 Parse主键的设置才能生效
            data:Parse(x3Data)
        end
    end
end

---解析Pbc decode出的数据
---@param source table
---@param releaseArray table 需要被回收的数据array
function X3DataSet:Decode(source, releaseArray)
    for x3DataType, array in pairs(source) do
        -- 清空已经有的数据
        if self[x3DataType] ~= nil then
            -- 清空记录
            for _, x3Data in pairs(self[x3DataType]) do
                -- 将数据加入需要Release的array
                table.insert(releaseArray, x3Data)
            end
            PoolUtil.ReleaseTable(self[x3DataType])
            PoolUtil.ReleaseTable(self.__X3DataSetMap[x3DataType])
            self[x3DataType] = nil
            self.__X3DataSetMap[x3DataType] = nil
        end

        -- 插入新数据
        for _, x3Data in pairs(array) do
            ---@type X3Data.X3DataBase
            local data = X3DataPool.Create(x3DataType)
            self:AddData(data, X3DataConst.Last)
            -- 这里需要先加入到数据库中再 Decode 主键的设置才能生效
            data:DecodeByField(x3Data)
        end
    end
end

---将X3Data整合成Pbc需要的格式
---@param result table
function X3DataSet:Encode(result)
    local x3DataSetMap = self.__X3DataSetMap
    self.__X3DataSetMap = nil
    for x3DataType, array in pairs(self) do
        local typeResult  = PoolUtil.GetTable()
        result[x3DataType] = typeResult
        -- 插入新数据
        for _, x3Data in ipairs(array) do
            local dataResult = PoolUtil.GetTable()
            x3Data:Encode(dataResult)
            table.insert(typeResult, dataResult)
        end
    end
    self.__X3DataSetMap = x3DataSetMap
end

---将X3Data整合成Pbc需要的格式，并筛选
---@param result table
---@param typeArray string[]
function X3DataSet:EncodeWithTypeArray(result, typeArray)
    local x3DataSetMap = self.__X3DataSetMap
    self.__X3DataSetMap = nil
    for _, x3DataType in ipairs(typeArray) do
        if self[x3DataType] then
            local typeResult  = PoolUtil.GetTable()
            result[x3DataType] = typeResult
            -- 插入新数据
            for _, x3Data in ipairs(self[x3DataType]) do
                local dataResult = PoolUtil.GetTable()
                x3Data:Encode(dataResult)
                table.insert(typeResult, dataResult)
            end
        end
    end
    self.__X3DataSetMap = x3DataSetMap
end

---将数据记录插入数据库
---@param x3Data X3Data.X3DataBase
---@param index number 必须非空，且要合理
---@return boolean
function X3DataSet:AddData(x3Data, index)
    local x3DataType = x3Data.__cname
    local dataTable = self[x3DataType]
    if table.isnilorempty(dataTable) then
        dataTable = PoolUtil.GetTable()
        self[x3DataType] = dataTable
    end

    if index == X3DataConst.Last then
        table.insert(dataTable, x3Data)
    else
        table.insert(dataTable, index, x3Data)
    end
    -- 标识该数据已经被X3DataSet记录
    rawset(x3Data, "__isInX3DataSet", true)
    return true
end

---更新data的primary信息，只有当主键被设置的时候才会触发设置
---@param x3Data X3Data.X3DataBase
---@param primary string|number
---@return boolean
function X3DataSet:AddPrimary(x3Data, primary)
    local x3DataType = x3Data.__cname

    local dataMap = self.__X3DataSetMap[x3DataType]
    if table.isnilorempty(dataMap) then
        dataMap = PoolUtil.GetTable()
        self.__X3DataSetMap[x3DataType] = dataMap
    end

    if dataMap[primary] ~= nil then
        --如果这个data是自己就允许重复设置
        return dataMap[primary].__uniqueId == x3Data.__uniqueId
    end
    
    dataMap[primary] = x3Data
    rawset(x3Data, "__isPrimarySet", true)
    return true
end

---从数据库中移除数据记录
---@param x3DataType string
---@param index number 必须非空，且要合理
---@return X3Data.X3DataBase 返回X3Data给X3DataMgr处理
function X3DataSet:RemoveDataByIndex(x3DataType, index)
    local dataArray = self[x3DataType]
    if index == X3DataConst.Last then
        index = #dataArray
    end

    ---@type X3Data.X3DataBase
    local x3Data = dataArray[index]
    self:RemoveDataWithTypeAndUniqueId(x3DataType, x3Data.__uniqueId)
    return x3Data
end

---从数据库中移除数据记录
---@param x3DataType string
---@param primaryValue string|number
---@return X3Data.X3DataBase
function X3DataSet:RemoveDataByPrimary(x3DataType, primaryValue)
    local dataMap = self.__X3DataSetMap[x3DataType]
    if dataMap == nil or dataMap[primaryValue] == nil then
        --尚未被记录过
        return nil
    end

    -- 删除primary的record
    local x3Data = dataMap[primaryValue]
    self:RemoveDataWithTypeAndUniqueId(x3DataType, x3Data.__uniqueId)
    return x3Data
end

---从数据库中移除数据记录，以uniqueId为准
---@private
---@param x3DataType string
---@param uniqueId string|number
---@return X3Data.X3DataBase
function X3DataSet:RemoveDataWithTypeAndUniqueId(x3DataType, uniqueId)
    --删除数组中的X3Data
    local dataTable = self[x3DataType]
    if not dataTable then
        return nil
    end

    ---@type X3Data.X3DataBase
    local removedData = nil
    ---@param data X3Data.X3DataBase
    for index, data in ipairs(dataTable) do
        if data.__uniqueId == uniqueId then
            removedData = table.remove(dataTable, index)
            --删除X3DataSet中的引用
            if removedData.__isPrimarySet then
                local dataMap = self.__X3DataSetMap[x3DataType]
                dataMap[removedData:GetPrimaryValue()] = nil
                if table.isnilorempty(dataMap) then
                    PoolUtil.ReleaseTable(dataMap)
                    self.__X3DataSetMap[x3DataType] = nil
                end
            end
            
            rawset(removedData, "__isInX3DataSet", false)
            rawset(removedData, "__isPrimarySet", false)
            break
        end
    end

    if table.isnilorempty(dataTable) then
        PoolUtil.ReleaseTable(dataTable)
        self[x3DataType] = nil
    end
    
    return removedData
end

---@param x3DataType string
---@param index number 必须非空
---@return X3Data.X3DataBase
function X3DataSet:GetDataByIndex(x3DataType, index)
    local dataTable = self[x3DataType]
    if dataTable == nil then
        return nil
    end

    if index == X3DataConst.Last then
        return dataTable[#dataTable]
    end
    return dataTable[index]
end

---通过primary进行获取
---@param x3DataType string
---@param primaryValue string|number
---@return X3Data.X3DataBase
function X3DataSet:GetDataByPrimary(x3DataType, primaryValue)
    local dataMap = self.__X3DataSetMap[x3DataType]
    if dataMap == nil then
        return nil
    end
    return dataMap[primaryValue]
end

---返回当前类型的array
---@param x3DataType string
---@return table
function X3DataSet:GetDataArray(x3DataType)
    return self[x3DataType]
end

---返回当前类型的array的count
---@param x3DataType string
---@return number
function X3DataSet:GetDataCount(x3DataType)
    local dataArray = self[x3DataType]
    if table.isnilorempty(dataArray) then
        return 0
    end
    return #dataArray
end

---@param x3DataType string
---@param result table
function X3DataSet:CloneDataArray(x3DataType, result)
    ---@type X3Data.X3DataBase[]
    local dataArray = self[x3DataType]
    if table.isnilorempty(dataArray) then
        return
    end

    for _, x3Data in ipairs(dataArray) do
        table.insert(result, x3Data:Clone())
    end
end

return X3DataSet