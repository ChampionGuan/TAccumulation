---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canghai.
--- DateTime: 2022/11/16 19:08
---

---@class X3DataCRUDHelper
local X3DataCRUDHelper = {}

---@type X3DataSet
local X3DataSet
---@type X3DataSafety
local X3DataSafety
---@type X3DataPublisher
local X3DataPublisher
---@type X3DataPool
local X3DataPool

---在帧尾通知完各个模块变更后再回收，防止同帧delete和add同一个对象
local X3DataReleaseQueue = {}
local LocalSortFunc = function(a, b) return a > b end

---@param x3DataSet X3DataSet
function X3DataCRUDHelper.InjectX3DataSetModule(x3DataSet)
    X3DataSet = x3DataSet
end

---@param x3DataSafety X3DataSafety
function X3DataCRUDHelper.InjectX3DataSafetyModule(x3DataSafety)
    X3DataSafety = x3DataSafety
end

---@param x3DataPublisher X3DataPublisher
function X3DataCRUDHelper.InjectX3DataPublisherModule(x3DataPublisher)
    X3DataPublisher = x3DataPublisher
end

---@param x3DataPool X3DataPool
function X3DataCRUDHelper.InjectX3DataPoolModule(x3DataPool)
    X3DataPool = x3DataPool
end

--region 查询方法
---返回符合查询条件的第一条数据
---@param x3DataType string
---@param condition table 查询的条件
---@return X3Data.X3DataBase
function X3DataCRUDHelper.GetByCondition(x3DataType, condition)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetByCondition") then
            return nil
        end

        if type(condition) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetByCondition 失败，condition为[%s]!!!", condition)
            return nil
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if table.isnilorempty(x3DataArray) then
        return nil
    end
    
    local isPass = true
    for _, x3Data in ipairs(x3DataArray) do
        isPass = true
        for fieldName, value in pairs(condition) do
            if (x3Data:_Get(fieldName) ~= value) then
                isPass = false
                break
            end
        end

        if isPass then
            return x3Data
        end
    end
    return nil
end

---返回最后一条数据，如果没有就创建空数据并返回
---@param x3DataType string
---@return X3Data.X3DataBase
function X3DataCRUDHelper.GetOrAdd(x3DataType)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetOrAdd") then
            return nil
        end
    end
    ---- 安全检查结束 ----

    local x3Data = X3DataSet:GetDataByIndex(x3DataType, X3DataConst.Last)
    if x3Data == nil then
        x3Data = X3DataPool.Create(x3DataType)
        X3DataSet:AddData(x3Data, X3DataConst.Last)
        -- 数据变更
        X3DataPublisher.AddX3DataChangeRecord(x3Data, X3DataConst.X3DataChangeFlag.Add)
    end

    return x3Data
end

---根据主键进行查询返回符合条件的数据
---如果数据放入了数据库但是没有设置过主键，无法获取
---@param x3DataType string
---@param primaryValue number|string 主键
---@return X3Data.X3DataBase
function X3DataCRUDHelper.Get(x3DataType, primaryValue)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Get") then
            return nil
        end

        if not X3DataSafety.X3DataPrimaryCheck(primaryValue, "Get") then
            return nil
        end
    end
    ---- 安全检查结束 ----

    return X3DataSet:GetDataByPrimary(x3DataType, primaryValue)
end

---根据index查询获取结果
---@param x3DataType string
---@param index number index默认是Last
---@return X3Data.X3DataBase
function X3DataCRUDHelper.GetByIndex(x3DataType, index)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetByIndex") then
            return nil
        end

        if type(index) ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetByIndex 失败，index为[%s]!!!", index)
            return nil
        end
    end
    ---- 安全检查结束 ----
    index = index or X3DataConst.Last
    return X3DataSet:GetDataByIndex(x3DataType, index)
end

---对数据进行筛选后返回经过排序的数据
---需要外界提供容器 result
---@param x3DataType string
---@param result table 存放结果的容器
---@param filterFunc fun(x3Data:X3Data.X3DataBase):boolean 数据的筛选方法，为空就是返回所有的数据不筛选
---@param sortFunc fun(a:X3Data.X3DataBase, b:X3Data.X3DataBase):boolean 数据的排序方法，为空就是自然顺序
---@return int
function X3DataCRUDHelper.GetAll(x3DataType, result, filterFunc, sortFunc)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetAll") then
            return 0
        end

        if type(result) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetAll 失败，result为[%s]!!!", result)
            return 0
        end

        if filterFunc ~= nil and type(filterFunc) ~= "function" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetAll 失败，filterFunc为[%s]!!!", filterFunc)
            return 0
        end

        if sortFunc ~= nil and type(sortFunc) ~= "function" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetAll 失败，sortFunc为[%s]!!!", sortFunc)
            return 0
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if x3DataArray == nil then
        return 0
    end

    local count = 0
    -- 筛选
    if filterFunc ~= nil then
        for _, x3Data in ipairs(x3DataArray) do
            if filterFunc(x3Data) then
                table.insert(result, x3Data)
                count = count + 1
            end
        end
    else
        count = #x3DataArray
        for _, x3Data in ipairs(x3DataArray) do
            table.insert(result, x3Data)
        end
    end

    --排序
    if sortFunc ~= nil then
        table.sort(result, sortFunc)
    end

    return count
end

---返回该类型的第一条数据
---@param x3DataType string
function X3DataCRUDHelper.GetFirst(x3DataType)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetFirst") then
            return 0
        end
    end
    ---- 安全检查结束 ----

    return X3DataSet:GetDataByIndex(x3DataType, X3DataConst.First)
end

---返回该类型的前count条数据，结果是正序的1,2,3...Count
---@param x3DataType string
---@param result table
---@param count number count如果是Last就是全部数据
---@return number 实际的结果数量 <= Count
function X3DataCRUDHelper.GetFirstByCount(x3DataType, result, count)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetFirstByCount") then
            return 0
        end

        if type(result) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetFirstByCount 失败，result为[%s]!!!", result)
            return 0
        end

        if type(count) ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetFirstByCount 失败，count为[%s]!!!", count)
            return 0
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if x3DataArray == nil then
        return 0
    end

    -- 确保count不会超过实际数量
    local arrayCount = #x3DataArray
    if count == X3DataConst.Last or count > arrayCount then
        count = arrayCount
    end

    for index = 1, count do
        table.insert(result, x3DataArray[index])
    end
    return count
end

---返回该类型的最后一条数据
---@param x3DataType string
---@return X3Data.X3DataBase
function X3DataCRUDHelper.GetLast(x3DataType)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetLast") then
            return nil
        end
    end
    ---- 安全检查结束 ----

    return X3DataSet:GetDataByIndex(x3DataType, X3DataConst.Last)
end

---返回该类型的后count条数据，结果是倒序的Last,Last-1,Last-2,...
---@param x3DataType string
---@param result table
---@param count number count如果是Last就是全部数据
---@return number 实际的结果数量 <= Count
function X3DataCRUDHelper.GetLastByCount(x3DataType, result, count)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "GetLastByCount") then
            return 0
        end

        if type(result) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetLastByCount 失败，result为[%s]!!!", result)
            return 0
        end

        if type(count) ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.GetLastByCount 失败，count为[%s]!!!", count)
            return 0
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if x3DataArray == nil then
        return 0
    end

    -- 确保count不会超过实际数量
    local arrayCount = #x3DataArray
    if count == X3DataConst.Last or count > arrayCount then
        count = arrayCount
    end

    for index = arrayCount, count, -1 do
        table.insert(result, x3DataArray[index])
    end
    return count
end

---判断该类型有没有符合条件的数据
---@param x3DataType string
---@param predictFunc fun(x3Data:X3Data.X3DataBase):boolean
---@return boolean
function X3DataCRUDHelper.Contains(x3DataType, predictFunc)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Contains") then
            return false
        end

        if type(predictFunc) ~= "function" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.Contains 失败，predictFunc为[%s]!!!", predictFunc)
            return false
        end
    end
    ---- 安全检查结束 ----
    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if x3DataArray == nil then
        return false
    end

    for _, x3Data in ipairs(x3DataArray) do
        if predictFunc(x3Data) then
            return true
        end
    end
    return false
end
--endregion 查询方法结束

--region 数据添加方法
---向数据库中插入一条记录，如果插入index = 3的位置，原先3号位置的就会向后移动
---如果需要插入到最后请使用 X3DataConst.Last
---@param x3DataType string
---@param source table 可以是nil会创建空数据并存入数据库
---@param index number 默认是Last，超出范围就会返回nil插入失败
---@return X3Data.X3DataBase
function X3DataCRUDHelper.Add(x3DataType, source, index)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Add") then
            return nil
        end

        if source ~= nil and type(source) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.Add 失败，source为[%s]!!!", source)
            return nil
        end

        if index ~= nil and type(index) ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.Add 失败，index为[%s]!!!", index)
            return nil
        end
    end
    ---- 安全检查结束 ----

    if index ~= nil then
        local count = X3DataSet:GetDataCount(x3DataType)
        -- 允许插入到真实的最后一个的位置
        if index < X3DataConst.First or index > count + 1 then
            return nil
        end
    else
        index = X3DataConst.Last
    end

    ---@type X3Data.X3DataBase
    local x3Data = X3DataPool.Create(x3DataType)
    if source ~= nil then
        rawset(x3Data, "__isDisableFieldRecord", true)
        rawset(x3Data, "__isDisableModifyRecord", true)
        if not x3Data:DecodeByIncrement(source) then
            --Release会调用Clear不需要手动将__isDisableModifyRecord置为false
            X3DataPool.Release(x3Data)
            return nil
        end
        rawset(x3Data, "__isDisableFieldRecord", false)
        rawset(x3Data, "__isDisableModifyRecord", false)
    end

    X3DataSet:AddData(x3Data, index)
    -- 数据变更
    X3DataPublisher.AddX3DataChangeRecord(x3Data, X3DataConst.X3DataChangeFlag.Add)
    return x3Data
end

---向数据库中插入一条记录（末尾），如果主键的值已经有对应的记录则插入失败返回 nil
---@param x3DataType string
---@param source table 可以是nil会创建空数据并存入数据库
---@param primaryValue number|string 必须保证主键非空
---@return X3Data.UseArgString1
function X3DataCRUDHelper.AddByPrimary(x3DataType, source, primaryValue)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Add") then
            return nil
        end

        if source ~= nil and type(source) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.AddByPrimary 失败，source为[%s]!!!", source)
            return nil
        end

        if primaryValue ~= nil and type(primaryValue) ~= "number" and type(primaryValue) ~= "string" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.AddByPrimary 失败，primaryValue为[%s]!!!", primaryValue)
            return nil
        end
    end
    ---- 安全检查结束 ----

    if primaryValue == nil then
        Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.AddByPrimary 失败，primaryValue为 nil !!!", primaryValue)
        return nil
    end

    if X3DataSet:GetDataByPrimary(x3DataType, primaryValue) ~= nil then
        Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.AddByPrimary 失败，primaryValue[%s] 已经被占用!!!", primaryValue)
        return nil
    end
    
    ---@type X3Data.X3DataBase
    local x3Data = X3DataPool.Create(x3DataType)
    if source ~= nil then
        rawset(x3Data, "__isDisableFieldRecord", true)
        rawset(x3Data, "__isDisableModifyRecord", true)
        if x3Data:DecodeByIncrement(source) == false then
            --Release会调用Clear不需要手动将__isDisableModifyRecord置为false
            X3DataPool.Release(x3Data)
            return nil
        end
        rawset(x3Data, "__isDisableFieldRecord", false)
        rawset(x3Data, "__isDisableModifyRecord", false)
    end
    
    if x3Data:SetPrimaryValue(primaryValue) then
        X3DataSet:AddData(x3Data, X3DataConst.Last)
        X3DataSet:AddPrimary(x3Data, primaryValue)
        -- 数据变更
        X3DataPublisher.AddX3DataChangeRecord(x3Data, X3DataConst.X3DataChangeFlag.Add)
        return x3Data
    else
        X3DataPool.Release(x3Data)
    end
    
    return nil
end
--endregion 数据添加方法结束

--region 删除方法
---根据主键移除数据，如果主键没有设置将移除失败
---@param x3DataType string
---@param primaryValue number|string 主键
---@return boolean
function X3DataCRUDHelper.Remove(x3DataType, primaryValue)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Remove") then
            return false
        end

        if not X3DataSafety.X3DataPrimaryCheck(primaryValue, "Remove") then
            return false
        end
    end
    ---- 安全检查结束 ----

    local removedData = X3DataSet:RemoveDataByPrimary(x3DataType, primaryValue)
    if removedData == nil then
        return false
    end

    table.insert(X3DataReleaseQueue, removedData)
    X3DataPublisher.AddX3DataChangeRecord(removedData, X3DataConst.X3DataChangeFlag.Remove)
    return true
end

---根据index移除数据，超出范围将移除失败
---@param x3DataType string
---@param index number 默认是 Last，超出范围会删除失败
---@return boolean
function X3DataCRUDHelper.RemoveByIndex(x3DataType, index)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "RemoveByIndex") then
            return false
        end

        if index ~= nil and type(index) ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.RemoveByIndex 失败，index为[%s]!!!", index)
            return false
        end
    end
    ---- 安全检查结束 ----

    if index ~= nil then
        local count = X3DataSet:GetDataCount(x3DataType)
        -- 如果没有记录也是无法删除的
        if index < X3DataConst.First or index > count then
            return false
        end
    else
        index = X3DataConst.Last
    end

    local removedData = X3DataSet:RemoveDataByIndex(x3DataType, index)
    if removedData == nil then
        return false
    end

    table.insert(X3DataReleaseQueue, removedData)
    X3DataPublisher.AddX3DataChangeRecord(removedData, X3DataConst.X3DataChangeFlag.Remove)
    return true
end

---删除所有符合条件的数据
---@param x3DataType string
---@param condition table 查询的条件
---@return boolean
function X3DataCRUDHelper.RemoveByCondition(x3DataType, condition)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "RemoveByCondition") then
            return false
        end

        if type(condition) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.RemoveByCondition 失败，condition为[%s]!!!", condition)
            return false
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if table.isnilorempty(x3DataArray) then
        return true
    end
    
    local isPass = true
    ---@type int[]
    local passArray = PoolUtil.GetTable()
    for index, x3Data in ipairs(x3DataArray) do
        isPass = true
        for fieldName, value in pairs(condition) do
            if (x3Data:_Get(fieldName) ~= value) then
                isPass = false
                break
            end
        end

        if isPass then
            table.insert(passArray, index)
        end
    end
    
    table.sort(passArray, LocalSortFunc)
    --这里需要倒着删除，因为删除后后面的元素会向前移动
    for _, index in ipairs(passArray) do
        local removedData = X3DataSet:RemoveDataByIndex(x3DataType, index)
        table.insert(X3DataReleaseQueue, removedData)
        X3DataPublisher.AddX3DataChangeRecord(removedData, X3DataConst.X3DataChangeFlag.Remove)
    end
    
    PoolUtil.ReleaseTable(passArray)
    return true
end

---删除该类型所有数据
---@param x3DataType string
function X3DataCRUDHelper.RemoveAll(x3DataType)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "RemoveAll") then
            return
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if x3DataArray == nil then
        return
    end

    local count = #x3DataArray
    for index = count, 1, -1 do
        local removedData = X3DataSet:RemoveDataByIndex(x3DataType, index)
        table.insert(X3DataReleaseQueue, removedData)
        X3DataPublisher.AddX3DataChangeRecord(removedData, X3DataConst.X3DataChangeFlag.Remove)
    end
    return
end
--endregion 删除方法结束

--region 更新方法
---只能更新主键已经设置过的数据
---@param x3DataType string
---@param primaryValue number|string
---@param source table
---@return boolean
function X3DataCRUDHelper.Update(x3DataType, primaryValue, source)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Update") then
            return false
        end

        if not X3DataSafety.X3DataPrimaryCheck(primaryValue, "Update") then
            return nil
        end

        if type(source) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.Update 失败，source为[%s]!!!", source)
            return false
        end
    end
    ---- 安全检查结束 ----

    local x3Data = X3DataSet:GetDataByPrimary(x3DataType, primaryValue)
    if x3Data == nil then
        return false
    end

    return x3Data:ParseByIncrement(source)
end

---根据index更新数据
---@param x3DataType string
---@param index number 没有默认值，超出范围或者是为空都会失败
---@param source table
---@return boolean
function X3DataCRUDHelper.UpdateByIndex(x3DataType, index, source)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "UpdateByIndex") then
            return false
        end

        if type(index) ~= "number" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.UpdateByIndex 失败，index为[%s]!!!", index)
            return false
        end

        if type(source) ~= "table" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.UpdateByIndex 失败，source为[%s]!!!", source)
            return false
        end
    end
    ---- 安全检查结束 ----
    index = index or X3DataConst.Last
    local x3Data = X3DataSet:GetDataByIndex(x3DataType, index)
    if x3Data == nil then
        return false
    end

    return x3Data:ParseByIncrement(source)
end
--endregion 更新方法结束

--region 遍历方法
---先筛选出符合条件的数据，依次调用iterationFunc
---@param x3DataType string
---@param iterationFunc fun(x3Data:X3Data.X3DataBase):void 迭代方法如果不允许为空
---@param filterFunc fun(x3Data:X3Data.X3DataBase):boolean 数据的筛选方法，为空就是不筛选
function X3DataCRUDHelper.ForEach(x3DataType, iterationFunc, filterFunc)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "ForEach") then
            return
        end

        if type(iterationFunc) ~= "function" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.ForEach 失败，iterationFunc为[%s]!!!", iterationFunc)
            return
        end

        if filterFunc ~= nil and type(filterFunc) ~= "function" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.ForEach 失败，filterFunc为[%s]!!!", filterFunc)
            return
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if x3DataArray == nil then
        return
    end

    if filterFunc ~= nil then
        for _, x3Data in ipairs(x3DataArray) do
            if filterFunc(x3Data) then
                iterationFunc(x3Data)
            end
        end
    else
        for _, x3Data in ipairs(x3DataArray) do
            iterationFunc(x3Data)
        end
    end
end
--endregion 遍历方法结束

--region 计数统计方法
---返回符合条件的数据的数量
---@param x3DataType string
---@param filterFunc fun(x3Data:X3Data.X3DataBase):boolean 数据的筛选方法，为空就是不筛选
---@return number
function X3DataCRUDHelper.Count(x3DataType, filterFunc)
    ---- 安全检查开始 ----
    if X3DataSafety.GetIsEnableSafetyCheck() then
        if not X3DataSafety.X3DataTypeCheck(x3DataType, "Count") then
            return 0
        end

        if filterFunc ~= nil and type(filterFunc) ~= "function" then
            Debug.LogErrorFormatWithTag(GameConst.LogTag.X3DataSys, "X3DataMgr.Count 失败，filterFunc为[%s]!!!", filterFunc)
            return 0
        end
    end
    ---- 安全检查结束 ----

    local x3DataArray = X3DataSet:GetDataArray(x3DataType)
    if x3DataArray == nil then
        return 0
    end

    -- 没有filter就直接返回当前数量
    if filterFunc == nil then
        return #x3DataArray
    end

    local count = 0
    for _, x3Data in ipairs(x3DataArray) do
        if filterFunc(x3Data) then
            count = count + 1
        end
    end
    return count
end
--endregion 计数统计方法结束

---回收当前帧被 Remove 的 X3Data
function X3DataCRUDHelper.ClearReleaseQueue()
    for _, x3Data in pairs(X3DataReleaseQueue) do
        X3DataPool.Release(x3Data)
    end

    table.clear(X3DataReleaseQueue)
end

--强制清空所有数据
function X3DataCRUDHelper.Clear()
    X3DataReleaseQueue = {}
end

return X3DataCRUDHelper