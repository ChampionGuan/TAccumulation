---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canghai.
--- DateTime: 2022/11/29 10:56
---

---处理X3Data持久化信息的地方
---@class X3DataPersistence
local X3DataPersistence = {}
---@type X3DataSet
local X3DataSet
---@type X3DataPublisher
local X3DataPublisher
---@type X3DataPool
local X3DataPool

---X3Data的持久化信息
---@class X3DataPersistenceInfo
---@field PersistenceFieldMap table<string, number>
---@field IsOverwrite boolean
---@type table<string, X3DataPersistenceInfo>
local X3DataPersistenceInfoMap
---是否需要进行持久化存储
local IsDirty = false
---@type table<string, number>
local X3DataPersistenceDirtyMap

---@param x3DataSet X3DataSet
function X3DataPersistence.InjectX3DataSetModule(x3DataSet)
    X3DataSet = x3DataSet
end

---@param x3DataPublisher X3DataPublisher
function X3DataPersistence.InjectX3DataPublisherModule(x3DataPublisher)
    X3DataPublisher = x3DataPublisher
end

---@param x3DataPool X3DataPool
function X3DataPersistence.InjectX3DataPoolModule(x3DataPool)
    X3DataPool = x3DataPool
end

---持久化初始化
---@param settings table
function X3DataPersistence.InitPersistence(settings)
    if settings == nil then
        return
    end

    if X3DataPersistenceInfoMap == nil then
        X3DataPersistenceInfoMap = PoolUtil.GetTable()
        X3DataPersistenceDirtyMap = PoolUtil.GetTable()
    else
        -- 清理旧的信息
        for _, v in pairs(X3DataPersistenceInfoMap) do
            PoolUtil.ReleaseTable(v.PersistenceFieldArray)
        end
        table.clear(X3DataPersistenceInfoMap)
        table.clear(X3DataPersistenceDirtyMap)
    end

    local persistenceList = settings.X3DataPersistenceList
    for i = 0, persistenceList.Count - 1 do
        ---@type PapeGames.X3.X3DataPersistence
        local persistence = persistenceList[i]
        ---@type X3DataPersistenceInfo
        local persistenceInfo = PoolUtil.GetTable()
        persistenceInfo.IsOverwrite = persistence.IsOverwrite
        persistenceInfo.PersistenceFieldMap = PoolUtil.GetTable()
        for j = 0, persistence.PersistenceFieldArray.Length - 1 do
            -- 只添加选中的信息
            if persistence.PersistenceFieldSelectedArray[j] then
                persistenceInfo.PersistenceFieldMap[persistence.PersistenceFieldArray[j]] = j + 1
            end
        end
        X3DataPersistenceInfoMap[persistence.X3DataType] = persistenceInfo
        -- 订阅数据变更
        X3DataPersistence.Subscribe(persistence.X3DataType, persistenceInfo.PersistenceFieldMap)
    end

    X3DataPersistence.InitX3DataSetWithPersistenceData()
end

---通过DBMgr还原存储的持久化信息
function X3DataPersistence.InitX3DataSetWithPersistenceData()
    if table.isnilorempty(X3DataPersistenceInfoMap) then
        return
    end

    -- 是否需要同步跨两个数据库的持久化数据
    local dataSet = PoolUtil.GetTable()
    ---@param persistenceInfo X3DataPersistenceInfo
    for x3DataType, persistenceInfo in pairs(X3DataPersistenceInfoMap) do
        table.clear(dataSet)
        if persistenceInfo.IsOverwrite then
            DBMgr.ReleaseIndexCtrl(x3DataType)
            -- 解除类型和与账号无关的DB的引用
            if DBMgr.ExistTable(x3DataType) then
                local dbCtrl = DBMgr.GetOrCreateIndexCtrl(x3DataType)
                ---@type X3Data.X3DataBase[]
                local oldDataCloneArray = PoolUtil.GetTable()
                X3DataSet:CloneDataArray(x3DataType, oldDataCloneArray)
                -- 保证引用不会丢失
                dataSet[x3DataType] = dbCtrl:GetAll()
                X3DataSet:UpdateWithDecodeByField(dataSet)
                -- 再使用登录前（主键相同）的数据覆盖登录后的数据
                dataSet[x3DataType] = oldDataCloneArray
                X3DataSet:UpdateWithParseByField(dataSet)
                for _, x3Data in ipairs(oldDataCloneArray) do
                    X3DataPool.Release(x3Data)
                end
                
                PoolUtil.ReleaseTable(oldDataCloneArray)
                --这里如果切换了数据库可能不会触发 Dirty 需要强制同步一次
                X3DataPersistence.SavePersistenceDataByDBMgr(x3DataType)
            end
        else
            -- 数据会根据第一次使用的时机决定存储在哪个数据库中
            if DBMgr.ExistTable(x3DataType) then
                local dbCtrl = DBMgr.GetOrCreateIndexCtrl(x3DataType)
                local sourceArray = dbCtrl:GetAll()
                dataSet[x3DataType] = sourceArray
                -- 保证引用不会丢失
                X3DataSet:UpdateWithDecodeByField(dataSet)
            end
        end
    end
    PoolUtil.ReleaseTable(dataSet)
end

---通过DBMgr存储持久化信息
---@param x3DataType string
function X3DataPersistence.SavePersistenceDataByDBMgr(x3DataType)
    if table.isnilorempty(X3DataPersistenceInfoMap) then
        return
    end

    for k, v in pairs(X3DataPersistenceInfoMap) do
        ---@type X3DataPersistenceInfo
        local persistenceInfo = v

        --找到后再更新
        if k == x3DataType then
            --建表
            local dbCtrl = DBMgr.GetOrCreateIndexCtrl(x3DataType)
            --清理原先表的数据
            dbCtrl:ClearTable()
            local dataArray = X3DataSet:GetDataArray(x3DataType)
            --保证有数据再存储
            local resultArray = PoolUtil.GetTable()
            if not table.isnilorempty(dataArray) then
                local length = #dataArray
                for i = 1, length do
                    ---@type X3Data.X3DataBase
                    local x3Data = dataArray[i]
                    --克隆一个x3Data并且清理掉不需要的字段，这里只要引用因此不用X3Data的Clone
                    local result = PoolUtil.GetTable()
                    x3Data:Encode(result)
                    for fieldName, _ in pairs(result) do
                        --去除所有多余的信息
                        if persistenceInfo.PersistenceFieldMap[fieldName] == nil then
                            result[fieldName] = nil
                        end
                    end
                    table.insert(resultArray, result)
                end

                dbCtrl:FillValues(resultArray)
                for _, result in ipairs(resultArray) do
                    PoolUtil.ReleaseTable(result)
                end
                PoolUtil.ReleaseTable(resultArray)
            end
            break
        end
    end
end

---订阅X3Data的变更>50%就
---@param x3DataType string
---@param persistenceFieldMap table<string, number>
function X3DataPersistence.Subscribe(x3DataType, persistenceFieldMap)
    local PersistenceFieldArray = table.keys(persistenceFieldMap)
    local x3DataFieldArray = table.keys(X3DataConst.X3DataField[x3DataType])
    --比例超过 50% 的时候就订阅类型
    if #PersistenceFieldArray / #x3DataFieldArray >= 0.5 then
        --订阅类型
        X3DataPublisher.Subscribe(x3DataType, X3DataPersistence.MarkDirty, nil)
    else
        --订阅字段
        for i = 1, #PersistenceFieldArray do
            -- 字段需要转义成标号
            X3DataPublisher.Subscribe(x3DataType, X3DataPersistence.MarkDirty, nil, X3DataConst.X3DataField[x3DataType][PersistenceFieldArray[i]])
        end
    end
end

---@param x3Data X3Data.X3DataBase
function X3DataPersistence.MarkDirty(x3Data)
    if X3DataPersistenceInfoMap[x3Data.__cname] then
        IsDirty = true
        X3DataPersistenceDirtyMap[x3Data.__cname] = 1
    end
end

---存储需要保存的持久化信息
function X3DataPersistence.SaveX3DataPersistence()
    if not IsDirty then
        return
    end

    ----todo: 剑心，写库Android暂时屏蔽 XTBUG-26572 临时解决
    for x3DataType, _ in pairs(X3DataPersistenceDirtyMap) do
        X3DataPersistence.SavePersistenceDataByDBMgr(x3DataType)
    end

    table.clear(X3DataPersistenceDirtyMap)
    IsDirty = false
end

function X3DataPersistence.Clear()
    X3DataPersistenceInfoMap = nil
    IsDirty = false
    X3DataPersistenceDirtyMap = nil
end

return X3DataPersistence