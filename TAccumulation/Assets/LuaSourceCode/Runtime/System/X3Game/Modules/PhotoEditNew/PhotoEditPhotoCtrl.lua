---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by deling.
--- DateTime: 2022/7/12 11:21
---

---照片对象逻辑类（拼图，单图）
local PhotoEditPhotoItemLogic = require "Runtime.System.X3Game.Modules.PhotoEditNew.PhotoEditPhotoItemLogic"
local PhotoEditPhotoStickerLogic = require "Runtime.System.X3Game.Modules.PhotoEditNew.PhotoEditPhotoStickerLogic"
local PurikuraConstNew = require "Runtime.System.X3Game.Modules.PurikuraNew.PurikuraConstNew"

local MementoObject = require("Runtime.System.X3Game.Modules.PurikuraProcess.MomentoBase.MementoObject")

---@class PhotoEditPhotoCtrl
local PhotoEditPhotoCtrl = class("PhotoEditPhotoCtrl")

function PhotoEditPhotoCtrl:ctor()
    self.id = nil
    self.lastSelectId = nil
    self.childPhotoList = {}
    self.stickerList = {}
    self.stickerSiblingList = {}
    self.stickerIdIndex = 1000;
    self.suitId = nil
    self.frameId = PurikuraConstNew.EmptyId
    self.filterId = PurikuraConstNew.EmptyId

    self.maxStickerNum = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PHOTOSTICKERNUMMAX)

    self.mementoList = {}
    for _, realKey in pairs(PurikuraConstNew.MementoMode) do
        self.mementoList[realKey] = MementoObject:new()
        self.mementoList[realKey]:Init()
    end
    ---长按时的初始位置
    self.exchangeStartPos = nil
end


---@param limitData table 基于整体的限制数据
function PhotoEditPhotoCtrl:Init(id, childDataList, limitData)
    self.id = id
    for index, data in pairs(childDataList) do
        self.childPhotoList[data.id] = PhotoEditPhotoItemLogic:new()
        self.childPhotoList[data.id]:Init(data, self.id)
    end

    self.exchangeData = {} ---交换数据
    for i = 1, 4 do
        self.exchangeData[i] = i;
    end

    ---用作贴纸位置生成逻辑
    local screenSize = limitData and limitData.screenSize or CS.X3Game.CameraUtility.GetScreenSize()
    self.screenOffset = limitData and limitData.screenOffset or  {x = 0, y = 0}
    self.screenSize = screenSize
    self.stickerInitPos = Vector2.new(screenSize.x / 2 + self.screenOffset.x, screenSize.y / 2 + self.screenOffset.y)
    self.stickerInitOffset = Vector2.new(20, 20)
    local offset = 100
    self.stickerInitMinPos = Vector2.new(self.screenOffset.x + offset, self.screenOffset.y + screenSize.y / 2)
    self.stickerInitMaxPos = Vector2.new(self.screenOffset.x + screenSize.x - offset, self.screenOffset.y + screenSize.y - offset)
    self.stickerMoveMin = self.screenOffset
    self.stickerMoveMax = Vector2.new(self.screenOffset.x + screenSize.x, self.screenOffset.y + screenSize.y)
end

-------临时先苟下，计算现存贴纸数量。
function PhotoEditPhotoCtrl:GetStickerNum()
    local num = 0
    for index, item in pairs(self.stickerList) do
        num = num + 1
    end
    return num
end

---供照片检查使用
function PhotoEditPhotoCtrl:GetStickerIdList()
    local list = {}
    for index, item in pairs(self.stickerList) do
        table.insert(list, item:GetConfigId())
    end
    return list
end

---添加一张贴纸
---@param stickerId int 贴纸id
function PhotoEditPhotoCtrl:AddSticker(stickerId)
    if (self:GetStickerNum() >= self.maxStickerNum) then
        UICommonUtil.ShowMessage(UITextConst.UI_TEXT_7319)
        return
    end
    local itemIndex = self.stickerIdIndex
    self:AddStickerSibling(itemIndex)
    self.stickerList[itemIndex] = PhotoEditPhotoStickerLogic:new()
    self.stickerList[itemIndex]:Init(stickerId, self.id, itemIndex, self.stickerMoveMin, self.stickerMoveMax)
    PhotoEditMgr.SelectItem(self.id, itemIndex)
    self.stickerIdIndex = self.stickerIdIndex + 1
    local startPos = self:GetStickerInitPos()
    self.stickerList[itemIndex]:SetStartPos(startPos)
end

---根据已有的数据创建贴纸
---@param data table 基础信息
function PhotoEditPhotoCtrl:AddStickerWithData(data)
    if (self:GetStickerNum() >= self.maxStickerNum) then
        UICommonUtil.ShowMessage(UITextConst.UI_TEXT_7319)
        return
    end
    local itemIndex = self.stickerIdIndex
    self:AddStickerSibling(itemIndex)
    self.stickerList[itemIndex] = PhotoEditPhotoStickerLogic:new()
    self.stickerList[itemIndex]:InitWithExData(self.id, itemIndex, data, self.stickerMoveMin, self.stickerMoveMax)
    PhotoEditMgr.SelectItem(self.id, itemIndex)
    self.stickerIdIndex = self.stickerIdIndex + 1
end

----套装的贴纸需要从配置中读信息
---@param config PhotoSuitStickers 对应配置
---@param noSelect bool 不要默认选中
function PhotoEditPhotoCtrl:AddStickerWithConfig(config, noSelect)
    local itemIndex = self.stickerIdIndex
    self:AddStickerSibling(itemIndex)
    self.stickerList[itemIndex] = PhotoEditPhotoStickerLogic:new()
    self.stickerList[itemIndex]:InitWithConfig(self.id, itemIndex, config, self.stickerMoveMin, self.stickerMoveMax)
    if (not noSelect) then
        PhotoEditMgr.SelectItem(self.id, itemIndex)
    end

    self.stickerIdIndex = self.stickerIdIndex + 1
end

---设置贴纸初始数据(与UI强相关的，例如对角线的长度)
---@param stickerIndex int 需要操作的贴纸逻辑ID
---@param data table 若干基础数据
function PhotoEditPhotoCtrl:SetStickerData(stickerIndex, data)
    if (self.stickerList[stickerIndex]) then
        self.stickerList[stickerIndex]:InitData(data)
        --self:UnSelect()
        --self:Select(stickerIndex)
    end
end

--- +1功能
---@param stickerIndex int 需要操作的贴纸逻辑ID
function PhotoEditPhotoCtrl:CopySticker(stickerIndex)
    if (self.stickerList[stickerIndex]) then
        local data = self.stickerList[stickerIndex]:GetData()
        data.pos.y = data.pos.y + 20
        data.pos.x = data.pos.x + 20

        if(data.pos.y >= self.stickerMoveMax.y) then
            data.pos.y = self.stickerMoveMax.y
            data.pos.x = self.stickerMoveMin.x
        end
        if(data.pos.x >= self.stickerMoveMax.x) then
            data.pos.x = self.stickerMoveMin.x
        end
        self:AddStickerWithData(data)
        --CopySticker()
        --local orginData =
    end
end

---翻转
---@param stickerIndex int 需要操作的贴纸逻辑ID
function PhotoEditPhotoCtrl:SwitchFlipState(stickerIndex)
    if (self.stickerList[stickerIndex]) then
        self.stickerList[stickerIndex]:SwitchFlipState()
    end
end

---进入旋转，缩放模式
function PhotoEditPhotoCtrl:SwitchRotateState(stickerIndex, state)
    if (self.stickerList[stickerIndex]) then
        self.stickerList[stickerIndex]:SwitchRotateState(state)
    end
end

----删除贴纸
---@param stickerIndex int 贴纸ID
function PhotoEditPhotoCtrl:DeleteSticker(stickerIndex)
    if (self.stickerList[stickerIndex]) then
        self.stickerList[stickerIndex] = nil
        self:RemoveStickerSibling(stickerIndex)
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoStickerDelete, self.id, stickerIndex)
        if (self.lastSelectId == stickerIndex) then
            self.lastSelectId = nil
        end
    end
end

function PhotoEditPhotoCtrl:AddStickerSibling(stickerIndex)
    table.insert(self.stickerSiblingList, stickerIndex)
end

---@param needRecord bool 需要记录操作步骤
function PhotoEditPhotoCtrl:ChangeStickerSiblingToTop(stickerIndex, needRecord)
    local tableIndex = table.removebyvalue(self.stickerSiblingList, stickerIndex)
    if(tableIndex) then
        table.insert(self.stickerSiblingList, stickerIndex)
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoStickerSiblingChange, self.id, stickerIndex, #self.stickerSiblingList)
        if(needRecord) then
            self:AddMemento(PurikuraConstNew.MementoMode.Item)
        end
    else
        Debug.LogError("ChangeStickerSiblingToTop error ", stickerIndex)
    end

end

function PhotoEditPhotoCtrl:RemoveStickerSibling(stickerIndex)
    table.removebyvalue(self.stickerSiblingList, stickerIndex)
end

---旋转照片
---@param value Quaternion 旋转值
function PhotoEditPhotoCtrl:Rotate(value)
    ---目前仅照片有
    if (self.lastSelectId) then
        local logic = self.childPhotoList[self.lastSelectId]
        if (logic) then
            logic:OnRotate(value)
        else
            Debug.LogError("Rotate no logic ", self.lastSelectId)
        end
    end
end

---获取当前选中逻辑的旋转值
---@return Quaternion
function PhotoEditPhotoCtrl:GetItemRotation()
    if (self.lastSelectId) then
        local logic = self.childPhotoList[self.lastSelectId] or self.stickerList[self.lastSelectId]
        if (logic) then
            return logic:GetRotation()
        else
            Debug.LogError("GetItemRotation no logic ", self.lastSelectId)
        end
    end
end

---获取自身基础数据
---@param notNeedFrame bool 边框无变化
---@param notNeedFilter bool 滤镜无变化
function PhotoEditPhotoCtrl:GetData(notNeedFrame, notNeedFilter)
    local data = {}
    data.frameId = (not notNeedFrame) and self.frameId or nil  ---先把边框变为增量，滤镜也需要变为增量
    data.suitId = self.suitId
    data.filterId = (not notNeedFilter) and self.filterId or nil--self.filterId
    data.exchangeData = {};
    for i = 1, #self.exchangeData do
        data.exchangeData[i] = self.exchangeData[i]
    end
    return data
end

----用于边框等，配置在表中的数据覆写(位置，选中，缩放)
---@param childId int 子照片逻辑ID
---@param data table 包含位置，选中，缩放等
function PhotoEditPhotoCtrl:SetPhotoItemData(childId, data)
    local logic = self.childPhotoList[childId]
    if (logic) then
        logic:SetPhotoItemData(data)
    else
        Debug.LogError("SetPhotoItemData no logic ", childId)
    end
end

function PhotoEditPhotoCtrl:SetStickerItemData(childId, data)
    local logic = self.stickerList[childId]
    if (logic) then
        logic:SetStickerItemData(data)
    else
        Debug.LogError("SetStickerItemData no logic ", childId)
    end
end


function PhotoEditPhotoCtrl:SetFilter(filterID)
    --for index, child in pairs(self.childPhotoList) do
    --    child:SetFilter(filterID)
    --end
    if (filterID == self.filterId) then
        return
    end
    self.filterId = filterID
    local notNeedFrame = true
    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemDataChange, self.id, self:GetData(notNeedFrame))
    ---每次变更时都会破坏套装
    self.suitId = nil
end

---设置边框
function PhotoEditPhotoCtrl:SetFrame(frameId)
    if (frameId == self.frameId) then
        return
    end
    --local detailList = nil
    --if frameId then
    --    local frameInfo = LuaCfgMgr.Get("PhotoFrame", frameId)
    --    local detailCondition = { FrameID = frameId }
    --    detailList = LuaCfgMgr.GetListByCondition("PhotoFrameDetail", detailCondition)
    --    table.sort(detailList, function(a, b)
    --        return a.Number < b.Number
    --    end)
    --
    --end
    --
    -----这里childId应该是连续数字的
    --local dataIndex = 1
    --for index, child in pairs(self.childPhotoList) do
    --    local detail = detailList and detailList[dataIndex] or nil
    --    child:OnSetFrame(detail, frameId)
    --    dataIndex = dataIndex + 1
    --end
    self.frameId = frameId or PurikuraConstNew.EmptyId
    local notNeedFilter = true
    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemDataChange, self.id, self:GetData(nil, notNeedFilter))
    ---每次变更时都会破坏套装
    self.suitId = nil
end

function PhotoEditPhotoCtrl:GetFrame()
    return self.frameId
end

---套装
function PhotoEditPhotoCtrl:SetSuit(suitId)
    if (suitId == self.suitId) then
        return
    end
    --self.frameId = nil
    --self.filterId = nil
    --self.stickerList = {}
    local orginFrame = self.frameId
    local orginFilter = self.filterId
    self.suitId = suitId

    if (suitId == nil) then
        return
    end

    local suitInfo = LuaCfgMgr.Get("PhotoSuit", suitId)
    if suitInfo.Frame ~= 0 then
        --设置边框
        self.frameId = suitInfo.Frame
    else
        self.frameId = PurikuraConstNew.EmptyId
    end

    if suitInfo.Filter ~= 0 then
        --设置滤镜
        self.filterId = suitInfo.Filter
    else
        self.filterId = PurikuraConstNew.EmptyId
    end
    for stickerIndex, sticker in pairs(self.stickerList) do
        self:DeleteSticker(stickerIndex)
    end

    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemDataChange, self.id, self:GetData(orginFrame == self.frameId, orginFilter == self.filterId))

    if (suitInfo.StickersGroup) then
        for i = 1, #suitInfo.StickersGroup do
            local condition = { StickersGroup = suitInfo.StickersGroup[i] }
            local stickers = LuaCfgMgr.GetListByCondition("PhotoSuitStickers", condition)
            for j = 1, #stickers do
                self:AddStickerWithConfig(stickers[j], true)
            end
        end
    end
end

---@param needRecord bool 需要记录操作步骤
function PhotoEditPhotoCtrl:Select(childId, needRecord)
    if (self.lastSelectId == childId) then
        return
    end

    if (self.lastSelectId) then
        self:UnSelect()
    end
    self.lastSelectId = childId

    local logic = self.childPhotoList[childId] or self.stickerList[childId]

    if (logic) then
        logic:OnSelect()
        if(self.stickerList[childId]) then
            self:ChangeStickerSiblingToTop(childId, needRecord)
        end
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemSelected, self.id, childId)
    else
        Debug.LogError("Select no logic ", childId)
    end

end

function PhotoEditPhotoCtrl:UnSelect()
    if (self.lastSelectId) then
        local logic = self.childPhotoList[self.lastSelectId] or self.stickerList[self.lastSelectId]
        if (logic) then
            logic:UnSelect()
            EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemStopUnSelect, self.id, self.lastSelectId)
        else
            Debug.LogError("UnSelect no logic ", self.lastSelectId)
        end
    end
    self.lastSelectId = nil
end

function PhotoEditPhotoCtrl:SetExchangeRootPos(pos)
    self.exchangeStartPos = pos
end

function PhotoEditPhotoCtrl:OnExchangeStart()
    local logic = self.childPhotoList[self.lastSelectId]
    if (logic) then
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoExchangeStart, self.lastSelectId)
        ---需要顺序，依赖重设的位置
        logic:OnExchangeStart(self.exchangeStartPos)
    else
        Debug.LogError("PhotoEditPhotoCtrl OnExchangeStart no logic ", self.lastSelectId)
    end
end

function PhotoEditPhotoCtrl:OnExchangeEnd()
    local logic = self.childPhotoList[self.lastSelectId]
    if (logic) then
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoExchangeResult, self.lastSelectId, logic.tempPos)
        ---先缩放，后交换，不会触发重计算，但照片尺寸实际已变化，因为这里不知道与哪张交换，全部刷下
        for id, itemLogic in pairs(self.childPhotoList) do
            --itemLogic:
        end
    else
        Debug.LogError("PhotoEditPhotoCtrl OnExchangeEnd no logic ", self.lastSelectId)
    end
end

----长按时拖动
function PhotoEditPhotoCtrl:OnExchangeDrag(deltaPos, pos)
    if (self.lastSelectId) then
        local logic = self.childPhotoList[self.lastSelectId]
        if (logic) then
            logic:OnExchangeDrag(deltaPos, pos)
        else
            Debug.LogError("PhotoEditPhotoCtrl OnExchangeDrag no logic ", self.lastSelectId)
        end
    end
end

function PhotoEditPhotoCtrl:OnDrag(deltaPos, pos)
    if (self.lastSelectId) then
        local logic = self.childPhotoList[self.lastSelectId] or self.stickerList[self.lastSelectId]
        if (logic) then
            logic:OnDrag(deltaPos, pos)
        else
            Debug.LogError("PhotoEditPhotoCtrl OnMove no logic ", self.lastSelectId)
        end
    end
end

---记录手势操作记录
function PhotoEditPhotoCtrl:OnEndDrag()
    if (self.lastSelectId) then
        self:AddMemento(PurikuraConstNew.MementoMode.Item)
        --EventMgr.Dispatch(PurikuraConstNew.Event.OnLogicChangeMemento)
        self:ForceCheckPhotoLimit()
    end
end

function PhotoEditPhotoCtrl:OnScale(delta)
    if (self.lastSelectId) then
        local logic = self.childPhotoList[self.lastSelectId] or self.stickerList[self.lastSelectId]
        if (logic) then
            logic:OnScale(delta)
        else
            Debug.LogError("PhotoEditPhotoCtrl OnScale no logic ", self.lastSelectId)
        end
    end
end


function PhotoEditPhotoCtrl:UpdatePhotoLimitScreenRect(id, data)
    local logic = self.childPhotoList[id]
    if (logic) then
        logic:UpdateLimitScreenRect(data)
    else
        Debug.LogError("UpdatePhotoLimitScreenRect no logic ", id)
    end
end

function PhotoEditPhotoCtrl:SetPhotoExchangeData(changeA, changeB)
    local tmp = self.exchangeData[changeA]
    self.exchangeData[changeA] = self.exchangeData[changeB]
    self.exchangeData[changeB] = tmp
    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoExchangeDataUpdate, {src = changeA, dst = changeB})
end

--region  操作记录
------------操作记录

function PhotoEditPhotoCtrl:GetMementoIndex()
    local memento = self.mementoList[PurikuraConstNew.MementoMode.Tab]
    return memento:GetCurIndex()
end

function PhotoEditPhotoCtrl:RecoverByTabMemento()
    local memento = self.mementoList[PurikuraConstNew.MementoMode.Tab]
    memento:RecoverEvent()
end

function PhotoEditPhotoCtrl:AddMemento(type)
    local memento = self.mementoList[type]
    local data = {}
    data.photoList = {}
    data.stickerList = {}
    data.stickerSiblingList = {}

    data.info = self:GetData()
    data.id = self.id
    for index, photoItem in pairs(self.childPhotoList) do
        local itemData = photoItem:GetData()
        --table.insert(data.photoList, )
        data.photoList[itemData.id] = itemData
        --Debug.LogError("PhotoEditPhotoCtrl:AddMemento ", itemData.pos)
    end

    for index, stickerItem in pairs(self.stickerList) do
        --table.insert(data.stickerList, stickerItem:GetData())
        local itemData = stickerItem:GetData()
        data.stickerList[itemData.id] = itemData
    end

    data.stickerSiblingList = table.clone(self.stickerSiblingList)

    memento:AddMemento(data)
    EventMgr.Dispatch(PurikuraConstNew.Event.OnLogicChangeMemento)
end

---@param isCancel bool 是否为关闭小页签
function PhotoEditPhotoCtrl:JumpFirstMemento(type, isCancel)
    local memento = self.mementoList[type]
    memento:JumpFirst(type == PurikuraConstNew.MementoMode.Item and isCancel);
    --memento:AddMemento()
    self:AddMemento(type)
end

function PhotoEditPhotoCtrl:UnDo(type)
    local memento = self.mementoList[type]
    memento:UnDoEvent()
end

function PhotoEditPhotoCtrl:ReDo(type)
    local memento = self.mementoList[type]
    memento:ReDoEvent()
end

function PhotoEditPhotoCtrl:ClearMemento(type)
    local memento = self.mementoList[type]
    memento:Clear()
end

---用于移除一切附加的操作
function PhotoEditPhotoCtrl:ReSet(type)
    --local memento = self.mementoList[type]
    --self.stickerList = {}
    --self:AddMemento(type)
    --return self.memento:ReSet()
end

function PhotoEditPhotoCtrl:CheckCanDo(type, isReDo)
    local memento = self.mementoList[type]
    return memento:CheckCanDo(isReDo)
end

function PhotoEditPhotoCtrl:OnMementoChange(data, isCancel)
    --Debug.LogError("PhotoEditPhotoCtrl OnMementoChange ")

    local changeA = nil
    local changeB = nil
    ---更新图片交换
    --local changeData = data.info.exchangeData
    --for i = 1, #changeData do
    --    if(self.exchangeData[i] ~= changeData[i]) then
    --        if(not changeA) then
    --            changeA = i
    --        elseif(not changeB) then
    --            changeB = i
    --        end
    --    end
    --    self.exchangeData[i] = changeData[i];
    --end
    --if(changeA and changeB) then
    --    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoExchangeDataUpdate, {src = changeA, dst = changeB})
    --end

    local changeData = data.info.exchangeData
    local exchangeData = table.clone(self.exchangeData)
    local changeTable = {}
    for i=1, #changeData do
        if exchangeData[i] ~= changeData[i] then
            for j=1, #exchangeData do
                if exchangeData[j] == changeData[i] then
                    table.insert(changeTable, {changeA = i, changeB = j})
                    local tmp = exchangeData[i]
                    exchangeData[i] = exchangeData[j]
                    exchangeData[j] = tmp
                    break
                end
            end
        end
        self.exchangeData[i] = changeData[i]
    end

    if #changeTable > 0 then
        for i=1, #changeTable do
            EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoExchangeDataUpdate, {src = changeTable[i].changeA, dst = changeTable[i].changeB})
        end
    end


    -----------必须先更新边框之类，否则更新完贴纸坐标，边框的Trans会改变
    local frameChange = data.info.frameId ~= self.frameId
    local filterChange = data.info.filterId ~= self.filterId
    self.suitId = data.info.suitId ---表现层其实不使用
    self.frameId = data.info.frameId
    self.filterId = data.info.filterId
    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemDataChange, self.id, self:GetData(not frameChange, not filterChange))



    local curStickerList = data.stickerList
    local curPhotoList = data.photoList
    local curStickerSiblingList = data.stickerSiblingList
    ----套装变更不更新贴纸，本身就会移除 -- id变了，也要回到之前有贴纸的时刻
    --if self.suitId == data.suitId then
    local selectedId = nil
    local realStickerList = {}

    for siblingIndex, stickerIndex in pairs(curStickerSiblingList) do
        local stickerData = curStickerList[stickerIndex]
        if(not stickerData) then
            Debug.LogError(" Restor siblingIndex Error ", stickerIndex)
            return
        end
        if (stickerData.isSelect) then
            selectedId = stickerIndex
        end
        ---存在的重设值
        if (self.stickerList[stickerIndex]) then
            self.stickerList[stickerIndex]:SetMementoData(stickerData)
            realStickerList[stickerIndex] = self.stickerList[stickerIndex]
            self.stickerList[stickerIndex] = nil
        else
            ---不存在，直接新建
            realStickerList[stickerIndex] = PhotoEditPhotoStickerLogic:new()
            realStickerList[stickerIndex]:Init(stickerData.stickerId, self.id, stickerIndex, self.stickerMoveMin, self.stickerMoveMax)
            realStickerList[stickerIndex]:SetMementoData(stickerData)
        end
        self.stickerSiblingList[siblingIndex] = stickerIndex
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoStickerSiblingChange, self.id, stickerIndex, siblingIndex)
    end

    --for stickerIndex, stickerData in pairs(curStickerList) do
        --if (stickerData.isSelect) then
        --    selectedId = stickerIndex
        --end
        -----存在的重设值
        --if (self.stickerList[stickerIndex]) then
        --    self.stickerList[stickerIndex]:SetMementoData(stickerData)
        --    realStickerList[stickerIndex] = self.stickerList[stickerIndex]
        --    self.stickerList[stickerIndex] = nil
        --else
        --    ---不存在，直接新建
        --    realStickerList[stickerIndex] = PhotoEditPhotoStickerLogic:new()
        --    realStickerList[stickerIndex]:Init(stickerData.stickerId, self.id, stickerIndex)
        --    realStickerList[stickerIndex]:SetMementoData(stickerData)
        --end
    --end
    ---删除
    for stickerIndex, sticker in pairs(self.stickerList) do
        self:DeleteSticker(stickerIndex)
    end
    self.stickerList = realStickerList
    --end

    ---照片
    for index, photoData in pairs(curPhotoList) do
        if (photoData.isSelect) then
            selectedId = index
        end
        if (self.childPhotoList[index]) then
            self.childPhotoList[index]:SetMementoData(photoData)
        end
    end

    if (selectedId and (not isCancel)) then
        self:Select(selectedId)
    else
        self:UnSelect()
    end
    EventMgr.Dispatch(PurikuraConstNew.Event.OnLogicChangeMemento)
end

function PhotoEditPhotoCtrl:GetStickerInitPos()
    local nextPos = self.stickerInitPos + self.stickerInitOffset;
    if ((nextPos.x > self.stickerInitMinPos.x and nextPos.y > self.stickerInitMinPos.y) and (nextPos.x < self.stickerInitMaxPos.x and nextPos.y < self.stickerInitMaxPos.y)) then
    else
        self.stickerInitOffset = Vector2.new(-self.stickerInitOffset.x, 0)
        nextPos = self.stickerInitPos + self.stickerInitOffset;
    end
    self.stickerInitPos = nextPos;
    return self.stickerInitPos
end

function PhotoEditPhotoCtrl:ForceCheckPhotoLimit()
    --if (self.lastSelectId and (self.id ~= PurikuraConstNew.GroupEditId)) then
    if (self.lastSelectId )then
        local logic = self.childPhotoList[self.lastSelectId]
        if (logic) then
            logic:ForceCheckPhotoLimit()
        else
            --Debug.LogError("PhotoEditPhotoCtrl ForceCheckPhotoLimit no logic ", self.lastSelectId)
        end
    end
end

function PhotoEditPhotoCtrl:Depose()
    --EventMgr.RemoveListenerByTarget(self)
end
--region end

return PhotoEditPhotoCtrl
