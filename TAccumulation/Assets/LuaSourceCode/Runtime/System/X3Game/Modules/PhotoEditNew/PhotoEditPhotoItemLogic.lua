---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by deling.
--- DateTime: 2022/7/12 11:27
---


---单张图片的逻辑
---
local PurikuraConstNew = require "Runtime.System.X3Game.Modules.PurikuraNew.PurikuraConstNew"

---@class PhotoEditPhotoItemLogic
local PhotoEditPhotoItemLogic = class("PhotoEditPhotoItemLogic")
---@type number 判断照片是否大于边框的阈值
local MoveCheckThreshold = 20

function PhotoEditPhotoItemLogic:ctor()
    self.isSelect = false
    self.pos = {x = 0, y = 0}
    self.parentId = nil
    self.id = nil
    self.rotation = nil
    self.scale = 1
    self.minPos = { x = math.mininteger, y = math.mininteger }
    self.maxPos = { x = math.maxinteger, y = math.maxinteger }
    self.maxScale = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PHOTOZOOMNOFRAMEMAX) / 100
    self.minScale = LuaCfgMgr.Get("SundryConfig", X3_CFG_CONST.PHOTOZOOMNOFRAMEMIN) / 100
    self.limitRect = nil--CS.X3Game.CameraUtility.GetScreenSize()
    self.baseSize = nil

    ---仅用作长按时的位移
    self.tempPos = {x = 0, y = 0}

    self.initPos = nil
    --self.screenRect = nil
    --self.sizeDelta = nil
end

function PhotoEditPhotoItemLogic:Init(data, parentId)
    self.pos.x = data.pos.x
    self.pos.y = data.pos.y
    self:UpdatePosLimit(data)
    --self.sizeDelta = {x = data.sizeDelta.x, y = data.sizeDelta.y}
    self.id = data.id
    self.parentId = parentId
end

function PhotoEditPhotoItemLogic:UpdatePosLimit(data)
    ---组图直接边框即可
    if (data.screenRect and data.baseSize) then

        ---23.2.21与策划沟通，组图边框规则为：图片大于边框时，最多贴边，小于边框时，使用中点。
        --local sizeX = data.baseSize.x * self.scale
        self.baseSize = data.baseSize
        self.limitRect = data.screenRect
        if(data.baseSize.width > (data.screenRect.width + MoveCheckThreshold) or data.baseSize.height > (data.screenRect.height + MoveCheckThreshold) ) then
            local center = data.screenRect.center
            self:UpdateGroupPosLimitWithScale(data.screenRect.width, data.screenRect.height, center.x, center.y)
        else
            self.minPos.x = data.screenRect.xMin
            self.minPos.y = data.screenRect.yMin
            self.maxPos.x = data.screenRect.xMax
            self.maxPos.y = data.screenRect.yMax
        end

        ----单图有特殊规则
    elseif (data.photoScreenRect) then
        self.baseSize = data.photoScreenRect
        self.limitRect = data.limitScreenRect or self.limitRect
        ---小于屏幕时，不能横向移动--23.9.11 UE新增了限位框，故这里需要配合修改
        self:UpdatePosLimitWithScale()
    end
end

---可以和下面代码合并
function PhotoEditPhotoItemLogic:UpdateGroupPosLimitWithScale(limitX, limitY, offsetX, offsetY)
    --Debug.LogError("UpdatePosLimitWithScale")
    if (not self.baseSize) then
        return
    end
    offsetX = offsetX or 0
    offsetY = offsetY or 0
    --local baseSizeX = self.baseSize.width * self.scale
    --local baseSizeY = self.baseSize.height * self.scale
    --Debug.LogError("UpdatePosLimitWithScale ", self.baseSize.width, " height ", self.baseSize.width, " minx ", self.baseSize.xMin, " Y ", self.baseSize.yMin)
    local baseSizeX = self.baseSize.width
    local baseSizeY = self.baseSize.height
    local halfScreenX = limitX / 2
    local halfScreenY = limitY / 2
    if (baseSizeX < limitX) then
        self.minPos.x = -halfScreenX + offsetX
        self.maxPos.x = halfScreenX + offsetX
    else
        local offset = baseSizeX - limitX
        self.minPos.x = offsetX - (offset / 2)
        self.maxPos.x = (offset / 2) + offsetX
    end

    if (baseSizeY < limitY) then
        self.minPos.y = -halfScreenY + offsetY
        self.maxPos.y = offsetY + halfScreenY
    else
        local offset = baseSizeY - limitY
        self.minPos.y = offsetY - (offset / 2)
        self.maxPos.y = (offset / 2) + offsetY
    end
end

---单图模式下，移动限位的特殊算法
function PhotoEditPhotoItemLogic:UpdatePosLimitWithScale()
    if (not (self.baseSize and self.limitRect)) then
        Debug.LogError("UpdatePosLimitWithScale date Error ", self.limitRect)
        return
    end
    --local baseSizeX = self.baseSize.width * self.scale
    --local baseSizeY = self.baseSize.height * self.scale
    --Debug.LogError("UpdatePosLimitWithScale ", self.baseSize.width, " height ", self.baseSize.width, " minx ", self.baseSize.xMin, " Y ", self.baseSize.yMin)
    local rectPosX = self.limitRect.x
    local rectPosY = self.limitRect.y

    local baseSizeX = self.baseSize.width
    local baseSizeY = self.baseSize.height
    local halfScreenX = self.limitRect.width / 2
    local halfScreenY = self.limitRect.height / 2
    if (baseSizeX < self.limitRect.width) then
        self.minPos.x = self.limitRect.width
    else
        local offset = baseSizeX - self.limitRect.width
        self.minPos.x = halfScreenX - (offset / 2) + rectPosX
        self.maxPos.x = halfScreenX + (offset / 2) + rectPosX
    end

    if (baseSizeY < self.limitRect.height) then
        self.minPos.y = self.limitRect.height
    else
        local offset = baseSizeY - self.limitRect.height
        self.minPos.y = halfScreenY - (offset / 2) + rectPosY
        self.maxPos.y = halfScreenY + (offset / 2) + rectPosY
    end
end

---更新照片移动的屏幕限位
function PhotoEditPhotoItemLogic:UpdateLimitScreenRect(data)
    self:UpdatePosLimit(data)
end

---按照快照重置数据
function PhotoEditPhotoItemLogic:SetMementoData(data)
    if (data.scale ~= self.scale) then
        self.scale = data.scale
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemScale, self.parentId, self.id, self.scale)
    end
    --
    if ((data.pos.x ~= self.pos.x) or (data.pos.y ~= self.pos.y)) then
        self.pos.x = data.pos.x
        self.pos.y = data.pos.y
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemMove, self.parentId, self.id, self.pos)
    end
    --
    if (data.rotation ~= self.rotation) then
        self.rotation = data.rotation
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemRotate, self.parentId, self.id, self.rotation)
    end
    if (data.baseSize ~= self.baseSize) then
        self.baseSize = data.baseSize
        self:UpdatePosLimitWithScale()
    end

end

---需要一个设置属性接口--因为部分数据仅存在表格里，且为局部坐标系
function PhotoEditPhotoItemLogic:SetPhotoItemData(data)

    ---这里应该优化，初始数据不是真正的初始位置，第一次设置这里才是
    if(not self.initPos) then
        self.initPos = { x = data.pos.x, y = data.pos.y }
    end

    if (data.pos) then
        self.pos.x = data.pos.x
        self.pos.y = data.pos.y
    end
    if (data.rotation) then
        self.rotation = data.rotation
    end
    if (data.scale) then
        self.scale = data.scale
    end
end

---获取快照数据
function PhotoEditPhotoItemLogic:GetData()
    local data = {}
    data.pos = { x = self.pos.x, y = self.pos.y }
    --data.nativeSize = { x = self.nativeSize.x, y = self.nativeSize.y }
    --data.sizeDelta = self.sizeDelta
    --data.frameId = self.frameId
    data.rotation = self.rotation
    data.isSelect = self.isSelect
    data.id = self.id
    data.parentId = self.parentId
    data.scale = self.scale
    data.baseSize = self.baseSize
    return data
end

---测试使用
--function PhotoEditPhotoItemLogic:OnDrag(deltaPos, pos)
--    local x = self.pos.x + deltaPos.x
--    local y = self.pos.y + deltaPos.y
--
--    self.pos.x = x
--    self.pos.y = y
--    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemMove, self.parentId, self.id, self.pos)
--end

---手势函数触发
function PhotoEditPhotoItemLogic:OnDrag(deltaPos, pos)
    local x = self.pos.x + deltaPos.x
    local y = self.pos.y + deltaPos.y

    --local realX = math.clamp(x, self.minPos.x, self.maxPos.x)
    --local realY = math.clamp(y, self.minPos.y, self.maxPos.y)
    local realX = self.pos.x
    local realY = self.pos.y
    local changeX = false
    local changeY = false
    if (x > self.minPos.x and x < self.maxPos.x) then
        realX = x
        changeX = true
    end
    if (y > self.minPos.y and y < self.maxPos.y) then
        realY = y
        changeY = true
    end
    --if(not ((x > self.minPos.x and y > self.minPos.y) and (x < self.maxPos.x and y < self.maxPos.y))) then
    --    return
    --end
    if (changeX or changeY) then
        self.pos.x = realX
        self.pos.y = realY
        EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemMove, self.parentId, self.id, self.pos)
    end
end

---长按浮起照片时
function PhotoEditPhotoItemLogic:OnExchangeStart(pos)
    if(pos) then
        self.tempPos.x = pos.x
        self.tempPos.y = pos.y
    else
        Debug.LogError("OnExchangeStart no pos")
    end
    --self.tempPos.x = self.pos.x
    --self.tempPos.y = self.pos.y
end
---交换状态下的移动事件
function PhotoEditPhotoItemLogic:OnExchangeDrag(deltaPos, pos)
    local x = self.tempPos.x + deltaPos.x
    local y = self.tempPos.y + deltaPos.y

    self.tempPos.x = x
    self.tempPos.y = y
    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoExchangeMove, self.parentId, self.id, self.tempPos)
end

---触发旋转
---@param value Quaternion 旋转值
function PhotoEditPhotoItemLogic:OnRotate(value)
    self.rotation = value
    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemRotate, self.parentId, self.id, value)
    --self:UpdatePosLimitWithScale()
end

function PhotoEditPhotoItemLogic:OnSelect()
    self.isSelect = true
end

function PhotoEditPhotoItemLogic:UnSelect()
    self.isSelect = false
end

---触发旋转
---@return Quaternion 旋转值
function PhotoEditPhotoItemLogic:GetRotation()
    return self.rotation
end

---形变
---@param delta int scale
function PhotoEditPhotoItemLogic:OnScale(delta)
    local result = self.scale + delta
    if result < self.minScale or result > self.maxScale then
        return
    end
    self.scale = result
    EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemScale, self.parentId, self.id, self.scale)
end

---将照片归到合适的位置 -------------self.pos的赋值可以开个函数，不用每次都新建table
function PhotoEditPhotoItemLogic:ForceCheckPhotoLimit()
    local needX = nil
    local needY = nil
    local curPosX = self.pos.x
    local curPosY = self.pos.y
    if (self.minPos.x == self.limitRect.width) then
        needX = self.initPos and self.initPos.x or self.limitRect.width / 2
    end
    if (self.minPos.y == self.limitRect.height) then
        needY = self.initPos and self.initPos.y or self.limitRect.height / 2
    end
    if (not needX) then
        if (curPosX > self.maxPos.x or curPosX < self.minPos.x) then
            needX = math.abs(curPosX - self.minPos.x) > math.abs(curPosX - self.maxPos.x) and self.maxPos.x or self.minPos.x
        end
    end

    if (not needY) then
        if (curPosY > self.maxPos.y or curPosY < self.minPos.y) then
            needY = math.abs(curPosY - self.minPos.y) > math.abs(curPosY - self.maxPos.y) and self.maxPos.y or self.minPos.y
        end
    end

    if(needX or needY)then
        needX = (not needX) and self.pos.x or needX
        needY = (not needY) and self.pos.y or needY
    end

    if(needX and needY and (not (self.pos.x == needX and self.pos.y == needY))) then
        self.pos.x = needX
        self.pos.y = needY
        EventMgr.Dispatch(PurikuraConstNew.Event.StartPhotoRestorePos, self.parentId, self.id, needX, needY)
    end
    --Debug.LogError("ForceCheckPhotoLimit mix ",self.minPos.x, " y ", self.minPos.y)
    --Debug.LogError("ForceCheckPhotoLimit maxPos ",self.maxPos.x, " y ", self.maxPos.y)
    --
    --Debug.LogError("ForceCheckPhotoLimit needX ",needX, " needY ", needY)
    -------------测试代码
    --EventMgr.Dispatch(PurikuraConstNew.Event.OnPhotoItemMove, self.parentId, self.id, self.pos)
end

return PhotoEditPhotoItemLogic