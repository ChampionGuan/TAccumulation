---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by baozhatou.
--- DateTime: 2023/05/23 18:51
---

---@type PureLogic.IComponent
local IComponent = require("PureLogic.Common.Component.IComponent")
---@class PureLogic.PlayerAIComp:PureLogic.IComponent
---@field entity PureLogic.ClientEntity
local PlayerAIComp = class("PlayerAIComp", IComponent)


---@type AI.AIMgr
local AIMgr = require("Runtime.Plugins.AIDesigner.Base.AIMgr").new()
AIMgr:SetConfig("Config.System.AIDesigner.","PureLogic.AI.AILogicContext")

function PlayerAIComp:ctor()
    ---@type PureLogic.MiaoLogicEntity
    self.entity = nil
    IComponent.ctor(self)
end

---初始化
function PlayerAIComp:OnInit()
    ---@type AITree[]
    self.AIMap = PoolUtil.GetTable()
    -- 各个功能牌对应的AITree
    self.FunCardAITreeName =
    {
        [2201] = "Miao_FuncCard_PassNum",
        [2202] = "Miao_FuncCard_PassFunc",
        --[2203] = "",-- 否决没有主动出牌的情况，写在外面 TreeName_FunCard_Veto
        [2204] = "Miao_FuncCard_GetNum",
        [2205] = "Miao_FuncCard_GetFunc",
        [2206] = "Miao_FuncCard_Reveal",
        [2207] = "Miao_FuncCard_Recycle",
        [2208] = "Miao_FuncCard_ChangeColor",
        [2209] = "Miao_FuncCard_Bankrupt",
        [2210] = "Miao_FuncCard_ChangeNum",
        [2211] = "Miao_FuncCard_Demolition",
        [2212] = "Miao_FuncCard_AddBuffNPlus",
    }
    -- 是否使用否决牌判断的AITree
    self.TreeName_FunCard_Veto = "Miao_FuncCard_Veto"
    -- 抽功能牌的AITree
    self.TreeName_DrawFunc ="Miao_FuncCard_Draw"
    -- 出数字牌
    self.TreeName_PlayNumCard = "MiaoCard_Base"
    
    self.Sequence_CardIDs = {
        [1] = 2201, -- 跳过喵，跳过数字牌阶段  
        [2] = 2205, -- 贪心喵，抽功能牌，并丢弃    
        [3] = 2202, -- 冰冻喵，跳过功能牌阶段 2203, -- 否决喵                  
        [4] = 2209, -- 破产喵，丢弃双发所有牌             
        [5] = 2206, -- 过河拆喵，看对方手牌后丢弃    2205, -- 贪心喵，抽功能牌，并丢弃      
        [6] = 2204, -- 发财喵，抽数字牌   
        [7] = 2208, -- 变色喵，随机改变格子颜色  2207, -- 顺手牵喵，从坟场回收牌       
        [8] = 2210, -- 变小喵，改格子上的卡  2208, -- 变色喵，随机改变格子颜色  
        [9] = 2211, -- 拆迁喵，拆格子上的卡     2209, -- 破产喵，丢弃双发所有牌      
        [10] = 2207, -- 顺手牵喵，从坟场回收牌        
        [11] = 2212, -- 兴奋喵，打出两张数字牌  
    }
end

---注销
function PlayerAIComp:OnDispose()
    PoolUtil.ReleaseTable(self.AIMap)
end

---暂停
function PlayerAIComp:OnPause()
end

---继续
function PlayerAIComp:OnResume()
end

---@return AITree
function PlayerAIComp:GetAITree(treeName)
    local finalTreeName = string.format("Miao.%s",treeName)
    ---@type AITree
    local aiTree = self.AIMap[finalTreeName]
    if aiTree == nil then
        aiTree = AIMgr:Create(finalTreeName,nil,nil,self.entity)
        if aiTree == nil then
            LogicUtil.LogError( "Create AI Tree failed , treeName : " , treeName)
        else
            self.AIMap[finalTreeName] = aiTree
        end
    else
        -- 清理上一次AI的数据
        aiTree:Interrupt()
    end
    return aiTree
end

---@param treeName string AI树名
---@param variable string 黑板值名
function PlayerAIComp:GetVariable(treeName,variable)
    local tree = self.AIMap[treeName]
    return tree:GetVariable(variable)
end


--- 查看当前手牌，找能用的牌和其可作用的目标对象
---@param player pbcmessage.MiaoPlayerClient
function PlayerAIComp:FindReserveFuncCards(player)
    local targetMap = {}
    local targetMapCount = 0
    local bbComp = self.entity:GetComponent(Miao.Component.Debug.BlackboardComp)
    for _,cardId in pairs(player.FuncCardList) do
        local target = targetMap[cardId]
        if target == nil then
            local cardTD = bbComp:GetMiaoCardInfoCfg(cardId)
            local effectTD = bbComp:GetMiaoCardFuncEffectCfg(cardTD.Num)
            local canUse,targets = self:FindFuncTarget(player,effectTD)
            if canUse then
                targets = targets or {}
                targetMapCount = targetMapCount + 1
                targetMap[cardId] = targets
            end
        end
    end
    return targetMap,targetMapCount
end

---@param player pbcmessage.MiaoPlayerClient
---@param effectTD cfg.MiaoCardFuncEffect
function PlayerAIComp:FindFuncTarget(player, effectTD)
    local canUse = false
    local targets = nil
    local effType = effectTD.EffectType
    
    local cardComp = self.entity:GetComponent(Miao.Component.Debug.PlayerCardComp)
    
    -- 判断能否使用
    -- 判断是否能使用
    if effType == Miao.MiaoFuncEffectType.ADDBUFF then
        canUse = cardComp:CheckFuncAddBuff(player,effectTD.Target,effectTD.Para0)
    elseif effType == Miao.MiaoFuncEffectType.VETO then
        canUse = false -- 不能主动否决牌
    elseif effType == Miao.MiaoFuncEffectType.GETCARD then
        -- 打出功能牌失效 or 额外摸牌并丢弃
        canUse = cardComp:CheckFuncDrawCard(effectTD)
    elseif effType == Miao.MiaoFuncEffectType.DISCARD or
            effType == Miao.MiaoFuncEffectType.BANKRUPT then
        local bbComp = self.entity:GetComponent(Miao.Component.Debug.BlackboardComp)
        local opponent = bbComp:GetPlayer(Miao.MiaoPlayerPos.MiaoPlayerPosP2)
        -- 看牌后丢弃 or 弃所有牌
        local cardCount = #opponent.NumCardList + #opponent.FuncCardList
        canUse = cardCount ~= 0
    elseif effType == Miao.MiaoFuncEffectType.RECYCLE then
        -- 回收牌
        canUse = cardComp:CheckFuncRecycle(effectTD.Para1)
    elseif effType == Miao.MiaoFuncEffectType.CHANGECOLOR or
            effType == Miao.MiaoFuncEffectType.CHANGENUM or
            effType == Miao.MiaoFuncEffectType.DEMOLITION then
        -- 改格子颜色、分数、重置
        targets = cardComp:FindReserveFuncSlot(effectTD)
        canUse = #targets > 0
    end

    return canUse,targets
end

--- 处理弃牌询问和否决询问的效果
---@param player pbcmessage.MiaoPlayerClient
---@param effect pbcmessage.MiaoEffect
function PlayerAIComp:HandleQueryEffect(player,effect)
    
    local result, actType, target ,cardID =true,0, 0,0
    local seat = effect.Seat
    
    if effect.EffectType == Miao.MiaoEffectType.MiaoEffectTypeVetoQuery then
        LogicUtil.Log("Handle MiaoEffectTypeVetoQuery")
        local aiTree = self:GetAITree(self.TreeName_FunCard_Veto)
        self:SetAITreeBlackboardValue(aiTree)
        aiTree:Tick()
        local checkResult = aiTree:GetVariable("CheckResult")
        if checkResult then
            actType = Miao.MiaoActionType.MiaoActionTypePlayFuncCard
            target = 2203
            cardID = 2203
        else
            -- 放弃
            actType = Miao.MiaoActionType.MiaoActionTypePassVeto
        end
    elseif effect.EffectType == Miao.MiaoEffectType.MiaoEffectTypeDiscardQuery then
        -- 弃牌询问 - 丢自己
        LogicUtil.Log("Handle MiaoEffectTypeDiscardQuery")

        -- 弃牌的类型， 0 全部 1数字 2功能 
        -- 现在默认都是0
        local cardType = effect.Params[1]
        -- 弃多少张, 默认都是1 
        local count = effect.Params[2]

        local cardList = {}
        table.merge(cardList,player.NumCardList)
        table.merge(cardList,player.FuncCardList)
        if #cardList ~= 0 then
            local random = self.entity:Random(1,#cardList)
            local targetCardId = cardList[random]
            actType = Miao.MiaoActionType.MiaoActionTypeDiscardSelf
            target = targetCardId
        else
            result = false    
        end
    elseif effect.EffectType == Miao.MiaoEffectType.MiaoEffectTypeReveal then
        -- 弃牌询问 - 丢别人
        LogicUtil.Log("Handle MiaoEffectTypeReveal")
        local cardId = 0
        if effect.Params ~= nil and #effect.Params > 0 then
            local random = self.entity:Random(1,#effect.Params)
            cardId = effect.Params[random]
            actType = Miao.MiaoActionType.MiaoActionTypeDiscardReveal
            target = cardId
        else
            result = false
            LogicUtil.Log("effect.Params is nil or empty")
        end
    else
        result = false
        LogicUtil.Log("Handle Other : " .. effect.EffectType)
    end

    if result then
        if seat == Miao.MiaoPlayerPos.MiaoPlayerPosP2 then
            actType,target,cardID = 0,0,0
        end
    end
    
    return result,actType, target ,cardID
end

--- 执行出牌的AI逻辑
---@param player pbcmessage.MiaoPlayerClient
function PlayerAIComp:ExecutePlayCardAILogic(player)
    
    local bbComp = self.entity:GetComponent(Miao.Component.Debug.BlackboardComp)
    local gameMode = bbComp:GetGameMode()
    local data = bbComp:GetBlackboardData()

    local playCardCmd = Miao.Command.PlayMiaoCardRequest
    if gameMode == 3 then
        playCardCmd = Miao.Command.MiaoPlayFuncCardRequest
    end
    local actType,actCardID,actTarget = 0,0,0
    -- 女主的ai
    if data.seat == Miao.MiaoPlayerPos.MiaoPlayerPosP1 then
        local p1 = bbComp:GetPlayer(Miao.MiaoPlayerPos.MiaoPlayerPosP1)
        if data.subState == Miao.MiaoSubState.MiaoSubStateFunc then
            actType,actCardID,actTarget = self:ExecuteFuncCardAILogic(p1)
        elseif data.subState == Miao.MiaoSubState.MiaoSubStateNum then
            actType,actCardID,actTarget = self:ExecuteNumCardAILogic(p1)
        elseif data.subState == Miao.MiaoSubState.MiaoSubStateNumPlus then
            actType,actCardID,actTarget = self:ExecuteNumCardAILogic(p1)
        else
            LogicUtil.LogError("Wrong SubState : " ..data.subState)
            return
        end
    end

    local param = PoolUtil.GetTable()
    param.ActionType = actType;
    param.CardId = actCardID
    param.Target = actTarget
    bbComp:SendToServer(playCardCmd,param)
    PoolUtil.ReleaseTable(param)
end

--- 功能牌AI逻辑
---@param player pbcmessage.MiaoPlayerClient
function PlayerAIComp:ExecuteFuncCardAILogic(player)

    local bbComp = self.entity:GetComponent(Miao.Component.Debug.BlackboardComp)
    local actType,actCardID,actTarget = Miao.MiaoActionType.MiaoActionTypeFinishFuncCard,0,0
    
    -- todo 需要优先处理否决请求和弃牌请求
    -- code
    
    -- 如果有跳过功能牌Buff，则不能主动出牌
    if bbComp:HasBuff(Miao.MiaoPlayerPos.MiaoPlayerPosP1,Miao.MiaoBuffType.MiaoBuffTypePassFunc) then
        LogicUtil.Log("Miao - Player[1] Check - Has PassNum Buff!")
        return actType,actCardID,actTarget
    end
    -- 查看当前手上的牌，筛选当前能使用的牌，以及能作用的目标对象
    local targetMap, targetMapCount = self:FindReserveFuncCards(player)
    -- 如果没有可用的牌
    if targetMapCount == 0 then
        LogicUtil.Log("Miao - Player[1] Check - Hasn't Useful Buff!")
        return actType,actCardID,actTarget
    end
    local cardSequence = self.Sequence_CardIDs
    for k,v in ipairs(cardSequence) do
        LogicUtil.Log("Miao - Player[1 Check FunCard - " .. v)
        local targets = targetMap[v]
        if targets ~= nil then
            local treeName = self.FunCardAITreeName[v]
            local aiTree = self:GetAITree(treeName)
            self:SetAITreeBlackboardValue(aiTree)
            aiTree:Tick()
            local result = aiTree:GetVariable("CheckResult")
            -- 检查结果，如果有可以出的牌
            if result then
                actType = Miao.MiaoActionType.MiaoActionTypePlayFuncCard
                actCardID ,actTarget = v, aiTree:GetVariable("TargetSlotIndex")
                LogicUtil.Log("Miao - Player[1] Check["..v.."] Usable True")
                break
            else
                LogicUtil.Log("Miao - Player[1] Check["..v.."] Usable False")    
            end
        else
            LogicUtil.Log("Miao - Player[1] Check["..v.."] Have no card")
        end
    end
    
    return actType,actCardID,actTarget 
end

---@param tree AITree
---@param player pbcmessage.MiaoPlayerClient
function PlayerAIComp:SetAITreeBlackboardValue(tree)
    local bbComp = self.entity:GetComponent(Miao.Component.Debug.BlackboardComp)
    local p1 = bbComp:GetPlayer(Miao.MiaoPlayerPos.MiaoPlayerPosP1)
    local p2 = bbComp:GetPlayer(Miao.MiaoPlayerPos.MiaoPlayerPosP2)
    -- 默认是女主
    tree:SetVariable("playerType",0);
    -- 难度，从外部设置，暂时默认为简单
    tree:SetVariable("difficulty",0);
    -- 数字牌手牌数
    tree:SetVariable("p1NumCardCount",#p1.NumCardList);
    tree:SetVariable("p2NumCardCount",#p2.NumCardList);
    -- 功能牌手牌数
    tree:SetVariable("p1FuncCardCount",#p1.FuncCardList);
    tree:SetVariable("p2FuncCardCount",#p2.FuncCardList);
    -- 双方分数 和 分差
    local p1Score,p2Score = bbComp:CalMiaoScore()
    tree:SetVariable("p1Score",p1Score);
    tree:SetVariable("p2Score",p2Score);
    tree:SetVariable("diffScore",p1Score - p2Score);
    -- 空格子数
    local emptySlotCount = #bbComp:GetEmptySlotList()
    tree:SetVariable("emptySlotCount",emptySlotCount);
    -- 功能牌检查结果每次重置为false
    tree:SetVariable("CheckResult",false);
end

---@param player pbcmessage.MiaoPlayerClient
function PlayerAIComp:ExecuteNumCardAILogic(player)
    if #player.NumCardList == 0 then
        LogicUtil.Log("Miao - Player[1] ExecuteNumCardAILogic , drawNumCard")
        return Miao.MiaoActionType.MiaoActionTypeDrawNumCard,0,0
    end

    local aiTree = self:GetAITree(self.TreeName_PlayNumCard)
    self:SetAITreeBlackboardValue(aiTree)
    aiTree:Tick()
    local actType = aiTree:GetVariable("actionType")
    local actCardID = aiTree:GetVariable("actionCardID")
    local actSlotIndex = aiTree:GetVariable("actionSlotIndex")
    LogicUtil.Log("Miao - Player[1] ExecuteNumCardAILogic ,actType : " .. actType)
    return actType,actCardID,actSlotIndex
end

return PlayerAIComp
