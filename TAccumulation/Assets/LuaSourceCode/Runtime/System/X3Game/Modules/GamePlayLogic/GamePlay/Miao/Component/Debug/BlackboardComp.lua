---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by baozhatou.
--- DateTime: 2023/05/23 18:51
---

---@type PureLogic.IComponent
local IComponent = require("PureLogic.Common.Component.IComponent")
---@class PureLogic.BlackboardComp:PureLogic.IComponent
---@field entity PureLogic.ClientEntity
---@field private blackboardData CatCardStateData
---@field private ChessBoard pbcmessage.MiaoChessBoardReply
---@field private MiaoPlayers pbcmessage.MiaoPlayerClient[]
local BlackboardComp = class("BlackboardComp", IComponent)

local state_data = require("Runtime.System.X3Game.Modules.GamePlayLogic.GamePlay.Miao.Data.BlackboardData")
local config = nil

function BlackboardComp:ctor()
    ---@type PureLogic.MiaoLogicEntity
    self.entity = nil
    IComponent.ctor(self)
end

---初始化
function BlackboardComp:OnInit()
    self.initCompleted = false
end

---暂停
function BlackboardComp:OnPause()
end

---继续
function BlackboardComp:OnResume()
end

---注销
function BlackboardComp:OnDispose()
    if config ~= nil then
        PoolUtil.ReleaseTable(config)
    end
end

---@private
function BlackboardComp:InitConfig()
    config = PoolUtil.GetTable()
    local subID = self.entity:GetLevelId()
    config.DifficultyCfg =  LuaCfgMgr.Get("MiaoCardDifficulty",subID)
    if config.DifficultyCfg == nil then
        LogicUtil.LogError("Init MiaoCardDifficulty Failed! SubID:" .. subID)
    end
    print("BlackboardComp : InitConfig Completed")
end

--- 初始化数据后赋值
function BlackboardComp:OnDatePrepared()
    if self.initCompleted then
        return
    end
    self.initCompleted = true
    
    self:InitConfig()
    self.blackBoardData = state_data.new()
    -- 获取关卡配置
    local subTD = self:GetDifficultyCfg()
    self.gameMode = subTD.Group
end

--- 解析数据
function BlackboardComp:ParseData(msg)
    self.blackBoardData:ParseInfo(msg)
    if msg.ChessBoard then
        self.ChessBoard = msg.ChessBoard
    end
    if msg.MiaoPlayers then
        self.MiaoPlayers = msg.MiaoPlayers
    end
end

--- 发送消息给数据层(AI跑测用的接口)
function BlackboardComp:SendToServer(cmdType,cmdParam)
    if PURELOGIC_MIAO_TEST_ERROE_INFO ~= 0 then
        LogicUtil.Log("Some Error, Pause Command")
        return
    end
    --LogicUtil.Log("BlackboardComp , SendToServer CmdType : " .. cmdType  .. " Param : " .. table.dump(cmdParam))
    self.entity:SendToServer(cmdType,cmdParam or {})
end

--- 获取黑板数据
---@return CatCardStateData
function BlackboardComp:GetBlackboardData()
    return self.blackBoardData
end

--- 获取当前模式(基础、功能 等)
---@return number
function BlackboardComp:GetGameMode()
    return self.gameMode
end

---@return pbcmessage.MiaoPlayerClient[]
function BlackboardComp:GetPlayers()
    return self.MiaoPlayers
end

---@param seat Miao.MiaoPlayerPos
---@return pbcmessage.MiaoPlayerClient
function BlackboardComp:GetPlayer(seat)
    return self.MiaoPlayers[seat]
end

---@return pbcmessage.MiaoChessBoardReply
function BlackboardComp:GetChessBoard()
   return self.ChessBoard 
end

---@return pbcmessage.MiaoSlot[]
function BlackboardComp:GetSlotList()
    return self.ChessBoard.SlotList
end

---@private
---@return table{}
function BlackboardComp:GetCalculatorData()
    local record = {
        ChessBoard = self.ChessBoard,
        MiaoPlayers = self.MiaoPlayers
    }
    return record
end

--- 获取难度配置表
---@return cfg.MiaoCardDifficulty
function BlackboardComp:GetDifficultyCfg()
    return config.DifficultyCfg
end

--- 获取card配置信息
---@return cfg.MiaoCardInfo
function BlackboardComp:GetMiaoCardInfoCfg(cardID)
    local cfg = LuaCfgMgr.Get("MiaoCardInfo",cardID)
    return cfg
end

--- 获取功能牌effect配置信息
---@return cfg.MiaoCardFuncEffect
function BlackboardComp:GetMiaoCardFuncEffectCfg(id)
    local cfg = LuaCfgMgr.Get("MiaoCardFuncEffect",id)
    return cfg
end

--- 获取spAction配置
---@return cfg.MiaoCardSPAction
function BlackboardComp:GetMiaoCardSPActionCfg(spAction)
    return LuaCfgMgr.Get("MiaoCardSPAction",spAction)
end

---@return pbcmessage.MiaoSlot[]
function BlackboardComp:GetEmptySlotList()
    local list = {}
    for k,v in pairs(self.ChessBoard.SlotList) do
        if v.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosNope then
            table.insert(list,v)
        end
    end
    return list
end

---@return table<number>
function BlackboardComp:GetEmptySlotIndexList()
    local list = {}
    for k,v in pairs(self.ChessBoard.SlotList) do
        if v.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosNope then
            table.insert(list,k)
        end
    end
    return list
end

--- 判断是否有Buff
---@param seat Miao.MiaoPlayerPos 玩家类型
---@param buffId number 
function BlackboardComp:HasBuff(seat,buffId)
    local player = self.MiaoPlayers[seat]
    for k,v in pairs(player.BuffList) do
        if v == buffId then
            return true
        end
    end
    return false
end


---@param player pbcmessage.MiaoPlayerClient
---@return boolean 手牌是否已满
function BlackboardComp:IsHandFull(player)
    local subTD = self:GetDifficultyCfg()
    local cardCount = #player.NumCardList + #player.FuncCardList
    return cardCount >= subTD.HandCardLimit
end

---@param player pbcmessage.MiaoPlayerClient
---@param subType Miao.MiaoHandSubClass
---@return boolean 手牌是否已满
function BlackboardComp:IsHandEmpty(player,subType)
    local hasCardCount = 0
    if subType == Miao.MiaoHandSubClass.MiaoHandSubClassNum then
        hasCardCount = #player.NumCardList
    elseif subType == Miao.MiaoHandSubClass.MiaoHandSubClassFunc then
        hasCardCount = #player.FuncCardList
    else
        hasCardCount = #player.NumCardList + #player.FuncCardList
    end
    return hasCardCount == 0
end

--- 检查effect是否能作用于指定的格子
---@param slot pbcmessage.MiaoSlot
---@param effectTD cfg.MiaoCardFuncEffect
function BlackboardComp:IsEffUsableInSlot(slot, effectTD)
    if slot == nil then
        return false
    end
    -- 对目标格子没有要求 
    if effectTD.Target == Miao.MiaoFuncEffectTargetType.NONE then
        return true
    end
    -- 没有被占领 
    if slot.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosNope then
        return false
    end

    local seat = Miao.MiaoPlayerPos.MiaoPlayerPosP1
    local playerType = 0
    if effectTD.Target == Miao.MiaoFuncEffectTarget.OPPONENT then
        seat = Miao.MiaoPlayerPos.MiaoPlayerPosP2
        playerType = 1
    end

    if slot.Occupy ~= seat then
        return false
    end
    return true
end

--- 计算插槽的分数
---@param slot pbcmessage.MiaoSlot
---@param cardID number 指定牌的id，如果传了就会以这个牌id来计算分数
---@return number
function BlackboardComp:CalSlotScore(slot, cardID)
    if slot.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosNope and cardID == nil then
        return 0
    end

    ---@type cfg.MiaoCardInfo
    local slotTD = self:GetMiaoCardInfoCfg(slot.SlotId)
    ---@type cfg.MiaoCardInfo
    local cardId = cardID and cardID or slot.CardId
    local occupyCardTD = self:GetMiaoCardInfoCfg(cardId)
    local sc = 0
    -- 普通插槽
    if slotTD.SubClass == Miao.MiaoSlotSubClass.MiaoSlotSubClassNormal then
        sc = occupyCardTD.Num
        -- 同色
    elseif slotTD.Type == occupyCardTD.Type then
        sc = occupyCardTD.Num * 2
    end
    return sc
end


--- 计算玩家当前数字牌出牌能获得的最大分数
---@param player pbcmessage.MiaoPlayer
---@param onlyDouble boolean 是否只针对双倍格子做计算
---@param excludeSlotIndex number 需要排除计算的格子索引
---@param slotList pbcmessage.MiaoSlot[] 指定的格子数据，不填则默认是当前的状态的格子
---@return number,number,number 出牌能获得的最大分数, 出的牌的id，格子索引
function BlackboardComp:CalMaxScoreByNumCards(player,onlyDouble,excludeSlotIndex,slotList)
    local maxScore,cardID,slotIndex = self:CalMaxScoreByNumCardsByCards(player.NumCardList,onlyDouble,excludeSlotIndex,slotList)
    return  maxScore,cardID,slotIndex
end

--- 计算玩家当前数字牌出牌能获得的最大分数
---@param numCardList table 数字牌手牌列表
---@param onlyDouble boolean 是否只针对双倍格子做计算
---@param excludeSlotIndex number 需要排除计算的格子索引
---@param slotList pbcmessage.MiaoSlot[] 指定的格子数据，不填则默认是当前的状态的格子
---@return number,number,number 出牌能获得的最大分数, 出的牌的id，格子索引
function BlackboardComp:CalMaxScoreByNumCardsByCards(numCardList,onlyDouble,excludeSlotIndex,slotList)
    local maxScore,cardID,slotIndex = -1,0,0    -- 出牌即使得分为0，也认为可以出牌

    if slotList == nil then
        slotList = self:GetSlotList()
    end
    for i = 1 , #numCardList do
        local cardId = numCardList[i]
        for j = 1, #slotList do
            local slot = slotList[j]
            -- 只计算没被占领的格子
            if slot.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosNope then
                local fit = true
                -- 不计算指定被排除的格子
                if j ~= excludeSlotIndex then
                    -- 如果只计算双倍格子
                    if onlyDouble then
                        local slotTD = self:GetMiaoCardInfoCfg(slot.SlotId)
                        if slotTD.SubClass ~= Miao.MiaoSlotSubClass.MiaoSlotSubClassDouble then
                            fit = false
                        end
                    end
                    if fit then
                        local score = self:CalSlotScore(slot,cardId)
                        if score > maxScore then
                            maxScore,cardID,slotIndex = score,cardId,j
                        end
                    end
                end
            end
        end
    end
    return maxScore,cardID,slotIndex
end

--- 计算双方分数
---@param slotList pbcmessage.MiaoSlot[] 棋牌格列表，如果传了这个参数，就以这个参数来做计算
---@return number,number p1分数，p2分数
function BlackboardComp:CalMiaoScore(slotList)
    local p1Score,p2Score = 0,0
    local chessBoardSlotList = slotList or self.ChessBoard.SlotList
    for _,v in ipairs(chessBoardSlotList) do
        if v.Occupy ~= Miao.MiaoPlayerPos.MiaoPlayerPosNope then
            local sc = self:CalSlotScore(v)
            if v.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosP1 then
                p1Score = p1Score + sc
            elseif v.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosP2 then
                p2Score = p2Score + sc
            end
        end
    end
    return p1Score,p2Score
end


---检查是否触发SP请求
---@param player pbcmessage.MiaoPlayerClient
---@param spRecords pbcmessage.MiaoSPRecord
---@param spAction pbcmessage.MiaoSPRecord
function BlackboardComp:CheckSPAction(player,spRecords,spAction)
    local result = false
    -- 如果有SP,直接触发SP
    if not table.isnilorempty(spAction) and spAction.id then
        if spAction.id == Miao.MiaoSPActionType.MiaoSPActionTypeReplace then
            -- ST 神游 
            result = self:SendSPReplaceRequest()
        elseif spAction.id == Miao.MiaoSPActionType.MiaoSPActionTypeSteal then
            -- FY 偷牌
            result = self:SPStealRequest()
        elseif spAction.id == Miao.MiaoSPActionType.MiaoSPActionTypeUndo then
            -- RY 悔牌
            result = self:SendSPUndoRequest(player)
        elseif spAction.id == Miao.MiaoSPActionType.MiaoSPActionTypeRob then
            -- YG 抢牌
            result = self:SendSPRobRequest()
        else
            -- nothing
        end
    end
    return result
end

-- 神游，换场上的牌
function BlackboardComp:SendSPReplaceRequest()
    local slotList = self:GetSlotList()
    -- 筛选当前可用于换牌的格子
    local slotIndexList = PoolUtil.GetTable()
    for k,v in pairs(slotList) do
        if v.Occupy ~= Miao.MiaoPlayerPos.MiaoPlayerPosNope then
            table.insert(slotIndexList,k)
        end
    end
    if #slotIndexList == 0 then
        LogicUtil.LogError("SendSPReplaceRequest Error!")
        return false
    end
    -- 随机选两个
    local random = self.entity:Random(1,#slotIndexList)
    local slotFromIndex = slotIndexList[random]
    table.remove(slotIndexList,random)
    random = self.entity:Random(1,#slotIndexList)
    local slotToIndex = slotIndexList[random]
    PoolUtil.ReleaseTable(slotIndexList)
    ---@type pbcmessage.MiaoSPReplaceRequest
    local param = PoolUtil.GetTable()
    param.SlotFromIndex = slotFromIndex
    param.SlotToIndex = slotToIndex
    self:SendToServer(Miao.Command.MiaoSPReplaceRequest,param)
    PoolUtil.ReleaseTable(param)

    return true
end

-- 偷牌
function BlackboardComp:SPStealRequest()
    return false
end

-- 玩家抢牌
function BlackboardComp:SendSPRobRequest()
    return false
end

-- 抢牌获得牌
function BlackboardComp:SendSPRobGetCard()
    return false
end

-- 交换手牌
function BlackboardComp:SendSPExchangedRequest()
    local random = self.entity:Random(1,2)
    if random == 1 then
        local param = PoolUtil.GetTable()
        self:SendToServer(Miao.Command.MiaoSPExchangeHandRequest,param)
        PoolUtil.ReleaseTable(param)
        return true
    end
    return false
end

-- 交换手牌后悔牌
function BlackboardComp:SendSPExchangedUndo()
    local random = self.entity:Random(1,2)
    if random == 1 then
        local param = PoolUtil.GetTable()
        self:SendToServer(Miao.Command.MiaoSPExchangeHandUndoRequest,param)
        PoolUtil.ReleaseTable(param)
        return true
    end
    return false
end

-- 悔牌
---@param player pbcmessage.MiaoPlayerClient
function BlackboardComp:SendSPUndoRequest(player)
    --[[
        1:开始悔牌 
        2:抓包失败，悔牌成功 
        3：抓包成功，阻止换牌，
        4：抓包成功，女主不能换牌，
        5：抓包成功，女主换牌，
        6：抓包成功，女主放弃换牌
    ]]--
    local random = self.entity:Random(2,6)
    local choice = random
    local cardID = 0
    local slotIndex = 0
    if random == 5 then
        if #player.NumCardList == 0 then
            choice = 6 -- 没有手牌，放弃换牌
        else
            local slotList = self:GetSlotList()
            local targetSlotList = PoolUtil.GetTable()
            for k,v in pairs(slotList) do
                if v.Occupy == Miao.MiaoPlayerPos.MiaoPlayerPosP1 then
                    table.insert(targetSlotList,k)
                end
            end
            if #targetSlotList == 0 then
                -- 没有出过牌，放弃换牌
                choice = 6;
            else
                random = self.entity:Random(1,#player.NumCardList)
                cardID = player.NumCardList[random]
                random = self.entity:Random(1,#targetSlotList)
                slotIndex = targetSlotList[random]
            end
            PoolUtil.ReleaseTable(targetSlotList)
        end
    end
    ---@type pbcmessage.MiaoSPUndoRequest
    local param = PoolUtil.GetTable()
    param.Choice = choice
    param.P1CardId = cardID
    param.P1SlotIndex = slotIndex
    self:SendToServer(Miao.Command.MiaoSPUndoRequest,param)
    PoolUtil.ReleaseTable(param)
    return true
end



function BlackboardComp:Log(content)
    Debug.Log("Miao BlackboardComp ")
    LogicUtil.Log(content)
end

return BlackboardComp