---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by changkong.
--- DateTime: 2021/9/2 14:08
--- 动态绑定轨道对象处理
local X3TimelineUtility = CS.X3.X3TimelineUtility
local BaseFeature = require("Runtime.System.X3Game.Modules.Timeline.Feature.BaseFeature")
-- 已知对象池配套的onDiscard方法，此处已经通过别的方式清理过了，没有添加这个方法
---@class TimelineTrackBindFeature:TimelineBaseFeature
local TrackBindFeature = XECS.class("TrackBindFeature", BaseFeature, true, 6)

local loopFxGroupName = "Loop Fx Group"
local RuntimeCinemachineClipName = "BattleRuntime"
local TimelineInterruptTool = CS.UnityEngine.Timeline.TimelineInterruptTool
local AnimationTrackType = typeof(CS.UnityEngine.Timeline.AnimationTrack)
local ControlTrackType = typeof(CS.UnityEngine.Timeline.ControlTrack)
local PhysicsWindTrackType = typeof(CS.UnityEngine.Timeline.PhysicsWindTrack)
local VisibilityTrackType = typeof(CS.UnityEngine.Timeline.VisibilityTrack)
local CharacterPartTrack = typeof(CS.UnityEngine.Timeline.CharacterPartTrack)
local FxPlayerTrackType = typeof(CS.UnityEngine.Timeline.FxPlayerTrack)
local GhostTrackType = typeof(CS.UnityEngine.Timeline.GhostTrack)
local CameraMixingTrack = typeof(CS.CameraMixingTrack)
local HookDetachPlayable = CS.PapeGames.HookDetachPlayable
local EffectFollowPosPlayable = CS.PapeGames.EffectFollowPosPlayable
local ZeroExtData = CS.UnityEngine.Timeline.TrackExtData()
ZeroExtData.localScale = Vector3.one

function TrackBindFeature:_OnBuild()
    self:_Reset()
    self.loopFxTracks = {}
    self.animationBindObj = {}
    self.stopByTimeTracks = {}
    self.subTranList = {}
    ---@type GameObject[] 所有加载出来的对象
    self.director = self.timeline:GetPlayableDirector()
    self.creator = self.timeline:GetForceBindObj()
    self.isFollowCreator = self.timeline:IsFollowCreator()
    self:InitTracks()
    return true
end

function TrackBindFeature:_Reset()
    ---@type table<TrackAsset, boolean> 预览loopFx的track
    self.loopFxTracks = nil
    ---@type table<string, GameObject> animation轨道绑定的对象
    self.animationBindObj = nil
    ---@type table<string, GameObject> 只受时间关闭的track
    self.stopByTimeTracks = nil
    ---@type GameObject[] 所有加载出来的对象
    self.subTranList = nil
    ---@type boolean 是否含有材质子轨道
    self.hasCreatureMaterialAnim = false
    ---@type boolean 是否受到时间独立结束
    self.isStopByTime = false
    self.director = nil
    self.creator = nil
    self.isFollowCreator = nil
end

-- 绑定轨道
function TrackBindFeature:InitTracks()
    local timelineAsset = self.timeline:GetTimelineAsset()
    local allTracks = timelineAsset:GetOutputTracks()
    local lastTrack  -- 上个被处理的轨道
    local lastIsHookEffectTrackAndObj = nil  -- 上个轨道是hookEffect轨并且获取到的绑定Obj
    for i = 0, allTracks.Length - 1 do
        local curHookEffectGameObj = nil  -- 本次是hookEffectGameObject
        local baseTrack = allTracks[i]
        -- 处理预览group，by雨天
        if not self:EvalLoopFXGropup(baseTrack) then
            local trackType = baseTrack:GetType()
            if trackType == AnimationTrackType then
                self:EvalAnimationTrack(baseTrack, lastIsHookEffectTrackAndObj)
            elseif trackType == ControlTrackType then
                curHookEffectGameObj = self:EvalControlTrack(baseTrack)
            elseif trackType == PhysicsWindTrackType then
                self:BindPhysicsWindTrack(self.director, baseTrack)
            elseif trackType == VisibilityTrackType then
                self:BindVisibilityTrack(self.director, baseTrack)
            elseif trackType == CharacterPartTrack then
                self:BindCharacterPartTrack(self.director, baseTrack)
            elseif trackType == FxPlayerTrackType then
                self:BindFxPlayerTrack(self.director, baseTrack)
            elseif trackType == GhostTrackType then
                self:BindGhostTrack(lastTrack, baseTrack)
            elseif trackType == CameraMixingTrack then
                self:EvalCinemachineTrack(baseTrack)
            end
        end
        lastIsHookEffectTrackAndObj = curHookEffectGameObj
        lastTrack = baseTrack
    end
    local timelineTrans = self.timeline:GetResObj().transform
    self:SetTimelineParent(self.creator, self.isFollowCreator, timelineTrans, ZeroExtData)
end

---@return boolean 是否走了预览处理逻辑
function TrackBindFeature:EvalLoopFXGropup(baseTrack)
    -- 预览Group处理
    local baseTrackParent = baseTrack.parent
    if baseTrackParent and baseTrackParent.name == loopFxGroupName then
        baseTrack.muted = true
        self.loopFxTracks[baseTrack] = true
        return true
    end
    return false
end

------------------------------------------ CinemachineTrack的处理 --------------------------------
function TrackBindFeature:EvalCinemachineTrack(track)
    -- 绑定track
    local cameraBrain = GlobalCameraMgr.GetCameraBrain()
    self.director:SetGenericBinding(track, cameraBrain)
    -- 绑定clip
    local clips = track:GetClipsArray()
    for i = 0, clips.Length - 1 do
        local timelineClip = clips[i]
        if timelineClip.displayName == RuntimeCinemachineClipName then
            local ctrlClip = timelineClip.asset
            local vartualCamera = g_BattleClient.cameraTrace and g_BattleClient.cameraTrace:GetVirtualCamera()
            X3TimelineUtility.BindCinemachineClip(self.director, ctrlClip, vartualCamera)
        end
    end
end

------------------------------------------ ControlTrack 的处理 -----------------------------------------
function TrackBindFeature:EvalControlTrack(controlTrack)
    local extData = controlTrack.extData
    local trackType = extData:GetTrackExtTypeInt()
    local curHookEffectGameObj
    if trackType == TrackExtType.HookEffect then
        self:EvalTrackIsStopByTime(controlTrack, extData.isStopByTime)
        local hookTran  -- 取到人物身上的挂载点
        if self.creator then
            hookTran = self:GetHookTransformByCreator(self.creator, extData.HookName)
        else
            hookTran = self:GetHookTransformByTrackExtData(extData)
        end
        curHookEffectGameObj = self:SetTrackEffect(self.director, controlTrack, extData, hookTran, extData.isFollowActor, false);
    elseif trackType == TrackExtType.IsolateEffect then
        self:EvalTrackIsStopByTime(controlTrack, extData.isStopByTime)
        -- isolate是独立特效，不会被设置到父节点上
        self:SetTrackEffect(self.director, controlTrack, extData, self.creator and self.creator.transform, false, false);
    end
    return curHookEffectGameObj
end

-- 处理需要根据时间结束的track（目前只有HookEffect和IsolateEffect会调到这个）
function TrackBindFeature:EvalTrackIsStopByTime(baseTrack, stopByTime)
    -- 若存在一个Track独立播放，则整个timeline独立播放
    if stopByTime then
        self.stopByTimeTracks[baseTrack] = true
        self.isStopByTime = true
        self.timeline.isStopByTime = true
    end
end

function TrackBindFeature:GetHookTransformByTrackExtData(auxData)
    local roleType = TimelineUtil:GetBindRoleTypeByTrackExtData(auxData)
    local role = self:GetRoleGOByRoleType(roleType)
    if role then
        local hookTrans = role.transform:Find(auxData.HookName)
        return hookTrans
    else
        self.context:LogError(string.format("警告！没有找到hook绑定对象。suitName=%s, topParentName=%s", auxData.bindSuitName, auxData.TopParentName))
    end
end

function TrackBindFeature:GetHookTransformByCreator(creator, HookName)
    return creator.transform:Find(HookName);
end

function TrackBindFeature:SetTrackEffect(director, track, VARIABLE, parentObj, followRoot, followScale)
    if not VARIABLE.bindPath or VARIABLE.bindPath == "" then
        return
    end
    -- 不是animation类型的可以重复创建
    local obj = self:InitOtherEffect(VARIABLE.bindPath)
    if obj then
        self.animationBindObj[VARIABLE.bindPath] = obj
        self:SetTimelineParent(parentObj, followRoot, obj.transform, VARIABLE, followScale)
        local trackType = VARIABLE:GetTrackExtTypeInt()
        if trackType == TrackExtType.HookEffect then
            -- hookEffect需要特殊处理，释放的那一刻取挂点信息，此刻父节点需要重设回去
            obj.transform.parent = parentObj
        end
        self:BindControlTrack(director, track, obj, VARIABLE, parentObj)
    end

    -- 编辑器下不设置轨道muted
    if not UNITY_EDITOR then
        track.muted = not obj
    end

    return obj
end

function TrackBindFeature:BindControlTrack(director, track, bindObj, trackExtData, creatureTran)
    local clips = track:GetClipsArray()
    for i = 0, clips.Length - 1 do
        local ctrlClip = clips[i].asset  -- ControlPlayableAsset
        X3TimelineUtility.BindControlClip(self.director, ctrlClip, bindObj)
        local trackType = trackExtData:GetTrackExtTypeInt()
        if trackType == TrackExtType.HookEffect then
            local hookDetachPlayable = HookDetachPlayable()
            hookDetachPlayable:SetData(trackExtData)
            ctrlClip:SetMountBehaviour(hookDetachPlayable)
        elseif trackType == TrackExtType.IsolateEffect and trackExtData.isFollowReferencePos then
            local effectFollowPos = EffectFollowPosPlayable()
            effectFollowPos:SetReferent(creatureTran)
            ctrlClip:SetMountBehaviour(effectFollowPos)
        end
    end
end

-------------------------------------------- AnimationTrack的处理 -------------------------------------
-- 处理Animation轨
function TrackBindFeature:EvalAnimationTrack(animTrack, lastIsHookEffectTrackAndObj)
    local extData = animTrack.extData
    local trackType = extData:GetTrackExtTypeInt()
    if trackType == TrackExtType.CreatureAnim or trackType == TrackExtType.CameraAnim then
        self:BindActorAnim(self.director, animTrack, extData)
        if (animTrack.HasMaterialSubTrack) then
            self.hasCreatureMaterialAnim = true
            self.timeline:SetHasCreatureMaterialAnim(true)
        end
    elseif trackType == TrackExtType.HookEffectAnim then
        self.director:SetGenericBinding(animTrack, lastIsHookEffectTrackAndObj)
    elseif trackType == TrackExtType.IsolateEffectAnim then
        self:SetTrackAnim(self.director, animTrack, extData, self.creator, self.isFollowCreator, false)
    end
end

-- 动态绑定actor的动画
function TrackBindFeature:BindActorAnim(director, track, trackExtData)
    if not self.creator then
        -- 表演模式根据绑定信息设置
        track.muted = false
        local roleType = TimelineUtil:GetBindRoleTypeByTrackExtData(trackExtData)
        local bindGameObject = self:GetRoleGOByRoleType(roleType)
        if bindGameObject then
            local trans = bindGameObject.transform
            X3TimelineUtility.SetTransPositionByExtData(trans, trackExtData)
            X3TimelineUtility.SetTransRotationByExtData(trans, trackExtData)
            X3TimelineUtility.SetTransLocalScaleByExtData(trans, trackExtData)
            if roleType == TrackBindRoleType.Male or roleType == TrackBindRoleType.Female or roleType == TrackBindRoleType.Monster then
                -- 男女主怪物现在不走timeline播表演了，而是生成playable，此处直接muted即可
                track.muted = true
            else
                director:SetGenericBinding(track, bindGameObject)
            end
        end
    else
        -- 技能模式直接设置mute
        track.muted = true
    end
end

function TrackBindFeature:GetRoleGOByRoleType(roleType)
    if roleType == TrackBindRoleType.Female then
        return self.timeline.womanObj
    elseif roleType == TrackBindRoleType.Male then
        return self.timeline.manObj
    elseif roleType == TrackBindRoleType.Monster then
        return self.timeline.monsterObj
    end
end

-- 设置轨道特效
function TrackBindFeature:SetTrackAnim(director, track, VARIABLE, parentObj, followRoot, followScale)
    local bindPath = VARIABLE.bindPath
    if not bindPath or bindPath == "" then
        return
    end
    -- animation类型的唯一
    local obj = self.animationBindObj[bindPath]
    if not obj then
        obj = self:InitOtherEffect(bindPath)
    end
    if obj then
        self.animationBindObj[bindPath] = obj
        self:SetTimelineParent(parentObj, followRoot, obj.transform, VARIABLE, followScale)
        obj:SetActive(true)
        director:SetGenericBinding(track, obj)
    end
end

-- 加载一个特效对象
function TrackBindFeature:InitOtherEffect(bindPath)
    local obj = self.context:LoadTimelineFxObject(bindPath)
    if obj then
        table.insert(self.subTranList, obj)
        obj:SetActive(false)
        return obj
    else
        self.context:LogError(string.format("timeline特效加载失败，如果GM中关闭了timeline特效，忽略这条报错！%s", bindPath))
    end
end

-- 设置节点的Parent
function TrackBindFeature:SetTimelineParent(parentObj, followRoot, childTran, extData, followScale)
    if parentObj then
        local parentTran = parentObj.transform
        if followRoot then
            childTran.parent = parentTran
            if extData then
                X3TimelineUtility.SetTransLocalPositionByExtData(childTran, extData)
                X3TimelineUtility.SetTransLocalRotationByExtData(childTran, extData)
            end
        else
            childTran.parent = self.context:GetRootTransform()
            if extData then
                X3TimelineUtility.SetTransPositionByExtData(childTran, extData, parentTran)
                X3TimelineUtility.SetTransRotationByExtData(childTran, extData, parentTran)
            end
        end
        if extData then
            X3TimelineUtility.SetTransLocalScaleByExtData(childTran, extData)
        end
    else
        childTran.parent = self.context:GetRootTransform()
        if extData then
            X3TimelineUtility.SetTransPositionByExtData(childTran, extData)
            X3TimelineUtility.SetTransRotationByExtData(childTran, extData)
            X3TimelineUtility.SetTransLocalScaleByExtData(childTran, extData)
        end
    end
end

---------------------------------------------- 设置风场相关 ----------------------------------------
function TrackBindFeature:BindPhysicsWindTrack(director, track)
    if self.creator then
        director:SetGenericBinding(track, self.creator)
    else
        local extData = track.extData
        local roleType = TimelineUtil:GetBindRoleTypeByTrackExtData(extData)
        local bindGameObject = self:GetRoleGOByRoleType(roleType)
        if bindGameObject then
            director:SetGenericBinding(track, bindGameObject)
        end
    end
end

---------------------------------------------- 设置人物可见性相关 ----------------------------------------
function TrackBindFeature:BindVisibilityTrack(director, track)
    if self.creator then
        director:SetGenericBinding(track, self.creator)
    else
        local extData = track.extData
        local roleType = TimelineUtil:GetBindRoleTypeByTrackExtData(extData)
        local bindGameObject = self:GetRoleGOByRoleType(roleType)
        if bindGameObject then
            director:SetGenericBinding(track, bindGameObject)
        end
    end
end

--------------------------------------- 设置人物部件相关 -----------------------------------------
function TrackBindFeature:BindCharacterPartTrack(director, track)
    if self.creator then
        director:SetGenericBinding(track, self.creator)
    else
        local extData = track.extData
        local roleType = TimelineUtil:GetBindRoleTypeByTrackExtData(extData)
        local bindGameObject = self:GetRoleGOByRoleType(roleType)
        if bindGameObject then
            director:SetGenericBinding(track, bindGameObject)
        end
    end
end

-------------------------------------------- 设置特效动画相关-------------------------------------------
function TrackBindFeature:BindFxPlayerTrack(director, track)
    local obj = self:InitOtherEffect(track.extData.bindPath)
    if obj then
        self:SetTimelineParent(nil, false, obj.transform)
        obj:SetActive(true)
        director:SetGenericBinding(track, obj)
    end
end
-------------------------------------------------- 设置残影相关 -------------------------------------------
function TrackBindFeature:BindGhostTrack(lastTrack, track)
    if self.creator then
        -- 技能模式使用主体的
        track.referTarget = self.creator
    else
        -- 表演模式使用相邻轨道的
        local lastTrackType = lastTrack:GetType()
        if lastTrackType == AnimationTrackType then
            track.referTarget = self.director:GetGenericBinding(lastTrack)
        elseif lastTrackType == GhostTrackType then
            track.referTarget = lastTrack.referTarget
        end
    end
    track:RefreshClipInfo(self.director);
end

--------------------------------------------------- 轨道打断逻辑 -----------------------------------------
function TrackBindFeature:_OnInterrupt()
    if self.isStopByTime then
        local timelineAsset = self.timeline:GetTimelineAsset()
         local allTracks = timelineAsset:GetOutputTracks()
         for i = 0, allTracks.Length - 1 do
             local baseTrack = allTracks[i]
             if self.stopByTimeTracks[baseTrack] then
                local curTime = self.timeline:GetTime()
                 if curTime < baseTrack.start then
                     -- 如果随时间结束的轨道，还没播到，也不用播了，直接打断
                     self:StopTrackRun(baseTrack)
                 end
             else
                 self:StopTrackRun(baseTrack)
             end
         end
    end
end

function TrackBindFeature:StopTrackRun(track)
    if track:GetRawEndTime() <= self.timeline:GetTime() then
        return
    end

    -- 首先尝试通用打断
    if TimelineInterruptTool.TryInterruptTrack(track) then
        return
    end

    -- 按类型特殊打断处理
    local trackType = track:GetType()
    if trackType == AnimationTrackType then
        self.director:SetGenericBinding(track, nil)
    elseif trackType == ControlTrackType then
        local clips = track:GetClipsArray()
        for i = 0, clips.Length - 1 do
            local ctrlClip = clips[i].asset
            local behaviour = ctrlClip.activationControlBehaviour
            if behaviour then
                behaviour:Interrupt()
            end
        end
    end
end

------------------------------------------------- 销毁逻辑 ----------------------------------------------
function TrackBindFeature:_OnDestroy()
    if self.loopFxTracks then
        for k, _ in pairs(self.loopFxTracks) do
            k.muted = false
        end
    end

    if self.subTranList then
        for _, v in ipairs(self.subTranList) do
            self.context:UnloadGameObject(v)
        end
    end
    self:_Reset()
    self:discard()
end

return TrackBindFeature