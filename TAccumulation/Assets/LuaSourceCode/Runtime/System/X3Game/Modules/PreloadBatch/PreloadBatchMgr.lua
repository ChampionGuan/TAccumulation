---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 峻峻.
--- DateTime: 2021/8/16 11:55
---

---资源预加载管理器
---@class PreloadBatchMgr
local PreloadBatchMgr = class("PreloadBatchMgr")
local CLS = CS.X3Game.PreloadBatchMgr
local _inited = false

---@class PreloadBatchType
PreloadBatchType =
{
    Dialogue = 1,
    Battle = 4,
}
---初始化
function PreloadBatchMgr.Init()
    if _inited == false then
        _inited = true

        PreloadBatchMgr.RegisterEstimator(PreloadBatchType.Dialogue, DialogueManager)

        local battleEstimator = require("Runtime.Battle.BattlePreloadEstimator")
        PreloadBatchMgr.RegisterEstimator(PreloadBatchType.Battle, battleEstimator)

        --预加载时间的系数
        CLS.preloadTimeRatio = 2
        --加载时长预估最小值
        CLS.preloadMinTime = 10
        --默认异步加载
        CLS.forceLoadSync = false
    end
end

---注册一个Estimator
---@param type PreloadBatchType 注册功能和预测管理器的对应关系
---@param estimator CS.X3Game.IPreloadEstimator 有两个必须的接口
function PreloadBatchMgr.RegisterEstimator(type, estimator)
    CLS.RegisterEstimator(type, estimator)
end

---业务逻辑发起一个加载，会去已有的Task里找是否有已经发起的Preload
---如果没有则新起一个PreloadBatch并立即开始加载
---加载完成后会调用回调
---@param type PreloadBatchType
---@param key string 用来提供给Estimator返回加载列表用
---@param onComplete fun 加载完成的回调
---@param loadingType GameConst.LoadingType
---@param autoHideUI boolean 自动隐藏UI
---@param onProgress fun 加载过程回调
---@param uiProgressWeight float 进度权重 0~1
---@param uiInitProgress float 进度初始权重 0~1
---@return int 返回一个BatchId
function PreloadBatchMgr.Load(type, key, onComplete, loadingType, autoHideUI, onProgress, uiProgressWeight, uiInitProgress)
    if uiProgressWeight == nil then
        uiProgressWeight = 1.0
    end
    if uiInitProgress == nil then
        uiInitProgress = 0.0
    end
    local is_need_loading = false
    if loadingType and loadingType ~= GameConst.LoadingType.None then
        is_need_loading = true
        UICommonUtil.SetLoadingEnable(loadingType, true)
    end
    local completeCall = function(collector)
        if onComplete then
            onComplete(collector)
        end
        if is_need_loading and autoHideUI then
            UICommonUtil.SetLoadingEnable(loadingType, false)
        end
    end
    local processCall = function(batchId, p)
        if onProgress then
            onProgress(batchId, p)
        end
        if uiProgressWeight ~= 0 then
            UICommonUtil.SetLoadingProgress(p * uiProgressWeight + uiInitProgress)
        end
    end
    return CLS.Load(type, key, completeCall, processCall)
end

---业务逻辑发起一个加载，会去已有的Task里找是否有已经发起的Preload
---如果没有则新起一个PreloadBatch并立即开始加载
---加载完成后会调用回调
---@param type PreloadBatchType
---@param key string 用来提供给Estimator返回加载列表用
---@param onComplete fun 加载完成的回调
---@param loadingType GameConst.LoadingType
---@param autoHideUI boolean 自动隐藏UI
---@param onProgress fun 加载过程回调
---@param uiProgressWeight float 进度权重 0~1
---@param uiInitProgress float 进度初始权重 0~1
---@return int 返回一个BatchId
function PreloadBatchMgr.LoadAsync(type, key, onComplete, loadingType, autoHideUI, onProgress, uiProgressWeight, uiInitProgress)
    if uiProgressWeight == nil then
        uiProgressWeight = 1.0
    end
    if uiInitProgress == nil then
        uiInitProgress = 0.0
    end
    local is_need_loading = false
    if loadingType and loadingType ~= GameConst.LoadingType.None then
        is_need_loading = true
        UICommonUtil.SetLoadingEnable(loadingType, true)
    end
    local completeCall = function(collector)
        if onComplete then
            onComplete(collector)
        end
        if is_need_loading and autoHideUI then
            UICommonUtil.SetLoadingEnable(loadingType, false)
        end
    end
    local processCall = function(batchId, p)
        if onProgress then
            onProgress(batchId, p)
        end
        if uiProgressWeight ~= 0 then
            UICommonUtil.SetLoadingProgress(p * uiProgressWeight + uiInitProgress)
        end
    end
    return CLS.LoadAsync(type, key, completeCall, processCall)
end

---业务逻辑发起一个预加载，会去已有的Task里找是否有已经发起的Preload
---如果没有则新起一个PreloadBatch并立即开始加载
---加载完成后会调用回调
---@param type PreloadBatchType
---@param key string 用来提供给Estimator返回加载列表用
---@param onComplete fun 加载完成的回调
---@return int 返回一个BatchId
function PreloadBatchMgr.PreloadAsync(type, key, onComplete)
    return CLS.PreloadAsync(type, key, onComplete)
end

---启动一个节点，不会对节点发起加载
---@param type PreloadBatchType
---@param key string 用来提供给Estimator返回加载列表用
---@return int 返回一个BatchId
function PreloadBatchMgr.StartNode(type, key)
    return CLS.StartNode(type, key)
end

---卸载一个Batch节点资源
---@param batchId
function PreloadBatchMgr.Unload(batchId)
    CLS.Unload(batchId)
end

---添加一个预加载节点及关系
---@param parentType PreloadBatchType 父节点类型
---@param parentKey string 父节点Key
---@param childType PreloadBatchType 子节点类型
---@param childKey string 子节点Key
---@param params table 询问父节点剩余时间时可能需要的一些参数 预留
---@return int linkId
function PreloadBatchMgr.AppendBatchLink(parentType, parentKey, childType, childKey, params)
    return CLS.AppendBatchLink(parentType, parentKey, childType, childKey, params)
end

---删除一个预加载节点及关系
---@param parentType PreloadBatchType 父节点类型
---@param parentKey string 父节点Key
---@param childType PreloadBatchType 子节点类型
---@param childKey string 子节点Key
function PreloadBatchMgr.SubBatchLink(parentType, parentKey, childType, childKey)
    CLS.SubBatchLink(parentType, parentKey, childType, childKey)
end

---删除一个预加载节点及关系
---@param linkId int
function PreloadBatchMgr.SubBatchLinkById(linkId)
    CLS.SubBatchLinkById(linkId)
end

---卸载闲置节点
function PreloadBatchMgr.UnloadHoldonNodes()
    CLS.UnloadHoldonNodes()
    CS.X3Battle.BattleResMgr.Instance:UnloadUnusedAll()
end

---Update函数
function PreloadBatchMgr.Update()
    CLS.Update()
end

function PreloadBatchMgr.Clear()
    _inited = false
    CLS.Clear()
end

function PreloadBatchMgr.Destroy()
    PreloadBatchMgr.Clear()
end

return PreloadBatchMgr