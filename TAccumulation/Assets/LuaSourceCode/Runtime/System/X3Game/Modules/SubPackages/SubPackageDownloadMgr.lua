---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jianxin.
--- DateTime: 2022/11/10
---

---对配置表 Module SubModule 操作的相关函数，本地数据，subModuleID 对应  packageID 关系

---SubModule 对应 PackageID
---@class MultiLanguagePackage
---@field packageID int
---@field existOriginalPackage bool
---@field languagePackageList table<int>
---@field voicePackageList table<int>

---@class SubPackageDownloadMgr
local SubPackageDownloadMgr = class("SubPackageDownloadMgr")

local ResPatchManager = CS.ResourcesPacker.Runtime.ResPatchManager
local CSL = nil
local this = SubPackageDownloadMgr
local cs_application = CS.UnityEngine.Application
local cs_reachableViaLocalAreaNetwork = CS.UnityEngine.NetworkReachability.ReachableViaLocalAreaNetwork
local downloadPackageIDKey = "SUBPACKAGE_ID"

function SubPackageDownloadMgr:Init()
    if not self.InitResPatchManager() then
        return
    end
    ---热更下载的b包清单
    self.ResDownloadPackageIDs = {}
    local packageIDStr = PlayerPrefs.GetString(downloadPackageIDKey, "")
    local splitStr = string.split(packageIDStr, "|")
    ---提审模式忽略掉热更参数，同时提审模式热更不会下载b包，需要手动下载
    if not AppInfoMgr.IsAudit() then
        for i, v in ipairs(splitStr) do
            table.insert(self.ResDownloadPackageIDs, tonumber(v))
        end
    end
    ---@type table<MultiLanguagePackage>
    self.multiLanguagePackageTab = {}
    self.modulePreDatas_cfg = LuaCfgMgr.GetAll("ModulePre")
    self.MIN_SURPLUS_SPACE = 10
    self.InitPackageIDMainFest()
    EventMgr.AddListener("OnStageFinish", handler(self, self.OnStageUpdate), self)
end

---主线关卡完成后通知检查 LYDJS-30511 剧情资源预先下载功能开发
function SubPackageDownloadMgr:OnStageUpdate()
    for k, preData in pairs(self.modulePreDatas_cfg) do
        if ConditionCheckUtil.CheckConditionByIntList(preData.ConditionCheck) then
            --- 判断是否需要弹窗下载
            local preKey = GameConst.CustomDataIndex.SUBPACKAGE_STAGE_CHECK_Start + preData.PreID
            local dataIntList = BllMgr.GetPlayerServerPrefsBLL():GetInt(preKey, 0)
            if dataIntList == 0 then
                ---允许弹出弹窗，进入弹出弹窗判断
                self:DownloadModulePre(preData)
            end
        end
    end
end

---@param preData cfg.ModulePre
function SubPackageDownloadMgr:DownloadModulePre(preData)
    local preKey = GameConst.CustomDataIndex.SUBPACKAGE_STAGE_CHECK_Start + preData.PreID
    local subModuleDatas_cfg = LuaCfgMgr.GetAll("SubModule")
    local needDownloadDatas = {}
    local downloadSize = 0
    for k, subModuleData in pairs(subModuleDatas_cfg) do
        if subModuleData.PreID ~= nil then
            if table.indexof(subModuleData.PreID, preData.PreID) then
                if not SubPackageUtil.GetFinishModelWithSubModuleID(subModuleData.ID) then
                    table.insert(needDownloadDatas, subModuleData)
                    ---计算需要下载的大小
                    local taskID = string.concat("moduleID", subModuleData.ModuleID)
                    local isHave, size = DownloadMgr:GetDownloadTaskTotalSize(taskID)
                    if not isHave then
                        local packageIDTabs = SubPackageUtil.GetPackageIDsWithSubModuleID(subModuleData.ID)
                        size = SubPackageUtil.GetTotalSizeWithPackageIDs(packageIDTabs)
                    end
                    downloadSize = downloadSize + size
                end
            end
        end
    end
    local isShowTips = false
    for i, subModuleData in ipairs(needDownloadDatas) do
        local taskID = string.concat("moduleID", subModuleData.ModuleID)
        local downloadState = DownloadMgr:GetDownloadTaskState(taskID)
        if downloadState == PackageDownloadState.None then
            isShowTips = true
        end
    end
    --- 进入弹窗弹出判断
    if not ErrandMgr.IsAdded(X3_CFG_CONST.POPUP_SUBPACKAGE_PREDOWNLOAD) and isShowTips then
        ErrandMgr.AddWithCallBack(X3_CFG_CONST.POPUP_SUBPACKAGE_PREDOWNLOAD, function()
            UICommonUtil.ShowMessageBox(UITextHelper.GetUIText(preData.Text, SubPackageUtil.GetFormatSize(downloadSize)), {
                { btn_type = GameConst.MessageBoxBtnType.CONFIRM, btn_call = function()
                    table.sort(needDownloadDatas, function(a, b)
                        return a.ID > b.ID
                    end)
                    for i, subModuleData in ipairs(needDownloadDatas) do
                        local packageIDTabs = SubPackageUtil.GetPackageIDsWithSubModuleID(subModuleData.ID)
                        local taskID = string.concat("moduleID", subModuleData.ModuleID)
                        local downloadState = DownloadMgr:GetDownloadTaskState(taskID)
                        if downloadState == PackageDownloadState.None then
                            DownloadMgr:AddDownloadTask(taskID, packageIDTabs, true, subModuleData.ModuleID)
                        end
                    end
                end },
                { btn_type = GameConst.MessageBoxBtnType.CANCEL, btn_call = function()
                end },
            })
            BllMgr.GetPlayerServerPrefsBLL():SetInt(preKey, 1)
            ErrandMgr.End(X3_CFG_CONST.POPUP_SUBPACKAGE_PREDOWNLOAD)
        end)
    end
end

---登录检查
function SubPackageDownloadMgr:LoginCheck()
    self:OnStageUpdate()
end

---@return bool
function SubPackageDownloadMgr.InitResPatchManager()
    if this.IsValid() then
        --ResPatchManager.DestroyInstance()
        CSL = ResPatchManager.Instance
        return true
    else
        return false
    end
end

function SubPackageDownloadMgr.IsValid()
    if not ResPatchManager.IsHotfix then
        return false
    end
    if not ResPatchManager.IsValid then
        return false
    end
    return true
end

function SubPackageDownloadMgr.IsEnable()
    if not this.IsValid() then
        return false
    end
    SubPackageDownloadMgr.ModuleDatas = LuaCfgMgr.GetAll("Module")
    if SubPackageDownloadMgr.ModuleDatas == nil or table.nums(SubPackageDownloadMgr.ModuleDatas) == 0 then
        return false
    end
    return true
end

function SubPackageDownloadMgr.StopAllDownload()
    if this.IsValid() then
        DownloadMgr:Clear()
        CS.ResourcesPacker.Runtime.ResPatchManager.Instance:StopAllDownload()
    end
end

function SubPackageDownloadMgr.Destroy()
    --SubPackageDownloadMgr.StopAllDownload()
end

function SubPackageDownloadMgr.Clear()
    SubPackageDownloadMgr.StopAllDownload()
end

---module

---@param moduleID int
---@return bool
function SubPackageDownloadMgr.DelModuleWithModuleID(moduleID)
    local moduleData = LuaCfgMgr.Get("Module", moduleID)
    local packageIDs = this.GetAllPackageIDsWithSubModuleIDTab(moduleData.SubModule)
    return this.DelPackageIDs(packageIDs)
end

---@param packegaIDs table<int>
---@return bool
function SubPackageDownloadMgr.DelPackageIDs(packageIDs)
    local isFinish = true
    for i, v in ipairs(packageIDs) do
        if DownloadMgr.HasDownloadedPkgTag(v) then
            isFinish = isFinish and DownloadMgr.DeleteChildPackage(v, true)
        end
    end
    return isFinish
end

---分包ID

function SubPackageDownloadMgr.InitPackageIDMainFest()
    this.multiLanguagePackageTab = {}
    local persistentDataPath = string.concat(CS.UnityEngine.Application.persistentDataPath, "/MultiLanguagePackageManiFest.json")
    local str = ""
    if io.exists(persistentDataPath) then
        str = CS.PapeGames.X3.FileUtility.ReadText(persistentDataPath)
    else
        local path = string.concat(CS.UnityEngine.Application.streamingAssetsPath, "/MultiLanguagePackageManiFest.json")
        if not io.exists(path) and UNITY_EDITOR then
            return
        end
        str = CS.PapeGames.X3.FileUtility.ReadText(path)
    end
    str = CS.X3Game.AESHelper.AesDecrypt(str)
    local jsonData = JsonUtil.Decode(str)
    for i, v in ipairs(jsonData.mainFest) do
        if this.multiLanguagePackageTab[v.packageID] == nil then
            ---@type MultiLanguagePackage
            local multiLanguagePackage = {}
            multiLanguagePackage.packageID = v.packageID
            multiLanguagePackage.existOriginalPackage = v.existOriginalPackage
            multiLanguagePackage.languagePackageList = table.clone(v.languagePackageList)
            multiLanguagePackage.voicePackageList = table.clone(v.voicePackageList)
            this.multiLanguagePackageTab[v.packageID] = multiLanguagePackage
        end
    end
end

---分包下载

---@param subModuleID int
---@return MultiLanguagePackage
function SubPackageDownloadMgr.GetMultiLanguagePackageWithSubModuleID(subModuleID)
    if this.multiLanguagePackageTab == nil then
        this.InitPackageIDMainFest()
    end
    return this.multiLanguagePackageTab[subModuleID]
end

---获取subModuleTab 所对应的所有PackageID
---@param subModuleIDTab  table<int>
---@return table<int>
function SubPackageDownloadMgr.GetAllPackageIDsWithSubModuleIDTab(subModuleIDTab)
    local packageIDs = {}
    for i, v in ipairs(subModuleIDTab) do
        table.insertto(packageIDs, this.GetAllPackageIDsWithSubModuleID(v))
    end
    return packageIDs
end

---获取subModuleID 所对应的所有PackageID
---@param subModuleID int
---@return table<int>
function SubPackageDownloadMgr.GetAllPackageIDsWithSubModuleID(subModuleID)
    local packageIDs = {}
    ---@type MultiLanguagePackage
    local multiLanguagePackage = this.GetMultiLanguagePackageWithSubModuleID(subModuleID)
    if multiLanguagePackage == nil then
        Debug.LogError("no subModuleID failed ", subModuleID)
        return packageIDs
    end
    if multiLanguagePackage.existOriginalPackage then
        packageIDs[#packageIDs + 1] = multiLanguagePackage.packageID
    end
    for _, packageData in ipairs(multiLanguagePackage.languagePackageList) do
        packageIDs[#packageIDs + 1] = packageData.packageID
    end
    for _, packageData in ipairs(multiLanguagePackage.voicePackageList) do
        packageIDs[#packageIDs + 1] = packageData.packageID
    end
    this.RebuildPackageIDs(packageIDs)
    return packageIDs
end

---获取对应SubModelID列表 所对应的语言，资源类型packageID
---@param subModuleIDTab int[]
---@param langType Locale.Language
---@param zipType Define.SubPackageZipType
---@return int[]
function SubPackageDownloadMgr.GetPackageIDsWithSubModuleIDs2LangType(subModuleIDTab, langType, zipType)
    local packageIDs = {}
    for i, v in ipairs(subModuleIDTab) do
        table.insertto(packageIDs, this.GetPackageIDsWithSubModuleID2LangType(v, langType, zipType))
    end
    return packageIDs
end

---@param subModuleID int
---@param langType Locale.Language
---@param zipType Define.SubPackageZipType
---@return int[]
function SubPackageDownloadMgr.GetPackageIDsWithSubModuleID2LangType(subModuleID, langType, zipType)
    local packageIDs = {}
    langType = langType or ((zipType == Define.SubPackageZipType.Language) and Locale.GetLang() or Locale.GetSoundLang())
    ---@type MultiLanguagePackage
    local multiLanguagePackage = this.GetMultiLanguagePackageWithSubModuleID(subModuleID)
    if multiLanguagePackage == nil then
        return packageIDs
    end
    if multiLanguagePackage.existOriginalPackage and zipType == Define.SubPackageZipType.ALL then
        packageIDs[#packageIDs + 1] = multiLanguagePackage.packageID
    end
    if zipType == Define.SubPackageZipType.Language or zipType == Define.SubPackageZipType.ALL then
        for _, packageData in ipairs(multiLanguagePackage.languagePackageList) do
            if packageData.language == langType then
                packageIDs[#packageIDs + 1] = packageData.packageID
            end
        end
    end
    if zipType == Define.SubPackageZipType.Sound or zipType == Define.SubPackageZipType.ALL then
        for _, packageData in ipairs(multiLanguagePackage.voicePackageList) do
            if packageData.language == langType then
                packageIDs[#packageIDs + 1] = packageData.packageID
            end
        end
    end
    this.RebuildPackageIDs(packageIDs)

    return packageIDs
end

---获取下载当前subModuleID 所有需要下载的PackageIDs
---@param subModuleIDTab  table<int>
---@param langArg Locale.Language | bool 校验指定语音，全语音(true)，或当前语音（false）
---@return table<int>
function SubPackageDownloadMgr.GetNeedDownloadPackageIDsWithSubModuleIDTab(subModuleIDTab, langArg)
    local packageIDs = {}
    for i, v in ipairs(subModuleIDTab) do
        table.insertto(packageIDs, this.GetNeedDownloadPackageIDsWithSubModuleID(v, langArg))
    end
    return packageIDs
end

---获取下载当前subModuleID 所有需要下载的PackageIDs
---@param subModuleID int
---@param langArg Locale.Language | bool 校验指定语音，全语音(true)，或当前语音（false）
---@return table<int>
function SubPackageDownloadMgr.GetNeedDownloadPackageIDsWithSubModuleID(subModuleID, langArg)
    local packageIDs = {}
    local langType = nil
    ---@type MultiLanguagePackage
    local multiLanguagePackage = this.GetMultiLanguagePackageWithSubModuleID(subModuleID)
    if multiLanguagePackage == nil then
        return packageIDs
    end
    if multiLanguagePackage.existOriginalPackage then
        packageIDs[#packageIDs + 1] = multiLanguagePackage.packageID
    end
    if langArg == nil then
        langType = Locale.GetLang()
    end
    for _, packageData in ipairs(multiLanguagePackage.languagePackageList) do
        if langArg then
            packageIDs[#packageIDs + 1] = packageData.packageID
        elseif packageData.language == langType then
            packageIDs[#packageIDs + 1] = packageData.packageID
        end
    end
    if langArg == nil then
        langType = Locale.GetSoundLang()
    end
    for _, packageData in ipairs(multiLanguagePackage.voicePackageList) do
        if langArg then
            packageIDs[#packageIDs + 1] = packageData.packageID
        elseif packageData.language == langType then
            packageIDs[#packageIDs + 1] = packageData.packageID
        end

    end

    this.RebuildPackageIDs(packageIDs)

    return packageIDs
end

---过滤不可用ID
function SubPackageDownloadMgr.RebuildPackageIDs(packageIDs)
    for i = #packageIDs, 1, -1 do
        if (not DownloadMgr.CheckPackageIDValid(packageIDs[i])) then
            table.remove(packageIDs, i)
        end
    end
end

---多语言分包下载

---获取需要下载对应语言包的语音语言包ID列表
---@param langType Locale.Language
---@param zipType Define.SubPackageZipType
---@return table<int>
function SubPackageDownloadMgr.GetNeedDownloadPackageIDsWithLangType(langType, zipType)
    zipType = zipType or Define.SubPackageZipType.Sound
    local downloadFinishSubModuleIDs = {}
    local subModule_cfgDatas = LuaCfgMgr.GetAll("SubModule")
    for _, v in pairs(subModule_cfgDatas) do
        if SubPackageUtil.GetFinishModelWithSubModuleID(v.ID) then
            downloadFinishSubModuleIDs[#downloadFinishSubModuleIDs + 1] = v.ID
        end
    end
    downloadFinishSubModuleIDs[#downloadFinishSubModuleIDs + 1] = 0
    return SubPackageDownloadMgr.GetPackageIDsWithSubModuleIDs2LangType(downloadFinishSubModuleIDs, langType, zipType)
end

function SubPackageDownloadMgr.GetAPackageMultiLanguagePackage()
    return SubPackageDownloadMgr.GetPackageMultiLanguagePackage_Fix(0)
end

function SubPackageDownloadMgr.GetPackageMultiLanguagePackage(subModuleID)
    local packageIDs = {}
    local langType = Locale.GetLang()
    local soundLangType = Locale.GetSoundLang()
    ---@type MultiLanguagePackage
    local multiLanguagePackage = this.GetMultiLanguagePackageWithSubModuleID(subModuleID)
    if multiLanguagePackage ~= nil then
        for _, packageData in ipairs(multiLanguagePackage.languagePackageList) do
            if packageData.language == langType then
                packageIDs[#packageIDs + 1] = packageData.packageID
            end
        end
        for _, packageData in ipairs(multiLanguagePackage.voicePackageList) do
            if packageData.language == soundLangType then
                packageIDs[#packageIDs + 1] = packageData.packageID
            end
        end
    end
    return packageIDs
end

function SubPackageDownloadMgr.GetPackageMultiLanguagePackage_Fix(subModuleID)
    local packageIDs = {}
    local langType = Locale.GetLang()
    local soundLangType = Locale.GetSoundLang()

    packageIDs[#packageIDs + 1] = (subModuleID + 100000) * 100 + langType
    packageIDs[#packageIDs + 1] = (subModuleID + 100000) * 100 + 10 + soundLangType
    return packageIDs
end

---多语言下载
---@param langType Locale.Language
---@param zipType Define.SubPackageZipType
function SubPackageDownloadMgr.AddPackageByLanguageChange(langType, zipType)
    local moduleIDs = DownloadMgr:GetAllNowDownloadModuleIDs()
    for i, moduleID in ipairs(moduleIDs) do
        local cfg_moduleData = LuaCfgMgr.Get("Module", moduleID)
        local taskID = string.concat("moduleID", moduleID)
        for i, v in ipairs(cfg_moduleData.SubModule) do
            local multiLanguagePackage = this.GetMultiLanguagePackageWithSubModuleID(v)
            if multiLanguagePackage ~= nil then
                local tempPackageList = zipType == Define.SubPackageZipType.Sound and multiLanguagePackage.voicePackageList or multiLanguagePackage.languagePackageList
                for _, packageData in ipairs(tempPackageList) do
                    if packageData.language == langType then
                        DownloadMgr:AddToDownloadList(taskID, packageData.packageID)
                    end
                end
            end
        end
    end
    DownloadMgr:WriteDownloadData()
end

---判断subModuleIDs对应的分包是否存在
---@param subModuleIDs int[]
---@return bool
function SubPackageDownloadMgr.IsValidWithSubModuleIDs(subModuleIDs)
    local isValid = false
    for k, v in pairs(subModuleIDs) do
        if not table.indexof(this.ResDownloadPackageIDs, v) then
            local multiLanguagePackage = this.GetMultiLanguagePackageWithSubModuleID(v)
            if multiLanguagePackage ~= nil then
                if multiLanguagePackage.existOriginalPackage or not table.isnilorempty(multiLanguagePackage.voicePackageList) or not table.isnilorempty(multiLanguagePackage.languagePackageList) then
                    isValid = true
                end
            end
        end
    end
    return isValid
end

---网络状态判断
function SubPackageDownloadMgr.IsWifi()
    Debug.LogError("!!!!当前网络状态", cs_application.internetReachability)
    return cs_application.internetReachability == cs_reachableViaLocalAreaNetwork
end

this:Init()

return SubPackageDownloadMgr