---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jianxin.
--- DateTime: 2022/7/20 17:31
---

---@class DownloadTask
local DownloadTask = class("DownloadTask")

function DownloadTask:Init(taskID, packageIDs, moduleID, groupCom)
    --local availableList = {}
    --for i = #packageIDs, #packageIDs do
    --    if(DownloadMgr.CheckPackageIDValid(packageIDs[i])) then
    --        table.insert(availableList, packageIDs[i])
    --    end
    --end

    ---已经在获取可用ID处过滤，此处不应有无效packageId
    ---@type table<int>
    self.downloadPackageIDTab = packageIDs
    ---@type SubPackage.PackageDownloadState
    self.downloadState = PackageDownloadState.Wait
    ---@type int
    self.finishedCount = 0
    ---@type int
    self.failedCount = 0
    ---@type table<DownloadMgr.PackageBase>
    self.packageBaseTab = {}
    ---@type string
    self.taskID = taskID
    ---@type int
    self.moduleID = moduleID
    ---@type int[]
    self.subModuleIDs = {}
    ---@type bool
    self.isNormalDownload = self.moduleID ~= nil

    ---@type DownloadGroup
    self.groupCom = groupCom

    if self.isNormalDownload then
        local moduleData_cfg = LuaCfgMgr.Get("Module", self.moduleID)
        if (moduleData_cfg) then
            for i, v in ipairs(moduleData_cfg.SubModule) do
                self.subModuleIDs[#self.subModuleIDs + 1] = v
            end
        else
            Debug.LogWarning("DownLoadTask Not Module Error ", self.moduleID)
        end
    end

    for _, v in ipairs(self.downloadPackageIDTab) do
        if not DownloadMgr.HasDownloadedPkgTag(v) then
            local tab = DownloadMgr:GetPackage(v)
            tab:SetDownloadState(self.downloadState)
            self.packageBaseTab[#self.packageBaseTab + 1] = tab
        else
            self.finishedCount = self.finishedCount + 1
        end
    end
    if self.finishedCount == #self.downloadPackageIDTab then
        self.downloadState = PackageDownloadState.Finished
    end
    EventMgr.RemoveListenerByTarget(self)
    EventMgr.AddListener("SubPackageMgr_PackageDownload_Finish", self.OnFinishPackage, self)
    EventMgr.AddListener("SubPackageMgr_PackageDownload_Failed", self.OnFailedPackage, self)
    --EventMgr.AddListener("SubPackageMgr_PackageDownload_DiskFull", self.OnDiskFullFailed, self)
end

---追加下载
---@param packageID int
function DownloadTask:AddPackageID(packageID)
    if not table.indexof(self.downloadPackageIDTab, packageID) then
        if not DownloadMgr.HasDownloadedPkgTag(packageID) then
            local tab = DownloadMgr:GetPackage(packageID)
            tab:SetDownloadState(self.downloadState)
            self.packageBaseTab[#self.packageBaseTab + 1] = tab
            self.downloadPackageIDTab[#self.downloadPackageIDTab + 1] = packageID
            if self.downloadState == PackageDownloadState.Downloading then
                tab:OpenDownload()
            end
        else
            self.finishedCount = self.finishedCount + 1
        end
    end
end

function DownloadTask:StartDownload()
    self.downloadState = PackageDownloadState.Downloading
    for _, v in ipairs(self.packageBaseTab) do
        v:OpenDownload()
        v:SetDownloadState(self.downloadState)
    end
    DownloadMgr:UpdateErrorTask(self.taskID, false, self.isNormalDownload)
    EventMgr.Dispatch("DownloadMgr_DownloadTask_StartDownload", self.taskID)
end

function DownloadTask:PauseDownload()
    if self.downloadState ~= PackageDownloadState.Pause then
        self.downloadState = PackageDownloadState.Pause
        for _, v in ipairs(self.packageBaseTab) do
            v:PauseDownload()
            v:SetDownloadState(self.downloadState)
        end
    end
end

function DownloadTask:ResumeDownload()
    self.downloadState = PackageDownloadState.Wait
    DownloadMgr:UpdateErrorTask(self.taskID, false, self.isNormalDownload)
    for _, v in ipairs(self.packageBaseTab) do
        v:SetDownloadState(self.downloadState)
    end
end

function DownloadTask:WaitDownload()
    self.downloadState = PackageDownloadState.Wait
    DownloadMgr:UpdateErrorTask(self.taskID, false, self.isNormalDownload)
    for _, v in ipairs(self.packageBaseTab) do
        v:PauseDownload()
        v:SetDownloadState(self.downloadState)
    end
end

function DownloadTask:DeleteDownload()
    self.downloadState = PackageDownloadState.None
    for _, v in ipairs(self.packageBaseTab) do
        v:PauseDownload()
        v:DelPackage(true)
    end
    for _, v in ipairs(self.downloadPackageIDTab) do
        DownloadMgr.DeleteChildPackage(v, true)
    end
    EventMgr.RemoveListenerByTarget(self)
    DownloadMgr:UpdateErrorTask(self.taskID, false, self.isNormalDownload)
end

function DownloadTask:ClearDownload()
    for _, v in ipairs(self.packageBaseTab) do
        v:DelPackage(true)
    end
    for _, v in ipairs(self.downloadPackageIDTab) do
        DownloadMgr.DeleteChildPackage(v, true)
    end
end

function DownloadTask:OnFinishPackage(packageID)
    if self.downloadState == PackageDownloadState.Finished or (not table.containsvalue(self.downloadPackageIDTab, packageID)) then
        return
    end
    for _, v in ipairs(self.downloadPackageIDTab) do
        if packageID == v then
            self.finishedCount = self.finishedCount + 1
        end
    end
    if self.finishedCount == #self.downloadPackageIDTab then
        self.downloadState = PackageDownloadState.Finished
        EventMgr.Dispatch("SubPackageMgr_TaskDownload_Finish")
        EventMgr.RemoveListenerByTarget(self)
    end
end

function DownloadTask:OnFailedPackage(packageID)
    if self.downloadState ~= PackageDownloadState.Failed then
        local isPause = false
        for _, v in ipairs(self.downloadPackageIDTab) do
            if packageID == v then
                isPause = true
            end
        end
        if isPause then
            --Debug.LogError(self.taskID, self.downloadState)
            self:PauseDownload()
            self:SetDownloadState(PackageDownloadState.Failed)
            --Debug.LogError(self)
            self.failedCount = self.failedCount + 1

            ---所有下载地方都应接管- --todo
            if(self.groupCom) then
                self.groupCom:OnFailedPackage(self.failedCount, self.downloadState, self.taskID, self.isNormalDownload)
            else
                if UIMgr.IsOpened(UIConf.DownloadWnd) and self.downloadState == PackageDownloadState.Failed then
                    if self.failedCount == 1 then
                        UICommonUtil.ShowMessage(UITextConst.UI_TEXT_30854)
                    else
                        UICommonUtil.ShowMessage(UITextConst.UI_TEXT_30858)
                    end
                elseif UIMgr.IsOpened(UIConf.SystemSettingWnd) and self.downloadState == PackageDownloadState.Failed then
                    UICommonUtil.ShowMessage(UITextConst.UI_TEXT_37233)
                else
                    UICommonUtil.ShowMessage(UITextConst.UI_TEXT_30860)
                end
                EventMgr.Dispatch("DownloadMgr_DownloadTask_DownloadFailed", self.taskID)
                DownloadMgr:UpdateErrorTask(self.taskID, true, self.isNormalDownload)
            end
        end
    end
end

function DownloadTask:OnDiskFullFailed(packageID)
    if self.downloadState ~= PackageDownloadState.Failed then
        local isPause = false
        for _, v in ipairs(self.downloadPackageIDTab) do
            if packageID == v then
                isPause = true
            end
        end
        if isPause then
            DownloadMgr:PauseNowDownloadTask()
            self:SetDownloadState(PackageDownloadState.Pause)
            if not ErrandMgr.IsAdded(X3_CFG_CONST.POPUP_SUBPACKAGE_STORAGE) then
                ErrandMgr.AddWithCallBack(X3_CFG_CONST.POPUP_SUBPACKAGE_STORAGE, function()
                    UICommonUtil.ShowMessageBox(UITextConst.UI_TEXT_30807, { { btn_type = GameConst.MessageBoxBtnType.CONFIRM, btn_text = UITextConst.UI_TEXT_30802, btn_call = function()
                        DownloadMgr:ResumePauseDownloadTask()
                    end }, { btn_type = GameConst.MessageBoxBtnType.CANCEL } }, AutoCloseMode.None)
                    ErrandMgr.End(X3_CFG_CONST.POPUP_SUBPACKAGE_STORAGE)
                end)
            end
            DownloadMgr:UpdateErrorTask(self.taskID, true, self.isNormalDownload)
        end
    end
end

function DownloadTask:GetDownloadState()
    return self.downloadState
end

function DownloadTask:SetDownloadState(state)
    self.downloadState = state
    if (state == PackageDownloadState.Wait or state == PackageDownloadState.Downloading) then
        DownloadMgr:UpdateErrorTask(self.taskID, false, self.isNormalDownload)
    end
    for _, v in ipairs(self.packageBaseTab) do
        v:SetDownloadState(self.downloadState)
    end
end

function DownloadTask:GetDownloadTaskTotalSize()
    return SubPackageUtil.GetTotalSizeWithPackageIDs(self.downloadPackageIDTab)
end

function DownloadTask:GetNormalState()
    return self.isNormalDownload
end

---获取剩余下载大小
function DownloadTask:GetLeftDownloadSize()
    local leftSize = 0
    for _, v in ipairs(self.packageBaseTab) do
        leftSize = leftSize + v:GetMaxTotalSize() - v:GetDownloadSize()
    end
    return leftSize
end

return DownloadTask
