---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiaozhu.
--- DateTime: 2023/5/22 11:44
---
---@class UITextHelper
local UITextHelper = {}
local isLanguageDebug = false
local GetUIText
local isCanTick = false
local CLS = CS.X3Game.UITextLanguage
local replaceMap = {}
local replaceMapFunc = {}
---延迟计算Tmp高度任务字典
---@type table<int, fun():void>
local delayCalcTmpHeightTaskDict = {}

---@type UITextReplace
local UITextReplace = require("Runtime.System.X3Game.Helper.UITextReplace")

---@param text_id | string ,UITextData 配置表中id
---@vararg number | string
---@return string
---参数的，格式化参数，eg:string.format("{0}-{1}",1,2)
function UITextHelper.GetUIText(text_id, ...)
    text_id = UITextHelper.GetTextId(text_id)
    return GetUIText(text_id, ...)
end

---@param text_id number | string
---@return int
function UITextHelper.GetTextId(text_id)
    if text_id ~= nil and type(text_id) == "number" then
        if text_id > 0 then
            text_id = math.tointeger(text_id)
            if not text_id then
                return tostring(text_id)
            end
            if text_id > 0 then
                if text_id >= Const.UI_TEXT_MIN_ID then
                    text_id = text_id - Const.UI_TEXT_MIN_ID
                elseif text_id <= Const.UI_TEXT_AUTO_MIN_ID then
                    if UNITY_EDITOR then
                        if UITextHelper.IsExist(text_id) then
                            local key = string.format("UI_TEXT_%s", text_id)
                            if not UITextConst[key] then
                                Debug.LogErrorFormat("请使用对应的枚举值设置文本[UITextConst.UI_TEXT_%s]", text_id)
                                return string.format("invalid [%s]", text_id)
                            end
                        end

                    end
                end
                if UNITY_EDITOR then
                    if not UITextHelper.IsExist(text_id) then
                        Debug.LogErrorFormat("未找到textId 请检测调用方式是否正确(数字类型的需要tostring):text_id=[%s]", text_id)
                    end
                end
            end
        elseif text_id < 0 then
            text_id = tostring(text_id)
        end
    elseif text_id == nil then
        text_id = ""
    else
        local t = type(text_id)
        if t~="number" and t~="string" then
            Debug.LogErrorFormat("[UITextHelper.GetTextId] failed text_id =[%s] type not valid please check!!!",text_id)
            text_id = tostring(text_id)
        end
    end
    return text_id
end

---@param text_id int
---@return boolean
function UITextHelper.IsExist(text_id)
    if text_id ~= nil and type(text_id) == "number" then
        text_id = math.tointeger(text_id)
        if text_id then
            return CLS.IsExist(text_id)
        end
    end
    return false
end

--特殊需求使用：给从第三方来的字符串做逻辑处理
---@param text string
---@return string,boolean
function UITextHelper.ReplaceTag(text)
    if string.isnilorempty(text) then
        return text
    end
    return CLS.ReplaceTag(text)
end

---@param _isCanTick boolean 是否可以tick
function UITextHelper.SetIsCanTick(_isCanTick)
    isCanTick = _isCanTick
end

---添加替换标签
---@param tag string
---@param repStr string | function
---@param needArg boolean 是否需要参数，仅限于动态替换逻辑
function UITextHelper.AddReplaceTag(tag, repStr,needArg)
    if not tag then
        return
    end
    if needArg == nil then
        needArg = false
    end
    local isCache = true
    if not string.isnilorempty(repStr) then
        if type(repStr) == "function" then
            replaceMapFunc[string.hash(tag)] = repStr
            repStr = nil
            isCache = false
        else
            repStr = tostring(repStr)
        end
    end
    if isCache then
        if replaceMap[tag] == repStr then
            return
        end
        replaceMap[tag] = repStr
    end
    CLS.AddReplaceTag(tag, repStr, isCache,needArg)
end

---删除替换标签
---@param tag string
function UITextHelper.RemoveReplaceTag(tag)
    CLS.RemoveReplaceTag(tag)
end

---初始化
function UITextHelper.Init()
    CLS.Init()
end

---清理
function UITextHelper.Clear()
    isCanTick = false
    table.clear(replaceMap)
    table.clear(replaceMapFunc)
    CLS.Clear()
end

function UITextHelper.Destroy()
    UITextHelper.Clear()
end

---检测替换标签
function UITextHelper.CheckUITextReplace()
    if not isCanTick then
        return
    end
    UITextHelper.InitReplaceTag()
end

---初始化replaceTag
---@param isStatic boolean 是否是静态的
---@param isTickEnable boolean
function UITextHelper.InitReplaceTag(isStatic, isTickEnable)
    if isTickEnable then
        UITextHelper.SetIsCanTick(isTickEnable)
        UITextReplace.InitWithParam()
    end
    if isStatic then
        UITextReplace.InitStatic()
    else
        UITextReplace.Init()
    end

end

---@param tag int
---@param strParam string
---@param externParam string
---@return string
function UITextHelper.GetUITextReplace(tag, strParam,externParam)
    local func = replaceMapFunc[tag]
    local res = nil
    if func then
        local temp = string.split(strParam, ",")
        local param = PoolUtil.GetTable()
        if temp then
            for k, v in ipairs(temp) do
                local t = tonumber(v)
                if t then
                    table.insert(param, t)
                end
            end
            if not string.isnilorempty(externParam) then
                table.insert(param, externParam)
            end
            
            PoolUtil.ReleaseTable(temp)
        end

        res = tostring(func(table.unpack(param)))
        PoolUtil.ReleaseTable(param)
    end
    return res
end

---@param isEnable boolean 是否是测试模式
function UITextHelper.SetLanguageDebug(isEnable)
    if isLanguageDebug~=isEnable then
        isLanguageDebug = isEnable
        CLS.IsLanguageDebug = isEnable
    end
end

---是否是debug模式
---@return boolean
function UITextHelper.IsLanguageDebug()
    return isLanguageDebug
end

---根据Tmp的Mesh数据重新设置Tmp的高度
---@param obj UObject
---@param withDelay bool 是否延迟到下一帧处理
function UITextHelper.RecalculateTmpHeight(obj, withDelay)
    local comp = GameObjectUtil.GetComponent(obj, nil, "TextMeshProUGUI", false, true)
    if (comp == nil) then
        return
    end

    local existedLEComp = GameObjectUtil.GetComponent(obj, nil, "LayoutElement", false, true)
    if (existedLEComp ~= nil) then
        existedLEComp.preferredHeight = -1
    end

    local existedTextSizeFitter = GameObjectUtil.GetComponent(obj, nil, "TextSizeFitter", false, true)
    if (existedTextSizeFitter ~= nil) then
        existedTextSizeFitter.enabled = true
    end

    if withDelay == nil then
        withDelay = true
    end

    local compInsId = comp:GetInstanceID()
    if withDelay and (delayCalcTmpHeightTaskDict[compInsId] ~= nil) then
        return
    end

    local delayCall = function()
        if GameObjectUtil.IsNull(comp) then
            delayCalcTmpHeightTaskDict[compInsId] = nil
            return
        end

        local textInfo = comp.textInfo
        if (textInfo == nil) or (textInfo.lineInfo.Length == 0) or (textInfo.lineCount == 0) then
            return
        end

        local MAX_VALUE = 99999999
        local MIN_VALUE = -99999999
        local min = Vector2.Temp(MAX_VALUE, MAX_VALUE)
        local max = Vector2.Temp(MIN_VALUE, MIN_VALUE)

        local blPos = Vector3.Temp(MAX_VALUE, MAX_VALUE, 0)
        local tlPos = Vector3.Temp(MAX_VALUE, MIN_VALUE, 0)
        local trPos = Vector3.Temp(MIN_VALUE, MIN_VALUE, 0)
        local brPos = Vector3.Temp(MIN_VALUE, MAX_VALUE, 0)
        for l = 0, textInfo.lineCount-1 do
            local lineInfo = textInfo.lineInfo[l]
            blPos.x = MAX_VALUE
            blPos.y = MAX_VALUE

            tlPos.x = MAX_VALUE
            tlPos.y = MIN_VALUE

            trPos.x = MIN_VALUE
            trPos.y = MIN_VALUE

            brPos.x = MIN_VALUE
            brPos.y = MAX_VALUE

            for c = lineInfo.firstCharacterIndex, lineInfo.lastCharacterIndex do
                local charInfo = textInfo.characterInfo[c]
                if charInfo.character ~= 32 then
                    blPos.x = math.min(charInfo.vertex_BL.position.x, blPos.x)
                    blPos.y = math.min(charInfo.vertex_BL.position.y, blPos.y)

                    tlPos.x = math.min(charInfo.vertex_TL.position.x, tlPos.x)
                    tlPos.y = math.max(charInfo.vertex_TL.position.y, tlPos.y)

                    trPos.x = math.max(charInfo.vertex_TR.position.x, trPos.x)
                    trPos.y = math.max(charInfo.vertex_TR.position.y, trPos.y)

                    brPos.x = math.max(charInfo.vertex_BR.position.x, brPos.x)
                    brPos.y = math.min(charInfo.vertex_BR.position.y, brPos.y)

                    min.x = math.min(blPos.x, min.x);
                    min.y = math.min(blPos.y, min.y);

                    max.x = math.max(trPos.x, max.x);
                    max.y = math.max(trPos.y, max.y);
                end
            end
        end

        local actualX = max.x - min.x
        local actualY = max.y - min.y

        local rtX, rtY = GameObjectUtil.GetSizeDeltaXY(comp)
        if actualY > (rtY + 5) then
            local leComp = existedLEComp
            if (leComp == nil) then
                leComp = comp.gameObject:AddComponent(typeof(CS.UnityEngine.UI.LayoutElement))
            end
            leComp.preferredHeight = actualY
            if existedTextSizeFitter then
                existedTextSizeFitter.enabled = false
            end
            comp.transform:SetSizeWithCurrentAnchors(CS.UnityEngine.RectTransform.Axis.__CastFrom(1), rtY)
        elseif (existedLEComp ~= nil) then
            existedLEComp.preferredHeight = -1
        end
        delayCalcTmpHeightTaskDict[compInsId] = nil
    end

    if withDelay then
        delayCalcTmpHeightTaskDict[compInsId] = true
        TimerMgr.AddTimerByFrame(1, delayCall)
    else
        delayCall()
    end
end


---@private
---@param text_id int
---@any
---@return string
GetUIText = function(text_id, ...)
    if not text_id or text_id == 0 then
        return ""
    end
    if type(text_id) ~= "number" then
        return text_id
    end
    if select("#", ...) > 0 then
        return CLS.GetUIText(text_id, ...)
    else
        return CLS.GetUIText(text_id)
    end
end
return UITextHelper