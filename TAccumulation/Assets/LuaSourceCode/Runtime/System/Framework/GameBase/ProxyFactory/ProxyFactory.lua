---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by junjun003.
--- DateTime: 2021/11/18 14:37
---

---Proxy工厂，每个玩家都有一个，数据在内部运转实现闭包
---Proxy实例使用惰性初始化，只有档Proxy被使用时才会被初始化出来
---@class ProxyFactory : ProxyConf
local ProxyFactory = class("ProxyFactory")
local ProxyConf = require("Config.System.AutoGenerated.ProxyConf")

local DIR_ROOT = "Runtime.System.X3Game.Data.DataProxy.Proxy."
local NAME_TO_PATH = {}

addPartial(ProxyFactory, ProxyConf)

---初始化函数
function ProxyFactory:OnInit(uid)
    ---@type int 玩家Id
    self.uid = uid
    ---@type table<string, BaseProxy> 所有Proxy
    self.proxyMap = {}
    ---@type table<string, BaseProxy> 清理缓存
    self.clearMap = {}
end

function ProxyFactory:OnClear()
    self.uid = nil
    local proxyNames = PoolUtil.GetTable()
    for proxyName, proxy in pairs(self.proxyMap) do
        table.insert(proxyNames, proxyName)
    end
    for _, proxyName in ipairs(proxyNames) do
        self:Clear(proxyName)
    end
    PoolUtil.ReleaseTable(proxyNames)
    self.proxyMap = nil
end

---获取一个Proxy
---@param proxyName
---@return BaseProxy
function ProxyFactory:Get(proxyName)
    if string.isnilorempty(proxyName) then
        Debug.LogWarning("---ProxyFactory.Get--failed--- proxyName is nil", proxyName)
        return nil
    end
    return self:Load(proxyName)
end

---初始化数据代理
---@param proxyName string
function ProxyFactory:InitProxy(proxyName)
    if not proxyName then
        return
    end
    local proxy = self:Get(proxyName)
    if proxy then
        proxy:SetOwner(self)
        proxy:OnInit()
    end
end

---新建Proxy
---@param proxyName string
---@return BaseProxy
function ProxyFactory:Load(proxyName)
    if proxyName == nil then
        Debug.LogWarning("---ProxyFactory.Load--failed---", proxyName)
        return nil
    end
    local proxy = self.proxyMap[proxyName]
    if not proxy then
        proxy = self.clearMap[proxyName]
        if not proxy then
            proxy = require(self:GetFilePath(proxyName)).new()
            if proxy then
                self.proxyMap[proxyName] = proxy
                self:InitProxy(proxyName)
            else
                Debug.LogError(proxyName, "Proxy not Return  please check your code !!! ")
            end
        else
            self.proxyMap[proxyName] = proxy
            self.clearMap[proxyName] = nil
            self:InitProxy(proxyName)
        end
    end
    return proxy
end

---卸载本地Proxy
---@param proxyName string
function ProxyFactory:Unload(proxyName)
    if not proxyName or not self.proxyMap then
        return
    end
    LuaUtil.UnLoadLua(self:GetFilePath(proxyName))
    local proxy = self.proxyMap[proxyName]
    if proxy then
        proxy:OnClear()
    end
    self.proxyMap[proxyName] = nil
end

---卸载所有Proxy
---@param proxyName string
function ProxyFactory:UnloadAll()
    for proxyName, proxy in pairs(self.proxyMap) do
        LuaUtil.UnLoadLua(self:GetFilePath(proxyName))
        proxy:OnClear()
    end
    table.clear(self.proxyMap)
end

---Clear本地Proxy
---@param proxyName string
function ProxyFactory:Clear(proxyName)
    if not proxyName or not self.proxyMap then
        return
    end
    local proxy = self.proxyMap[proxyName]
    if proxy then
        proxy:OnClear()
    end
end

---Clear所有Proxy
---@param proxyName string
function ProxyFactory:ClearAll()
    for proxyName , proxy in pairs(self.proxyMap) do
        self.clearMap[proxyName] = proxy
        proxy:OnClear()
    end
    table.clear(self.proxyMap)
end

---Init所有Proxy
---@param proxyName string
function ProxyFactory:InitAll()
    for _, proxy in pairs(self.proxyMap) do
        proxy:OnInit()
    end
end

---获取路径
---@param file_name string
---@return string
function ProxyFactory:GetFilePath(file_name)
    if file_name == nil then
        return file_name
    end
    local f_path = NAME_TO_PATH[file_name]
    if string.isnilorempty(f_path) then
        f_path = string.concat(DIR_ROOT, file_name)
        NAME_TO_PATH[file_name] = f_path
    end
    return f_path
end

return ProxyFactory