---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by canglan.
--- DateTime: 2021/11/18 11:04
---

local UIBehaviorBase = require("Runtime.Battle.Behavior.UI.UIBehaviorBase")

local csBattleUtil = CS.X3Battle.BattleUtil
local csBattleEnv = CS.X3Battle.BattleEnv
local PlayerBtnType = CS.X3Battle.PlayerBtnType
local csParticleSystemStopBehavior = CS.UnityEngine.ParticleSystemStopBehavior

---@class SlotBase:UIBehaviorBase
local SlotBase = XECS.class("SlotBase", UIBehaviorBase)

function SlotBase:ctor()
    UIBehaviorBase.ctor(self)
    ---@type X3Battle.PlayerBtnType
    self._btnType = nil
    ---@type X3Battle.SkillSlot
    self._slot = nil

    ---@type UnityEngine.Transform
    self._headImgTrans = nil
    ---@type UnityEngine.Transform
    self._cdImgTrans = nil
    ---@type TMPro.TextMeshProUGUI
    self._cdText = nil
    ---@type UnityEngine.ParticleSystem
    self._effect = nil
    ---@type UnityEngine.ParticleSystem
    self._emergeEffect = nil
    ---@type UnityEngine.ParticleSystem
    self._longPressOutEffect = nil
    ---@type UnityEngine.ParticleSystem
    self._longLoopEffect = nil
    ---@type UnityEngine.ParticleSystem
    self._activeLoopEffect = nil
    ---@type PapeGames.X3UI.StyleEnum
    self._styleEnum = nil
    ---@type TMPro.TextMeshProUGUI
    self._costEgNumText = nil
    ---@type Transform
    self._gridBgTrans = nil
    ---@type Transform
    self._gridTrans = nil
    ---@type Transform
    self._cdGridTrans = nil

    self._cdIndex = 0
    self._disableIndex = 1
    self._egIndex = 2
    self._activeIndex = 3

    self._curIndex = 0

    self._longPressEffectActive = nil

    self._showNormalMessage = true
    self._finalConditionMessage = 20015
    self._afterConditionMessage = 0
    --用于处理减CD效果生效时突然跳变的问题。开始冷却CD的过程中，显示时的认为表现不再收到CD值的影响
    self._lastMaxCD = 0

    ---@type X3Battle.Actor
    self._actor = nil

    self._ratio = 0
    self._gridRatio = 0
    self._castCount = 0
    self._maxCastCount = 0
    self._maxCastCountReciprocal = 0
end

function SlotBase:Start()
    self._grids = {}
    self._gridPool = {}
    self._curIndex = -1
    self._cd = 0
    self._longPressTime = csBattleUtil.GetLongPressTime()
    self._curLongPressTime = 0
    self._longPressEffectActive = false
    self._skillCanCast = false
    self:_TransSlotState(self._activeIndex)
    if not GameObjectUtil.IsNull(self._effect) then
        self._effect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
    end

    self:SetBarProgress(self._cdImgTrans, 0)
    if not GameObjectUtil.IsNull(self._longLoopEffect) then
        self._longLoopEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
    end
    if not GameObjectUtil.IsNull(self._activeLoopEffect) then
        self._activeLoopEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
    end
    if not GameObjectUtil.IsNull(self._longPressOutEffect) then
        self._longPressOutEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
    end
    if not GameObjectUtil.IsNull(self._emergeEffect) then
        self._emergeEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
    end
    self:_PreLoadGrids()
    self:SetSlot()
end

function SlotBase:_TransSlotState(stateIndex)
    if self._curIndex == stateIndex then
        return false
    end
    self._curIndex = stateIndex
    if not GameObjectUtil.IsNull(self._styleEnum) then
        self._styleEnum:SetIdx(self._curIndex)
    end
    return true
end

function SlotBase:_PreLoadGrids()
    if GameObjectUtil.IsNull(self._gridBgTrans) then
        return
    end
    for i = 1, 5 do
        local gridObj = GameObjectUtil.InstantiateGameObject(self._gridTrans, self._gridBgTrans)
        self:SetNodeVisible(gridObj.transform, false)
        table.insert(self._gridPool, gridObj)
    end
end

function SlotBase:_GetGrid()
    local gridObj
    if #self._gridPool > 0 then
        gridObj = self._gridPool[1]
        table.remove(self._gridPool,1)
    else
        gridObj = GameObjectUtil.InstantiateGameObject(self._gridTrans, self._gridBgTrans)
    end
    self:SetNodeVisible(gridObj.transform, true)
    return gridObj
end

function SlotBase:_InitGrids(maxCount)
    if GameObjectUtil.IsNull(self._gridBgTrans) then
        return
    end
    if maxCount <= 1 then
        --使用次数是1的时候，直接隐藏掉外圈的条
        self:SetNodeVisible(self._gridBgTrans,false)
        return
    end
    self:SetNodeVisible(self._gridBgTrans,true)
    for _, gridObj in ipairs(self._grids) do
        self:SetNodeVisible(gridObj.transform,false)
        table.insert(self._gridPool, gridObj)
    end
    for i = 1, maxCount do
        table.insert(self._grids, self:_GetGrid())
    end
    local stepRotation = 360 * self._maxCastCountReciprocal
    for i = 1, #self._grids do
        self._battleUI._battleWnd:SetEulerAngles(self._grids[i], 0, 0, stepRotation * (i-1))
    end
end

function SlotBase:SetLeftDeadBtnState()
    if not self._slot then
        return
    end
    self:_TransSlotState(self._disableIndex)
    self._slot = nil
end

function SlotBase:_OnUpdate()
    if not self._battleUI.csBattle.isBegin and not self._battleUI.csBattle.isEnd then
        return
    end
    self:UpdateBtnState()
end

function SlotBase:SetSkillSlot(actor, btnType, skillSlot)
    if actor ~= self._actor or btnType ~= self._btnType then
        return false
    end
    self._slot = skillSlot
    self:_ResetSlot()
    return true
end

function SlotBase:SetSlot()
    local tempSlot = self._slot
    if not self._actor then
        self._actor = self._battleUI.player
    end
    if self._battleUI.playerInput and self._actor then
        self._slot = self._battleUI.playerInput:GetStaticSkillSlot(self._btnType, self._actor.insID)
    end
    if tempSlot or not self._slot then
        return
    end
    self:_ResetSlot()
end

function SlotBase:_ResetSlot()
    if not self._slot then
        return
    end
    self._maxCastCount = self._slot.maxCastCount
    if self._maxCastCount > 1 then
        self._maxCastCountReciprocal = 1 / self._maxCastCount
    end
    self._maxCdNum = self._slot:GetMaxCD() or 1
    self._lastMaxCD = self._slot:CalcRemainCD(self._maxCdNum)
    if not GameObjectUtil.IsNull(self._costEgNumText) then
        local cost = csBattleUtil.CalCostEnergy(self._slot)
        self:SetText(self._costEgNumText, tostring(math.tointeger(cost)))
    end

    self:_InitGrids(self._maxCastCount)
    self:UpdateBtnState()

    local skillIcon = self._slot.skill.skillIcon
    if skillIcon and skillIcon ~= "" then
        self:SetImage(self._headImgTrans, skillIcon)
    end
end

function SlotBase:DebugSetSlot()
    if self._actor then
        self._slot = csBattleUtil.GetSkillSlot(self._actor, self._btnType)
    end
    self:_ResetSlot()
end

function SlotBase:UpdateBtnState()
    if self:UpdateSkillDisable() or self:IsGirlDead() or self:IsBoyDead() then
        return
    end
    if not self._slot then
        return
    end
    local cd
    if self._lastMaxCD == 0 then
        cd = 0
    else
        cd = self:GetCD(self._slot.remainCD)
    end
    if cd > 0 and self._castCount == 0 then
        if self:_TransSlotState(self._cdIndex) then
            if not GameObjectUtil.IsNull(self._activeLoopEffect) then
                self._activeLoopEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
            end
        end
        if self._cd ~= cd and not GameObjectUtil.IsNull(self._cdText) then
            self._cd = cd
            csBattleUtil.SetTextByFloat(self._cdText, cd, true)
        end
    elseif not self._slot:IsEnergyFull() then
        if self:_TransSlotState(self._egIndex) then
            if not GameObjectUtil.IsNull(self._activeLoopEffect) then
                self._activeLoopEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
            end
        end
    else
        if self:_TransSlotState(self._activeIndex) then
            if not GameObjectUtil.IsNull(self._ringEffect) then
                self._ringEffect:Play()
            end
            if not GameObjectUtil.IsNull(self._emergeEffect) then
                self._emergeEffect:Play()
            end
            if not GameObjectUtil.IsNull(self._activeLoopEffect) then
                self._activeLoopEffect:Play()
            end
            if not GameObjectUtil.IsNull(self._energyFullSound) then
                UIUtil.PlaySoundFX(self._energyFullSound, 0)
            end
        end
    end
end

---@return Int
function SlotBase:GetCD(cdNum)
    --- cd向上取整且不显示小数，策划要求
    local cd = 0
    if cdNum > 0 then
        cd = math.ceil(cdNum)
    end
    if cd < 0 then
        cd = 0
    end
    return cd
end

function SlotBase:UpdateSkillDisable()
    --在男女主初始化前，update就在执行了
    if self._battleUI.disableController == nil then
        return false
    end
    --兼容调试器跳过结算流程，男主死后继续游戏
    if self._slot == nil then
        return true
    end
    if self._battleUI.disableController:IsDisableSkill(self._slot.skill) then
        self:_TransSlotState(self._disableIndex)
        return true
    end
    return false
end

function SlotBase:UpdateProgress()
    if not self._slot then
        return
    end

    if self._curLongPressTime ~= 0 then
        self._curLongPressTime = self._curLongPressTime - self._battleUI.player.unscaledDeltaTime
        if self._curLongPressTime < 0 and self._skillCanCast then
            self._longPressEffectActive = true
            self._longLoopEffect:Play()
            self._curLongPressTime = 0
        end
    end

    local cdNum = self._slot.remainCD
    if self._maxCastCount > 1 then
        if self._slot.castCount ~= self._castCount then
            if self._slot.castCount >= 1 then
                if not GameObjectUtil.IsNull(self._emergeEffect) then
                    self._emergeEffect:Play()
                end
            end
            self._castCount = self._slot.castCount
        end
        if self._lastMaxCD > 0 or not GameObjectUtil.IsNull(self._cdGridTrans) then
            local gridRatio = (self._castCount + (self._lastMaxCD - cdNum) / self._lastMaxCD) * self._maxCastCountReciprocal
            if self._gridRatio ~= gridRatio then
                self._gridRatio = gridRatio
                self:SetBarProgress(self._cdGridTrans, self._gridRatio)
            end
        end
    end

    local ratio = 0
    if self._lastMaxCD == 0 then
        ratio = 0
    else
        if self._castCount < 1 then
            ratio = cdNum / self._lastMaxCD
            if ratio > 1 then
                ratio = 1
            end
        end
    end
    if self._ratio ~= ratio then
        self._ratio = ratio
        self:SetBarProgress(self._cdImgTrans, self._ratio)
    end

end

function SlotBase:Register()
    UIBehaviorBase.Register(self)
    self:AddButtonListener(self._transform, nil, g_BattleClient:SafeHandler(self, self._OnPointerDown), g_BattleClient:SafeHandler(self, self._OnPointerUp))
    g_BattleClient:AddListener(EventType.RefreshSkillUI, self, self.UpdateBtnState, "SlotBase.RefreshSkillUI.UpdateBtnState")
    g_BattleClient:AddListener(EventType.EnergyCostChange, self, self.UpdateBtnState, "SlotBase.EnergyCostChange.UpdateBtnState")
end

function SlotBase:Unregister()
    g_BattleClient:RemoveListener(EventType.RefreshSkillUI, self, self.UpdateBtnState)
    g_BattleClient:RemoveListener(EventType.EnergyCostChange, self, self.UpdateBtnState)
    UIBehaviorBase.Unregister(self)
end

function SlotBase:_OnPointerDown()
    if self._btnType == PlayerBtnType.Attack or self._btnType == PlayerBtnType.Active then
        self._curLongPressTime = self._longPressTime
    end
    self:TryPlaySkill(1)
end

function SlotBase:_OnPointerUp()
    if self._btnType == PlayerBtnType.Attack or self._btnType == PlayerBtnType.Active then
        self._curLongPressTime = 0
        if self._longPressEffectActive then
            self._longLoopEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
            if not GameObjectUtil.IsNull(self._longPressOutEffect) then
                self._longPressOutEffect:Play()
            end
            self._longPressEffectActive = false
        end
    end
    self:TryPlaySkill(0)
end

function SlotBase:StopEffect()
    if self._btnType == PlayerBtnType.Attack or self._btnType == PlayerBtnType.Active then
        self._curLongPressTime = 0
        if self._longPressEffectActive then
            self._longLoopEffect:Stop(true, csParticleSystemStopBehavior.StopEmittingAndCleanup)
            self._longPressEffectActive = false
        end
    end
end

---@param state Int
---@param beforeCondition bool
---@param afterCondition bool
---@param casterID BattleEntityID 默认为nil，让主控者释放技能
function SlotBase:TryPlaySkill(state, beforeCondition, afterCondition, casterID)
    if state == 1 then
        self._skillCanCast = false
        --即时技能不能释放，也要打断自动AI
        self:LogicAutoBattle(false)
    end
    if not self._battleUI.playerInput then
        return
    end
    if self:IsGirlDead() then
        return
    end
    if not self._slot then
        return
    end
    if beforeCondition and not csBattleEnv.NoCdForPlayerSkills then
        return
    end

    local caster
    if casterID then
        caster = self._battleUI.actorMgr:GetActor(casterID)
    else
        caster = self._battleUI.player
    end

    self:PlayerBtnStateChange(self._btnType, state == 1, caster.insID)

    if not afterCondition then
        if state == 1 then
            if not GameObjectUtil.IsNull(self._effect) then
                self._effect:Play()
                self._skillCanCast = not afterCondition
            end
        end
    end

    local isEnergyFull = self._slot:IsEnergyFull()
    local isCD = self._slot:IsCD()
    if state == 1 and  self._showNormalMessage == true then
        if isEnergyFull == false and isCD == false then
            ----跳出能量不足弹窗提示
            --UICommonUtil.ShowMessage(20006)
            return
        end
        if isEnergyFull == true and isCD == true then
            ----跳出CD中的弹窗提示
            --UICommonUtil.ShowMessage(20007)
            return
        end
    end

    if state == 1 and afterCondition and self._afterConditionMessage > 0 then
        ----afterCondition不满足弹窗提示
        --UICommonUtil.ShowMessage(self._afterConditionMessage)
        return
    end

    if  self._finalConditionMessage > 0 and not csBattleUtil.CanCastSkillByBtnType(caster.skillOwner, self._btnType) and not csBattleEnv.NoCdForPlayerSkills then
        --if state == 1 then
        --    --其他情况，被控制等。 跳出技能无法释放的弹窗提示
        --    UICommonUtil.ShowMessage(self._finalConditionMessage)
        --end
        return
    end

    --现在CD最大值会动态变化，但在cd中的表现不受影响，只在释放技能前更新CD最大值
    self._lastMaxCD = self._slot:CalcRemainCD(self._maxCdNum)

    if state == 1 then
        local actor
        if casterID then
            actor = self._battleUI.actorMgr:GetActor(casterID)
        else
            actor = self._battleUI.player
        end
        if actor then
            if self._battleUI.playerInput then
                self._battleUI.playerInput:TryCastSkill(self._btnType , actor.insID, true)  --  目前UI中1表示按下
            end
        end
    end
end

function SlotBase:PlayerBtnStateChange(btnType,isDown,casterID)
    if self._battleUI.playerInput then
        self._battleUI.playerInput:PlayerBtnStateChange(btnType, isDown, casterID)
    end
end

function SlotBase:IsGirlDead()
    if not self._battleUI.player then
        return false
    end
    return self._battleUI.player.isDead
end

function SlotBase:IsBoyDead()
    if not self._battleUI.boy then
        return false
    end
    return self._battleUI.boy.isDead
end

function SlotBase:DebugSetSlotEffectActive(isActive)
    if not GameObjectUtil.IsNull(self._effect) then
        self:SetActive(self._effect, isActive)
    end
    if not GameObjectUtil.IsNull(self._longPressOutEffect) then
        self:SetActive(self._longPressOutEffect, isActive)
    end
    if not GameObjectUtil.IsNull(self._longLoopEffect) then
        self:SetActive(self._longLoopEffect, isActive)
    end
    if not GameObjectUtil.IsNull(self._activeLoopEffect) then
        self:SetActive(self._activeLoopEffect, isActive)
    end
    if not GameObjectUtil.IsNull(self._emergeEffect) then
        self:SetActive(self._emergeEffect, isActive)
    end
end

function SlotBase:OnDestroy()
    self:Unregister()
    for _, v in ipairs(self._grids) do
        GameObjectUtil.Destroy(v.gameObject)
    end
    for i, v in ipairs(self._gridPool) do
        GameObjectUtil.Destroy(v.gameObject)
    end
    self._grids = nil
    self._gridPool = nil
    self._btnType = nil
    self._slot = nil
    self._headImgTrans = nil
    self._cdImgTrans = nil
    self._cdText = nil
    self._effect = nil
    self._emergeEffect = nil
    self._longPressOutEffect = nil
    self._longLoopEffect = nil
    self._activeLoopEffect = nil
    self._styleEnum = nil
    self._costEgNumText = nil
    self._gridBgTrans = nil
    self._gridTrans = nil
    self._cdGridTrans = nil
    self._actor = nil
    UIBehaviorBase.OnDestroy(self)
end

return SlotBase