---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by fuqiang.
--- DateTime: 2023/2/1 11:13
---

require("Runtime.Battle.Common.BattleUtil")
require("Runtime.Battle.Common.BattleLuaBridge")

---@class BattlePreloadEstimator : CS.X3Game.IPreloadEstimator
---@field analyzeUsedTime number 分析总耗时
---@field analyzeLoadUsedTime number 加载资源总耗时 = ab加载总耗时 + 实例化总耗时
---@field analyzeABLoadUsedTime number ab加载总耗时
---@field analyzeInstantiateUsedTime number 实例化总耗时
local BattlePreloadEstimator = class("BattlePreloadEstimator")

local csX3Battle = CS.X3Battle
local csBattleUtil = csX3Battle.BattleUtil
local csBattleEnv = csX3Battle.BattleEnv
local resLoadType = csX3Battle.BattleResLoadType
local BattleResTypeScene = csX3Battle.BattleResType.Scene
local Time = CS.UnityEngine.Time

function BattlePreloadEstimator:ctor()
    --- @type Dictionary<BattleResType, Dictionary<string, ResDesc>>
    self.battleResAnalyzeResult = nil
    self.analyzeUsedTime = 0
    self.analyzeLoadUsedTime = 0    -- load资源总用时
    self.analyzeABLoadUsedTime = 0 -- load ab 用时
    self.analyzeInstantiateUsedTime = 0 -- 实例化用时
end

---C#Call过来的，所以会带个self
---@param name string
---@param collector CS.PapeGames.X3.PreloadTaskCollector
function BattlePreloadEstimator.RequestBatch(self, name, collector)
    if not name then
        return
    end
    Profiler.BeginSample("BattlePreloadEstimator.RequestBatch")
    local startTime = Time.realtimeSinceStartup
    local battleArg = csBattleEnv.StartupArg

    local levelID = nil
    local resAnalyzer = nil
    local callFromBattleState = battleArg ~= nil
    if not callFromBattleState then -- 非战斗状态的调用，剧情连播
        -- 新号进入1-3时的预加载， 此时战斗尚未启动
        --这里男女主是未知的， 外部没有指定， 此时男女主预加载是不成功的。
        -- 特殊情况，设计如此
        levelID = tonumber(name)
        battleArg = csX3Battle.BattleArg()
        battleArg.levelID = levelID
        csBattleEnv.StartupArg = battleArg
        resAnalyzer = csX3Battle.BattleLevelResAnalyzer(levelID)
    else
        levelID = battleArg.levelID
        resAnalyzer = csX3Battle.BattleResAnalyzer(battleArg)
    end
    
    if not BattleUtil.GetBattleLevelConfig(levelID) then
        Debug.LogErrorFormat("level:%s configuration does not exist, please check!", levelID)
        Profiler.EndSample("BattlePreloadEstimator.RequestBatch")
        return
    end

    CriticalLog.LogFormat("[战斗][资源分析][BattlePreloadEstimator.RequestBatch()] 分析并返回战斗资源列表！ argInfo: %s",battleArg:ToString())

    local sceneName = csBattleUtil.GetSceneName()
    collector:AddSceneTask(sceneName)

    Profiler.BeginSample("BattlePreloadEstimator.Analyze")
    -- 时间统计
    local counterMgr = csX3Battle.BattleCounterMgr.Instance
    local CounterType = csX3Battle.CounterType
    counterMgr:Start(CounterType.BattleLoad)
    counterMgr:Start(CounterType.ABLoad)
    counterMgr:Start(CounterType.Instantiate)

    if UNITY_EDITOR and battleArg.startupType == csX3Battle.BattleStartupType.Online then
        -- 编辑器下，在线战斗使用实时逻辑分析
        csX3Battle.ResAnalyzer.AnalyzeRunEnv = csX3Battle.AnalyzeRunEnv.RunTimeLogic
    else
        -- 默认使用离线数据, 离线数据不存在时会自动切换为逻辑实时分析
        csX3Battle.ResAnalyzer.AnalyzeRunEnv = csX3Battle.AnalyzeRunEnv.RunTimeOffline
    end

    resAnalyzer:Analyze()

    local resMgr = csX3Battle.BattleResMgr.Instance
    -- 剧情联播时，无需资源tag的解析，此时分析结果不全
    if callFromBattleState then
        -- 通过资源树，解析资源之间的依赖关系
        resMgr.ResTags:Init(resAnalyzer.resModule)
    end

    -- 卸载爆衣后的资源， 需要时动态load
    resMgr:UnloadUnusedTagRes(csX3Battle.BattleResTag.AfterBrokenShirt, true, true)

    -- todo: 考虑换个地方调用
    local tempTime = CS.UnityEngine.Time.realtimeSinceStartup
    TbUtil.InitByResModule(resAnalyzer.resModule)
    Debug.LogFormat("战斗流程：动态配置 preload, 耗时：%s", CS.UnityEngine.Time.realtimeSinceStartup - tempTime)

    Profiler.EndSample("BattlePreloadEstimator.Analyze")
    --csX3Battle.BattleResMgr.Instance.poolMgr:EditorWriteInfoToFile()

    self.battleResAnalyzeResult = resAnalyzer:GetResult()
    local iteration = function(resDes)
        local fullPath = resDes.fullPath
        if string.isnilorempty(fullPath) or resDes.type == BattleResTypeScene then
            return -- 场景已经在上面独立 add 了
        end
        if g_BattleSVC:IsTargetSVCRes(resDes.type) then
            return
        end
        if not BattleUtil.IsNeedPreloadRes(resDes) then
            return
        end
        local loadType = csBattleUtil.GetResLoadType(resDes.type)
        if loadType == resLoadType.Prefab then
            collector:AddAssetTask(fullPath, typeof(CS.UnityEngine.GameObject))
        elseif loadType == resLoadType.Atlas then
            collector:AddAssetTask(fullPath, typeof(CS.UnityEngine.U2D.SpriteAtlas))
        --    动态引用的icon不走统一的预加载,不用全局路径
        --elseif loadType == resLoadType.Sprite then
            --UIUtil.GetSprite(fullPath,x3BattleClient.gameObject)
        elseif loadType == resLoadType.Hero then
            local assets = csBattleUtil.GetCharacterAssetPaths(resDes.suitID)
            collector:AddAssetTaskArray(assets)
        elseif loadType == resLoadType.Audio then
            collector:AddWwiseEventTask(resDes.path)
        elseif loadType == resLoadType.Music then -- BGM
            local musicEventName = g_battleLuaBridge:GetMusicEventName(resDes.path)
            if not musicEventName then
                collector:AddWwiseEventTask(musicEventName)
            end
        else
            collector:AddAssetTask(fullPath)
        end
    end
    -- 这里把字典的遍历放到C#端， 避免lua端遍历字典的时候，通过反射访问字典
    csX3Battle.BattleUtil.ForeachAnalyzeResult(self.battleResAnalyzeResult, iteration)

    self.analyzeUsedTime = Time.realtimeSinceStartup - startTime
    self.analyzeLoadUsedTime = counterMgr:End(CounterType.BattleLoad)
    self.analyzeABLoadUsedTime = counterMgr:End(CounterType.ABLoad)
    self.analyzeInstantiateUsedTime = counterMgr:End(CounterType.Instantiate)

    if not callFromBattleState then -- 剧情联播战斗时，赋值的临时battleArg, 使用后清空
        csBattleEnv.StartupArg = nil
    end
    Debug.LogFormat("战斗流程：资源分析总耗时：%s,耗时Load：%s, LoadAB:%s, instantiate:%s",
            self.analyzeUsedTime, self.analyzeLoadUsedTime, self.analyzeABLoadUsedTime,
            self.analyzeInstantiateUsedTime)
    Profiler.EndSample("BattlePreloadEstimator.RequestBatch")
end

---C#Call过来的，所以会带个self
---@param name string
---@param params string[] 预留参数
---@return float 预估剩余时间，单位秒
function BattlePreloadEstimator.EstimateRemainingTime(self, name, params)
    local battleIns = csX3Battle.Battle.Instance
    if (battleIns == nil) then
        return math.maxinteger
    end
    local time = battleIns.levelFlow.remainTime
    return time
end

function BattlePreloadEstimator:Clear()
    self.battleResAnalyzeResult = nil
end

g_battlePreloadEstimator = BattlePreloadEstimator.new()
return g_battlePreloadEstimator