---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chaoguan.
--- DateTime: 2024/1/30 18:50
---

local CSX3Battle = CS.X3Battle
local CSUnityEngine = CS.UnityEngine
local CSEnumToInt = CS.System.Convert.ToInt32
local CSJSONSerializer = CS.ParadoxNotion.Serialization.JSONSerializer
local CSPreloadBatchMgr = CS.X3Game.PreloadBatchMgr
local CSBattleResMgr = CSX3Battle.BattleResMgr
local CSBattleUtil = CSX3Battle.BattleUtil
local CSBattleEnv = CSX3Battle.BattleEnv
local CSTime = CSUnityEngine.Time
local CSBattleResType = CSX3Battle.BattleResType
local CSGameObject = CSUnityEngine.GameObject
local CSBattleClient = CSX3Battle.BattleClient
local CSBattleCounterMgr = CSX3Battle.BattleCounterMgr
local CSBattleLuaExport = CSX3Battle.BattleLuaExport
local CSQualitySettings = CS.UnityEngine.QualitySettings
local CSXResources = CS.XAssetsManager.XResources
local CSX3AssetInsProvider = CS.PapeGames.X3.X3AssetInsProvider
local CSApplication = CSUnityEngine.Application
local CSPhysics = CSUnityEngine.Physics

local BaseState = require("Runtime.Battle.Common.SimpleStateMachine").BaseState
local BattleSVC = require("Runtime.Battle.BattleSVC")

---战斗启动状态
---@class BattleStartupState:BaseState
---@field context BattleLauncher
local StartupState = XECS.class("StartupState", BaseState)

function StartupState:ctor(context)
    self.lastRealtime = 0 -- 最新的时间
    self.startupBattleRealTime = 0 -- 战斗开始启动的时间
    self.openLoadingUIElapsedTime = 0 -- 打开loadingUI耗时
    self.closeLoadingUIElapsedTime = 0 -- 关闭loadingUI耗时
    self.switchBattleStateElapsedTime = 0 -- 切换到BattleState耗时
    self.unloadExtraResElapsedTime = 0 -- 卸载战斗外资源耗时（关闭战斗外UI，切换横屏， 设置TextureStreaming）
    self.svcWarmUpElapsedTime = 0 -- SVC预热耗时
    self.prepareAssetElapsedTime = 0 -- 准备战斗资源耗时（音效，场景，及所有战斗内ab）
    self.preloadAssetInsElapsedTime = 0 -- 资源实例预创建耗时
    self.createBattleElapsedTime = 0 -- 创建战斗实例耗时
    self.battleBeginElapsedTime = 0 -- 开始战斗逻辑耗时
    self.startupBattleElapsedTime = 0 -- 战斗启动总耗时

    BaseState.ctor(self, context)
end

function StartupState:CanEnter(prevState)
    return prevState == nil
end

function StartupState:OnEnter(prevState, battleArg)
    CSBattleEnv.StartupArg = battleArg
    self._isWorking = true
    self._battleArg = battleArg
    self._levelID = self._battleArg.levelID
    self._stageId = self._battleArg.commonStageId
    self._girlWeaponID = self._battleArg.girlWeaponID
    self._girlSuitID = self._battleArg.girlSuitID
    self._boySuitID = self._battleArg.boySuitID
    PerformanceLog.Begin(PerformanceLog.Tag.BattleStartup, self._levelID)

    --- 开始启动步骤
    self:_OpenLoadingUI()
end

function StartupState:CanExit(nextState)
    return (not self._isWorking) and nextState == self.context.inBattleState
end

function StartupState:OnExit(nextState)
    self._battleArg = nil
    self._csBattleClient = nil
    PerformanceLog.End(PerformanceLog.Tag.BattleStartup, self._levelID)
end

---启动步骤1
---呼起loading（黑白屏渐入/LoadingUI打开）
function StartupState:_OpenLoadingUI()
    CriticalLog.LogFormat("[战斗][启动流程][StartupState._OpenLoadingUI()] 当前战斗Girl：%s,Boy：%s,关卡：%s,武器：%s", self._battleArg.girlID, self._battleArg.boyID, self._levelID, self._girlWeaponID)

    --- 记录战斗开始启动时间
    self.startupBattleRealTime = CSTime.realtimeSinceStartup
    --- 记录OpenLoadingUI开始的时间
    self.lastRealtime = CSTime.realtimeSinceStartup

    --- 禁用断线表现
    GrpcMgr.SetReConnectIsShow(false)
    --- 上报关卡ID
    CrashSightMgr.SetBattleLevelID(self._levelID)

    --- loadingType
    self._loadingType = BattleLoadingType.Loading
    if self._battleArg.fromGameState ~= GameState.EnterGame and ChapterStageManager then
        self._loadingType = ChapterStageManager.GetBattleEnterOrEndShow(self._stageId, 1)
    end

    --- show loading UI
    local isCallOk = false
    if self._loadingType == BattleLoadingType.BlackScreen then
        isCallOk = XECS.XPCall(UICommonUtil.BlackScreenIn, handler(self, self._SwitchToBattleState))
    elseif self._loadingType == BattleLoadingType.WriteScreen then
        isCallOk = XECS.XPCall(UICommonUtil.WhiteScreenIn, handler(self, self._SwitchToBattleState))
    elseif self._loadingType == BattleLoadingType.Loading then
        self._loadingTipsType = ChapterStageManager.GetStageLoadingType(self._stageId)
        --- 当前在战斗主状态时，不需要loading的渐入状态（暂停界面中重新开始战斗）
        if self._battleArg.fromGameState == GameState.Battle then
            XECS.XPCall(BattleUtil.SetLoadingEnable, self._loadingTipsType, true, nil, false)
        else
            isCallOk = XECS.XPCall(BattleUtil.SetLoadingEnable, self._loadingTipsType, true, handler(self, self._SwitchToBattleState))
        end
    end
    if not isCallOk then
        self:_SwitchToBattleState()
    end
end

---启动步骤2
---loading阶段，呼起loadingUI完成
---切换到斗状态
function StartupState:_SwitchToBattleState()
    CriticalLog.Log("[战斗][启动流程][StartupState._SwitchToBattleState()] 呼起loadingUI成功，准备切换到战斗主状态!！")

    --- 记录打开LoadingUI的耗时    
    self.openLoadingUIElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime
    --- 记录切换战斗状态开始时间
    self.lastRealtime = CSTime.realtimeSinceStartup

    --- 切换游戏状态
    if self._battleArg.fromGameState == GameState.Battle then
        self:_OnEnterBattleState()
    else
        GameStateMgr.Switch(GameState.Battle, handler(self, self._OnEnterBattleState))
    end
end

---启动步骤3
---loading阶段，进入战斗主状态完成
---关闭其他UI面板，开启低模，开始横竖屏切换
function StartupState:_OnEnterBattleState()
    CriticalLog.Log("[战斗][启动流程][StartupState._OnEnterBattleState()] 切换到战斗主状态成功，准备关闭编队UI，设置低模，切换横屏等!！")

    --- 记录切换战斗状态的耗时    
    self.switchBattleStateElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime
    --- 记录准备卸载战斗外资源开始时间
    self.lastRealtime = CSTime.realtimeSinceStartup

    --- 关闭UI
    UIMgr.Close(UIConf.MainHomeWnd, false)
    UIMgr.Close(UIConf.TeamWnd, false)
    UIMgr.Close(UIConf.BattleWnd, false)
    UIMgr.Close(UIConf.BattleTipsWnd, false)
    UIMgr.Close(UIConf.BattleResultWnd, false)

    --- 设置横屏
    UIMgr.SetLandscapeMode(handler(self, self._LandscapeComplete))
end

---启动步骤4.1
---loading阶段，切换横竖屏结束
---清理局外数据，初始化战斗环境
function StartupState:_LandscapeComplete()
    CriticalLog.Log("[战斗][启动流程][StartupState._LandscapeComplete()] 切换横屏模式完成，开始设置战前环境！！")

    ---清空资源,清理局外音频资源 如果不是连播模式才卸载资源
    X3AssetInsProvider.DestroyPoolAllLifeMode()
    if ChapterStageManager ~= nil and not ChapterStageManager.GetIsInAutoStage() then
        --Debug.Log("战斗流程：卸载战斗外Bank资源")
        WwiseMgr.UnloadUnusedBanks()
    end

    --- 一些游戏设置
    self:_SetGameSetting()
    --- 发起内存清理
    BattleUtil.ClearMemory()

    --- 监听资源加载的耗时统计
    local counterMgr = CSBattleCounterMgr.Instance
    counterMgr:Clear()
    counterMgr:StartResLoadCount()

    BattleUtil.StartCoroutine(self._CoPrepareAssets, self)
end

---启动步骤4.2
---loading阶段，战斗环境初始化完成
--- 这里主要做：资源预热，只load Asset。 加载声音bank， 加载并切换场景
function StartupState:_CoPrepareAssets()
    CriticalLog.Log("[战斗][启动流程][StartupState._CoPrepareAssets()] 战前环境设置完成，开始准备战斗资源（战斗资源分析，场景加载）！")

    -- 设置一个初始进度，防止下面启动资源分析时，耗时较长，卡进度0,体验较差
    local initProgress = 0.05
    UICommonUtil.SetLoadingProgress(initProgress)
    coroutine.yield(CSUnityEngine.WaitForSeconds(0.1))

    -- 自动化测试，抓内存快照
    BattleUtil:TryBattleMemorySnapShot(1)

    -- 设置每帧加载资源的数量为100
    self.context._preLoadingCntPerFrame = CSPreloadBatchMgr.loadingCntPerFrame
    CSPreloadBatchMgr.loadingCntPerFrame = 100

    --- 记录卸载战斗外资源的耗时
    self.unloadExtraResElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime
    --- 记录加载资源的开始时间
    self.lastRealtime = CSTime.realtimeSinceStartup

    ---开启预分析
    TbUtil.Init()
    self.context._preloadBatchID = PreloadBatchMgr.Load(
            PreloadBatchType.Battle,
            tostring(self._levelID),
            function()
                BattleUtil.StartCoroutine(self._LoadSceneComplete, self)
            end,
            GameConst.LoadingType.None,
            true,
            nil, 0.8, initProgress
    )

    local resAnalyzeResult = g_battlePreloadEstimator.battleResAnalyzeResult

    CriticalLog.Log("[战斗][启动流程][StartupState._CoPrepareAssets()] 开始SVC异步预热！")
    local lastRealTime = CSTime.realtimeSinceStartup
    BattleSVC:WarmUpAsync(resAnalyzeResult)
    self.svcWarmUpElapsedTime = CSTime.realtimeSinceStartup - lastRealTime
    --Debug.LogFormat("战斗流程：资源分析完成，SVC异步warmUp，耗时：%s", self.svcWarmUpElapsedTime)
end

---启动步骤5
---loading阶段，场景加载结束
---清理局外数据，创建战斗实例
function StartupState:_LoadSceneComplete()
    CriticalLog.Log("[战斗][启动流程][StartupState._LoadSceneComplete()] 战斗资源准备完成，场景加载结束！")

    --- 上报当前场景
    CrashSightMgr.SetCurSceneName(SceneMgr.GetCurScene())
    UIMgr.Close(UIConf.InputEffectWnd)

    --- 记录加载资源的耗时
    local prepareAssetsElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime
    self.prepareAssetsElapsedTime = prepareAssetsElapsedTime
    --Debug.LogFormat("战斗流程：资源加载结束, 耗时：%s秒，开始对象预创建", prepareAssetsElapsedTime)

    coroutine.yield(CSUnityEngine.WaitForSeconds(0.2))
    -- 卸载一批无用资源
    X3AssetInsProvider.DestroyPoolAllLifeMode()
    BattleUtil.ClearMemory()

    ---记录预创建战斗实例的开始时间
    self.lastRealtime = CSTime.realtimeSinceStartup
    UICommonUtil.SetLoadingProgress(0.85)

    --- 预创建对象池中对象
    self:_CoPreloadAssetIns()
    BattleUtil.ClearMemory()

    self.preloadAssetInsElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime
    --Debug.LogFormat("战斗流程：对象池中对象预创建完成，耗时：%s秒， 开始创建战斗", self.preloadAssetInsElapsedTime)

    ---记录战斗实例创建，预加载的开始时间
    self.lastRealtime = CSTime.realtimeSinceStartup
    UICommonUtil.SetLoadingProgress(0.95)

    --- 启动战斗
    self._csBattleClient = CSGameObject("BattleClient"):AddComponent(typeof(CSBattleClient))
    self._csBattleClient:Startup(self._battleArg)

    --- UI 打开需要等1帧
    coroutine.yield(nil)
    self._csBattleClient:Preload()
    BattleUtil.ClearMemory()

    --- 等3帧让爆发技真正播一下
    coroutine.yield(nil)
    coroutine.yield(nil)
    coroutine.yield(nil)
    self._csBattleClient:StartupFinished()

    --- 等一帧, 等女主因预加载爆发技里播放的WeaponIdle过渡至Idle后在去掉加载UI.
    coroutine.yield(nil)
    --- 暂停战斗，等待白屏渐出完成后开始战斗
    self._csBattleClient.battle:SetWorldEnable(false)
    --- loading进度100%
    UICommonUtil.SetLoadingProgress(1)

    ---记录战斗实例创建，预加载的耗时
    self.createBattleElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime
    ---记录关闭LoadingUI的开始时间
    self.lastRealtime = CSTime.realtimeSinceStartup
    --Debug.LogFormat("战斗流程：创建战斗完成，耗时：%s", self.createBattleTime)

    -- 关掉Res.load资源回调的监听
    CSBattleCounterMgr.Instance:EndResLoadCount()
    BattleUtil.ClearMemory()

    --- 关闭 Loading UI
    coroutine.yield(CSUnityEngine.WaitForSeconds(0.1))
    self:_CloseLoadingUI()
end

---启动步骤5.1
---loading阶段
---预创建战斗资源
function StartupState:_CoPreloadAssetIns()
    CriticalLog.Log("[战斗][启动流程][StartupState._CoPreloadAssetIns()] 开始资源实例的预创建！")

    ---预加载战斗资源
    --local perPath  = CSApplication.persistentDataPath
    --local path = string.format("%s/BattlePreCreateInfo_%s.csv",perPath, self._levelID)
    --log中搜索关键子：“资源预创建信息” 可以查看最终文件存储路径
    --解开上面注释，即可查看预创建的统计信息
    local objList = {}
    local tempObj = nil
    local numType = CSEnumToInt(CSBattleResType.Num)
    local resAnalyzeResult = g_battlePreloadEstimator.battleResAnalyzeResult
    local CSBattleResMgrIns = CSBattleResMgr.Instance
    local iteration = function(resDes)
        local fullPath = resDes.fullPath
        local resType = resDes.type
        local curTypeNum = CSEnumToInt(resType)
        if not fullPath or curTypeNum >= numType then
            return
        end
        if BattleSVC:IsTargetSVCRes(resType) then
            return -- SVC 不在这里处理
        end
        if not BattleUtil.IsNeedPreloadRes(resDes) then
            return
        end

        -- TODO for付强 HurtFx需要预加载数量.
        local maxCount = 1
        if resType == CSBattleResType.HurtFX then
            maxCount = resDes.count
        end
        for _ = 1, maxCount do
            tempObj = CSBattleResMgrIns:LoadObj(resDes, true)
            if tempObj then
                table.insert(objList, tempObj)
            end
        end
        -- 进入对象池
        for i = #objList, 1, -1 do
            CSBattleResMgrIns:UnloadObj(objList[i])
            objList[i] = nil
        end
    end

    ---关闭：BattleResMgr模块内加载的资源，战斗中加载资源时，打印错误日志开关
    --- 预加载阶段的资源加载，属于符合预期的资源加载，不做报错
    local preValue = CSBattleResMgr.isDynamicLoadErring
    CSBattleResMgr.isDynamicLoadErring = false
    -- 这里把字典的遍历放到C#端， 避免lua端遍历字典的时候，通过反射访问字典
    CSBattleUtil.ForeachAnalyzeResult(resAnalyzeResult, iteration)
    CSBattleResMgr.isDynamicLoadErring = preValue
end

---启动步骤6
---关闭loading（黑白屏渐出/LoadingUI关闭）
function StartupState:_CloseLoadingUI()
    CriticalLog.LogFormat("[战斗][启动流程][StartupState._LoadingClose(), 战斗资源以及战斗环境准备完成，开始关闭LoadingUI, loadingType:%s] loading开始淡出！", self._loadingType)

    local isCallOk = false
    if self._loadingType == BattleLoadingType.BlackScreen then
        isCallOk = XECS.XPCall(UICommonUtil.BlackScreenOut, handler(self, self._ToBeginBattle))
    elseif self._loadingType == BattleLoadingType.WriteScreen then
        isCallOk = XECS.XPCall(UICommonUtil.WhiteScreenOut, handler(self, self._ToBeginBattle))
    elseif self._loadingType == BattleLoadingType.Loading then
        isCallOk = XECS.XPCall(BattleUtil.SetLoadingEnable, self._loadingTipsType, false, handler(self, self._ToBeginBattle))
    end
    if not isCallOk then
        self:_ToBeginBattle()
    end
end

---启动步骤7
---启动结束，开始战斗！！
function StartupState:_ToBeginBattle()
    CriticalLog.LogFormat("[战斗][启动流程][StartupState._ToBeginBattle(), 关闭LoadingUI完成, 开始战斗实例逻辑的创建，可以开始战斗！！")

    ---记录关闭LoadingUI的耗时
    self.closeLoadingUIElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime
    ---记录启动战斗的完整耗时
    self.startupBattleElapsedTime = CSTime.realtimeSinceStartup - self.startupBattleRealTime
    --Debug.LogFormat("战斗流程：关闭LoadingUI结束, 耗时：%s秒，战斗开始, LoadingUI存在总时间：%s", self.closeLoadingUITime, self.loadingKeepTime)

    ---记录战斗逻辑开始的时间
    self.lastRealtime = CSTime.realtimeSinceStartup
    ---恢复战斗
    self._csBattleClient.battle:SetWorldEnable(true)
    CSJSONSerializer.FlushMem()

    ---无脑关闭无缝衔接时，上一个场景的截屏
    UICommonUtil.SetCaptureEnable(false)

    ---开启：战斗中加载资源时，打印错误日志
    CSBattleResMgr.isDynamicLoadErring = true
    ---开启：非战斗resMgr模块内，加载行为发生时是否打印错误日志,例如武器部件，UI依赖的材质资源
    CSBattleResMgr.isDynamicBottomLoadErring = true

    ---开始战斗
    self._csBattleClient:Begin()
    ---记录战斗逻辑开始耗时
    self.battleBeginElapsedTime = CSTime.realtimeSinceStartup - self.lastRealtime

    ---卸载LoadingUI资源
    BattleUtil.StartCoroutine(self._UnloadLoadingUI, self)
    --自动化测试截取内存快照
    BattleUtil:TryBattleMemorySnapShot(2)

    ---- 把资源预加载的详细信息写到本地，支持真机
    --BattleUtil:WriteResLoadInfo(self._levelID)
    -- 把启动流程各个阶段的耗时写到本地（追加的方式），支持真机
    --BattleUtil:RecordLoadingTime(self._levelID)

    self._isWorking = false
    -- 切换到战斗中状态
    self.stateMachine:Switch(self.context.inBattleState)
end

function StartupState:_UnloadLoadingUI()
    -- 系统需要一帧时间入池
    coroutine.yield(nil)
    -- 卸载冗余资源
    X3AssetInsProvider.DestroyPoolAllLifeMode()

    -- 这边还需要一帧
    coroutine.yield(nil)
    BattleUtil.ClearMemory()
end

--- 启动战斗时的一些游戏设置
---（在横屏切换完成后调用！）
function StartupState:_SetGameSetting()
    -- 记录原始值
    self.context._mainlineStreamingActive = CSQualitySettings.streamingMipmapsActive
    self.context._mainlineStreamingBudget = CSQualitySettings.streamingMipmapsMemoryBudget
    self.context._originalFsrEnableState = BattleUtil.GetFSREnableState()
    self.context._prevFrameRate = CSApplication.targetFrameRate
    self.context._fixedDeltaTime = CSTime.fixedDeltaTime
    self.context._prevAutoSimulation = CSPhysics.autoSimulation
    self.context._prevAutoSyncTransforms = CSPhysics.autoSyncTransforms
    self.context._preXResourcesPauseTick = CSXResources.PauseTick
    self.context._x3AssetInsProviderTickEnable = CSX3AssetInsProvider.Instance.TickEnable
    self.context._curEnergySavingModel = BattleUtil.GetEnergySavingModel()

    -- 关闭蓝图cache机制(在战斗实例销毁时，会恢复)
    CSBattleUtil.EnableNotionDataCache(false)
    -- 加载lua端用到的cs类型
    CSBattleLuaExport.LoadWraps()
    -- 开启低模
    CharacterMgr.SetGlobalLOD(1)

    -- 开启mipMap
    CSQualitySettings.streamingMipmapsActive = true
    -- 小米9目前档位是2，战斗支持的最低标准
    if BllMgr:GetSystemSettingBLL():GetRecommendGQLevel() <= 2 then
        CSQualitySettings.streamingMipmapsMemoryBudget = 150
    end
    --低内存（3G）关闭FSR
    if BattleUtil.GetMemorySizeLevel() == MemoryLevelType.Low then
        BattleUtil.EnableFSR(false)
    end
    -- 开始战斗，设置帧率
    CSApplication.targetFrameRate = 30
    -- 设置物理帧更新频率
    CSTime.fixedDeltaTime = 0.05
    -- 这里关掉Unity原生的物理，因为已经全部替换为引擎组开发的物理模块
    CSPhysics.autoSimulation = false
    -- 关闭物理自动同步transform（GameWorld 到 Physics.World）当使用物理的查询接口时
    CSPhysics.autoSyncTransforms = false
    -- 停掉 底层的资源加载模块tick，不在支持，异步加载，自动卸载。 如果需要卸载，手动调用 CSRes.UnloadUnusedLoaders()
    CSXResources.PauseTick = true
    -- 停掉 底层的资源加载模块tick
    CSX3AssetInsProvider.Instance.TickEnable = false
    -- 进入战斗打开多点触控功能
    GameHelper.SetMultiTouchEnable(true, GameConst.MultiTouchLockType.Battle)
    -- 节能设置
    BattleUtil.SetEnergySavingModel(true)
end

return StartupState