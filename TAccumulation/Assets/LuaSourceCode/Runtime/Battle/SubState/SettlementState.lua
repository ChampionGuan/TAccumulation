---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chaoguan.
--- DateTime: 2022/6/12 16:38
---

local CSX3Battle = CS.X3Battle
local CSBattle = CSX3Battle.Battle
local CSBattleResMgr = CSX3Battle.BattleResMgr
local CSShaderVariantCollection = CS.UnityEngine.ShaderVariantCollection
local CSRes = CS.PapeGames.X3.Res

local BaseState = require("Runtime.Battle.Common.SimpleStateMachine").BaseState

---战斗结算状态
---@class BattleSettlementState:BaseState
---@field context BattleLauncher
local SettlementState = XECS.class("SettlementState", BaseState)

function SettlementState:CanEnter(prevState)
    return prevState == self.context.inBattleState
end

---@param battleEndInfo CS.X3Battle.EventBattleEnd
function SettlementState:OnEnter(_, battleEndInfo, onServerAck)
    if not onServerAck then
        Debug.LogError("SettlementState:开始结算流程没有传服务区应答后的回调函数，请检查!")
    end

    self._isWorking = true
    self._csBattle = CSBattle.Instance
    self._battleArg = self._csBattle.arg
    self._battleEndInfo = battleEndInfo
    self._onServerAck = onServerAck
    self._isOnline = self._battleArg.startupType == BattleStartupType.Online

    --- 开始结算流程
    self:StartProcess()
end

function SettlementState:CanExit(nextState)
    return (not self._isWorking) and nextState == self.context.shutdownState
end

function SettlementState:OnExit(nextState)
    self._csBattle = nil
    self._battleArg = nil
    self._battleEndInfo = nil
    self._onServerAck = nil
    self._statisticsData = nil
    self._formationStr = nil
    self._serverSettlementData = nil
end

---战斗结束： 步骤一
---监听关卡结束逻辑，关卡结束
function SettlementState:StartProcess()
    CriticalLog.LogFormat("[战斗][结算流程][SettlementState._OnLevelEnd()] 结算流程开始，关卡结束:%s", self._battleEndInfo.isWin and "胜利" or "失败")

    --战斗结束恢复断线表现
    if self._isOnline then
        GrpcMgr.SetReConnectIsShow(true)
    end
    ---如果胜利保存防作弊编队信息
    if self._battleEndInfo.isWin then
        self.context._formationStr = BattleUtil.GetFormation(BllMgr.GetChapterAndStageBLL():GetEnterBattleFormationData())
    end

    BattleUtil.StartCoroutine(self._GenServerMsg, self)
end

---战斗结束： 步骤一.二
---延迟5帧发送结束协议
function SettlementState:_GenServerMsg()
    coroutine.yield(nil)
    coroutine.yield(nil)
    coroutine.yield(nil)
    coroutine.yield(nil)
    coroutine.yield(nil)
    ---收集战斗结束协议所需数据！！
    if self._isOnline and self._battleEndInfo.failRes ~= -1 then
        local data = {}
        local subInfo = {}
        local resNum = 1
        if self._battleEndInfo.isWin then
            resNum = 0
        elseif self._battleEndInfo.failRes > 0 then
            resNum = self._battleEndInfo.failRes
        end

        subInfo["Result"] = resNum
        subInfo["BattleTime"] = math.round(self._csBattle.levelFlow.levelTime)
        subInfo["IsBurst"] = self._csBattle.statistics.isAlreadyBrokenSuit

        --  统计数据
        local battleData = self._csBattle.statistics
        local girlActor = self._csBattle.actorMgr.girl
        local girlEntityID = 0
        if girlActor then
            girlEntityID = girlActor.insID
        end

        local boyActor = self._csBattle.actorMgr.boy
        local boyEntityID = 0
        if boyActor then
            boyEntityID = boyActor.insID
        end

        local boyData = battleData:GetEntityData(boyEntityID)
        local girlData = battleData:GetEntityData(girlEntityID)

        local resultList = {}
        table.insert(resultList, { Id = 1, Num = math.round(boyData.leftHp) })
        table.insert(resultList, { Id = 2, Num = math.round(girlData.leftHp) })
        table.insert(resultList, { Id = 3, Num = math.round(boyData.damageGet) })
        table.insert(resultList, { Id = 4, Num = math.round(girlData.damageGet) })
        table.insert(resultList, { Id = 6, Num = math.round(boyData.maxHp) })
        table.insert(resultList, { Id = 7, Num = math.round(girlData.maxHp) })
        subInfo["ResultList"] = resultList

        --怪物血量
        local monsterDic = {}
        for k, v in pairs(battleData.entities) do
            if v.actorType == CS.X3Battle.ActorType.Monster then
                local monsterHp = {}
                table.insert(monsterHp, { Id = 8, Num = math.round(v.leftHp) })
                table.insert(monsterHp, { Id = 10, Num = math.round(v.maxHp) })
                monsterDic[v.spawnID] = monsterHp
            end
        end
        subInfo["MonsterResults"] = monsterDic
        data["Result"] = subInfo

        --防作弊信息
        --Profiler.BeginCoroutineSample("csBattle.cheatStatistics")
        local battleCheatData = self._csBattle.cheatStatistics
        local isUpLevel = 0
        isUpLevel = battleCheatData:GetIsUp()
        if isUpLevel then
            local reviewInfo = {}
            local recordInfo = {}
            local Statistic = {}
            local cheatHurtlist = {}
            local cheatSkilllist = {}
            data["Review"] = reviewInfo
            reviewInfo["Records"] = recordInfo

            cheatHurtlist = battleCheatData:GetCheatHurtMax()

            for k, v in pairs(cheatHurtlist) do

                local atkBuff = {}
                for q, e in pairs(v.atkBuffs) do
                    table.insert(atkBuff, { Id = e.ID, Num = e.SubKey })
                end

                local hurtBuff = {}
                for q, e in pairs(v.hurtBuffs) do
                    table.insert(hurtBuff, { Id = e.ID, Num = e.SubKey })
                end

                local skillData = {}
                skillData.Id = v.skillID
                skillData.Num = v.skillType

                table.insert(recordInfo, { AttackType = v.atkType, AttackID = v.atkID, AttackSummonLevel = v.atkSummonLevel,
                                           AttackSummonFromType = v.atkBelongType, AttackSummonFromID = v.atkBelongId,
                                           AttackBuffs = atkBuff,
                                           ReceiveType = v.hurtType, ReceiveID = v.hurtID, ReceiveSummonLevel = v.hurtLevel,
                                           ReceiveSummonFromType = v.hurtBelongType, ReceiveSummonFromID = v.hurtBelongId,
                                           ReceiveBuffs = hurtBuff,
                                           Skill = skillData, DamageID = v.hitParamCfgId, DamageRatio = v.damagePercent,
                                           IsCritical = v.isCritical, ClientDamage = v.damageNum, IsCore = v.isWeak })
            end
            reviewInfo["Statistic"] = Statistic
            cheatSkilllist = battleCheatData:GetCheatSkillInfo()
            for k, v in pairs(cheatSkilllist) do
                table.insert(Statistic, { SkillID = v.skillID, Count = v.useNum,
                                          AccDamage = v.damage })
            end
        end
        --Profiler.EndCoroutineSample()

        self._serverSettlementData = data
        EventMgr.Dispatch(ErrandConst.ERRAND_DELAY_OPEN)
    end

    ---请求服务器战斗结束
    ---todo 发送时机后移(由关卡逻辑选择合适时机发出)，为了处理游戏结束时的概率卡断现象
    self:_ReqServerEnd()
end

---战斗结束： 步骤二
---向服务器发起结束请求
function SettlementState:_ReqServerEnd()
    CriticalLog.Log("[战斗][结算流程][SettlementState.ReqServerEnd()] 向服务器同步协议!")

    if not self._isOnline then
        self:SetStatisticsUIData()
    elseif self._serverSettlementData then
        --- 新手引导需要的特定消息
        BattleUtil.SendCleanGuideEvent()
        GrpcMgr.SendRequest(RpcDefines.DungeonEndRequest, self._serverSettlementData, true)
    else
        local messageBody = {}
        messageBody.StageID = self._battleArg.commonStageId
        GrpcMgr.SendRequest(RpcDefines.CancelStageRequest, messageBody, true)
    end
    self._serverSettlementData = nil
end

---战斗结束： 步骤四
---服务器战斗结算数据更新，由协议应答
---@param msg pbcmessage.FinStageReply
function SettlementState:SetStatisticsUIData(msg)
    CriticalLog.LogFormat("[战斗][结算流程][SettlementState.SetStatisticsUIData()] 服务器回复消息，确认在线战斗结束，打开结算UI，结果：%s", nil == msg and "nil" or msg.IsWin)

    self._statisticsData = { msg = msg }
    --- 服务器结算数据传到客户端
    XECS.XPCall(self._onServerAck, self)
    self._onServerAck = nil
end

---战斗结束：步骤五
---打开战斗结算面板，由关卡flow发起
function SettlementState:ShowStatisticsUI()
    CriticalLog.LogFormat("[战斗][结算流程][SettlementState.ShowStatisticsUI()] 开始打开结算UI!!")

    CSBattleResMgr.isDynamicBottomLoadErring = false
    BattleUtil.StartCoroutine(self._CoShowStatisticsUI, self)
end

---协程显示结算UI
function SettlementState:_CoShowStatisticsUI()
    BattleUtil:TryBattleMemorySnapShot(3)

    CSShaderVariantCollection.StopBackgroundJob()
    BattleUtil.CloseBattleUI(self._battleArg.levelID)
    -- 暂停战斗沟通
    --self._csBattle.dialogue:Pause(true)
    -- 目的：允许角色动画继续播放，防止暂停到一个奇怪的姿势
    self._csBattle:SetWorldEnable(true)

    coroutine.yield(nil)
    self._csBattle:UnloadUnusedRes()

    coroutine.yield(nil)
    X3AssetInsProvider.DestroyPoolAllLifeMode()
    CSRes.UnloadUnusedLoaders()

    coroutine.yield(CS.UnityEngine.WaitForSeconds(0.1))
    self._csBattle:SetWorldEnable(false)
    self._isWorking = false

    if self._isOnline then
        ChapterStageManager.ShowBattleResult(self._statisticsData.msg, handler(self, self._ToShutdown))
    else
        self:_ToShutdown()
    end
end

---战斗结束：步骤六
---结算流程完成，进入退出状态
function SettlementState:_ToShutdown()
    -- 切换到退出战斗状态
    self.stateMachine:Switch(self.context.shutdownState, BattleShutdownType.AftSettlement, self._statisticsData.msg)
end

return SettlementState