--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by pc.
--- DateTime: 2020/12/24 19:08
---

local cfg_meta_table
local bind_metatable
local _pairs
local KEY_NAME = "_s"
local MULTI_KEY_NAME = "_m"
local ORIGIN_KEY = "_k"
local CFG_DIR_ROOT = "LuaCfg."
local CFG_META_KEY = "_cfg_meta_"
local CFG_PATH_MAP = { ["Dialogue"] = ".Dialogue_", ["RunChess"] = ".RunChess_", ["CircleChess"] = ".CircleChess_", ["StoryStage"] = ".StoryStage_" }
local SKIP_TAG = "ExamineInclude"
local CFG_MAP = {}
local NAME_TO_PATH_MAP = {}
local NAME_MAP = {}
local log, log_warn, log_error, un_load_file, clone_cfg, check_meta_valid, save_debug_cfg, cfg_pairs, cfg_len, is_line_valid, check_skip,get_table,release_table
local _log, _log_warn, _log_error = print, print, print
local is_debug_enable = false
local is_write_enable = false
local is_skip_enable = false
local ignore_skip_enable = true
local VALUE_IDX = 1
local IS_PARSED_IDX = 2
local IS_MULTI_KEY_IDX = 3
local pool = {}
local struct_meta = {}
local log_enable = true

---根据key获取index
local function get_index(name, t_keys)
    if not t_keys then
        return nil
    end
    local t = t_keys[name]
    if type(t) == "table" then
        --第一个是index，第二个是keys
        return t[1], t[2]
    end
    return t
end

---for 循环重写
_pairs = function(tbl, key)
    local t = rawget(tbl, KEY_NAME)
    t = t and t or tbl
    local nk, nv = next(t, key)
    if nk then
        if nk == MULTI_KEY_NAME or nk == KEY_NAME then
            return _pairs(tbl, nk)
        end
        nv = tbl[nk]
    end
    return nk, nv
end

---检测是否属于配置表结构体或者结构体列表
local function check_value_type(v , keyMap)
    if table.isnilorempty(v) then
        return false, false
    end
    local is_struct = false
    local is_struct_list = v[1] ~= nil and type(v[1]) == "table"
    if is_struct_list then
        for _, _v in cfg_pairs(v) do
            if type(_v) ~= "table" then
                is_struct_list = false
                break
            end
        end
    else
        for _, _v in cfg_pairs(v) do
            if type(_v) == "table" then
                is_struct_list = true
            else
                is_struct_list = false
                break
            end
        end
    end
    if not is_struct_list then
        for m, _ in cfg_pairs(v) do
            if type(m) == "string" then
                is_struct = true
                break
            end
        end
    end
    return is_struct, is_struct_list
end

---所有配置表的统一metable
cfg_meta_table = {
    [CFG_META_KEY] = true,
    --重写index
    __index = function(tb, key)
        if key == nil then
            return nil
        end
        local keys = rawget(tb, KEY_NAME)
        local idx, sub_keys = get_index(key, keys)
        if not idx then
            return nil
        end
        local o = rawget(tb, idx)
        if not sub_keys then
            return o
        end
        if o then
            local k_map = keys[key]
            local is_need_set_metatable = true
            local is_struct_list = k_map[3]
            if is_struct_list == nil then
                local is_struct
                is_struct, is_struct_list = check_value_type(o, k_map[2])
                if is_struct or is_struct_list then
                    is_struct_list = not is_struct and is_struct_list
                    k_map[3] = is_struct_list
                end
            end
            if is_struct_list then
                if getmetatable(o) == nil then
                    for _, v in cfg_pairs(o) do
                        if type(v) == "table" then
                            is_need_set_metatable = false
                            bind_metatable(v, sub_keys)
                        end
                    end
                    setmetatable(o , struct_meta)
                else
                    is_need_set_metatable = false
                end
            end
            if not is_need_set_metatable then
                return o
            end
            return bind_metatable(o, sub_keys)
        end
        return o
    end,

    ----重写newindex
    __newindex = function(tb, key, value)
        if not is_write_enable then
            log_error(string.concat("try change cfg:", "key=:", key, "   value=:", value))
        else
            rawset(tb, key, value)
        end
    end,
    --重写len
    __len = function(tb)
        return table.nums(rawget(tb, KEY_NAME))
    end,

    --重写 pairs
    __pairs = function(tb, key)
        return _pairs, tb, nil
    end,
}

---获取metable
bind_metatable = function(data, keys)
    local is_success = false
    if data and keys then
        if table.isnilorempty(data) then
            is_success = true
            return data, is_success
        end
        if not rawget(data, KEY_NAME) then
            rawset(data, KEY_NAME, keys)
            setmetatable(data, cfg_meta_table)
            is_success = true
        end
    else
        is_success = true
    end
    return data, is_success
end

---检测是否是文件夹格式文件
local function is_dir_file(cfg_name)
    return CFG_PATH_MAP[cfg_name] ~= nil
end

---获取文件路径
local function get_file_path(cfg_name)
    if not cfg_name then
        return
    end
    local f_path = NAME_TO_PATH_MAP[cfg_name]
    if string.isnilorempty(f_path) then
        f_path = string.concat(CFG_DIR_ROOT, cfg_name)
        NAME_TO_PATH_MAP[cfg_name] = f_path
    end
    return f_path
end

---获取文件名称
local function get_file_name(cfg_name, name_index)
    local file_name = cfg_name
    local is_special = false
    if name_index and is_dir_file(cfg_name) then
        local file_name_map = NAME_MAP[cfg_name]
        if not file_name_map then
            file_name_map = {}
            NAME_MAP[cfg_name] = file_name_map
        end
        file_name = file_name_map[name_index]
        if string.isnilorempty(file_name) then
            file_name = string.concat(cfg_name, CFG_PATH_MAP[cfg_name], name_index)
            file_name_map[name_index] = file_name
        end
        is_special = true
    end
    return file_name, is_special
end

---卸载配置表
---@param cfg_name string
---@param name_index number default nil
---@param no_clear_cache boolean
local function unload(cfg_name, name_index, no_clear_cache)
    if string.isnilorempty(cfg_name) then
        if log_enable then
            log_warn("CfgHelper.unload --failed:cfg_name is nil")
        end
        return
    end
    cfg_name = get_file_name(cfg_name, name_index)
    if un_load_file then
        un_load_file(get_file_path(cfg_name))
    end
    CFG_MAP[cfg_name] = nil
    if not no_clear_cache then
        NAME_MAP[cfg_name] = nil
        NAME_TO_PATH_MAP[cfg_name] = nil
    end
end

---加载配置表
---@param cfg_name string
---@param is_safe boolean
local function load(cfg_name,is_safe)
    if not cfg_name then
        return log_error("cfg_name is nil", cfg_name)
    end
    local cfg = CFG_MAP[cfg_name] and CFG_MAP[cfg_name][VALUE_IDX] or nil
    if not cfg then
        cfg = require(get_file_path(cfg_name),is_safe,is_safe)
        if cfg then
            unload(cfg_name, nil, true)
            local cfg_v = { cfg, false }
            local keys = cfg[ORIGIN_KEY]
            local is_multi_key = keys and keys[MULTI_KEY_NAME]
            if is_multi_key then
                if keys then
                    keys[MULTI_KEY_NAME] = nil
                end
                cfg_v[IS_MULTI_KEY_IDX] = true
            end
            CFG_MAP[cfg_name] = cfg_v
        end
    end
    if not cfg and not is_safe then
        log_error("--------LoadCfg failed cfg not exist !!!----------- cfg_name. ", cfg_name)
    end
    return cfg
end

---绑定keys
local function bind_keys(data, keys, is_multi_key)
    if is_multi_key then
        for _, v in pairs(data) do
            for _, n in pairs(v) do
                bind_metatable(n, keys)
            end
        end
    else
        for _, v in pairs(data) do
            bind_metatable(v, keys)
        end
    end
end

---检测是否是多key
local function is_multi_key(cfg_name, name_index)
    cfg_name = get_file_name(cfg_name, name_index)
    return cfg_name and CFG_MAP[cfg_name] and CFG_MAP[cfg_name][IS_MULTI_KEY_IDX]
end

---是否已经解析过
local function is_parsed(cfg_name)
    return cfg_name and CFG_MAP[cfg_name] and CFG_MAP[cfg_name][IS_PARSED_IDX]
end

---解析配置表
local function parse_cfg(cfg_name, cfg, is_debug)
    if is_parsed(cfg_name) then
        return cfg
    end
    local keys = rawget(cfg, ORIGIN_KEY)
    if keys then
        rawset(cfg, ORIGIN_KEY, nil)
        CFG_MAP[cfg_name][IS_PARSED_IDX] = true
        bind_keys(cfg, keys, is_multi_key(cfg_name))
        if is_debug then
            cfg = save_debug_cfg(cfg_name, cfg)
        end
        check_skip(cfg, is_multi_key(cfg_name),cfg_name)
    end
    return cfg
end

---获取该配置表的所有数据
---@param cfg_name string
---@param name_index number default nil
---@param is_set_metatable boolean default true
local function get_all(cfg_name, name_index, is_set_metatable)
    local file_name = get_file_name(cfg_name, name_index)
    local cfg = load(file_name)
    if cfg then
        if is_set_metatable == nil then
            is_set_metatable = true
        end
        if is_debug_enable or is_set_metatable then
            cfg = parse_cfg(file_name, cfg, is_debug_enable)
        end
    end
    return cfg
end
---@param cfg_name string
---@param key1 number
---@param key2 number
local function get(cfg_name, key1, key2, ...)
    if not cfg_name or not key1 then
        if log_enable then
            log_warn("CfgHelper.get---failed:", cfg_name, "->", key1, ":", key2)
        end
        return nil
    end
    local cfg = get_all(cfg_name, key1, false)
    local data
    local is_dir = is_dir_file(cfg_name)
    local file_name = get_file_name(cfg_name, key1)
    if cfg then
        data = is_dir and cfg or cfg[key1]
        if key2 then
            if data then
                data = data[key2]
            end
        else
            if is_dir then
                parse_cfg(file_name, cfg)
            end
        end
    end
    if not data then
        if log_enable then
            log_warn("CfgHelper.get---failed:", cfg_name, "->", key1, ":", key2)
        end
    else
        if not is_parsed(file_name) then
            local keys = rawget(cfg, ORIGIN_KEY)
            if is_multi_key(file_name) then
                if key2 == nil then
                    bind_keys(data, keys, false)
                    check_skip(data,false,cfg_name,key1)
                else
                    data = bind_metatable(data, keys)
                end
            else
                data = bind_metatable(data, keys)
            end
            if data then
                if not is_line_valid(data,is_multi_key(file_name),cfg_name,key1,key2) then
                    return nil
                end
            end
        end
    end
    return data
end

check_skip = function(cfg, is_multi_key,cfg_name,key)
    if ignore_skip_enable then return end
    if not cfg  then return end
    if is_multi_key then
        for k, v in pairs(cfg) do
            check_skip(v, false,cfg_name,k)
            if table.isnilorempty(v) then
                cfg[k] = nil
            end
        end
    else
        for k, v in pairs(cfg) do
            if not is_line_valid(v,is_multi_key,cfg_name,key,k) then
                cfg[k] = nil
            end
        end
    end
end

local function debug_to_skip(data,is_multi_key,cfg_name,key1,key2)
    if UNITY_EDITOR then
        is_multi_key = key1~=nil and key2~=nil
        if key1==nil then
            key1 = key2
        end
        log(string.format("【提审包模式】 该行数据剔除:cfg_name=[%s],", cfg_name), is_multi_key and string.format("[key1]=[%s],[key2]=[%s]",key1,key2) or string.format("[key]=[%s]",key1))
    end
end

is_line_valid = function(data,is_multi_key,cfg_name,key1,key2)
    if ignore_skip_enable or not data or type(data)~="table" then return true end
    local tag = data[SKIP_TAG] or 1
    if tag == 0 then
        if is_skip_enable then
            debug_to_skip(data,is_multi_key,cfg_name,key1,key2)
            return false
        end
    elseif tag == 2 then
        if is_skip_enable then
            return true
        else
            debug_to_skip(data,is_multi_key,cfg_name,key1,key2)
            return false
        end
    end
    return true
end

---清理所有配置表
local function clear()
    if not CFG_MAP then
        return
    end
    for k, _ in pairs(CFG_MAP) do
        unload(k)
    end
end

local function set_log_enable(is_enable)
    log_enable = is_enable
end

local function set_log(_log_, _log_warn_, _log_error_)
    _log = _log_
    _log_warn = _log_warn_
    _log_error = _log_error_
end

local function set_un_load_func(_un_load_func)
    un_load_file = _un_load_func
end

local function set_cfg_dir(cfg_dir)
    CFG_DIR_ROOT = cfg_dir
end

un_load_file = function(f_name)
    package.loaded[f_name] = nil
end

log = function(...)
    if log_enable and  _log then
        _log(...)
    end
end

log_error = function(...)
    if _log_error then
        _log_error(...)
    end
end

log_warn = function(...)
    if log_enable and _log_warn then
        _log_warn(...)
    end
end

clone_cfg = function(cfg)
    return table.clone(cfg, false, check_meta_valid)
end

save_debug_cfg = function(cfg_name, cfg)
    if cfg_name and cfg then
        cfg = clone_cfg(cfg)
        CFG_MAP[cfg_name][VALUE_IDX] = cfg
        return cfg
    end
    return cfg
end

---检测是否是配置表meta
check_meta_valid = function(meta)
    return meta and meta[CFG_META_KEY]
end

---设置调试模式
local function set_debug_enable(is_enable)
    is_debug_enable = is_enable
end

---设置是否可写
local function set_write_enable(is_enable)
    is_write_enable = is_enable
end

cfg_pairs = function(t)
    if not t then
        return function()
            log_error("cfg is null")
        end
    end
    local meta = getmetatable(t)
    if check_meta_valid(meta) then
        return meta.__pairs(t)
    end
    return pairs(t)
end

cfg_len = function(t)
    if not t then
        return 0
    end
    local meta = getmetatable(t)
    if check_meta_valid(meta) then
        return meta.__len(t)
    end
    return #t
end

---@return table
get_table = function()
    if #pool>0 then
        return table.remove(pool)
    end
    return {}
end

release_table = function(t)
    if t then
        if not table.containsvalue(pool,t) then
            table.insert(pool,t)
        end
    end
end

---设置是否可以跳过
---@param is_enable boolean
---@param skip_tag string
local function set_skip_enable(is_enable,skip_tag)
    is_skip_enable = is_enable
    SKIP_TAG = skip_tag
    ignore_skip_enable = false
end

---解析多表合并
---@param mergeMap table<string,string[]>
local function parse_merge(mergeMap)
    for k,v in pairs(mergeMap) do
        local dst = load(k)
        for _,n in ipairs(v) do
            local src = load(n,true)
            if src and type(src) == "table" then
                unload(n)
                table.merge(dst,src)
            end
        end
    end
end

return {
    Get = get,
    GetAll = get_all,
    Clear = clear,
    UnLoad = unload,
    SetLog = set_log,
    SetLogEnable = set_log_enable,
    SetUnLoadFunc = set_un_load_func,
    SetCfgDir = set_cfg_dir,
    IsMultiKey = is_multi_key,
    CloneCfg = clone_cfg,
    SetDebugEnable = set_debug_enable,
    GetLen = cfg_len,
    CfgPairs = cfg_pairs,
    SetWriteEnable = set_write_enable,
    SetSkipEnable = set_skip_enable,
    ParseMerge = parse_merge,
}