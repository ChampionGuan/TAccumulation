---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiaozhu.
--- DateTime: 2021/12/15 22:29

---@class LuaEvent
local Event = class("Event")
---@class _eventData
---@field name string | int 注册id
---@field call function 回调方法
---@field target table 绑定对象
---@field count int 默认-1 永久触发
---@field is_self boolean 触发回调是否绑定对象
---@field is_valid boolean 是否有效

--region 初始化
---@private
function Event:ctor()
    ---缓存池获取方法
    ---@type fun():table
    self.pool_get = nil
    ---缓存池释放方法
    ---@type fun(type:table):void
    self.pool_release = nil
    ---事件列表
    ---@type table<string,_eventData[]>
    self.event_map = {}
    ---本地缓存，如果没有设置缓存池，默认用本地
    ---@type table[]
    self.pool = {}
end
--endregion

--region 公开方法
---触发事件
---@param event_name string | int
---@vararg any
function Event:Dispatch(event_name, ...)
    local list = self:GetEventList(event_name)
    if list then
        -- mark 这里获取数量，防止在执行API的过程中对列表进行修改
        local count = #list
        for k = 1,count do
            local event = list[k]
            if event and event.is_valid then
                self:CheckCount(event)
                if event.is_self then
                    event.call(event.target, ...)
                else
                    event.call(...)
                end
            end
        end
    end
end

---监听事件
---@param event_name string | int 事件id或者事件名称
---@param func function 事件回调
---@param target table 回调对象
---@param count int 执行次数之后自动注销
---@return boolean
function Event:Add(event_name, func, target, count)
    if string.isnilorempty(event_name) or not func then
        return false
    end
    target = target or self
    local need_check = true
    local list = self:GetEventList(event_name)
    if not list then
        list = self:GetTable()
        self:AddEventList(event_name, list)
        need_check = false
    end
    if need_check then
        for k, v in pairs(list) do
            if self:IsEqual(v, func, target) then
                return true
            end
        end
    end
    local data = self:GetData(event_name, func, target, count)
    table.insert(list, data)
    return true
end

---删除事件
---@param event_name string | int 事件id或者事件名称
---@param func function 事件回调
---@param target table 回调对象
function Event:Remove(event_name, func, target)
    target = target or self
    local list = self:GetEventList(event_name)
    if list then
        for k, v in pairs(list) do
            if self:IsEqual(v, func, target) then
                self:SetEventValid(v, false)
                break
            end
        end
    end
end

---删除事件
---@param event_name string | int 事件id或者事件名称
---@param target table 回调对象
function Event:RemoveByName(event_name, target)
    local list = self:GetEventList(event_name)
    target = target or self
    if list then
        for k, v in pairs(list) do
            if v.is_valid and v.target == target then
                self:SetEventValid(v, false)
            end
        end
    end
end

---根据target反注册
---@param target table
function Event:RemoveByTarget(target)
    if not target then
        return
    end
    local list = self:GetTable()
    for _, v in pairs(self.event_map) do
        for _, event in pairs(v) do
            if event.target == target then
                table.insert(list, event)
            end
        end
    end
    if #list > 0 then
        for k, v in ipairs(list) do
            self:Remove(v.name, v.call, v.target)
        end
    end
    self:Release(list)
end

---清理所有事件
function Event:Clear()
    table.clear(self.event_map)
end

---检测无效事件
function Event:Check()
    local data
    for name, list in pairs(self.event_map) do
        for i = #list, 1, -1 do
            data = list[i]
            if not data.is_valid then
                table.remove(list, i)
                self:Release(data)
            end
        end
        if #list == 0 then
            self.event_map[name] = nil
            self:Release(list)
        end
    end
end

---设置缓存池
---@param pool_get fun():table
---@param pool_release fun(type:table)
function Event:SetPool(pool_get, pool_release)
    self.pool_get = pool_get
    self.pool_release = pool_release
end
--endregion

--region 内部函数

---检测是否是统一事件
---@private
---@param event _eventData
---@param func function
---@param target table
function Event:IsEqual(event, func, target)
    return event and event.is_valid and event.target == target and event.call == func
end

---@private
---检测触发数量
---@param event _eventData
function Event:CheckCount(event)
    if event.count == -1 then
        return
    else
        event.count = event.count - 1
        if event.count <= 0 then
            self:SetEventValid(event, false)
        end
    end
end

---@private
---设置事件是否有效
---@param event _eventData
---@param is_valid boolean
function Event:SetEventValid(event, is_valid)
    event.is_valid = is_valid
end

---根据事件名称获取事件列表
---@private
---@param event_name string | int
---@return _eventData[]
function Event:GetEventList(event_name)
    return self.event_map[event_name]
end

---添加列表到map中
---@private
---@param event_name string | int
---@param list _eventData[]
function Event:AddEventList(event_name, list)
    self.event_map[event_name] = list
end

---从缓存池中获取数据
---@private
---@param name string | int
---@param call function
---@param target table
---@return _eventData
function Event:GetData(name, call, target, count)
    target = target or self
    ---@type _eventData
    local data = self:GetTable()
    data.name = name
    data.count = count or -1
    data.target = target
    data.call = call
    data.is_self = target ~= self
    data.is_valid = true
    return data
end

---@private
---@return table
function Event:GetTable()
    local data
    if self.pool_get then
        data = self.pool_get()
    end
    if not data then
        data = #self.pool > 0 and table.remove(self.pool) or {}
    end
    return data
end

---数据添加到缓存池
---@private
---@param data table
function Event:Release(data)
    if self.pool_release then
        self.pool_release(data)
    else
        table.clear(data)
        table.insert(self.pool, data)
    end
end
--endregion

return Event