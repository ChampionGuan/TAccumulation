---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by pc.
--- DateTime: 2021/3/10 14:28
---

local NAME_SPACE = "pbcmessage."

local messageType = {
    ["double"] = "number",
    ["float"] = "number",
    ["int32"] = "number",
    ["int64"] = "number",
    ["uint32"] = "number",
    ["uint64"] = "number",
    ["sint64"] = "number",
    ["fixed32"] = "number",
    ["fixed64"] = "number",
    ["sfixde32"] = "number",
    ["sfixde64"] = "number",
    ["bytes"] = "number",
    ["bool"] = "boolean",
    ["string"] = "string",
}


---消息类型转换
local function toolmessage(str)
    if not str then
        return ""
    end
    if  messageType[str] ~= nil then
        return messageType[str]
    end
    if string.find(str,"table",1,true) then
        return str
    end
    return string.concat(NAME_SPACE,str)
end

function table.TrimTab(tab)
    local o ={}
    for i = 1, #tab do
        if tab[i] ~= ""then
            o[#o + 1] = string.gsub(tab[i],'\t','')
        end
    end
    return o
end
local this = {}
--- message 一个协议 协议名称为 key 里面内容为值 临时存储 中转
local messageTab = {}
---当前正在读取这个协议头
local messageName = ""
---读取时需要调用的函数
local funcEventHandle = nil

---保存协议的注解
local NoteTab = {}
local Note = ""
local SubTile,MessageTpe

local function Read(path,tab)
    messageTab = tab
    funcEventHandle = SubTile
    local file = io.open(path, "r")
    for line in file:lines() do
        if line ~= "" then
            funcEventHandle(line)
        end
    end
    file:close()
end

local function Trim(str)
    if str == nil then
        return str
    end
    return string.gsub(str, "\r", "")
end

local function Writer(path,t)
    local keys = {}
    for k,v in pairs(t) do
        table.insert(keys,k)
    end
    table.sort(keys)
    local file = io.open(path,'w+')
    ---读取协议头 里面内容是个协议里面的表
    file:write("--警告 文件内容通过菜单修改  请勿更改--\n\n")
    local word = {}
    for _,k in ipairs(keys) do
        local v = t[k]
        local class_name_str = string.split(k,"message")
        local temp = string.trim(class_name_str[#class_name_str])
        --local class_name = not string.find(temp,"table",1,true)  and string.concat(NAME_SPACE,temp) or temp
        local class_name = string.concat(NAME_SPACE,temp)
        word[#word + 1] = '---@class '..class_name..(NoteTab[k] ~= nil and ' @'..Trim(NoteTab[k])..'\n' or " \n")
        ---遍历这条协议
        for i = 1, #v do
            local value = v[i]
            ---不是枚举
            ---不是枚举
            if #value == 0 then
            elseif #value == 1 then
                word[#word + 1] = '--- '.. Trim(value[1])
            elseif string.find(value[1],'repeated')  then
                word[#word + 1] = '---@field '..value[3]..' '..toolmessage(value[2])..'[] ' ..(value[5] == nil and "" or Trim(value[5]))
            elseif string.find(value[1],'option') then
                word[#word + 1] = '---@field '..value[2]..' boolean'..' '..(value[5] == nil and "" or Trim(value[5]))
            else
                -- word[#word + 1] = '---@field '..value[1]..' number'..' '..(value[3] == nil and "" or value[3])
                word[#word + 1] = '---@field '..value[2]..' '..toolmessage(value[1])..' ' ..(value[4] == nil and "" or Trim(value[4]))
            end
            word[#word + 1] = '\n'
        end
        word[#word + 1] = 'local '..(#class_name_str>=1 and Trim(class_name_str[1]) or k)..' = {}\n'
    end
    
    file:write(table.concat(word))
    file:flush()
    file:close()
end

---截取 message 一段整的
SubTile  = function (str)
    if str == "" or str == " " then
        return
    end
    if string.find(str,'/') then
        Note = string.gsub(str,'/','')
    end
    ---获取协议头
    if string.find(str, "message", 0) and string.startswith(str,"message") then
        if string.containchinese(str) then
            local startIdx = string.find(str,"/",1,true)
            if startIdx then
                str = string.sub(str,0,startIdx-1)
            end
        end
        messageName = string.gsub(str,"}","")
        messageName = string.gsub(messageName,"{","")
        messageTab[messageName] = {}
        if Note ~= '' and Note ~= nil then
            NoteTab[messageName] = Note
        end
        Note = ""
        ---替换函数 用于截取这个协议头内的文件
        funcEventHandle = MessageTpe
        return
    end

    -----获取枚举
    --if string.find(str,"enum",0) then
    --    messageName = string.split(str, " ")[2]
    --    messageTab[messageName] = {}
    --    if Note ~= '' and Note ~= nil then
    --        NoteTab[messageName] = Note
    --    end
    --    Note = ""
    --    funcEventHandle = MessageTpe
    --    return
    --end
end

---切割当前协议里面的内容
MessageTpe = function (str)
    if string.find(str, "{") then
        return
    end
    if string.find(str, "}") then
        funcEventHandle = SubTile
        return
    end
    ---[1]协议内容 [2] 注释
    local sp = string.split(str, "=")
    ---代表空消息 只有注释
    if #sp < 2 then
        local tab = messageTab[messageName]
        tab[#tab + 1] = table.TrimTab(sp)
    else

        local contentTab = string.split(sp[1],' ')
        if string.find(sp[1],">",1,true) then
            contentTab = string.split(sp[1],">")
            local t = string.split(contentTab[1],"<")
            t = string.split(t[2],",")
            for k,v in pairs(t) do
                t[k] = string.trim(v)
            end
            contentTab[1] = string.concat("table<",toolmessage(t[1]),",",toolmessage(t[2]),">")
            --contentTab[1] = string.gsub( string.trim(contentTab[1])..">","map","table")
            contentTab = table.TrimTab(contentTab)
        end
        local annotationTab = string.split(sp[2],';')
        for i = 1, #annotationTab do
            if annotationTab[i]~= nil then
                local index = string.find(annotationTab[i],'/')
                if index then
                    contentTab[#contentTab + 1] = '@' ..(string.gsub(string.sub(annotationTab[i],index),'/',''))
                else
                    contentTab[#contentTab + 1] = annotationTab[i]
                end
            end
        end
        local tab = messageTab[messageName]
        tab[#tab + 1] = table.TrimTab(contentTab)
    end
end

local function Process(proto_path,lua_path)
    table.clear(messageTab)
    table.clear(NoteTab)
    Note = ""
    messageName = ""
    Read(proto_path,messageTab)
    Writer(lua_path,messageTab)
end


return Process 

