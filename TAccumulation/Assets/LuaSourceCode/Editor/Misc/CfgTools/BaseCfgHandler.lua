---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by pc.
--- DateTime: 2021/1/15 14:03
---
local GetKeys, GetAllKeys, MergerKeys, SortKeys, CheckValueType, ToStringEx, TableToStr, TableToStr1, ToCommonValue
local STR_FORMAT = "%slocal K = %s \n\nlocal %s = %s \n%s._k = K \nreturn %s"
local FILE_FORMAT = "local %s = %s\nreturn %s"
local CV_THRESHOLD = 2 ---公共变量提取阈值
local LOCAL_LIMIT = 1
local COLLECT_CV = true

---@class BaseCfgHandler
BaseCfgHandler = class("BaseCfgHandler")

---统一写文件入口
---@param f_path string 文件全路径，包含后缀名称
---@param is_two_key boolean 是否是双key表
function BaseCfgHandler:WriteFile(f_path, lua_table, is_two_key , is_dialogue)
    LOCAL_LIMIT = is_dialogue and 1 or 100
    
    local path_info = io.pathinfo(f_path)
    local table_name = path_info.basename
    local values, keys, cv_values = self:ParseTable(lua_table, is_two_key)
    if is_two_key then
        keys["_m"] = true
    end
    local cv_table_str = self:GetCommonValueContent(cv_values)
    cv_table_str = cv_table_str == "" and "" or cv_table_str.."\n"
    local contents = string.format(STR_FORMAT, cv_table_str, self:GetFileContents(keys), table_name, self:GetFileContents1(values), table_name, table_name)
    io.writefile(f_path, contents)
end

---直接写文件
---@param f_path string
---@param lua_table table
function BaseCfgHandler:WriteTableToFile(f_path, lua_table, table_name)
    if not table_name then
        local path_info = io.pathinfo(f_path)
        table_name = path_info.basename
    end
    local contnets = self:GetFileContents1(lua_table)
    io.writefile(f_path, string.format(FILE_FORMAT, table_name, contnets, table_name))
end

---@param f_path string
---@param f_content string
---@return boolean
function BaseCfgHandler:Write(f_path, f_content)
    return io.writefile(f_path, f_content)
end

---删除文件
---@param f_path string 文件全路径
function BaseCfgHandler:Delete(f_path)
    os.remove(f_path)
end

---统一执行入口
function BaseCfgHandler:Execute()
    ---逻辑入口
end

---获取配置表
function BaseCfgHandler:GetCfg(cfg_name, name_index)
    return self:CloneCfg(LuaCfgMgr.GetAll(cfg_name, name_index))
end

---克隆一份配置表用于修改
function BaseCfgHandler:CloneCfg(object)
    local lookup_table = {}
    local function _copy(object)
        if type(object) ~= "table" then
            return object
        elseif lookup_table[object] then
            return lookup_table[object]
        end
        local new_table = {}
        lookup_table[object] = new_table
        for key, value in pairs(object) do
            new_table[_copy(key)] = _copy(value)
        end
        return new_table
    end
    return _copy(object)
end

---本类自定义方法
function BaseCfgHandler:GetKeys(lua_table)
    local keys = GetAllKeys(lua_table)
    return SortKeys(keys)
end

---获取对应的value
function BaseCfgHandler:GetValues(lua_table, keys , cv_table)
    local values = {}
    local idx
    local k, v
    local temp_keys = {}
    for k, v in pairs(keys) do
        table.insert(temp_keys, { key = k, value = v })
    end
    table.sort(temp_keys, function(a, b)
        local v1 = type(a.value) == "table" and a.value[1] or a.value
        local v2 = type(b.value) == "table" and b.value[1] or b.value
        return v1 < v2
    end)
    for i, j in ipairs(temp_keys) do
        k = j.key
        v = j.value
        if type(v) == "table" then
            idx = v[1]
            local t = {}
            local keyTmp = v[2]
            if lua_table[k] ~= nil then
                local is_truct, is_struct_list = CheckValueType(lua_table[k])
                if is_truct then
                    t = self:GetValues(lua_table[k], keyTmp, cv_table)
                elseif is_struct_list then
                    for m, n in pairs(lua_table[k]) do
                        local value = self:GetValues(n, keyTmp, cv_table)
                        t[m] = self:ReplaceCommonValue(value, cv_table,keyTmp)
                    end
                else
                    t = lua_table[k]
                end
            else
                t = nil
            end
            t = self:ReplaceCommonValue(t, cv_table,keyTmp)
            values[idx] = t
        else
            idx = v
            local t = self:ReplaceCommonValue(lua_table[k], cv_table)
            values[idx] = t
        end
    end
    return values
end

---替换成公共字段
function BaseCfgHandler:ReplaceCommonValue(value , cv_table , key)
    local res = value
    if cv_table then
        local _cv_key = self:GetCommonKey(value , key)
        if cv_table[_cv_key] then
            local cv_value = cv_table[_cv_key].value
            local useCount = cv_value.useCount
            cv_value.useCount = useCount + 1
            res = ToCommonValue(cv_table[_cv_key].value.name)
        end
    end
    return res
end

---获取所有的公共字段
function BaseCfgHandler:GetAllCommonValue(lua_table , keys, is_two_key)
    local cv_table = {}
    if not COLLECT_CV then
        return cv_table
    end
    for _, v in pairs(lua_table) do
        if is_two_key then
            for _, n in pairs(v) do
                self:GetCommonValue(cv_table , n ,keys)
            end
        else
            self:GetCommonValue(cv_table , v ,keys)
        end
    end

    ---整理所有的公共变量, 并替换公共变量里面的公共变量
    local cv_table_res_key = {}
    for k , v in pairs(cv_table) do
        if v.count >= CV_THRESHOLD then
            cv_table_res_key[#cv_table_res_key + 1] = k
        end
    end
    table.sort(cv_table_res_key)
    local key_name = #cv_table_res_key > LOCAL_LIMIT and "S.A" or "A"
    for index, cv_k in ipairs(cv_table_res_key) do
        local cv_v = cv_table[cv_k]
        cv_v.name = key_name..index
    end

    local res = {}
    for _ , cv_k in pairs(cv_table_res_key) do
        local cv_v = cv_table[cv_k]
        local depth = self:ParseCommonValueKey(cv_table ,cv_v.value , cv_v.key)
        local key = self:GetCommonKey(cv_v.value , cv_v.key)
        res[key] = {depth = depth , value = cv_v}
    end
    return res
end

---递归替换公共变量
function BaseCfgHandler:ParseCommonValueKey(cv_table ,value_tab , key)
    local depth = 0
    if type(key) == "table" and value_tab ~= nil then
        local temp_keys = {}
        for k, _ in pairs(key) do
            table.insert(temp_keys, k)
        end
        table.sort(temp_keys)

        local _ , is_struct_list = CheckValueType(value_tab)
        if is_struct_list then
            for k , v in pairs(value_tab) do
                local value_str = self:GetCommonKey(v , key)
                if cv_table[value_str] ~= nil then
                    depth = depth + 1
                    value_tab[k] = ToCommonValue(cv_table[value_str].name)
                end
                depth = depth + self:ParseCommonValueKey(cv_table ,v , key)
            end
        else
            for k , keyName in ipairs(temp_keys) do
                local value = value_tab[k]
                local realKey = key[keyName]
                if type(realKey) == "table" then
                    local value_str = self:GetCommonKey(value , realKey[2])
                    if cv_table[value_str] ~= nil then
                        depth = depth + 1
                        value_tab[k] = ToCommonValue(cv_table[value_str].name)
                    end
                    depth = depth + self:ParseCommonValueKey(cv_table ,value , realKey[2])
                elseif type(value) == "function" then
                    local value_str = ToStringEx(value)
                    if cv_table[value_str] ~= nil then
                        depth = depth + 1
                        value_tab[k] = ToCommonValue(cv_table[value_str].name)
                    end
                end
            end
        end
    else
        local value_str = ToStringEx(value_tab)
        if cv_table[value_str] ~= nil then
            value_tab = ToCommonValue(cv_table[value_str].name)
        end
    end
    return depth
end

---获取单个公共变量
function BaseCfgHandler:GetCommonValue(cv_table ,lua_table, keys)
    for k, v in pairs(keys) do
        local lua_table_value = lua_table[k]
        if lua_table_value ~= nil then
            if type(v) == "table" then
                local t = {}
                local keyTmp = v[2]
                local is_truct, is_struct_list = CheckValueType(lua_table_value)
                if is_truct then
                    local value = self:GetValues(lua_table_value, keyTmp)
                    self:AddInCVTable(cv_table ,value , keyTmp)
                    self:GetCommonValue(cv_table ,lua_table_value, keyTmp)
                elseif is_struct_list then
                    for _, n in pairs(lua_table_value) do
                        local value = self:GetValues(n, keyTmp)
                        self:AddInCVTable(cv_table ,value , keyTmp)
                        t[#t + 1] = value
                        self:GetCommonValue(cv_table ,n, keyTmp)
                    end
                    self:AddInCVTable(cv_table, t , keyTmp)
                end
            elseif type(lua_table_value) == "function" then
                self:AddInCVTable(cv_table, lua_table_value)
            end
        end
    end
end

---添加到公共变量容器内
function BaseCfgHandler:AddInCVTable(cv_table ,value , key)
    local valueType = type(value)
    if valueType == "table" or valueType == "function" then
        local finalKey = self:GetCommonKey(value , key)
        if not cv_table[finalKey] then
            cv_table[finalKey] = {}
            cv_table[finalKey].value = valueType == "function" and value or table.clone(value , true)
            cv_table[finalKey].key = key and table.clone(key , true) or nil
            cv_table[finalKey].count = 0
            cv_table[finalKey].useCount = 0
        end
        cv_table[finalKey].count = cv_table[finalKey].count + 1
    end
end


function BaseCfgHandler:GetCommonKey(value , key)
    if key ~= nil then
        return ToStringEx(key)..ToStringEx(value)
    end
    return ToStringEx(value)
end

function BaseCfgHandler:GetFileContents(lua_table)
    return TableToStr(lua_table)
end

function BaseCfgHandler:GetFileContents1(lua_table)
    return TableToStr1(lua_table)
end

function BaseCfgHandler:GetCommonValueContent(lua_table)
    local keys = {}
    for k , _ in pairs(lua_table) do
        keys[#keys + 1] = k
    end
    table.sort(keys ,function(a, b)
        if lua_table[a].depth ~= lua_table[b].depth then
            return lua_table[a].depth < lua_table[b].depth
        end
        return a < b
    end)

    local res = ""
    if #keys <= LOCAL_LIMIT then
        for _ , key in ipairs(keys) do
            local v = lua_table[key]
            local str = string.format("local %s = %s\n" , v.value.name, ToStringEx(v.value.value))
            res = res..str
        end
    else
        res = "local S = {}\n"
        for _ , key in ipairs(keys) do
            local v = lua_table[key]
            local str = string.format("%s = %s\n" , v.value.name, ToStringEx(v.value.value))
            res = res..str
        end
    end

    return res
end

---根据table重新解析成配置表结构数据
function BaseCfgHandler:ParseTable(lua_table, is_two_key)
    local values = {}
    ---收集所有数据
    for k, v in pairs(lua_table) do
        if is_two_key then
            for m, n in pairs(v) do
                table.insert(values, n)
            end
        else
            table.insert(values, v)
        end
    end

    ---根据所有数据获取最全的keys
    local keys = self:GetKeys(values)

    ---提取所有公共字段
    local common_values = self:GetAllCommonValue(lua_table , keys , is_two_key)

    ---根据keys重新组织数据
    values = {}
    for k, v in pairs(lua_table) do
        if not values[k] then
            values[k] = {}
        end
        if is_two_key then
            for m, n in pairs(v) do
                if not values[k][m] then
                    values[k][m] = self:GetValues(n, keys, common_values)
                end
            end
        else
            values[k] = self:GetValues(v, keys, common_values)
        end
    end
    
    ---移除未用到的公共变量
    local res_common_values = {}
    for k, v in pairs(common_values) do
        if v.value.useCount >= 1 then
            res_common_values[k] = v
        end
    end
    
    return values, keys, res_common_values
end

CheckValueType = function(v)
    if v == nil then
        return false, false
    end
    local is_truct = false
    local is_struct_list = v[1] ~= nil and type(v[1]) == "table"
    if is_struct_list then
        for _, _v in pairs(v) do
            if type(_v) ~= "table" then
                is_struct_list = false
                break
            end
        end
    else
        for _k, _v in pairs(v) do
            if type(_v) == "table" then
                is_struct_list = true
            else
                is_struct_list = false
                break
            end
        end
        --if is_struct_list then
        --    for _k, _v in pairs(v) do
        --        if type(_k) == "string" then
        --            is_struct_list = false
        --            break
        --        end
        --    end
        --end
    end
    if not is_struct_list then
        for m, n in pairs(v) do
            if type(m) == "string" then
                is_truct = true
                break
            end
        end
    end
    return is_truct, is_struct_list
end

---排序
SortKeys = function(keys)
    local list = {}
    for k, v in pairs(keys) do
        table.insert(list, k)
    end
    table.sort(list)
    local id
    for k, v in pairs(keys) do
        id = table.indexof(list, k)
        if type(v) == "table" then
            keys[k] = { id, SortKeys(v) }
        else
            keys[k] = id
        end
    end
    return keys
end

MergerKeys = function(dest, src)
    for k, v in pairs(src) do
        if dest[k] and type(dest[k]) == "table" and type(v) == "table" then
            MergerKeys(dest[k], v)
        else
            dest[k] = v
        end
    end
end

GetAllKeys = function(lua_table, is_show)
    local keys = {}
    for k, v in pairs(lua_table) do
        MergerKeys(keys, GetKeys(v))
    end
    return keys
end

GetKeys = function(lua_table)
    local keys = {}
    for k, v in pairs(lua_table) do
        if not keys[k] then
            if v ~= nil then
                if type(v) == "table" then
                    if #v > 0 or table.nums(v) > 0 then
                        local is_truct, is_struct_list = CheckValueType(v)
                        if is_truct then
                            keys[k] = GetKeys(v)
                        elseif is_struct_list then
                            keys[k] = GetAllKeys(v)
                        else
                            keys[k] = true
                        end
                    end

                else
                    keys[k] = true
                end
            end

        end
    end
    return keys
end

ToStringEx = function(value)
    if value == nil then
        return tostring(value)
    end
    local v_type = type(value)
    if v_type == 'table' then
        return TableToStr(value)
    elseif v_type == "function" then
        local firstResult = value()
        return firstResult
    elseif v_type == 'string' then
        return "\'" .. value .. "\'"
    else
        return tostring(value)
    end
end

TableToStr = function(t)
    if t == nil then
        return ""
    end
    local retstr = "{"

    local i = 1
    local key_type
    local keys = {}
    for key, value in pairs(t) do
        table.insert(keys, key)
    end
    table.sort(keys)
    local key, value
    for k, v in ipairs(keys) do
        key = v
        value = t[key]
        local signal = ","
        if i == 1 then
            signal = ""
        end
        if key == i then
            retstr = retstr..signal..ToStringEx(value)
        else
            key_type = type(key)
            if key_type == "number" then
                retstr = retstr..signal..'['..ToStringEx(key).."]="..ToStringEx(value)
            elseif key_type == "string" then
                retstr = retstr..signal..key.."="..ToStringEx(value)
                --elseif key_type == "userdata" then
                --    --retstr = retstr..signal.."*s"..TableToStr(getmetatable(key)).."*e".."="..ToStringEx(value)
            else
                retstr = retstr..signal..key.."="..ToStringEx(value)
            end
        end

        i = i + 1
    end

    retstr = retstr .. "}"
    return retstr
end

TableToStr1 = function(t)
    if t == nil then
        return ""
    end
    local retstr = "\n{\n\t"

    local i = 1
    local key_type
    local keys = {}
    for key, value in pairs(t) do
        table.insert(keys, key)
    end
    table.sort(keys)
    local key, value
    for k, v in ipairs(keys) do
        --local rowStr = 1
        key = v
        value = t[key]
        local signal = ",\n\t"
        if i == 1 then
            signal = ""
        end
        if key == i then
            retstr = retstr..signal..ToStringEx(value)
        else
            key_type = type(key)
            if key_type == "number" then
                retstr = retstr..signal..'['..ToStringEx(key).."]="..ToStringEx(value)
            elseif key_type == "string" then
                retstr = retstr..signal..key.."="..ToStringEx(value)
                --elseif key_type == "userdata" then
                --    --retstr = retstr..signal.."*s"..TableToStr(getmetatable(key)).."*e".."="..ToStringEx(value)
            else
                retstr =retstr..signal..key.."="..ToStringEx(value)
            end
            retstr = retstr
        end

        i = i + 1
    end

    retstr = retstr .. "\n}"
    return retstr
end

---通用公共变量类型
ToCommonValue = function(valueName)
    return function()
        return valueName
    end
end

return BaseCfgHandler